/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all2) => {
  for (var name3 in all2)
    __defProp(target, name3, { get: all2[name3], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/min-dash/dist/index.cjs
var require_dist = __commonJS({
  "node_modules/min-dash/dist/index.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function flatten5(arr) {
      return Array.prototype.concat.apply([], arr);
    }
    var nativeToString2 = Object.prototype.toString;
    var nativeHasOwnProperty2 = Object.prototype.hasOwnProperty;
    function isUndefined8(obj) {
      return obj === void 0;
    }
    function isDefined8(obj) {
      return obj !== void 0;
    }
    function isNil3(obj) {
      return obj == null;
    }
    function isArray32(obj) {
      return nativeToString2.call(obj) === "[object Array]";
    }
    function isObject15(obj) {
      return nativeToString2.call(obj) === "[object Object]";
    }
    function isNumber16(obj) {
      return nativeToString2.call(obj) === "[object Number]";
    }
    function isFunction10(obj) {
      const tag = nativeToString2.call(obj);
      return tag === "[object Function]" || tag === "[object AsyncFunction]" || tag === "[object GeneratorFunction]" || tag === "[object AsyncGeneratorFunction]" || tag === "[object Proxy]";
    }
    function isString9(obj) {
      return nativeToString2.call(obj) === "[object String]";
    }
    function ensureArray(obj) {
      if (isArray32(obj)) {
        return;
      }
      throw new Error("must supply array");
    }
    function has7(target, key) {
      return nativeHasOwnProperty2.call(target, key);
    }
    function find28(collection, matcher) {
      matcher = toMatcher(matcher);
      let match;
      forEach79(collection, function(val, key) {
        if (matcher(val, key)) {
          match = val;
          return false;
        }
      });
      return match;
    }
    function findIndex4(collection, matcher) {
      matcher = toMatcher(matcher);
      let idx = isArray32(collection) ? -1 : void 0;
      forEach79(collection, function(val, key) {
        if (matcher(val, key)) {
          idx = key;
          return false;
        }
      });
      return idx;
    }
    function filter28(collection, matcher) {
      let result = [];
      forEach79(collection, function(val, key) {
        if (matcher(val, key)) {
          result.push(val);
        }
      });
      return result;
    }
    function forEach79(collection, iterator) {
      let val, result;
      if (isUndefined8(collection)) {
        return;
      }
      const convertKey = isArray32(collection) ? toNum2 : identity2;
      for (let key in collection) {
        if (has7(collection, key)) {
          val = collection[key];
          result = iterator(val, convertKey(key));
          if (result === false) {
            return val;
          }
        }
      }
    }
    function without3(arr, matcher) {
      if (isUndefined8(arr)) {
        return [];
      }
      ensureArray(arr);
      matcher = toMatcher(matcher);
      return arr.filter(function(el, idx) {
        return !matcher(el, idx);
      });
    }
    function reduce12(collection, iterator, result) {
      forEach79(collection, function(value, idx) {
        result = iterator(result, value, idx);
      });
      return result;
    }
    function every7(collection, matcher) {
      return !!reduce12(collection, function(matches2, val, key) {
        return matches2 && matcher(val, key);
      }, true);
    }
    function some8(collection, matcher) {
      return !!find28(collection, matcher);
    }
    function map14(collection, fn2) {
      let result = [];
      forEach79(collection, function(val, key) {
        result.push(fn2(val, key));
      });
      return result;
    }
    function keys4(collection) {
      return collection && Object.keys(collection) || [];
    }
    function size2(collection) {
      return keys4(collection).length;
    }
    function values5(collection) {
      return map14(collection, (val) => val);
    }
    function groupBy7(collection, extractor, grouped = {}) {
      extractor = toExtractor(extractor);
      forEach79(collection, function(val) {
        let discriminator = extractor(val) || "_";
        let group = grouped[discriminator];
        if (!group) {
          group = grouped[discriminator] = [];
        }
        group.push(val);
      });
      return grouped;
    }
    function uniqueBy2(extractor, ...collections) {
      extractor = toExtractor(extractor);
      let grouped = {};
      forEach79(collections, (c5) => groupBy7(c5, extractor, grouped));
      let result = map14(grouped, function(val, key) {
        return val[0];
      });
      return result;
    }
    var unionBy2 = uniqueBy2;
    function sortBy11(collection, extractor) {
      extractor = toExtractor(extractor);
      let sorted = [];
      forEach79(collection, function(value, key) {
        let disc = extractor(value, key);
        let entry = {
          d: disc,
          v: value
        };
        for (var idx = 0; idx < sorted.length; idx++) {
          let { d: d5 } = sorted[idx];
          if (disc < d5) {
            sorted.splice(idx, 0, entry);
            return;
          }
        }
        sorted.push(entry);
      });
      return map14(sorted, (e7) => e7.v);
    }
    function matchPattern8(pattern) {
      return function(el) {
        return every7(pattern, function(val, key) {
          return el[key] === val;
        });
      };
    }
    function toExtractor(extractor) {
      return isFunction10(extractor) ? extractor : (e7) => {
        return e7[extractor];
      };
    }
    function toMatcher(matcher) {
      return isFunction10(matcher) ? matcher : (e7) => {
        return e7 === matcher;
      };
    }
    function identity2(arg) {
      return arg;
    }
    function toNum2(arg) {
      return Number(arg);
    }
    function debounce4(fn2, timeout) {
      let timer;
      let lastArgs;
      let lastThis;
      let lastNow;
      function fire(force) {
        let now = Date.now();
        let scheduledDiff = force ? 0 : lastNow + timeout - now;
        if (scheduledDiff > 0) {
          return schedule(scheduledDiff);
        }
        fn2.apply(lastThis, lastArgs);
        clear3();
      }
      function schedule(timeout2) {
        timer = setTimeout(fire, timeout2);
      }
      function clear3() {
        if (timer) {
          clearTimeout(timer);
        }
        timer = lastNow = lastArgs = lastThis = void 0;
      }
      function flush() {
        if (timer) {
          fire(true);
        }
        clear3();
      }
      function callback(...args) {
        lastNow = Date.now();
        lastArgs = args;
        lastThis = this;
        if (!timer) {
          schedule(timeout);
        }
      }
      callback.flush = flush;
      callback.cancel = clear3;
      return callback;
    }
    function throttle(fn2, interval) {
      let throttling = false;
      return function(...args) {
        if (throttling) {
          return;
        }
        fn2(...args);
        throttling = true;
        setTimeout(() => {
          throttling = false;
        }, interval);
      };
    }
    function bind10(fn2, target) {
      return fn2.bind(target);
    }
    function assign71(target, ...others) {
      return Object.assign(target, ...others);
    }
    function set4(target, path, value) {
      let currentTarget = target;
      forEach79(path, function(key, idx) {
        if (typeof key !== "number" && typeof key !== "string") {
          throw new Error("illegal key type: " + typeof key + ". Key should be of type number or string.");
        }
        if (key === "constructor") {
          throw new Error("illegal key: constructor");
        }
        if (key === "__proto__") {
          throw new Error("illegal key: __proto__");
        }
        let nextKey = path[idx + 1];
        let nextTarget = currentTarget[key];
        if (isDefined8(nextKey) && isNil3(nextTarget)) {
          nextTarget = currentTarget[key] = isNaN(+nextKey) ? {} : [];
        }
        if (isUndefined8(nextKey)) {
          if (isUndefined8(value)) {
            delete currentTarget[key];
          } else {
            currentTarget[key] = value;
          }
        } else {
          currentTarget = nextTarget;
        }
      });
      return target;
    }
    function get4(target, path, defaultValue) {
      let currentTarget = target;
      forEach79(path, function(key) {
        if (isNil3(currentTarget)) {
          currentTarget = void 0;
          return false;
        }
        currentTarget = currentTarget[key];
      });
      return isUndefined8(currentTarget) ? defaultValue : currentTarget;
    }
    function pick10(target, properties) {
      let result = {};
      let obj = Object(target);
      forEach79(properties, function(prop) {
        if (prop in obj) {
          result[prop] = target[prop];
        }
      });
      return result;
    }
    function omit6(target, properties) {
      let result = {};
      let obj = Object(target);
      forEach79(obj, function(prop, key) {
        if (properties.indexOf(key) === -1) {
          result[key] = prop;
        }
      });
      return result;
    }
    function merge(target, ...sources) {
      if (!sources.length) {
        return target;
      }
      forEach79(sources, function(source) {
        if (!source || !isObject15(source)) {
          return;
        }
        forEach79(source, function(sourceVal, key) {
          if (key === "__proto__") {
            return;
          }
          let targetVal = target[key];
          if (isObject15(sourceVal)) {
            if (!isObject15(targetVal)) {
              targetVal = {};
            }
            target[key] = merge(targetVal, sourceVal);
          } else {
            target[key] = sourceVal;
          }
        });
      });
      return target;
    }
    exports.assign = assign71;
    exports.bind = bind10;
    exports.debounce = debounce4;
    exports.ensureArray = ensureArray;
    exports.every = every7;
    exports.filter = filter28;
    exports.find = find28;
    exports.findIndex = findIndex4;
    exports.flatten = flatten5;
    exports.forEach = forEach79;
    exports.get = get4;
    exports.groupBy = groupBy7;
    exports.has = has7;
    exports.isArray = isArray32;
    exports.isDefined = isDefined8;
    exports.isFunction = isFunction10;
    exports.isNil = isNil3;
    exports.isNumber = isNumber16;
    exports.isObject = isObject15;
    exports.isString = isString9;
    exports.isUndefined = isUndefined8;
    exports.keys = keys4;
    exports.map = map14;
    exports.matchPattern = matchPattern8;
    exports.merge = merge;
    exports.omit = omit6;
    exports.pick = pick10;
    exports.reduce = reduce12;
    exports.set = set4;
    exports.size = size2;
    exports.some = some8;
    exports.sortBy = sortBy11;
    exports.throttle = throttle;
    exports.unionBy = unionBy2;
    exports.uniqueBy = uniqueBy2;
    exports.values = values5;
    exports.without = without3;
  }
});

// node_modules/path-intersection/intersect.js
var require_intersect = __commonJS({
  "node_modules/path-intersection/intersect.js"(exports, module2) {
    "use strict";
    var p2s = /,?([a-z]),?/gi;
    var toFloat = parseFloat;
    var math = Math;
    var PI = math.PI;
    var mmin = math.min;
    var mmax = math.max;
    var pow = math.pow;
    var abs8 = math.abs;
    var pathCommand = /([a-z])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?[\s]*,?[\s]*)+)/ig;
    var pathValues = /(-?\d*\.?\d*(?:e[-+]?\d+)?)[\s]*,?[\s]*/ig;
    var isArray32 = Array.isArray || function(o7) {
      return o7 instanceof Array;
    };
    function hasProperty(obj, property) {
      return Object.prototype.hasOwnProperty.call(obj, property);
    }
    function clone2(obj) {
      if (typeof obj == "function" || Object(obj) !== obj) {
        return obj;
      }
      var res = new obj.constructor();
      for (var key in obj) {
        if (hasProperty(obj, key)) {
          res[key] = clone2(obj[key]);
        }
      }
      return res;
    }
    function repush(array, item) {
      for (var i6 = 0, ii = array.length; i6 < ii; i6++)
        if (array[i6] === item) {
          return array.push(array.splice(i6, 1)[0]);
        }
    }
    function cacher(f5) {
      function newf() {
        var arg = Array.prototype.slice.call(arguments, 0), args = arg.join("\u2400"), cache = newf.cache = newf.cache || {}, count = newf.count = newf.count || [];
        if (hasProperty(cache, args)) {
          repush(count, args);
          return cache[args];
        }
        count.length >= 1e3 && delete cache[count.shift()];
        count.push(args);
        cache[args] = f5.apply(0, arg);
        return cache[args];
      }
      return newf;
    }
    function parsePathString(pathString) {
      if (!pathString) {
        return null;
      }
      var pth = paths(pathString);
      if (pth.arr) {
        return clone2(pth.arr);
      }
      var paramCounts = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 }, data = [];
      if (isArray32(pathString) && isArray32(pathString[0])) {
        data = clone2(pathString);
      }
      if (!data.length) {
        String(pathString).replace(pathCommand, function(a6, b5, c5) {
          var params = [], name3 = b5.toLowerCase();
          c5.replace(pathValues, function(a7, b6) {
            b6 && params.push(+b6);
          });
          if (name3 == "m" && params.length > 2) {
            data.push([b5].concat(params.splice(0, 2)));
            name3 = "l";
            b5 = b5 == "m" ? "l" : "L";
          }
          while (params.length >= paramCounts[name3]) {
            data.push([b5].concat(params.splice(0, paramCounts[name3])));
            if (!paramCounts[name3]) {
              break;
            }
          }
        });
      }
      data.toString = paths.toString;
      pth.arr = clone2(data);
      return data;
    }
    function paths(ps) {
      var p6 = paths.ps = paths.ps || {};
      if (p6[ps]) {
        p6[ps].sleep = 100;
      } else {
        p6[ps] = {
          sleep: 100
        };
      }
      setTimeout(function() {
        for (var key in p6) {
          if (hasProperty(p6, key) && key != ps) {
            p6[key].sleep--;
            !p6[key].sleep && delete p6[key];
          }
        }
      });
      return p6[ps];
    }
    function rectBBox(x4, y4, width, height) {
      if (arguments.length === 1) {
        y4 = x4.y;
        width = x4.width;
        height = x4.height;
        x4 = x4.x;
      }
      return {
        x: x4,
        y: y4,
        width,
        height,
        x2: x4 + width,
        y2: y4 + height
      };
    }
    function pathToString() {
      return this.join(",").replace(p2s, "$1");
    }
    function pathClone(pathArray) {
      var res = clone2(pathArray);
      res.toString = pathToString;
      return res;
    }
    function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t6) {
      var t1 = 1 - t6, t13 = pow(t1, 3), t12 = pow(t1, 2), t22 = t6 * t6, t32 = t22 * t6, x4 = t13 * p1x + t12 * 3 * t6 * c1x + t1 * 3 * t6 * t6 * c2x + t32 * p2x, y4 = t13 * p1y + t12 * 3 * t6 * c1y + t1 * 3 * t6 * t6 * c2y + t32 * p2y;
      return {
        x: fixError(x4),
        y: fixError(y4)
      };
    }
    function bezierBBox(points) {
      var bbox = curveBBox.apply(null, points);
      return rectBBox(bbox.x0, bbox.y0, bbox.x1 - bbox.x0, bbox.y1 - bbox.y0);
    }
    function isPointInsideBBox3(bbox, x4, y4) {
      return x4 >= bbox.x && x4 <= bbox.x + bbox.width && y4 >= bbox.y && y4 <= bbox.y + bbox.height;
    }
    function isBBoxIntersect(bbox1, bbox2) {
      bbox1 = rectBBox(bbox1);
      bbox2 = rectBBox(bbox2);
      return isPointInsideBBox3(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox3(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox3(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox3(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox3(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox3(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox3(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox3(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
    }
    function base3(t6, p1, p22, p32, p42) {
      var t1 = -3 * p1 + 9 * p22 - 9 * p32 + 3 * p42, t22 = t6 * t1 + 6 * p1 - 12 * p22 + 6 * p32;
      return t6 * t22 - 3 * p1 + 3 * p22;
    }
    function bezlen(x1, y1, x22, y22, x32, y32, x4, y4, z5) {
      if (z5 == null) {
        z5 = 1;
      }
      z5 = z5 > 1 ? 1 : z5 < 0 ? 0 : z5;
      var z22 = z5 / 2, n5 = 12, Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816], Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472], sum = 0;
      for (var i6 = 0; i6 < n5; i6++) {
        var ct = z22 * Tvalues[i6] + z22, xbase = base3(ct, x1, x22, x32, x4), ybase = base3(ct, y1, y22, y32, y4), comb = xbase * xbase + ybase * ybase;
        sum += Cvalues[i6] * math.sqrt(comb);
      }
      return z22 * sum;
    }
    function intersectLines(x1, y1, x22, y22, x32, y32, x4, y4) {
      if (mmax(x1, x22) < mmin(x32, x4) || mmin(x1, x22) > mmax(x32, x4) || mmax(y1, y22) < mmin(y32, y4) || mmin(y1, y22) > mmax(y32, y4)) {
        return;
      }
      var nx = (x1 * y22 - y1 * x22) * (x32 - x4) - (x1 - x22) * (x32 * y4 - y32 * x4), ny = (x1 * y22 - y1 * x22) * (y32 - y4) - (y1 - y22) * (x32 * y4 - y32 * x4), denominator = (x1 - x22) * (y32 - y4) - (y1 - y22) * (x32 - x4);
      if (!denominator) {
        return;
      }
      var px = fixError(nx / denominator), py = fixError(ny / denominator), px2 = +px.toFixed(2), py2 = +py.toFixed(2);
      if (px2 < +mmin(x1, x22).toFixed(2) || px2 > +mmax(x1, x22).toFixed(2) || px2 < +mmin(x32, x4).toFixed(2) || px2 > +mmax(x32, x4).toFixed(2) || py2 < +mmin(y1, y22).toFixed(2) || py2 > +mmax(y1, y22).toFixed(2) || py2 < +mmin(y32, y4).toFixed(2) || py2 > +mmax(y32, y4).toFixed(2)) {
        return;
      }
      return { x: px, y: py };
    }
    function fixError(number) {
      return Math.round(number * 1e11) / 1e11;
    }
    function findBezierIntersections(bez1, bez2, justCount) {
      var bbox1 = bezierBBox(bez1), bbox2 = bezierBBox(bez2);
      if (!isBBoxIntersect(bbox1, bbox2)) {
        return justCount ? 0 : [];
      }
      var l1 = bezlen.apply(0, bez1), l22 = bezlen.apply(0, bez2), n1 = isLine(bez1) ? 1 : ~~(l1 / 5) || 1, n22 = isLine(bez2) ? 1 : ~~(l22 / 5) || 1, dots1 = [], dots2 = [], xy = {}, res = justCount ? 0 : [];
      for (var i6 = 0; i6 < n1 + 1; i6++) {
        var p6 = findDotsAtSegment.apply(0, bez1.concat(i6 / n1));
        dots1.push({ x: p6.x, y: p6.y, t: i6 / n1 });
      }
      for (i6 = 0; i6 < n22 + 1; i6++) {
        p6 = findDotsAtSegment.apply(0, bez2.concat(i6 / n22));
        dots2.push({ x: p6.x, y: p6.y, t: i6 / n22 });
      }
      for (i6 = 0; i6 < n1; i6++) {
        for (var j6 = 0; j6 < n22; j6++) {
          var di = dots1[i6], di1 = dots1[i6 + 1], dj = dots2[j6], dj1 = dots2[j6 + 1], ci = abs8(di1.x - di.x) < 0.01 ? "y" : "x", cj = abs8(dj1.x - dj.x) < 0.01 ? "y" : "x", is4 = intersectLines(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y), key;
          if (is4) {
            key = is4.x.toFixed(9) + "#" + is4.y.toFixed(9);
            if (xy[key]) {
              continue;
            }
            xy[key] = true;
            var t1 = di.t + abs8((is4[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t), t22 = dj.t + abs8((is4[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
            if (t1 >= 0 && t1 <= 1 && t22 >= 0 && t22 <= 1) {
              if (justCount) {
                res++;
              } else {
                res.push({
                  x: is4.x,
                  y: is4.y,
                  t1,
                  t2: t22
                });
              }
            }
          }
        }
      }
      return res;
    }
    function findPathIntersections(path1, path2, justCount) {
      path1 = pathToCurve(path1);
      path2 = pathToCurve(path2);
      var x1, y1, x22, y22, x1m, y1m, x2m, y2m, bez1, bez2, res = justCount ? 0 : [];
      for (var i6 = 0, ii = path1.length; i6 < ii; i6++) {
        var pi = path1[i6];
        if (pi[0] == "M") {
          x1 = x1m = pi[1];
          y1 = y1m = pi[2];
        } else {
          if (pi[0] == "C") {
            bez1 = [x1, y1].concat(pi.slice(1));
            x1 = bez1[6];
            y1 = bez1[7];
          } else {
            bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
            x1 = x1m;
            y1 = y1m;
          }
          for (var j6 = 0, jj = path2.length; j6 < jj; j6++) {
            var pj = path2[j6];
            if (pj[0] == "M") {
              x22 = x2m = pj[1];
              y22 = y2m = pj[2];
            } else {
              if (pj[0] == "C") {
                bez2 = [x22, y22].concat(pj.slice(1));
                x22 = bez2[6];
                y22 = bez2[7];
              } else {
                bez2 = [x22, y22, x22, y22, x2m, y2m, x2m, y2m];
                x22 = x2m;
                y22 = y2m;
              }
              var intr = findBezierIntersections(bez1, bez2, justCount);
              if (justCount) {
                res += intr;
              } else {
                for (var k6 = 0, kk = intr.length; k6 < kk; k6++) {
                  intr[k6].segment1 = i6;
                  intr[k6].segment2 = j6;
                  intr[k6].bez1 = bez1;
                  intr[k6].bez2 = bez2;
                }
                res = res.concat(intr);
              }
            }
          }
        }
      }
      return res;
    }
    function pathToAbsolute(pathArray) {
      var pth = paths(pathArray);
      if (pth.abs) {
        return pathClone(pth.abs);
      }
      if (!isArray32(pathArray) || !isArray32(pathArray && pathArray[0])) {
        pathArray = parsePathString(pathArray);
      }
      if (!pathArray || !pathArray.length) {
        return [["M", 0, 0]];
      }
      var res = [], x4 = 0, y4 = 0, mx = 0, my = 0, start = 0, pa0;
      if (pathArray[0][0] == "M") {
        x4 = +pathArray[0][1];
        y4 = +pathArray[0][2];
        mx = x4;
        my = y4;
        start++;
        res[0] = ["M", x4, y4];
      }
      for (var r6, pa, i6 = start, ii = pathArray.length; i6 < ii; i6++) {
        res.push(r6 = []);
        pa = pathArray[i6];
        pa0 = pa[0];
        if (pa0 != pa0.toUpperCase()) {
          r6[0] = pa0.toUpperCase();
          switch (r6[0]) {
            case "A":
              r6[1] = pa[1];
              r6[2] = pa[2];
              r6[3] = pa[3];
              r6[4] = pa[4];
              r6[5] = pa[5];
              r6[6] = +pa[6] + x4;
              r6[7] = +pa[7] + y4;
              break;
            case "V":
              r6[1] = +pa[1] + y4;
              break;
            case "H":
              r6[1] = +pa[1] + x4;
              break;
            case "M":
              mx = +pa[1] + x4;
              my = +pa[2] + y4;
            default:
              for (var j6 = 1, jj = pa.length; j6 < jj; j6++) {
                r6[j6] = +pa[j6] + (j6 % 2 ? x4 : y4);
              }
          }
        } else {
          for (var k6 = 0, kk = pa.length; k6 < kk; k6++) {
            r6[k6] = pa[k6];
          }
        }
        pa0 = pa0.toUpperCase();
        switch (r6[0]) {
          case "Z":
            x4 = +mx;
            y4 = +my;
            break;
          case "H":
            x4 = r6[1];
            break;
          case "V":
            y4 = r6[1];
            break;
          case "M":
            mx = r6[r6.length - 2];
            my = r6[r6.length - 1];
          default:
            x4 = r6[r6.length - 2];
            y4 = r6[r6.length - 1];
        }
      }
      res.toString = pathToString;
      pth.abs = pathClone(res);
      return res;
    }
    function isLine(bez) {
      return bez[0] === bez[2] && bez[1] === bez[3] && bez[4] === bez[6] && bez[5] === bez[7];
    }
    function lineToCurve(x1, y1, x22, y22) {
      return [
        x1,
        y1,
        x22,
        y22,
        x22,
        y22
      ];
    }
    function qubicToCurve(x1, y1, ax, ay, x22, y22) {
      var _13 = 1 / 3, _23 = 2 / 3;
      return [
        _13 * x1 + _23 * ax,
        _13 * y1 + _23 * ay,
        _13 * x22 + _23 * ax,
        _13 * y22 + _23 * ay,
        x22,
        y22
      ];
    }
    function arcToCurve(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x22, y22, recursive) {
      var _120 = PI * 120 / 180, rad = PI / 180 * (+angle || 0), res = [], xy, rotate2 = cacher(function(x5, y5, rad2) {
        var X = x5 * math.cos(rad2) - y5 * math.sin(rad2), Y2 = x5 * math.sin(rad2) + y5 * math.cos(rad2);
        return { x: X, y: Y2 };
      });
      if (!recursive) {
        xy = rotate2(x1, y1, -rad);
        x1 = xy.x;
        y1 = xy.y;
        xy = rotate2(x22, y22, -rad);
        x22 = xy.x;
        y22 = xy.y;
        var x4 = (x1 - x22) / 2, y4 = (y1 - y22) / 2;
        var h5 = x4 * x4 / (rx * rx) + y4 * y4 / (ry * ry);
        if (h5 > 1) {
          h5 = math.sqrt(h5);
          rx = h5 * rx;
          ry = h5 * ry;
        }
        var rx2 = rx * rx, ry2 = ry * ry, k6 = (large_arc_flag == sweep_flag ? -1 : 1) * math.sqrt(abs8((rx2 * ry2 - rx2 * y4 * y4 - ry2 * x4 * x4) / (rx2 * y4 * y4 + ry2 * x4 * x4))), cx = k6 * rx * y4 / ry + (x1 + x22) / 2, cy = k6 * -ry * x4 / rx + (y1 + y22) / 2, f1 = math.asin(((y1 - cy) / ry).toFixed(9)), f22 = math.asin(((y22 - cy) / ry).toFixed(9));
        f1 = x1 < cx ? PI - f1 : f1;
        f22 = x22 < cx ? PI - f22 : f22;
        f1 < 0 && (f1 = PI * 2 + f1);
        f22 < 0 && (f22 = PI * 2 + f22);
        if (sweep_flag && f1 > f22) {
          f1 = f1 - PI * 2;
        }
        if (!sweep_flag && f22 > f1) {
          f22 = f22 - PI * 2;
        }
      } else {
        f1 = recursive[0];
        f22 = recursive[1];
        cx = recursive[2];
        cy = recursive[3];
      }
      var df = f22 - f1;
      if (abs8(df) > _120) {
        var f2old = f22, x2old = x22, y2old = y22;
        f22 = f1 + _120 * (sweep_flag && f22 > f1 ? 1 : -1);
        x22 = cx + rx * math.cos(f22);
        y22 = cy + ry * math.sin(f22);
        res = arcToCurve(x22, y22, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f22, f2old, cx, cy]);
      }
      df = f22 - f1;
      var c1 = math.cos(f1), s1 = math.sin(f1), c22 = math.cos(f22), s22 = math.sin(f22), t6 = math.tan(df / 4), hx = 4 / 3 * rx * t6, hy = 4 / 3 * ry * t6, m1 = [x1, y1], m22 = [x1 + hx * s1, y1 - hy * c1], m32 = [x22 + hx * s22, y22 - hy * c22], m42 = [x22, y22];
      m22[0] = 2 * m1[0] - m22[0];
      m22[1] = 2 * m1[1] - m22[1];
      if (recursive) {
        return [m22, m32, m42].concat(res);
      } else {
        res = [m22, m32, m42].concat(res).join().split(",");
        var newres = [];
        for (var i6 = 0, ii = res.length; i6 < ii; i6++) {
          newres[i6] = i6 % 2 ? rotate2(res[i6 - 1], res[i6], rad).y : rotate2(res[i6], res[i6 + 1], rad).x;
        }
        return newres;
      }
    }
    function curveBBox(x0, y0, x1, y1, x22, y22, x32, y32) {
      var tvalues = [], bounds = [[], []], a6, b5, c5, t6, t1, t22, b2ac, sqrtb2ac;
      for (var i6 = 0; i6 < 2; ++i6) {
        if (i6 == 0) {
          b5 = 6 * x0 - 12 * x1 + 6 * x22;
          a6 = -3 * x0 + 9 * x1 - 9 * x22 + 3 * x32;
          c5 = 3 * x1 - 3 * x0;
        } else {
          b5 = 6 * y0 - 12 * y1 + 6 * y22;
          a6 = -3 * y0 + 9 * y1 - 9 * y22 + 3 * y32;
          c5 = 3 * y1 - 3 * y0;
        }
        if (abs8(a6) < 1e-12) {
          if (abs8(b5) < 1e-12) {
            continue;
          }
          t6 = -c5 / b5;
          if (0 < t6 && t6 < 1) {
            tvalues.push(t6);
          }
          continue;
        }
        b2ac = b5 * b5 - 4 * c5 * a6;
        sqrtb2ac = math.sqrt(b2ac);
        if (b2ac < 0) {
          continue;
        }
        t1 = (-b5 + sqrtb2ac) / (2 * a6);
        if (0 < t1 && t1 < 1) {
          tvalues.push(t1);
        }
        t22 = (-b5 - sqrtb2ac) / (2 * a6);
        if (0 < t22 && t22 < 1) {
          tvalues.push(t22);
        }
      }
      var j6 = tvalues.length, jlen = j6, mt;
      while (j6--) {
        t6 = tvalues[j6];
        mt = 1 - t6;
        bounds[0][j6] = mt * mt * mt * x0 + 3 * mt * mt * t6 * x1 + 3 * mt * t6 * t6 * x22 + t6 * t6 * t6 * x32;
        bounds[1][j6] = mt * mt * mt * y0 + 3 * mt * mt * t6 * y1 + 3 * mt * t6 * t6 * y22 + t6 * t6 * t6 * y32;
      }
      bounds[0][jlen] = x0;
      bounds[1][jlen] = y0;
      bounds[0][jlen + 1] = x32;
      bounds[1][jlen + 1] = y32;
      bounds[0].length = bounds[1].length = jlen + 2;
      return {
        x0: mmin.apply(0, bounds[0]),
        y0: mmin.apply(0, bounds[1]),
        x1: mmax.apply(0, bounds[0]),
        y1: mmax.apply(0, bounds[1])
      };
    }
    function pathToCurve(path) {
      var pth = paths(path);
      if (pth.curve) {
        return pathClone(pth.curve);
      }
      var curvedPath = pathToAbsolute(path), attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null }, processPath = function(path2, d5, pathCommand3) {
        var nx, ny;
        if (!path2) {
          return ["C", d5.x, d5.y, d5.x, d5.y, d5.x, d5.y];
        }
        !(path2[0] in { T: 1, Q: 1 }) && (d5.qx = d5.qy = null);
        switch (path2[0]) {
          case "M":
            d5.X = path2[1];
            d5.Y = path2[2];
            break;
          case "A":
            path2 = ["C"].concat(arcToCurve.apply(0, [d5.x, d5.y].concat(path2.slice(1))));
            break;
          case "S":
            if (pathCommand3 == "C" || pathCommand3 == "S") {
              nx = d5.x * 2 - d5.bx;
              ny = d5.y * 2 - d5.by;
            } else {
              nx = d5.x;
              ny = d5.y;
            }
            path2 = ["C", nx, ny].concat(path2.slice(1));
            break;
          case "T":
            if (pathCommand3 == "Q" || pathCommand3 == "T") {
              d5.qx = d5.x * 2 - d5.qx;
              d5.qy = d5.y * 2 - d5.qy;
            } else {
              d5.qx = d5.x;
              d5.qy = d5.y;
            }
            path2 = ["C"].concat(qubicToCurve(d5.x, d5.y, d5.qx, d5.qy, path2[1], path2[2]));
            break;
          case "Q":
            d5.qx = path2[1];
            d5.qy = path2[2];
            path2 = ["C"].concat(qubicToCurve(d5.x, d5.y, path2[1], path2[2], path2[3], path2[4]));
            break;
          case "L":
            path2 = ["C"].concat(lineToCurve(d5.x, d5.y, path2[1], path2[2]));
            break;
          case "H":
            path2 = ["C"].concat(lineToCurve(d5.x, d5.y, path2[1], d5.y));
            break;
          case "V":
            path2 = ["C"].concat(lineToCurve(d5.x, d5.y, d5.x, path2[1]));
            break;
          case "Z":
            path2 = ["C"].concat(lineToCurve(d5.x, d5.y, d5.X, d5.Y));
            break;
        }
        return path2;
      }, fixArc = function(pp, i7) {
        if (pp[i7].length > 7) {
          pp[i7].shift();
          var pi = pp[i7];
          while (pi.length) {
            pathCommands[i7] = "A";
            pp.splice(i7++, 0, ["C"].concat(pi.splice(0, 6)));
          }
          pp.splice(i7, 1);
          ii = curvedPath.length;
        }
      }, pathCommands = [], pfirst = "", pathCommand2 = "";
      for (var i6 = 0, ii = curvedPath.length; i6 < ii; i6++) {
        curvedPath[i6] && (pfirst = curvedPath[i6][0]);
        if (pfirst != "C") {
          pathCommands[i6] = pfirst;
          i6 && (pathCommand2 = pathCommands[i6 - 1]);
        }
        curvedPath[i6] = processPath(curvedPath[i6], attrs, pathCommand2);
        if (pathCommands[i6] != "A" && pfirst == "C")
          pathCommands[i6] = "C";
        fixArc(curvedPath, i6);
        var seg = curvedPath[i6], seglen = seg.length;
        attrs.x = seg[seglen - 2];
        attrs.y = seg[seglen - 1];
        attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
        attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
      }
      pth.curve = pathClone(curvedPath);
      return curvedPath;
    }
    module2.exports = findPathIntersections;
  }
});

// node_modules/css.escape/css.escape.js
var require_css_escape = __commonJS({
  "node_modules/css.escape/css.escape.js"(exports, module2) {
    (function(root, factory) {
      if (typeof exports == "object") {
        module2.exports = factory(root);
      } else if (typeof define == "function" && define.amd) {
        define([], factory.bind(root, root));
      } else {
        factory(root);
      }
    })(typeof global != "undefined" ? global : exports, function(root) {
      if (root.CSS && root.CSS.escape) {
        return root.CSS.escape;
      }
      var cssEscape2 = function(value) {
        if (arguments.length == 0) {
          throw new TypeError("`CSS.escape` requires an argument.");
        }
        var string = String(value);
        var length2 = string.length;
        var index2 = -1;
        var codeUnit;
        var result = "";
        var firstCodeUnit = string.charCodeAt(0);
        while (++index2 < length2) {
          codeUnit = string.charCodeAt(index2);
          if (codeUnit == 0) {
            result += "\uFFFD";
            continue;
          }
          if (codeUnit >= 1 && codeUnit <= 31 || codeUnit == 127 || index2 == 0 && codeUnit >= 48 && codeUnit <= 57 || index2 == 1 && codeUnit >= 48 && codeUnit <= 57 && firstCodeUnit == 45) {
            result += "\\" + codeUnit.toString(16) + " ";
            continue;
          }
          if (index2 == 0 && length2 == 1 && codeUnit == 45) {
            result += "\\" + string.charAt(index2);
            continue;
          }
          if (codeUnit >= 128 || codeUnit == 45 || codeUnit == 95 || codeUnit >= 48 && codeUnit <= 57 || codeUnit >= 65 && codeUnit <= 90 || codeUnit >= 97 && codeUnit <= 122) {
            result += string.charAt(index2);
            continue;
          }
          result += "\\" + string.charAt(index2);
        }
        return result;
      };
      if (!root.CSS) {
        root.CSS = {};
      }
      root.CSS.escape = cssEscape2;
      return cssEscape2;
    });
  }
});

// node_modules/object-refs/lib/collection.js
var require_collection = __commonJS({
  "node_modules/object-refs/lib/collection.js"(exports, module2) {
    "use strict";
    function extend2(collection, refs, property, target) {
      var inverseProperty = property.inverse;
      Object.defineProperty(collection, "remove", {
        value: function(element) {
          var idx = this.indexOf(element);
          if (idx !== -1) {
            this.splice(idx, 1);
            refs.unset(element, inverseProperty, target);
          }
          return element;
        }
      });
      Object.defineProperty(collection, "contains", {
        value: function(element) {
          return this.indexOf(element) !== -1;
        }
      });
      Object.defineProperty(collection, "add", {
        value: function(element, idx) {
          var currentIdx = this.indexOf(element);
          if (typeof idx === "undefined") {
            if (currentIdx !== -1) {
              return;
            }
            idx = this.length;
          }
          if (currentIdx !== -1) {
            this.splice(currentIdx, 1);
          }
          this.splice(idx, 0, element);
          if (currentIdx === -1) {
            refs.set(element, inverseProperty, target);
          }
        }
      });
      Object.defineProperty(collection, "__refs_collection", {
        value: true
      });
      return collection;
    }
    function isExtended(collection) {
      return collection.__refs_collection === true;
    }
    module2.exports.extend = extend2;
    module2.exports.isExtended = isExtended;
  }
});

// node_modules/object-refs/lib/refs.js
var require_refs = __commonJS({
  "node_modules/object-refs/lib/refs.js"(exports, module2) {
    "use strict";
    var Collection2 = require_collection();
    function hasOwnProperty2(e7, property) {
      return Object.prototype.hasOwnProperty.call(e7, property.name || property);
    }
    function defineCollectionProperty(ref, property, target) {
      var collection = Collection2.extend(target[property.name] || [], ref, property, target);
      Object.defineProperty(target, property.name, {
        enumerable: property.enumerable,
        value: collection
      });
      if (collection.length) {
        collection.forEach(function(o7) {
          ref.set(o7, property.inverse, target);
        });
      }
    }
    function defineProperty2(ref, property, target) {
      var inverseProperty = property.inverse;
      var _value = target[property.name];
      Object.defineProperty(target, property.name, {
        configurable: property.configurable,
        enumerable: property.enumerable,
        get: function() {
          return _value;
        },
        set: function(value) {
          if (value === _value) {
            return;
          }
          var old = _value;
          _value = null;
          if (old) {
            ref.unset(old, inverseProperty, target);
          }
          _value = value;
          ref.set(_value, inverseProperty, target);
        }
      });
    }
    function Refs2(a6, b5) {
      if (!(this instanceof Refs2)) {
        return new Refs2(a6, b5);
      }
      a6.inverse = b5;
      b5.inverse = a6;
      this.props = {};
      this.props[a6.name] = a6;
      this.props[b5.name] = b5;
    }
    Refs2.prototype.bind = function(target, property) {
      if (typeof property === "string") {
        if (!this.props[property]) {
          throw new Error("no property <" + property + "> in ref");
        }
        property = this.props[property];
      }
      if (property.collection) {
        defineCollectionProperty(this, property, target);
      } else {
        defineProperty2(this, property, target);
      }
    };
    Refs2.prototype.ensureRefsCollection = function(target, property) {
      var collection = target[property.name];
      if (!Collection2.isExtended(collection)) {
        defineCollectionProperty(this, property, target);
      }
      return collection;
    };
    Refs2.prototype.ensureBound = function(target, property) {
      if (!hasOwnProperty2(target, property)) {
        this.bind(target, property);
      }
    };
    Refs2.prototype.unset = function(target, property, value) {
      if (target) {
        this.ensureBound(target, property);
        if (property.collection) {
          this.ensureRefsCollection(target, property).remove(value);
        } else {
          target[property.name] = void 0;
        }
      }
    };
    Refs2.prototype.set = function(target, property, value) {
      if (target) {
        this.ensureBound(target, property);
        if (property.collection) {
          this.ensureRefsCollection(target, property).add(value);
        } else {
          target[property.name] = value;
        }
      }
    };
    module2.exports = Refs2;
  }
});

// node_modules/object-refs/index.js
var require_object_refs = __commonJS({
  "node_modules/object-refs/index.js"(exports, module2) {
    module2.exports = require_refs();
    module2.exports.Collection = require_collection();
  }
});

// node_modules/hammerjs/hammer.js
var require_hammer = __commonJS({
  "node_modules/hammerjs/hammer.js"(exports, module2) {
    (function(window2, document2, exportName, undefined2) {
      "use strict";
      var VENDOR_PREFIXES = ["", "webkit", "Moz", "MS", "ms", "o"];
      var TEST_ELEMENT = document2.createElement("div");
      var TYPE_FUNCTION = "function";
      var round13 = Math.round;
      var abs8 = Math.abs;
      var now = Date.now;
      function setTimeoutContext(fn2, timeout, context) {
        return setTimeout(bindFn(fn2, context), timeout);
      }
      function invokeArrayArg(arg, fn2, context) {
        if (Array.isArray(arg)) {
          each(arg, context[fn2], context);
          return true;
        }
        return false;
      }
      function each(obj, iterator, context) {
        var i6;
        if (!obj) {
          return;
        }
        if (obj.forEach) {
          obj.forEach(iterator, context);
        } else if (obj.length !== undefined2) {
          i6 = 0;
          while (i6 < obj.length) {
            iterator.call(context, obj[i6], i6, obj);
            i6++;
          }
        } else {
          for (i6 in obj) {
            obj.hasOwnProperty(i6) && iterator.call(context, obj[i6], i6, obj);
          }
        }
      }
      function deprecate(method, name3, message) {
        var deprecationMessage = "DEPRECATED METHOD: " + name3 + "\n" + message + " AT \n";
        return function() {
          var e7 = new Error("get-stack-trace");
          var stack = e7 && e7.stack ? e7.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace";
          var log2 = window2.console && (window2.console.warn || window2.console.log);
          if (log2) {
            log2.call(window2.console, deprecationMessage, stack);
          }
          return method.apply(this, arguments);
        };
      }
      var assign71;
      if (typeof Object.assign !== "function") {
        assign71 = function assign72(target) {
          if (target === undefined2 || target === null) {
            throw new TypeError("Cannot convert undefined or null to object");
          }
          var output = Object(target);
          for (var index2 = 1; index2 < arguments.length; index2++) {
            var source = arguments[index2];
            if (source !== undefined2 && source !== null) {
              for (var nextKey in source) {
                if (source.hasOwnProperty(nextKey)) {
                  output[nextKey] = source[nextKey];
                }
              }
            }
          }
          return output;
        };
      } else {
        assign71 = Object.assign;
      }
      var extend2 = deprecate(function extend3(dest, src, merge2) {
        var keys4 = Object.keys(src);
        var i6 = 0;
        while (i6 < keys4.length) {
          if (!merge2 || merge2 && dest[keys4[i6]] === undefined2) {
            dest[keys4[i6]] = src[keys4[i6]];
          }
          i6++;
        }
        return dest;
      }, "extend", "Use `assign`.");
      var merge = deprecate(function merge2(dest, src) {
        return extend2(dest, src, true);
      }, "merge", "Use `assign`.");
      function inherit(child, base, properties) {
        var baseP = base.prototype, childP;
        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;
        if (properties) {
          assign71(childP, properties);
        }
      }
      function bindFn(fn2, context) {
        return function boundFn() {
          return fn2.apply(context, arguments);
        };
      }
      function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) {
          return val.apply(args ? args[0] || undefined2 : undefined2, args);
        }
        return val;
      }
      function ifUndefined(val1, val2) {
        return val1 === undefined2 ? val2 : val1;
      }
      function addEventListeners(target, types3, handler) {
        each(splitStr(types3), function(type) {
          target.addEventListener(type, handler, false);
        });
      }
      function removeEventListeners(target, types3, handler) {
        each(splitStr(types3), function(type) {
          target.removeEventListener(type, handler, false);
        });
      }
      function hasParent(node2, parent) {
        while (node2) {
          if (node2 == parent) {
            return true;
          }
          node2 = node2.parentNode;
        }
        return false;
      }
      function inStr(str, find28) {
        return str.indexOf(find28) > -1;
      }
      function splitStr(str) {
        return str.trim().split(/\s+/g);
      }
      function inArray(src, find28, findByKey) {
        if (src.indexOf && !findByKey) {
          return src.indexOf(find28);
        } else {
          var i6 = 0;
          while (i6 < src.length) {
            if (findByKey && src[i6][findByKey] == find28 || !findByKey && src[i6] === find28) {
              return i6;
            }
            i6++;
          }
          return -1;
        }
      }
      function toArray2(obj) {
        return Array.prototype.slice.call(obj, 0);
      }
      function uniqueArray(src, key, sort) {
        var results = [];
        var values5 = [];
        var i6 = 0;
        while (i6 < src.length) {
          var val = key ? src[i6][key] : src[i6];
          if (inArray(values5, val) < 0) {
            results.push(src[i6]);
          }
          values5[i6] = val;
          i6++;
        }
        if (sort) {
          if (!key) {
            results = results.sort();
          } else {
            results = results.sort(function sortUniqueArray(a6, b5) {
              return a6[key] > b5[key];
            });
          }
        }
        return results;
      }
      function prefixed(obj, property) {
        var prefix3, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i6 = 0;
        while (i6 < VENDOR_PREFIXES.length) {
          prefix3 = VENDOR_PREFIXES[i6];
          prop = prefix3 ? prefix3 + camelProp : property;
          if (prop in obj) {
            return prop;
          }
          i6++;
        }
        return undefined2;
      }
      var _uniqueId = 1;
      function uniqueId() {
        return _uniqueId++;
      }
      function getWindowForElement(element) {
        var doc = element.ownerDocument || element;
        return doc.defaultView || doc.parentWindow || window2;
      }
      var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
      var SUPPORT_TOUCH = "ontouchstart" in window2;
      var SUPPORT_POINTER_EVENTS = prefixed(window2, "PointerEvent") !== undefined2;
      var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
      var INPUT_TYPE_TOUCH = "touch";
      var INPUT_TYPE_PEN = "pen";
      var INPUT_TYPE_MOUSE = "mouse";
      var INPUT_TYPE_KINECT = "kinect";
      var COMPUTE_INTERVAL = 25;
      var INPUT_START = 1;
      var INPUT_MOVE = 2;
      var INPUT_END = 4;
      var INPUT_CANCEL = 8;
      var DIRECTION_NONE = 1;
      var DIRECTION_LEFT = 2;
      var DIRECTION_RIGHT = 4;
      var DIRECTION_UP = 8;
      var DIRECTION_DOWN = 16;
      var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
      var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
      var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
      var PROPS_XY = ["x", "y"];
      var PROPS_CLIENT_XY = ["clientX", "clientY"];
      function Input(manager, callback) {
        var self2 = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;
        this.domHandler = function(ev) {
          if (boolOrFn(manager.options.enable, [manager])) {
            self2.handler(ev);
          }
        };
        this.init();
      }
      Input.prototype = {
        handler: function() {
        },
        init: function() {
          this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        },
        destroy: function() {
          this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
      };
      function createInputInstance(manager) {
        var Type2;
        var inputClass = manager.options.inputClass;
        if (inputClass) {
          Type2 = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
          Type2 = PointerEventInput;
        } else if (SUPPORT_ONLY_TOUCH) {
          Type2 = TouchInput;
        } else if (!SUPPORT_TOUCH) {
          Type2 = MouseInput;
        } else {
          Type2 = TouchMouseInput;
        }
        return new Type2(manager, inputHandler);
      }
      function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;
        if (isFirst) {
          manager.session = {};
        }
        input.eventType = eventType;
        computeInputData(manager, input);
        manager.emit("hammer.input", input);
        manager.recognize(input);
        manager.session.prevInput = input;
      }
      function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;
        if (!session.firstInput) {
          session.firstInput = simpleCloneInputData(input);
        }
        if (pointersLength > 1 && !session.firstMultiple) {
          session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
          session.firstMultiple = false;
        }
        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center2 = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle2(offsetCenter, center2);
        input.distance = getDistance3(offsetCenter, center2);
        computeDeltaXY(session, input);
        input.offsetDirection = getDirection2(input.deltaX, input.deltaY);
        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
        input.overallVelocityX = overallVelocity.x;
        input.overallVelocityY = overallVelocity.y;
        input.overallVelocity = abs8(overallVelocity.x) > abs8(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
        input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
        computeIntervalInputData(session, input);
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) {
          target = input.srcEvent.target;
        }
        input.target = target;
      }
      function computeDeltaXY(session, input) {
        var center2 = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};
        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
          prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
          };
          offset = session.offsetDelta = {
            x: center2.x,
            y: center2.y
          };
        }
        input.deltaX = prevDelta.x + (center2.x - offset.x);
        input.deltaY = prevDelta.y + (center2.y - offset.y);
      }
      function computeIntervalInputData(session, input) {
        var last2 = session.lastInterval || input, deltaTime = input.timeStamp - last2.timeStamp, velocity, velocityX, velocityY, direction;
        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last2.velocity === undefined2)) {
          var deltaX = input.deltaX - last2.deltaX;
          var deltaY = input.deltaY - last2.deltaY;
          var v5 = getVelocity(deltaTime, deltaX, deltaY);
          velocityX = v5.x;
          velocityY = v5.y;
          velocity = abs8(v5.x) > abs8(v5.y) ? v5.x : v5.y;
          direction = getDirection2(deltaX, deltaY);
          session.lastInterval = input;
        } else {
          velocity = last2.velocity;
          velocityX = last2.velocityX;
          velocityY = last2.velocityY;
          direction = last2.direction;
        }
        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
      }
      function simpleCloneInputData(input) {
        var pointers = [];
        var i6 = 0;
        while (i6 < input.pointers.length) {
          pointers[i6] = {
            clientX: round13(input.pointers[i6].clientX),
            clientY: round13(input.pointers[i6].clientY)
          };
          i6++;
        }
        return {
          timeStamp: now(),
          pointers,
          center: getCenter(pointers),
          deltaX: input.deltaX,
          deltaY: input.deltaY
        };
      }
      function getCenter(pointers) {
        var pointersLength = pointers.length;
        if (pointersLength === 1) {
          return {
            x: round13(pointers[0].clientX),
            y: round13(pointers[0].clientY)
          };
        }
        var x4 = 0, y4 = 0, i6 = 0;
        while (i6 < pointersLength) {
          x4 += pointers[i6].clientX;
          y4 += pointers[i6].clientY;
          i6++;
        }
        return {
          x: round13(x4 / pointersLength),
          y: round13(y4 / pointersLength)
        };
      }
      function getVelocity(deltaTime, x4, y4) {
        return {
          x: x4 / deltaTime || 0,
          y: y4 / deltaTime || 0
        };
      }
      function getDirection2(x4, y4) {
        if (x4 === y4) {
          return DIRECTION_NONE;
        }
        if (abs8(x4) >= abs8(y4)) {
          return x4 < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return y4 < 0 ? DIRECTION_UP : DIRECTION_DOWN;
      }
      function getDistance3(p1, p22, props) {
        if (!props) {
          props = PROPS_XY;
        }
        var x4 = p22[props[0]] - p1[props[0]], y4 = p22[props[1]] - p1[props[1]];
        return Math.sqrt(x4 * x4 + y4 * y4);
      }
      function getAngle2(p1, p22, props) {
        if (!props) {
          props = PROPS_XY;
        }
        var x4 = p22[props[0]] - p1[props[0]], y4 = p22[props[1]] - p1[props[1]];
        return Math.atan2(y4, x4) * 180 / Math.PI;
      }
      function getRotation(start, end) {
        return getAngle2(end[1], end[0], PROPS_CLIENT_XY) + getAngle2(start[1], start[0], PROPS_CLIENT_XY);
      }
      function getScale(start, end) {
        return getDistance3(end[0], end[1], PROPS_CLIENT_XY) / getDistance3(start[0], start[1], PROPS_CLIENT_XY);
      }
      var MOUSE_INPUT_MAP = {
        mousedown: INPUT_START,
        mousemove: INPUT_MOVE,
        mouseup: INPUT_END
      };
      var MOUSE_ELEMENT_EVENTS = "mousedown";
      var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
      function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.pressed = false;
        Input.apply(this, arguments);
      }
      inherit(MouseInput, Input, {
        handler: function MEhandler(ev) {
          var eventType = MOUSE_INPUT_MAP[ev.type];
          if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
          }
          if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
          }
          if (!this.pressed) {
            return;
          }
          if (eventType & INPUT_END) {
            this.pressed = false;
          }
          this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
          });
        }
      });
      var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START,
        pointermove: INPUT_MOVE,
        pointerup: INPUT_END,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
      };
      var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT
      };
      var POINTER_ELEMENT_EVENTS = "pointerdown";
      var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
      if (window2.MSPointerEvent && !window2.PointerEvent) {
        POINTER_ELEMENT_EVENTS = "MSPointerDown";
        POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
      }
      function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = [];
      }
      inherit(PointerEventInput, Input, {
        handler: function PEhandler(ev) {
          var store = this.store;
          var removePointer = false;
          var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
          var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
          var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
          var isTouch = pointerType == INPUT_TYPE_TOUCH;
          var storeIndex = inArray(store, ev.pointerId, "pointerId");
          if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
              store.push(ev);
              storeIndex = store.length - 1;
            }
          } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
          }
          if (storeIndex < 0) {
            return;
          }
          store[storeIndex] = ev;
          this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType,
            srcEvent: ev
          });
          if (removePointer) {
            store.splice(storeIndex, 1);
          }
        }
      });
      var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
      };
      var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
      var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
      function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input.apply(this, arguments);
      }
      inherit(SingleTouchInput, Input, {
        handler: function TEhandler(ev) {
          var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
          if (type === INPUT_START) {
            this.started = true;
          }
          if (!this.started) {
            return;
          }
          var touches = normalizeSingleTouches.call(this, ev, type);
          if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
          }
          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });
      function normalizeSingleTouches(ev, type) {
        var all2 = toArray2(ev.touches);
        var changed = toArray2(ev.changedTouches);
        if (type & (INPUT_END | INPUT_CANCEL)) {
          all2 = uniqueArray(all2.concat(changed), "identifier", true);
        }
        return [all2, changed];
      }
      var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
      };
      var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
      function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input.apply(this, arguments);
      }
      inherit(TouchInput, Input, {
        handler: function MTEhandler(ev) {
          var type = TOUCH_INPUT_MAP[ev.type];
          var touches = getTouches.call(this, ev, type);
          if (!touches) {
            return;
          }
          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });
      function getTouches(ev, type) {
        var allTouches = toArray2(ev.touches);
        var targetIds = this.targetIds;
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
          targetIds[allTouches[0].identifier] = true;
          return [allTouches, allTouches];
        }
        var i6, targetTouches, changedTouches = toArray2(ev.changedTouches), changedTargetTouches = [], target = this.target;
        targetTouches = allTouches.filter(function(touch) {
          return hasParent(touch.target, target);
        });
        if (type === INPUT_START) {
          i6 = 0;
          while (i6 < targetTouches.length) {
            targetIds[targetTouches[i6].identifier] = true;
            i6++;
          }
        }
        i6 = 0;
        while (i6 < changedTouches.length) {
          if (targetIds[changedTouches[i6].identifier]) {
            changedTargetTouches.push(changedTouches[i6]);
          }
          if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i6].identifier];
          }
          i6++;
        }
        if (!changedTargetTouches.length) {
          return;
        }
        return [
          uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true),
          changedTargetTouches
        ];
      }
      var DEDUP_TIMEOUT = 2500;
      var DEDUP_DISTANCE = 25;
      function TouchMouseInput() {
        Input.apply(this, arguments);
        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);
        this.primaryTouch = null;
        this.lastTouches = [];
      }
      inherit(TouchMouseInput, Input, {
        handler: function TMEhandler(manager, inputEvent, inputData) {
          var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
          if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
          }
          if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
          } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
          }
          this.callback(manager, inputEvent, inputData);
        },
        destroy: function destroy() {
          this.touch.destroy();
          this.mouse.destroy();
        }
      });
      function recordTouches(eventType, eventData) {
        if (eventType & INPUT_START) {
          this.primaryTouch = eventData.changedPointers[0].identifier;
          setLastTouch.call(this, eventData);
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
          setLastTouch.call(this, eventData);
        }
      }
      function setLastTouch(eventData) {
        var touch = eventData.changedPointers[0];
        if (touch.identifier === this.primaryTouch) {
          var lastTouch = { x: touch.clientX, y: touch.clientY };
          this.lastTouches.push(lastTouch);
          var lts = this.lastTouches;
          var removeLastTouch = function() {
            var i6 = lts.indexOf(lastTouch);
            if (i6 > -1) {
              lts.splice(i6, 1);
            }
          };
          setTimeout(removeLastTouch, DEDUP_TIMEOUT);
        }
      }
      function isSyntheticEvent(eventData) {
        var x4 = eventData.srcEvent.clientX, y4 = eventData.srcEvent.clientY;
        for (var i6 = 0; i6 < this.lastTouches.length; i6++) {
          var t6 = this.lastTouches[i6];
          var dx = Math.abs(x4 - t6.x), dy = Math.abs(y4 - t6.y);
          if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
          }
        }
        return false;
      }
      var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
      var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined2;
      var TOUCH_ACTION_COMPUTE = "compute";
      var TOUCH_ACTION_AUTO = "auto";
      var TOUCH_ACTION_MANIPULATION = "manipulation";
      var TOUCH_ACTION_NONE = "none";
      var TOUCH_ACTION_PAN_X = "pan-x";
      var TOUCH_ACTION_PAN_Y = "pan-y";
      var TOUCH_ACTION_MAP = getTouchActionProps();
      function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
      }
      TouchAction.prototype = {
        set: function(value) {
          if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
          }
          if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
          }
          this.actions = value.toLowerCase().trim();
        },
        update: function() {
          this.set(this.manager.options.touchAction);
        },
        compute: function() {
          var actions = [];
          each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
              actions = actions.concat(recognizer.getTouchAction());
            }
          });
          return cleanTouchActions(actions.join(" "));
        },
        preventDefaults: function(input) {
          var srcEvent = input.srcEvent;
          var direction = input.offsetDirection;
          if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
          }
          var actions = this.actions;
          var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
          if (hasNone) {
            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;
            if (isTapPointer && isTapMovement && isTapTouchTime) {
              return;
            }
          }
          if (hasPanX && hasPanY) {
            return;
          }
          if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
            return this.preventSrc(srcEvent);
          }
        },
        preventSrc: function(srcEvent) {
          this.manager.session.prevented = true;
          srcEvent.preventDefault();
        }
      };
      function cleanTouchActions(actions) {
        if (inStr(actions, TOUCH_ACTION_NONE)) {
          return TOUCH_ACTION_NONE;
        }
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        if (hasPanX && hasPanY) {
          return TOUCH_ACTION_NONE;
        }
        if (hasPanX || hasPanY) {
          return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
          return TOUCH_ACTION_MANIPULATION;
        }
        return TOUCH_ACTION_AUTO;
      }
      function getTouchActionProps() {
        if (!NATIVE_TOUCH_ACTION) {
          return false;
        }
        var touchMap = {};
        var cssSupports = window2.CSS && window2.CSS.supports;
        ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(val) {
          touchMap[val] = cssSupports ? window2.CSS.supports("touch-action", val) : true;
        });
        return touchMap;
      }
      var STATE_POSSIBLE = 1;
      var STATE_BEGAN = 2;
      var STATE_CHANGED = 4;
      var STATE_ENDED = 8;
      var STATE_RECOGNIZED = STATE_ENDED;
      var STATE_CANCELLED = 16;
      var STATE_FAILED = 32;
      function Recognizer(options2) {
        this.options = assign71({}, this.defaults, options2 || {});
        this.id = uniqueId();
        this.manager = null;
        this.options.enable = ifUndefined(this.options.enable, true);
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
      }
      Recognizer.prototype = {
        defaults: {},
        set: function(options2) {
          assign71(this.options, options2);
          this.manager && this.manager.touchAction.update();
          return this;
        },
        recognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) {
            return this;
          }
          var simultaneous = this.simultaneous;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
          }
          return this;
        },
        dropRecognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) {
            return this;
          }
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          delete this.simultaneous[otherRecognizer.id];
          return this;
        },
        requireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "requireFailure", this)) {
            return this;
          }
          var requireFail = this.requireFail;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
          }
          return this;
        },
        dropRequireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) {
            return this;
          }
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          var index2 = inArray(this.requireFail, otherRecognizer);
          if (index2 > -1) {
            this.requireFail.splice(index2, 1);
          }
          return this;
        },
        hasRequireFailures: function() {
          return this.requireFail.length > 0;
        },
        canRecognizeWith: function(otherRecognizer) {
          return !!this.simultaneous[otherRecognizer.id];
        },
        emit: function(input) {
          var self2 = this;
          var state = this.state;
          function emit(event2) {
            self2.manager.emit(event2, input);
          }
          if (state < STATE_ENDED) {
            emit(self2.options.event + stateStr(state));
          }
          emit(self2.options.event);
          if (input.additionalEvent) {
            emit(input.additionalEvent);
          }
          if (state >= STATE_ENDED) {
            emit(self2.options.event + stateStr(state));
          }
        },
        tryEmit: function(input) {
          if (this.canEmit()) {
            return this.emit(input);
          }
          this.state = STATE_FAILED;
        },
        canEmit: function() {
          var i6 = 0;
          while (i6 < this.requireFail.length) {
            if (!(this.requireFail[i6].state & (STATE_FAILED | STATE_POSSIBLE))) {
              return false;
            }
            i6++;
          }
          return true;
        },
        recognize: function(inputData) {
          var inputDataClone = assign71({}, inputData);
          if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
          }
          if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
          }
          this.state = this.process(inputDataClone);
          if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
          }
        },
        process: function(inputData) {
        },
        getTouchAction: function() {
        },
        reset: function() {
        }
      };
      function stateStr(state) {
        if (state & STATE_CANCELLED) {
          return "cancel";
        } else if (state & STATE_ENDED) {
          return "end";
        } else if (state & STATE_CHANGED) {
          return "move";
        } else if (state & STATE_BEGAN) {
          return "start";
        }
        return "";
      }
      function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
          return "down";
        } else if (direction == DIRECTION_UP) {
          return "up";
        } else if (direction == DIRECTION_LEFT) {
          return "left";
        } else if (direction == DIRECTION_RIGHT) {
          return "right";
        }
        return "";
      }
      function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) {
          return manager.get(otherRecognizer);
        }
        return otherRecognizer;
      }
      function AttrRecognizer() {
        Recognizer.apply(this, arguments);
      }
      inherit(AttrRecognizer, Recognizer, {
        defaults: {
          pointers: 1
        },
        attrTest: function(input) {
          var optionPointers = this.options.pointers;
          return optionPointers === 0 || input.pointers.length === optionPointers;
        },
        process: function(input) {
          var state = this.state;
          var eventType = input.eventType;
          var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
          var isValid = this.attrTest(input);
          if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
          } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
              return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
              return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
          }
          return STATE_FAILED;
        }
      });
      function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);
        this.pX = null;
        this.pY = null;
      }
      inherit(PanRecognizer, AttrRecognizer, {
        defaults: {
          event: "pan",
          threshold: 10,
          pointers: 1,
          direction: DIRECTION_ALL
        },
        getTouchAction: function() {
          var direction = this.options.direction;
          var actions = [];
          if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
          }
          if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
          }
          return actions;
        },
        directionTest: function(input) {
          var options2 = this.options;
          var hasMoved = true;
          var distance2 = input.distance;
          var direction = input.direction;
          var x4 = input.deltaX;
          var y4 = input.deltaY;
          if (!(direction & options2.direction)) {
            if (options2.direction & DIRECTION_HORIZONTAL) {
              direction = x4 === 0 ? DIRECTION_NONE : x4 < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
              hasMoved = x4 != this.pX;
              distance2 = Math.abs(input.deltaX);
            } else {
              direction = y4 === 0 ? DIRECTION_NONE : y4 < 0 ? DIRECTION_UP : DIRECTION_DOWN;
              hasMoved = y4 != this.pY;
              distance2 = Math.abs(input.deltaY);
            }
          }
          input.direction = direction;
          return hasMoved && distance2 > options2.threshold && direction & options2.direction;
        },
        attrTest: function(input) {
          return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
        },
        emit: function(input) {
          this.pX = input.deltaX;
          this.pY = input.deltaY;
          var direction = directionStr(input.direction);
          if (direction) {
            input.additionalEvent = this.options.event + direction;
          }
          this._super.emit.call(this, input);
        }
      });
      function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(PinchRecognizer, AttrRecognizer, {
        defaults: {
          event: "pinch",
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function(input) {
          return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },
        emit: function(input) {
          if (input.scale !== 1) {
            var inOut = input.scale < 1 ? "in" : "out";
            input.additionalEvent = this.options.event + inOut;
          }
          this._super.emit.call(this, input);
        }
      });
      function PressRecognizer() {
        Recognizer.apply(this, arguments);
        this._timer = null;
        this._input = null;
      }
      inherit(PressRecognizer, Recognizer, {
        defaults: {
          event: "press",
          pointers: 1,
          time: 251,
          threshold: 9
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_AUTO];
        },
        process: function(input) {
          var options2 = this.options;
          var validPointers = input.pointers.length === options2.pointers;
          var validMovement = input.distance < options2.threshold;
          var validTime = input.deltaTime > options2.time;
          this._input = input;
          if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
            this.reset();
          } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
              this.state = STATE_RECOGNIZED;
              this.tryEmit();
            }, options2.time, this);
          } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
          }
          return STATE_FAILED;
        },
        reset: function() {
          clearTimeout(this._timer);
        },
        emit: function(input) {
          if (this.state !== STATE_RECOGNIZED) {
            return;
          }
          if (input && input.eventType & INPUT_END) {
            this.manager.emit(this.options.event + "up", input);
          } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
          }
        }
      });
      function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(RotateRecognizer, AttrRecognizer, {
        defaults: {
          event: "rotate",
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function(input) {
          return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
      });
      function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(SwipeRecognizer, AttrRecognizer, {
        defaults: {
          event: "swipe",
          threshold: 10,
          velocity: 0.3,
          direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
          pointers: 1
        },
        getTouchAction: function() {
          return PanRecognizer.prototype.getTouchAction.call(this);
        },
        attrTest: function(input) {
          var direction = this.options.direction;
          var velocity;
          if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
          } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
          } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
          }
          return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs8(velocity) > this.options.velocity && input.eventType & INPUT_END;
        },
        emit: function(input) {
          var direction = directionStr(input.offsetDirection);
          if (direction) {
            this.manager.emit(this.options.event + direction, input);
          }
          this.manager.emit(this.options.event, input);
        }
      });
      function TapRecognizer() {
        Recognizer.apply(this, arguments);
        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
      }
      inherit(TapRecognizer, Recognizer, {
        defaults: {
          event: "tap",
          pointers: 1,
          taps: 1,
          interval: 300,
          time: 250,
          threshold: 9,
          posThreshold: 10
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_MANIPULATION];
        },
        process: function(input) {
          var options2 = this.options;
          var validPointers = input.pointers.length === options2.pointers;
          var validMovement = input.distance < options2.threshold;
          var validTouchTime = input.deltaTime < options2.time;
          this.reset();
          if (input.eventType & INPUT_START && this.count === 0) {
            return this.failTimeout();
          }
          if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
              return this.failTimeout();
            }
            var validInterval = this.pTime ? input.timeStamp - this.pTime < options2.interval : true;
            var validMultiTap = !this.pCenter || getDistance3(this.pCenter, input.center) < options2.posThreshold;
            this.pTime = input.timeStamp;
            this.pCenter = input.center;
            if (!validMultiTap || !validInterval) {
              this.count = 1;
            } else {
              this.count += 1;
            }
            this._input = input;
            var tapCount = this.count % options2.taps;
            if (tapCount === 0) {
              if (!this.hasRequireFailures()) {
                return STATE_RECOGNIZED;
              } else {
                this._timer = setTimeoutContext(function() {
                  this.state = STATE_RECOGNIZED;
                  this.tryEmit();
                }, options2.interval, this);
                return STATE_BEGAN;
              }
            }
          }
          return STATE_FAILED;
        },
        failTimeout: function() {
          this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
          }, this.options.interval, this);
          return STATE_FAILED;
        },
        reset: function() {
          clearTimeout(this._timer);
        },
        emit: function() {
          if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
          }
        }
      });
      function Hammer2(element, options2) {
        options2 = options2 || {};
        options2.recognizers = ifUndefined(options2.recognizers, Hammer2.defaults.preset);
        return new Manager(element, options2);
      }
      Hammer2.VERSION = "2.0.7";
      Hammer2.defaults = {
        domEvents: false,
        touchAction: TOUCH_ACTION_COMPUTE,
        enable: true,
        inputTarget: null,
        inputClass: null,
        preset: [
          [RotateRecognizer, { enable: false }],
          [PinchRecognizer, { enable: false }, ["rotate"]],
          [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],
          [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ["swipe"]],
          [TapRecognizer],
          [TapRecognizer, { event: "doubletap", taps: 2 }, ["tap"]],
          [PressRecognizer]
        ],
        cssProps: {
          userSelect: "none",
          touchSelect: "none",
          touchCallout: "none",
          contentZooming: "none",
          userDrag: "none",
          tapHighlightColor: "rgba(0,0,0,0)"
        }
      };
      var STOP = 1;
      var FORCED_STOP = 2;
      function Manager(element, options2) {
        this.options = assign71({}, Hammer2.defaults, options2 || {});
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.oldCssProps = {};
        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each(this.options.recognizers, function(item) {
          var recognizer = this.add(new item[0](item[1]));
          item[2] && recognizer.recognizeWith(item[2]);
          item[3] && recognizer.requireFailure(item[3]);
        }, this);
      }
      Manager.prototype = {
        set: function(options2) {
          assign71(this.options, options2);
          if (options2.touchAction) {
            this.touchAction.update();
          }
          if (options2.inputTarget) {
            this.input.destroy();
            this.input.target = options2.inputTarget;
            this.input.init();
          }
          return this;
        },
        stop: function(force) {
          this.session.stopped = force ? FORCED_STOP : STOP;
        },
        recognize: function(inputData) {
          var session = this.session;
          if (session.stopped) {
            return;
          }
          this.touchAction.preventDefaults(inputData);
          var recognizer;
          var recognizers = this.recognizers;
          var curRecognizer = session.curRecognizer;
          if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
            curRecognizer = session.curRecognizer = null;
          }
          var i6 = 0;
          while (i6 < recognizers.length) {
            recognizer = recognizers[i6];
            if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer == curRecognizer || recognizer.canRecognizeWith(curRecognizer))) {
              recognizer.recognize(inputData);
            } else {
              recognizer.reset();
            }
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
              curRecognizer = session.curRecognizer = recognizer;
            }
            i6++;
          }
        },
        get: function(recognizer) {
          if (recognizer instanceof Recognizer) {
            return recognizer;
          }
          var recognizers = this.recognizers;
          for (var i6 = 0; i6 < recognizers.length; i6++) {
            if (recognizers[i6].options.event == recognizer) {
              return recognizers[i6];
            }
          }
          return null;
        },
        add: function(recognizer) {
          if (invokeArrayArg(recognizer, "add", this)) {
            return this;
          }
          var existing = this.get(recognizer.options.event);
          if (existing) {
            this.remove(existing);
          }
          this.recognizers.push(recognizer);
          recognizer.manager = this;
          this.touchAction.update();
          return recognizer;
        },
        remove: function(recognizer) {
          if (invokeArrayArg(recognizer, "remove", this)) {
            return this;
          }
          recognizer = this.get(recognizer);
          if (recognizer) {
            var recognizers = this.recognizers;
            var index2 = inArray(recognizers, recognizer);
            if (index2 !== -1) {
              recognizers.splice(index2, 1);
              this.touchAction.update();
            }
          }
          return this;
        },
        on: function(events, handler) {
          if (events === undefined2) {
            return;
          }
          if (handler === undefined2) {
            return;
          }
          var handlers = this.handlers;
          each(splitStr(events), function(event2) {
            handlers[event2] = handlers[event2] || [];
            handlers[event2].push(handler);
          });
          return this;
        },
        off: function(events, handler) {
          if (events === undefined2) {
            return;
          }
          var handlers = this.handlers;
          each(splitStr(events), function(event2) {
            if (!handler) {
              delete handlers[event2];
            } else {
              handlers[event2] && handlers[event2].splice(inArray(handlers[event2], handler), 1);
            }
          });
          return this;
        },
        emit: function(event2, data) {
          if (this.options.domEvents) {
            triggerDomEvent(event2, data);
          }
          var handlers = this.handlers[event2] && this.handlers[event2].slice();
          if (!handlers || !handlers.length) {
            return;
          }
          data.type = event2;
          data.preventDefault = function() {
            data.srcEvent.preventDefault();
          };
          var i6 = 0;
          while (i6 < handlers.length) {
            handlers[i6](data);
            i6++;
          }
        },
        destroy: function() {
          this.element && toggleCssProps(this, false);
          this.handlers = {};
          this.session = {};
          this.input.destroy();
          this.element = null;
        }
      };
      function toggleCssProps(manager, add3) {
        var element = manager.element;
        if (!element.style) {
          return;
        }
        var prop;
        each(manager.options.cssProps, function(value, name3) {
          prop = prefixed(element.style, name3);
          if (add3) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
          } else {
            element.style[prop] = manager.oldCssProps[prop] || "";
          }
        });
        if (!add3) {
          manager.oldCssProps = {};
        }
      }
      function triggerDomEvent(event2, data) {
        var gestureEvent = document2.createEvent("Event");
        gestureEvent.initEvent(event2, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
      }
      assign71(Hammer2, {
        INPUT_START,
        INPUT_MOVE,
        INPUT_END,
        INPUT_CANCEL,
        STATE_POSSIBLE,
        STATE_BEGAN,
        STATE_CHANGED,
        STATE_ENDED,
        STATE_RECOGNIZED,
        STATE_CANCELLED,
        STATE_FAILED,
        DIRECTION_NONE,
        DIRECTION_LEFT,
        DIRECTION_RIGHT,
        DIRECTION_UP,
        DIRECTION_DOWN,
        DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL,
        DIRECTION_ALL,
        Manager,
        Input,
        TouchAction,
        TouchInput,
        MouseInput,
        PointerEventInput,
        TouchMouseInput,
        SingleTouchInput,
        Recognizer,
        AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,
        on: addEventListeners,
        off: removeEventListeners,
        each,
        merge,
        extend: extend2,
        assign: assign71,
        inherit,
        bindFn,
        prefixed
      });
      var freeGlobal = typeof window2 !== "undefined" ? window2 : typeof self !== "undefined" ? self : {};
      freeGlobal.Hammer = Hammer2;
      if (typeof define === "function" && define.amd) {
        define(function() {
          return Hammer2;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = Hammer2;
      } else {
        window2[exportName] = Hammer2;
      }
    })(window, document, "Hammer");
  }
});

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports, module2) {
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      var nativeCodeString = "[native code]";
      function classNames() {
        var classes3 = [];
        for (var i6 = 0; i6 < arguments.length; i6++) {
          var arg = arguments[i6];
          if (!arg)
            continue;
          var argType = typeof arg;
          if (argType === "string" || argType === "number") {
            classes3.push(arg);
          } else if (Array.isArray(arg)) {
            if (arg.length) {
              var inner = classNames.apply(null, arg);
              if (inner) {
                classes3.push(inner);
              }
            }
          } else if (argType === "object") {
            if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
              classes3.push(arg.toString());
              continue;
            }
            for (var key in arg) {
              if (hasOwn.call(arg, key) && arg[key]) {
                classes3.push(key);
              }
            }
          }
        }
        return classes3.join(" ");
      }
      if (typeof module2 !== "undefined" && module2.exports) {
        classNames.default = classNames;
        module2.exports = classNames;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames;
        });
      } else {
        window.classNames = classNames;
      }
    })();
  }
});

// node_modules/@bpmn-io/extract-process-variables/zeebe/index.js
var require_zeebe = __commonJS({
  "node_modules/@bpmn-io/extract-process-variables/zeebe/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var minDash = require_dist();
    function getInputOutput2(element) {
      return (getElements2(element, "zeebe:IoMapping") || [])[0];
    }
    function getInputParameters2(element) {
      return getParameters2(element, "inputParameters");
    }
    function getOutMappings2(element) {
      return (getInputOutput2(element) || {}).outputParameters;
    }
    function getInMappings2(element) {
      return (getInputOutput2(element) || {}).inputParameters;
    }
    function getInputElement(loopCharacteristics) {
      const extensionElement = getElements2(loopCharacteristics, "zeebe:LoopCharacteristics")[0];
      return extensionElement && extensionElement.inputElement;
    }
    function getOutputCollection(loopCharacteristics) {
      const extensionElement = getElements2(loopCharacteristics, "zeebe:LoopCharacteristics")[0];
      return extensionElement && extensionElement.outputCollection;
    }
    function getCalledDecision2(element) {
      return (getElements2(element, "zeebe:CalledDecision") || [])[0];
    }
    function getElements2(element, type, property) {
      var elements = getExtensionElements2(element, type);
      return !property ? elements : (elements[0] || {})[property] || [];
    }
    function getParameters2(element, property) {
      var inputOutput = getInputOutput2(element);
      return inputOutput && inputOutput.get(property) || [];
    }
    function getExtensionElements2(element, type) {
      var elements = [];
      var extensionElements = element.get("extensionElements");
      if (typeof extensionElements !== "undefined") {
        var extensionValues = extensionElements.get("values");
        if (typeof extensionValues !== "undefined") {
          elements = minDash.filter(extensionValues, function(value) {
            return is$2(value, type);
          });
        }
      }
      return elements;
    }
    function is$2(element, type) {
      return element && typeof element.$instanceOf === "function" && element.$instanceOf(type);
    }
    function getParents3(element) {
      var parents = [];
      var current = element;
      while (current.$parent) {
        parents.push(current.$parent);
        current = current.$parent;
      }
      return parents;
    }
    function eachElement2(elements, fn2, depth) {
      depth = depth || 0;
      if (!minDash.isArray(elements)) {
        elements = [elements];
      }
      minDash.forEach(elements, function(s5, i6) {
        var filter28 = fn2(s5, i6, depth);
        if (minDash.isArray(filter28) && filter28.length) {
          eachElement2(filter28, fn2, depth + 1);
        }
      });
    }
    function add3(elements, e7, unique) {
      var canAdd = !unique || elements.indexOf(e7) === -1;
      if (canAdd) {
        elements.push(e7);
      }
      return canAdd;
    }
    function selfAndFlowElements(elements, unique, maxDepth) {
      var result = [], processedFlowElements = [];
      eachElement2(elements, function(element, i6, depth) {
        add3(result, element, unique);
        var flowElements = element.flowElements;
        if (maxDepth === -1 || depth < maxDepth) {
          if (flowElements && add3(processedFlowElements, flowElements, unique)) {
            return flowElements;
          }
        }
      });
      return result;
    }
    function selfAndAllFlowElements2(elements, allowDuplicates) {
      return selfAndFlowElements(elements, !allowDuplicates, -1);
    }
    function getElement(elementId, rootElement) {
      var allElements = selfAndAllFlowElements2(rootElement);
      return minDash.find(allElements, function(element) {
        return element.id === elementId;
      });
    }
    function addVariableToList(variablesList, newVariable) {
      var foundIdx = minDash.findIndex(variablesList, function(variable) {
        return variable.name === newVariable.name && variable.scope === newVariable.scope;
      });
      if (foundIdx >= 0) {
        variablesList[foundIdx].origin = combineArrays$1(variablesList[foundIdx].origin, newVariable.origin);
      } else {
        variablesList.push(newVariable);
      }
    }
    function createProcessVariable(flowElement, name3, defaultScope) {
      var scope = getScope$1(flowElement, defaultScope, name3);
      return {
        name: name3,
        origin: [flowElement],
        scope
      };
    }
    function getScope$1(element, globalScope, variableName) {
      var parents = getParents3(element);
      var scopedParent = minDash.find(parents, function(parent) {
        return is$1(parent, "bpmn:SubProcess") && hasInputParameter(parent, variableName);
      });
      return scopedParent ? scopedParent : globalScope;
    }
    function is$1(element, type) {
      return element && typeof element.$instanceOf === "function" && element.$instanceOf(type);
    }
    function hasInputParameter(element, name3) {
      return minDash.find(getInputParameters2(element), function(input) {
        return input.target === name3;
      });
    }
    function combineArrays$1(a6, b5) {
      return a6.concat(b5);
    }
    function extractInMappings(options2) {
      var elements = options2.elements, processVariables = options2.processVariables;
      if (!minDash.isArray(elements)) {
        elements = [elements];
      }
      minDash.forEach(elements, function(element) {
        var inMappings = getInMappings2(element);
        minDash.forEach(inMappings, function(mapping) {
          var newVariable = createProcessVariable(element, mapping.target, element);
          addVariableToList(processVariables, newVariable);
        });
      });
      return processVariables;
    }
    function extractInputElement(options2) {
      var elements = options2.elements, processVariables = options2.processVariables;
      if (!minDash.isArray(elements)) {
        elements = [elements];
      }
      minDash.forEach(elements, function(element) {
        var loopCharacteristics = element.loopCharacteristics;
        var inputElement = loopCharacteristics && getInputElement(loopCharacteristics);
        if (inputElement) {
          var newVariable = createProcessVariable(element, inputElement, element);
          addVariableToList(processVariables, newVariable);
        }
      });
      return processVariables;
    }
    function extractOutMappings(options2) {
      var elements = options2.elements, containerElement = options2.containerElement, processVariables = options2.processVariables;
      if (!minDash.isArray(elements)) {
        elements = [elements];
      }
      minDash.forEach(elements, function(element) {
        var outMappings = getOutMappings2(element);
        minDash.forEach(outMappings, function(mapping) {
          var newVariable = createProcessVariable(element, mapping.target, containerElement);
          addVariableToList(processVariables, newVariable);
        });
      });
      return processVariables;
    }
    function extractOutputCollections(options2) {
      var elements = options2.elements, containerElement = options2.containerElement, processVariables = options2.processVariables;
      if (!minDash.isArray(elements)) {
        elements = [elements];
      }
      minDash.forEach(elements, function(element) {
        var loopCharacteristics = element.loopCharacteristics;
        var outputCollection = loopCharacteristics && getOutputCollection(loopCharacteristics);
        if (outputCollection) {
          var newVariable = createProcessVariable(element, outputCollection, containerElement);
          addVariableToList(processVariables, newVariable);
        }
      });
      return processVariables;
    }
    function extractResultVariables(options2) {
      var elements = options2.elements, containerElement = options2.containerElement, processVariables = options2.processVariables;
      if (!minDash.isArray(elements)) {
        elements = [elements];
      }
      minDash.forEach(elements, function(element) {
        var calledDecision = getCalledDecision2(element);
        if (!calledDecision) {
          return;
        }
        var resultVariable = calledDecision.resultVariable;
        if (resultVariable) {
          var newVariable = createProcessVariable(element, resultVariable, containerElement);
          addVariableToList(processVariables, newVariable);
        }
      });
      return processVariables;
    }
    var extractors = [
      extractInMappings,
      extractInputElement,
      extractOutMappings,
      extractOutputCollections,
      extractResultVariables
    ];
    function getProcessVariables(containerElement) {
      var processVariables = [];
      var elements = selfAndAllFlowElements2([containerElement], false);
      minDash.forEach(extractors, function(extractor) {
        extractor({
          elements,
          containerElement,
          processVariables
        });
      });
      return processVariables;
    }
    function getVariablesForScope2(scope, rootElement) {
      var allVariables = getProcessVariables(rootElement);
      var scopeElement = getElement(scope, rootElement);
      var scopeVariables = minDash.filter(allVariables, function(variable) {
        return variable.scope.id === scopeElement.id;
      });
      var parents = getParents3(scopeElement);
      var parentsScopeVariables = minDash.filter(allVariables, function(variable) {
        return minDash.find(parents, function(parent) {
          return parent.id === variable.scope.id;
        });
      });
      return combineArrays(scopeVariables, parentsScopeVariables);
    }
    function getVariablesForElement2(element) {
      return getVariablesForScope2(getScope2(element), getRootElement3(element));
    }
    function getScope2(element) {
      const bo = getBusinessObject2(element);
      if (is4(element, "bpmn:Participant")) {
        return bo.processRef.id;
      }
      return bo.id;
    }
    function getRootElement3(element) {
      const businessObject = getBusinessObject2(element);
      if (is4(businessObject, "bpmn:Participant")) {
        return businessObject.processRef;
      }
      if (is4(businessObject, "bpmn:Process")) {
        return businessObject;
      }
      let parent = businessObject;
      while (parent.$parent && !is4(parent, "bpmn:Process")) {
        parent = parent.$parent;
      }
      return parent;
    }
    function combineArrays(a6, b5) {
      return a6.concat(b5);
    }
    function getBusinessObject2(element) {
      return element && element.businessObject || element;
    }
    function is4(element, type) {
      var bo = getBusinessObject2(element);
      return bo && typeof bo.$instanceOf === "function" && bo.$instanceOf(type);
    }
    exports.getProcessVariables = getProcessVariables;
    exports.getVariablesForElement = getVariablesForElement2;
    exports.getVariablesForScope = getVariablesForScope2;
  }
});

// node_modules/array-move/index.js
var require_array_move = __commonJS({
  "node_modules/array-move/index.js"(exports, module2) {
    "use strict";
    var arrayMoveMutate = (array, from, to) => {
      const startIndex = from < 0 ? array.length + from : from;
      if (startIndex >= 0 && startIndex < array.length) {
        const endIndex = to < 0 ? array.length + to : to;
        const [item] = array.splice(from, 1);
        array.splice(endIndex, 0, item);
      }
    };
    var arrayMove = (array, from, to) => {
      array = [...array];
      arrayMoveMutate(array, from, to);
      return array;
    };
    module2.exports = arrayMove;
    module2.exports.mutate = arrayMoveMutate;
  }
});

// node_modules/@bpmn-io/extract-process-variables/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@bpmn-io/extract-process-variables/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var minDash = require_dist();
    function getInputOutput2(element) {
      return (getElements2(element, "camunda:InputOutput") || [])[0];
    }
    function getInputParameters2(element) {
      return getParameters2(element, "inputParameters");
    }
    function getOutputParameters2(element) {
      return getParameters2(element, "outputParameters");
    }
    function getFormFields(element) {
      var formData = getFormData2(element);
      return formData && formData.get("fields") || [];
    }
    function getFormData2(element) {
      return getElements2(element, "camunda:FormData")[0];
    }
    function getOutMappings2(element) {
      return getElements2(element, "camunda:Out");
    }
    function getElements2(element, type, property) {
      var elements = getExtensionElements2(element, type);
      return !property ? elements : (elements[0] || {})[property] || [];
    }
    function getParameters2(element, property) {
      var inputOutput = getInputOutput2(element);
      return inputOutput && inputOutput.get(property) || [];
    }
    function getExtensionElements2(element, type) {
      var elements = [];
      var extensionElements = element.get("extensionElements");
      if (typeof extensionElements !== "undefined") {
        var extensionValues = extensionElements.get("values");
        if (typeof extensionValues !== "undefined") {
          elements = minDash.filter(extensionValues, function(value) {
            return is$2(value, type);
          });
        }
      }
      return elements;
    }
    function is$2(element, type) {
      return element && typeof element.$instanceOf === "function" && element.$instanceOf(type);
    }
    function getParents3(element) {
      var parents = [];
      var current = element;
      while (current.$parent) {
        parents.push(current.$parent);
        current = current.$parent;
      }
      return parents;
    }
    function eachElement2(elements, fn2, depth) {
      depth = depth || 0;
      if (!minDash.isArray(elements)) {
        elements = [elements];
      }
      minDash.forEach(elements, function(s5, i6) {
        var filter28 = fn2(s5, i6, depth);
        if (minDash.isArray(filter28) && filter28.length) {
          eachElement2(filter28, fn2, depth + 1);
        }
      });
    }
    function add3(elements, e7, unique) {
      var canAdd = !unique || elements.indexOf(e7) === -1;
      if (canAdd) {
        elements.push(e7);
      }
      return canAdd;
    }
    function selfAndFlowElements(elements, unique, maxDepth) {
      var result = [], processedFlowElements = [];
      eachElement2(elements, function(element, i6, depth) {
        add3(result, element, unique);
        var flowElements = element.flowElements;
        if (maxDepth === -1 || depth < maxDepth) {
          if (flowElements && add3(processedFlowElements, flowElements, unique)) {
            return flowElements;
          }
        }
      });
      return result;
    }
    function selfAndAllFlowElements2(elements, allowDuplicates) {
      return selfAndFlowElements(elements, !allowDuplicates, -1);
    }
    function getElement(elementId, rootElement) {
      var allElements = selfAndAllFlowElements2(rootElement);
      return minDash.find(allElements, function(element) {
        return element.id === elementId;
      });
    }
    function addVariableToList(variablesList, newVariable) {
      var foundIdx = minDash.findIndex(variablesList, function(variable) {
        return variable.name === newVariable.name && variable.scope === newVariable.scope;
      });
      if (foundIdx >= 0) {
        variablesList[foundIdx].origin = combineArrays$1(variablesList[foundIdx].origin, newVariable.origin);
      } else {
        variablesList.push(newVariable);
      }
    }
    function createProcessVariable(flowElement, name3, defaultScope) {
      var scope = getScope2(flowElement, defaultScope, name3);
      return {
        name: name3,
        origin: [flowElement],
        scope
      };
    }
    function getScope2(element, globalScope, variableName) {
      var parents = getParents3(element);
      var scopedParent = minDash.find(parents, function(parent) {
        return is$1(parent, "bpmn:SubProcess") && hasInputParameter(parent, variableName);
      });
      return scopedParent ? scopedParent : globalScope;
    }
    function is$1(element, type) {
      return element && typeof element.$instanceOf === "function" && element.$instanceOf(type);
    }
    function hasInputParameter(element, name3) {
      return minDash.find(getInputParameters2(element), function(input) {
        return input.name === name3;
      });
    }
    function combineArrays$1(a6, b5) {
      return a6.concat(b5);
    }
    function extractOutputParameters(options2) {
      var elements = options2.elements, containerElement = options2.containerElement, processVariables = options2.processVariables;
      if (!minDash.isArray(elements)) {
        elements = [elements];
      }
      minDash.forEach(elements, function(element) {
        var outputParameters = getOutputParameters2(element);
        minDash.forEach(outputParameters, function(parameter) {
          var newVariable = createProcessVariable(element, parameter.name, containerElement);
          addVariableToList(processVariables, newVariable);
        });
      });
      return processVariables;
    }
    function extractResultVariables(options2) {
      var elements = options2.elements, containerElement = options2.containerElement, processVariables = options2.processVariables;
      if (!minDash.isArray(elements)) {
        elements = [elements];
      }
      minDash.forEach(elements, function(element) {
        var resultVariable = getResultVariable2(element);
        if (resultVariable) {
          var newVariable = createProcessVariable(element, resultVariable, containerElement);
          addVariableToList(processVariables, newVariable);
        }
      });
      return processVariables;
    }
    function getResultVariable2(element) {
      return element.get("camunda:resultVariable");
    }
    function extractFormFields(options2) {
      var elements = options2.elements, containerElement = options2.containerElement, processVariables = options2.processVariables;
      if (!minDash.isArray(elements)) {
        elements = [elements];
      }
      minDash.forEach(elements, function(element) {
        var formFields = getFormFields(element);
        minDash.forEach(formFields, function(field) {
          var newVariable = createProcessVariable(element, field.id, containerElement);
          addVariableToList(processVariables, newVariable);
        });
      });
      return processVariables;
    }
    function extractOutMappings(options2) {
      var elements = options2.elements, containerElement = options2.containerElement, processVariables = options2.processVariables;
      if (!minDash.isArray(elements)) {
        elements = [elements];
      }
      minDash.forEach(elements, function(element) {
        var outMappings = getOutMappings2(element);
        minDash.forEach(outMappings, function(mapping) {
          if (mapping.local) {
            return;
          }
          var newVariable = createProcessVariable(element, mapping.target, containerElement);
          addVariableToList(processVariables, newVariable);
        });
      });
      return processVariables;
    }
    function getEventDefinitions(element, type) {
      var eventDefinitions = element.eventDefinitions;
      if (!eventDefinitions || !type) {
        return eventDefinitions;
      }
      return minDash.filter(eventDefinitions, function(definition) {
        return is4(definition, type);
      });
    }
    function getErrorEventDefinitions(element) {
      return getEventDefinitions(element, "bpmn:ErrorEventDefinition");
    }
    function getEscalationEventDefinitions(element) {
      return getEventDefinitions(element, "bpmn:EscalationEventDefinition");
    }
    function is4(element, type) {
      return element && typeof element.$instanceOf === "function" && element.$instanceOf(type);
    }
    function extractEventDefinitionVariables(options2) {
      var elements = options2.elements, containerElement = options2.containerElement, processVariables = options2.processVariables;
      var addVariable = function(element, name3) {
        var newVariable = createProcessVariable(element, name3, containerElement);
        addVariableToList(processVariables, newVariable);
      };
      if (!minDash.isArray(elements)) {
        elements = [elements];
      }
      minDash.forEach(elements, function(element) {
        var errorEventDefinitions = getErrorEventDefinitions(element);
        minDash.forEach(errorEventDefinitions, function(definition) {
          var errorCodeVariable = definition.get("errorCodeVariable"), errorMessageVariable = definition.get("errorMessageVariable");
          if (errorCodeVariable) {
            addVariable(element, errorCodeVariable);
          }
          if (errorMessageVariable) {
            addVariable(element, errorMessageVariable);
          }
        });
        var escalationEventDefinitions = getEscalationEventDefinitions(element);
        minDash.forEach(escalationEventDefinitions, function(definition) {
          var escalationCodeVariable = definition.get("escalationCodeVariable");
          if (escalationCodeVariable) {
            addVariable(element, escalationCodeVariable);
          }
        });
      });
      return processVariables;
    }
    var extractors = [
      extractOutputParameters,
      extractResultVariables,
      extractFormFields,
      extractOutMappings,
      extractEventDefinitionVariables
    ];
    function getProcessVariables(containerElement) {
      var processVariables = [];
      var elements = selfAndAllFlowElements2([containerElement], false);
      minDash.forEach(extractors, function(extractor) {
        extractor({
          elements,
          containerElement,
          processVariables
        });
      });
      return processVariables;
    }
    function getVariablesForScope2(scope, rootElement) {
      var allVariables = getProcessVariables(rootElement);
      var scopeElement = getElement(scope, rootElement);
      var scopeVariables = minDash.filter(allVariables, function(variable) {
        return variable.scope.id === scopeElement.id;
      });
      var parents = getParents3(scopeElement);
      var parentsScopeVariables = minDash.filter(allVariables, function(variable) {
        return minDash.find(parents, function(parent) {
          return parent.id === variable.scope.id;
        });
      });
      return combineArrays(scopeVariables, parentsScopeVariables);
    }
    function combineArrays(a6, b5) {
      return a6.concat(b5);
    }
    exports.getProcessVariables = getProcessVariables;
    exports.getVariablesForScope = getVariablesForScope2;
  }
});

// node_modules/semver-compare/index.js
var require_semver_compare = __commonJS({
  "node_modules/semver-compare/index.js"(exports, module2) {
    module2.exports = function cmp(a6, b5) {
      var pa = a6.split(".");
      var pb = b5.split(".");
      for (var i6 = 0; i6 < 3; i6++) {
        var na = Number(pa[i6]);
        var nb = Number(pb[i6]);
        if (na > nb)
          return 1;
        if (nb > na)
          return -1;
        if (!isNaN(na) && isNaN(nb))
          return 1;
        if (isNaN(na) && !isNaN(nb))
          return -1;
      }
      return 0;
    };
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ObsidianBPMNPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// settings.ts
var import_obsidian = require("obsidian");
var ObsidianBpmnPluginSettings = class {
  constructor() {
    this.opendiagram_by_default = true;
    this.showzoom_by_default = true;
    this.height_by_default = 400;
    this.force_white_background_by_default = true;
  }
};
var ObsidianBpmnPluginSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Default height").setDesc('Set the default height of the rendered BPMN. Adjust this inline with e.g., `"height":600`').addSlider((slider) => slider.setValue(this.plugin.settings.height_by_default).onChange((value) => {
      this.plugin.settings.height_by_default = value;
      this.plugin.saveData(this.plugin.settings);
    }).setLimits(200, 1e3, 20).setDynamicTooltip());
    new import_obsidian.Setting(containerEl).setName("Default show open diagram").setDesc("Set the default for showing the 'Open diagram' link").addToggle((toggle2) => toggle2.setValue(this.plugin.settings.opendiagram_by_default).onChange((value) => {
      this.plugin.settings.opendiagram_by_default = value;
      this.plugin.saveData(this.plugin.settings);
    }));
    new import_obsidian.Setting(containerEl).setName("Default show zoom buttons").setDesc("Set the default for showing the zoom buttons").addToggle((toggle2) => toggle2.setValue(this.plugin.settings.showzoom_by_default).onChange((value) => {
      this.plugin.settings.showzoom_by_default = value;
      this.plugin.saveData(this.plugin.settings);
    }));
    new import_obsidian.Setting(containerEl).setName("Default force white background").setDesc("Set the default for forcing a white background").addToggle((toggle2) => toggle2.setValue(this.plugin.settings.force_white_background_by_default).onChange((value) => {
      this.plugin.settings.force_white_background_by_default = value;
      this.plugin.saveData(this.plugin.settings);
    }));
  }
};

// node_modules/inherits-browser/dist/index.es.js
function e(e7, t6) {
  t6 && (e7.super_ = t6, e7.prototype = Object.create(t6.prototype, { constructor: { value: e7, enumerable: false, writable: true, configurable: true } }));
}

// node_modules/bpmn-js/lib/draw/BpmnRenderer.js
var import_min_dash4 = __toESM(require_dist());

// node_modules/diagram-js/lib/draw/BaseRenderer.js
var DEFAULT_RENDER_PRIORITY = 1e3;
function BaseRenderer(eventBus, renderPriority) {
  var self2 = this;
  renderPriority = renderPriority || DEFAULT_RENDER_PRIORITY;
  eventBus.on(["render.shape", "render.connection"], renderPriority, function(evt, context) {
    var type = evt.type, element = context.element, visuals = context.gfx, attrs = context.attrs;
    if (self2.canRender(element)) {
      if (type === "render.shape") {
        return self2.drawShape(visuals, element, attrs);
      } else {
        return self2.drawConnection(visuals, element, attrs);
      }
    }
  });
  eventBus.on(["render.getShapePath", "render.getConnectionPath"], renderPriority, function(evt, element) {
    if (self2.canRender(element)) {
      if (evt.type === "render.getShapePath") {
        return self2.getShapePath(element);
      } else {
        return self2.getConnectionPath(element);
      }
    }
  });
}
BaseRenderer.prototype.canRender = function() {
};
BaseRenderer.prototype.drawShape = function() {
};
BaseRenderer.prototype.drawConnection = function() {
};
BaseRenderer.prototype.getShapePath = function() {
};
BaseRenderer.prototype.getConnectionPath = function() {
};

// node_modules/bpmn-js/lib/util/ModelUtil.js
var import_min_dash = __toESM(require_dist());
function is(element, type) {
  var bo = getBusinessObject(element);
  return bo && typeof bo.$instanceOf === "function" && bo.$instanceOf(type);
}
function isAny(element, types3) {
  return (0, import_min_dash.some)(types3, function(t6) {
    return is(element, t6);
  });
}
function getBusinessObject(element) {
  return element && element.businessObject || element;
}
function getDi(element) {
  return element && element.di;
}

// node_modules/bpmn-js/lib/util/DiUtil.js
var import_min_dash2 = __toESM(require_dist());
function isExpanded(element, di) {
  if (is(element, "bpmn:CallActivity")) {
    return false;
  }
  if (is(element, "bpmn:SubProcess")) {
    di = di || getDi(element);
    if (di && is(di, "bpmndi:BPMNPlane")) {
      return true;
    }
    return di && !!di.isExpanded;
  }
  if (is(element, "bpmn:Participant")) {
    return !!getBusinessObject(element).processRef;
  }
  return true;
}
function isInterrupting(element) {
  return element && getBusinessObject(element).isInterrupting !== false;
}
function isEventSubProcess(element) {
  return element && !!getBusinessObject(element).triggeredByEvent;
}
function hasEventDefinition(element, eventType) {
  var bo = getBusinessObject(element), hasEventDefinition4 = false;
  if (bo.eventDefinitions) {
    (0, import_min_dash2.forEach)(bo.eventDefinitions, function(event2) {
      if (is(event2, eventType)) {
        hasEventDefinition4 = true;
      }
    });
  }
  return hasEventDefinition4;
}
function hasErrorEventDefinition(element) {
  return hasEventDefinition(element, "bpmn:ErrorEventDefinition");
}
function hasEscalationEventDefinition(element) {
  return hasEventDefinition(element, "bpmn:EscalationEventDefinition");
}
function hasCompensateEventDefinition(element) {
  return hasEventDefinition(element, "bpmn:CompensateEventDefinition");
}

// node_modules/bpmn-js/lib/features/label-editing/LabelUtil.js
function getLabelAttr(semantic) {
  if (is(semantic, "bpmn:FlowElement") || is(semantic, "bpmn:Participant") || is(semantic, "bpmn:Lane") || is(semantic, "bpmn:SequenceFlow") || is(semantic, "bpmn:MessageFlow") || is(semantic, "bpmn:DataInput") || is(semantic, "bpmn:DataOutput")) {
    return "name";
  }
  if (is(semantic, "bpmn:TextAnnotation")) {
    return "text";
  }
  if (is(semantic, "bpmn:Group")) {
    return "categoryValueRef";
  }
}
function getCategoryValue(semantic) {
  var categoryValueRef = semantic["categoryValueRef"];
  if (!categoryValueRef) {
    return "";
  }
  return categoryValueRef.value || "";
}
function getLabel(element) {
  var semantic = element.businessObject, attr3 = getLabelAttr(semantic);
  if (attr3) {
    if (attr3 === "categoryValueRef") {
      return getCategoryValue(semantic);
    }
    return semantic[attr3] || "";
  }
}
function setLabel(element, text, isExternal) {
  var semantic = element.businessObject, attr3 = getLabelAttr(semantic);
  if (attr3) {
    if (attr3 === "categoryValueRef") {
      semantic["categoryValueRef"].value = text;
    } else {
      semantic[attr3] = text;
    }
  }
  return element;
}

// node_modules/tiny-svg/dist/index.esm.js
function ensureImported(element, target) {
  if (element.ownerDocument !== target.ownerDocument) {
    try {
      return target.ownerDocument.importNode(element, true);
    } catch (e7) {
    }
  }
  return element;
}
function appendTo(element, target) {
  return target.appendChild(ensureImported(element, target));
}
function append(target, node2) {
  appendTo(node2, target);
  return target;
}
var LENGTH_ATTR = 2;
var CSS_PROPERTIES = {
  "alignment-baseline": 1,
  "baseline-shift": 1,
  "clip": 1,
  "clip-path": 1,
  "clip-rule": 1,
  "color": 1,
  "color-interpolation": 1,
  "color-interpolation-filters": 1,
  "color-profile": 1,
  "color-rendering": 1,
  "cursor": 1,
  "direction": 1,
  "display": 1,
  "dominant-baseline": 1,
  "enable-background": 1,
  "fill": 1,
  "fill-opacity": 1,
  "fill-rule": 1,
  "filter": 1,
  "flood-color": 1,
  "flood-opacity": 1,
  "font": 1,
  "font-family": 1,
  "font-size": LENGTH_ATTR,
  "font-size-adjust": 1,
  "font-stretch": 1,
  "font-style": 1,
  "font-variant": 1,
  "font-weight": 1,
  "glyph-orientation-horizontal": 1,
  "glyph-orientation-vertical": 1,
  "image-rendering": 1,
  "kerning": 1,
  "letter-spacing": 1,
  "lighting-color": 1,
  "marker": 1,
  "marker-end": 1,
  "marker-mid": 1,
  "marker-start": 1,
  "mask": 1,
  "opacity": 1,
  "overflow": 1,
  "pointer-events": 1,
  "shape-rendering": 1,
  "stop-color": 1,
  "stop-opacity": 1,
  "stroke": 1,
  "stroke-dasharray": 1,
  "stroke-dashoffset": 1,
  "stroke-linecap": 1,
  "stroke-linejoin": 1,
  "stroke-miterlimit": 1,
  "stroke-opacity": 1,
  "stroke-width": LENGTH_ATTR,
  "text-anchor": 1,
  "text-decoration": 1,
  "text-rendering": 1,
  "unicode-bidi": 1,
  "visibility": 1,
  "word-spacing": 1,
  "writing-mode": 1
};
function getAttribute(node2, name3) {
  if (CSS_PROPERTIES[name3]) {
    return node2.style[name3];
  } else {
    return node2.getAttributeNS(null, name3);
  }
}
function setAttribute(node2, name3, value) {
  var hyphenated = name3.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  var type = CSS_PROPERTIES[hyphenated];
  if (type) {
    if (type === LENGTH_ATTR && typeof value === "number") {
      value = String(value) + "px";
    }
    node2.style[hyphenated] = value;
  } else {
    node2.setAttributeNS(null, name3, value);
  }
}
function setAttributes(node2, attrs) {
  var names = Object.keys(attrs), i6, name3;
  for (i6 = 0, name3; name3 = names[i6]; i6++) {
    setAttribute(node2, name3, attrs[name3]);
  }
}
function attr(node2, name3, value) {
  if (typeof name3 === "string") {
    if (value !== void 0) {
      setAttribute(node2, name3, value);
    } else {
      return getAttribute(node2, name3);
    }
  } else {
    setAttributes(node2, name3);
  }
  return node2;
}
var toString = Object.prototype.toString;
function classes(el) {
  return new ClassList(el);
}
function ClassList(el) {
  if (!el || !el.nodeType) {
    throw new Error("A DOM element reference is required");
  }
  this.el = el;
  this.list = el.classList;
}
ClassList.prototype.add = function(name3) {
  this.list.add(name3);
  return this;
};
ClassList.prototype.remove = function(name3) {
  if (toString.call(name3) == "[object RegExp]") {
    return this.removeMatching(name3);
  }
  this.list.remove(name3);
  return this;
};
ClassList.prototype.removeMatching = function(re) {
  const arr = this.array();
  for (let i6 = 0; i6 < arr.length; i6++) {
    if (re.test(arr[i6])) {
      this.remove(arr[i6]);
    }
  }
  return this;
};
ClassList.prototype.toggle = function(name3, force) {
  if (typeof force !== "undefined") {
    if (force !== this.list.toggle(name3, force)) {
      this.list.toggle(name3);
    }
  } else {
    this.list.toggle(name3);
  }
  return this;
};
ClassList.prototype.array = function() {
  return Array.from(this.list);
};
ClassList.prototype.has = ClassList.prototype.contains = function(name3) {
  return this.list.contains(name3);
};
function remove(element) {
  var parent = element.parentNode;
  if (parent) {
    parent.removeChild(element);
  }
  return element;
}
function clear(element) {
  var child;
  while (child = element.firstChild) {
    remove(child);
  }
  return element;
}
function clone(element) {
  return element.cloneNode(true);
}
var ns = {
  svg: "http://www.w3.org/2000/svg"
};
var SVG_START = '<svg xmlns="' + ns.svg + '"';
function parse(svg) {
  var unwrap = false;
  if (svg.substring(0, 4) === "<svg") {
    if (svg.indexOf(ns.svg) === -1) {
      svg = SVG_START + svg.substring(4);
    }
  } else {
    svg = SVG_START + ">" + svg + "</svg>";
    unwrap = true;
  }
  var parsed = parseDocument(svg);
  if (!unwrap) {
    return parsed;
  }
  var fragment = document.createDocumentFragment();
  var parent = parsed.firstChild;
  while (parent.firstChild) {
    fragment.appendChild(parent.firstChild);
  }
  return fragment;
}
function parseDocument(svg) {
  var parser2;
  parser2 = new DOMParser();
  parser2.async = false;
  return parser2.parseFromString(svg, "text/xml");
}
function create(name3, attrs) {
  var element;
  if (name3.charAt(0) === "<") {
    element = parse(name3).firstChild;
    element = document.importNode(element, true);
  } else {
    element = document.createElementNS(ns.svg, name3);
  }
  if (attrs) {
    attr(element, attrs);
  }
  return element;
}
var node = null;
function getNode() {
  if (node === null) {
    node = create("svg");
  }
  return node;
}
function extend(object, props) {
  var i6, k6, keys4 = Object.keys(props);
  for (i6 = 0; k6 = keys4[i6]; i6++) {
    object[k6] = props[k6];
  }
  return object;
}
function createMatrix(a6, b5, c5, d5, e7, f5) {
  var matrix = getNode().createSVGMatrix();
  switch (arguments.length) {
    case 0:
      return matrix;
    case 1:
      return extend(matrix, a6);
    case 6:
      return extend(matrix, {
        a: a6,
        b: b5,
        c: c5,
        d: d5,
        e: e7,
        f: f5
      });
  }
}
function createTransform(matrix) {
  if (matrix) {
    return getNode().createSVGTransformFromMatrix(matrix);
  } else {
    return getNode().createSVGTransform();
  }
}
var TEXT_ENTITIES = /([&<>]{1})/g;
var ATTR_ENTITIES = /([\n\r"]{1})/g;
var ENTITY_REPLACEMENT = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "'"
};
function escape(str, pattern) {
  function replaceFn(match, entity) {
    return ENTITY_REPLACEMENT[entity] || entity;
  }
  return str.replace(pattern, replaceFn);
}
function serialize(node2, output) {
  var i6, len, attrMap, attrNode, childNodes;
  switch (node2.nodeType) {
    case 3:
      output.push(escape(node2.textContent, TEXT_ENTITIES));
      break;
    case 1:
      output.push("<", node2.tagName);
      if (node2.hasAttributes()) {
        attrMap = node2.attributes;
        for (i6 = 0, len = attrMap.length; i6 < len; ++i6) {
          attrNode = attrMap.item(i6);
          output.push(" ", attrNode.name, '="', escape(attrNode.value, ATTR_ENTITIES), '"');
        }
      }
      if (node2.hasChildNodes()) {
        output.push(">");
        childNodes = node2.childNodes;
        for (i6 = 0, len = childNodes.length; i6 < len; ++i6) {
          serialize(childNodes.item(i6), output);
        }
        output.push("</", node2.tagName, ">");
      } else {
        output.push("/>");
      }
      break;
    case 8:
      output.push("<!--", escape(node2.nodeValue, TEXT_ENTITIES), "-->");
      break;
    case 4:
      output.push("<![CDATA[", node2.nodeValue, "]]>");
      break;
    default:
      throw new Error("unable to handle node " + node2.nodeType);
  }
  return output;
}
function set(element, svg) {
  var parsed = parse(svg);
  clear(element);
  if (!svg) {
    return;
  }
  if (!isFragment(parsed)) {
    parsed = parsed.documentElement;
  }
  var nodes = slice(parsed.childNodes);
  for (var i6 = 0; i6 < nodes.length; i6++) {
    appendTo(nodes[i6], element);
  }
}
function get(element) {
  var child = element.firstChild, output = [];
  while (child) {
    serialize(child, output);
    child = child.nextSibling;
  }
  return output.join("");
}
function isFragment(node2) {
  return node2.nodeName === "#document-fragment";
}
function innerSVG(element, svg) {
  if (svg !== void 0) {
    try {
      set(element, svg);
    } catch (e7) {
      throw new Error("error parsing SVG: " + e7.message);
    }
    return element;
  } else {
    return get(element);
  }
}
function slice(arr) {
  return Array.prototype.slice.call(arr);
}
function wrapMatrix(transformList, transform3) {
  if (transform3 instanceof SVGMatrix) {
    return transformList.createSVGTransformFromMatrix(transform3);
  }
  return transform3;
}
function setTransforms(transformList, transforms) {
  var i6, t6;
  transformList.clear();
  for (i6 = 0; t6 = transforms[i6]; i6++) {
    transformList.appendItem(wrapMatrix(transformList, t6));
  }
}
function transform(node2, transforms) {
  var transformList = node2.transform.baseVal;
  if (transforms) {
    if (!Array.isArray(transforms)) {
      transforms = [transforms];
    }
    setTransforms(transformList, transforms);
  }
  return transformList.consolidate();
}

// node_modules/diagram-js/lib/util/RenderUtil.js
function componentsToPath(elements) {
  return elements.join(",").replace(/,?([A-z]),?/g, "$1");
}
function toSVGPoints(points) {
  var result = "";
  for (var i6 = 0, p6; p6 = points[i6]; i6++) {
    result += p6.x + "," + p6.y + " ";
  }
  return result;
}
function createLine(points, attrs) {
  var line = create("polyline");
  attr(line, { points: toSVGPoints(points) });
  if (attrs) {
    attr(line, attrs);
  }
  return line;
}
function updateLine(gfx, points) {
  attr(gfx, { points: toSVGPoints(points) });
  return gfx;
}

// node_modules/bpmn-js/lib/draw/BpmnRenderUtil.js
var import_min_dash3 = __toESM(require_dist());
var black = "hsl(225, 10%, 15%)";
function isTypedEvent(event2, eventDefinitionType, filter28) {
  function matches2(definition, filter29) {
    return (0, import_min_dash3.every)(filter29, function(val, key) {
      return definition[key] == val;
    });
  }
  return (0, import_min_dash3.some)(event2.eventDefinitions, function(definition) {
    return definition.$type === eventDefinitionType && matches2(event2, filter28);
  });
}
function isThrowEvent(event2) {
  return event2.$type === "bpmn:IntermediateThrowEvent" || event2.$type === "bpmn:EndEvent";
}
function isCollection(element) {
  var dataObject = element.dataObjectRef;
  return element.isCollection || dataObject && dataObject.isCollection;
}
function getSemantic(element) {
  return element.businessObject;
}
function getFillColor(element, defaultColor) {
  var di = getDi(element);
  return di.get("color:background-color") || di.get("bioc:fill") || defaultColor || "white";
}
function getStrokeColor(element, defaultColor) {
  var di = getDi(element);
  return di.get("color:border-color") || di.get("bioc:stroke") || defaultColor || black;
}
function getLabelColor(element, defaultColor, defaultStrokeColor) {
  var di = getDi(element), label = di.get("label");
  return label && label.get("color:color") || defaultColor || getStrokeColor(element, defaultStrokeColor);
}
function getCirclePath(shape) {
  var cx = shape.x + shape.width / 2, cy = shape.y + shape.height / 2, radius = shape.width / 2;
  var circlePath2 = [
    ["M", cx, cy],
    ["m", 0, -radius],
    ["a", radius, radius, 0, 1, 1, 0, 2 * radius],
    ["a", radius, radius, 0, 1, 1, 0, -2 * radius],
    ["z"]
  ];
  return componentsToPath(circlePath2);
}
function getRoundRectPath(shape, borderRadius) {
  var x4 = shape.x, y4 = shape.y, width = shape.width, height = shape.height;
  var roundRectPath = [
    ["M", x4 + borderRadius, y4],
    ["l", width - borderRadius * 2, 0],
    ["a", borderRadius, borderRadius, 0, 0, 1, borderRadius, borderRadius],
    ["l", 0, height - borderRadius * 2],
    ["a", borderRadius, borderRadius, 0, 0, 1, -borderRadius, borderRadius],
    ["l", borderRadius * 2 - width, 0],
    ["a", borderRadius, borderRadius, 0, 0, 1, -borderRadius, -borderRadius],
    ["l", 0, borderRadius * 2 - height],
    ["a", borderRadius, borderRadius, 0, 0, 1, borderRadius, -borderRadius],
    ["z"]
  ];
  return componentsToPath(roundRectPath);
}
function getDiamondPath(shape) {
  var width = shape.width, height = shape.height, x4 = shape.x, y4 = shape.y, halfWidth = width / 2, halfHeight = height / 2;
  var diamondPath = [
    ["M", x4 + halfWidth, y4],
    ["l", halfWidth, halfHeight],
    ["l", -halfWidth, halfHeight],
    ["l", -halfWidth, -halfHeight],
    ["z"]
  ];
  return componentsToPath(diamondPath);
}
function getRectPath(shape) {
  var x4 = shape.x, y4 = shape.y, width = shape.width, height = shape.height;
  var rectPath = [
    ["M", x4, y4],
    ["l", width, 0],
    ["l", 0, height],
    ["l", -width, 0],
    ["z"]
  ];
  return componentsToPath(rectPath);
}

// node_modules/min-dom/dist/index.esm.js
function _mergeNamespaces(n5, m6) {
  m6.forEach(function(e7) {
    e7 && typeof e7 !== "string" && !Array.isArray(e7) && Object.keys(e7).forEach(function(k6) {
      if (k6 !== "default" && !(k6 in n5)) {
        var d5 = Object.getOwnPropertyDescriptor(e7, k6);
        Object.defineProperty(n5, k6, d5.get ? d5 : {
          enumerable: true,
          get: function() {
            return e7[k6];
          }
        });
      }
    });
  });
  return Object.freeze(n5);
}
var nativeToString = Object.prototype.toString;
var nativeHasOwnProperty = Object.prototype.hasOwnProperty;
function isUndefined(obj) {
  return obj === void 0;
}
function isArray(obj) {
  return nativeToString.call(obj) === "[object Array]";
}
function has(target, key) {
  return nativeHasOwnProperty.call(target, key);
}
function forEach2(collection, iterator) {
  let val, result;
  if (isUndefined(collection)) {
    return;
  }
  const convertKey = isArray(collection) ? toNum : identity;
  for (let key in collection) {
    if (has(collection, key)) {
      val = collection[key];
      result = iterator(val, convertKey(key));
      if (result === false) {
        return val;
      }
    }
  }
}
function identity(arg) {
  return arg;
}
function toNum(arg) {
  return Number(arg);
}
function assign(element, ...styleSources) {
  const target = element.style;
  forEach2(styleSources, function(style) {
    if (!style) {
      return;
    }
    forEach2(style, function(value, key) {
      target[key] = value;
    });
  });
  return element;
}
function attr2(el, name3, val) {
  if (arguments.length == 2) {
    return el.getAttribute(name3);
  }
  if (val === null) {
    return el.removeAttribute(name3);
  }
  el.setAttribute(name3, val);
  return el;
}
var toString2 = Object.prototype.toString;
function classes2(el) {
  return new ClassList2(el);
}
function ClassList2(el) {
  if (!el || !el.nodeType) {
    throw new Error("A DOM element reference is required");
  }
  this.el = el;
  this.list = el.classList;
}
ClassList2.prototype.add = function(name3) {
  this.list.add(name3);
  return this;
};
ClassList2.prototype.remove = function(name3) {
  if (toString2.call(name3) == "[object RegExp]") {
    return this.removeMatching(name3);
  }
  this.list.remove(name3);
  return this;
};
ClassList2.prototype.removeMatching = function(re) {
  const arr = this.array();
  for (let i6 = 0; i6 < arr.length; i6++) {
    if (re.test(arr[i6])) {
      this.remove(arr[i6]);
    }
  }
  return this;
};
ClassList2.prototype.toggle = function(name3, force) {
  if (typeof force !== "undefined") {
    if (force !== this.list.toggle(name3, force)) {
      this.list.toggle(name3);
    }
  } else {
    this.list.toggle(name3);
  }
  return this;
};
ClassList2.prototype.array = function() {
  return Array.from(this.list);
};
ClassList2.prototype.has = ClassList2.prototype.contains = function(name3) {
  return this.list.contains(name3);
};
function clear2(el) {
  var c5;
  while (el.childNodes.length) {
    c5 = el.childNodes[0];
    el.removeChild(c5);
  }
  return el;
}
function matches(element, selector) {
  return element && typeof element.matches === "function" && element.matches(selector);
}
function closest(element, selector, checkYourSelf) {
  var currentElem = checkYourSelf ? element : element.parentNode;
  while (currentElem && currentElem.nodeType !== document.DOCUMENT_NODE && currentElem.nodeType !== document.DOCUMENT_FRAGMENT_NODE) {
    if (matches(currentElem, selector)) {
      return currentElem;
    }
    currentElem = currentElem.parentNode;
  }
  return matches(currentElem, selector) ? currentElem : null;
}
var componentEvent = {};
var bind$1 = window.addEventListener ? "addEventListener" : "attachEvent";
var unbind$1 = window.removeEventListener ? "removeEventListener" : "detachEvent";
var prefix = bind$1 !== "addEventListener" ? "on" : "";
var bind_1 = componentEvent.bind = function(el, type, fn2, capture) {
  el[bind$1](prefix + type, fn2, capture || false);
  return fn2;
};
var unbind_1 = componentEvent.unbind = function(el, type, fn2, capture) {
  el[unbind$1](prefix + type, fn2, capture || false);
  return fn2;
};
var event = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  bind: bind_1,
  unbind: unbind_1,
  "default": componentEvent
}, [componentEvent]);
var forceCaptureEvents = ["focus", "blur"];
function bind(el, selector, type, fn2, capture) {
  if (forceCaptureEvents.indexOf(type) !== -1) {
    capture = true;
  }
  return event.bind(el, type, function(e7) {
    var target = e7.target || e7.srcElement;
    e7.delegateTarget = closest(target, selector, true);
    if (e7.delegateTarget) {
      fn2.call(el, e7);
    }
  }, capture);
}
function unbind(el, type, fn2, capture) {
  if (forceCaptureEvents.indexOf(type) !== -1) {
    capture = true;
  }
  return event.unbind(el, type, fn2, capture);
}
var delegate = {
  bind,
  unbind
};
var domify = parse2;
var innerHTMLBug = false;
var bugTestDiv;
if (typeof document !== "undefined") {
  bugTestDiv = document.createElement("div");
  bugTestDiv.innerHTML = '  <link/><table></table><a href="/a">a</a><input type="checkbox"/>';
  innerHTMLBug = !bugTestDiv.getElementsByTagName("link").length;
  bugTestDiv = void 0;
}
var map = {
  legend: [1, "<fieldset>", "</fieldset>"],
  tr: [2, "<table><tbody>", "</tbody></table>"],
  col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
  _default: innerHTMLBug ? [1, "X<div>", "</div>"] : [0, "", ""]
};
map.td = map.th = [3, "<table><tbody><tr>", "</tr></tbody></table>"];
map.option = map.optgroup = [1, '<select multiple="multiple">', "</select>"];
map.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, "<table>", "</table>"];
map.polyline = map.ellipse = map.polygon = map.circle = map.text = map.line = map.path = map.rect = map.g = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">', "</svg>"];
function parse2(html, doc) {
  if (typeof html != "string")
    throw new TypeError("String expected");
  if (!doc)
    doc = document;
  var m6 = /<([\w:]+)/.exec(html);
  if (!m6)
    return doc.createTextNode(html);
  html = html.replace(/^\s+|\s+$/g, "");
  var tag = m6[1];
  if (tag == "body") {
    var el = doc.createElement("html");
    el.innerHTML = html;
    return el.removeChild(el.lastChild);
  }
  var wrap2 = Object.prototype.hasOwnProperty.call(map, tag) ? map[tag] : map._default;
  var depth = wrap2[0];
  var prefix3 = wrap2[1];
  var suffix = wrap2[2];
  var el = doc.createElement("div");
  el.innerHTML = prefix3 + html + suffix;
  while (depth--)
    el = el.lastChild;
  if (el.firstChild == el.lastChild) {
    return el.removeChild(el.firstChild);
  }
  var fragment = doc.createDocumentFragment();
  while (el.firstChild) {
    fragment.appendChild(el.removeChild(el.firstChild));
  }
  return fragment;
}
var domify$1 = domify;
function query(selector, el) {
  el = el || document;
  return el.querySelector(selector);
}
function all(selector, el) {
  el = el || document;
  return el.querySelectorAll(selector);
}
function remove2(el) {
  el.parentNode && el.parentNode.removeChild(el);
}

// node_modules/diagram-js/lib/util/SvgTransformUtil.js
function transform2(gfx, x4, y4, angle, amount) {
  var translate3 = createTransform();
  translate3.setTranslate(x4, y4);
  var rotate2 = createTransform();
  rotate2.setRotate(angle || 0, 0, 0);
  var scale = createTransform();
  scale.setScale(amount || 1, amount || 1);
  transform(gfx, [translate3, rotate2, scale]);
}
function translate(gfx, x4, y4) {
  var translate3 = createTransform();
  translate3.setTranslate(x4, y4);
  transform(gfx, translate3);
}
function rotate(gfx, angle) {
  var rotate2 = createTransform();
  rotate2.setRotate(angle, 0, 0);
  transform(gfx, rotate2);
}

// node_modules/ids/dist/index.esm.js
function createCommonjsModule(fn2, module2) {
  return module2 = { exports: {} }, fn2(module2, module2.exports), module2.exports;
}
var hat_1 = createCommonjsModule(function(module2) {
  var hat = module2.exports = function(bits, base) {
    if (!base)
      base = 16;
    if (bits === void 0)
      bits = 128;
    if (bits <= 0)
      return "0";
    var digits = Math.log(Math.pow(2, bits)) / Math.log(base);
    for (var i6 = 2; digits === Infinity; i6 *= 2) {
      digits = Math.log(Math.pow(2, bits / i6)) / Math.log(base) * i6;
    }
    var rem = digits - Math.floor(digits);
    var res = "";
    for (var i6 = 0; i6 < Math.floor(digits); i6++) {
      var x4 = Math.floor(Math.random() * base).toString(base);
      res = x4 + res;
    }
    if (rem) {
      var b5 = Math.pow(base, rem);
      var x4 = Math.floor(Math.random() * b5).toString(base);
      res = x4 + res;
    }
    var parsed = parseInt(res, base);
    if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {
      return hat(bits, base);
    } else
      return res;
  };
  hat.rack = function(bits, base, expandBy) {
    var fn2 = function(data) {
      var iters = 0;
      do {
        if (iters++ > 10) {
          if (expandBy)
            bits += expandBy;
          else
            throw new Error("too many ID collisions, use more bits");
        }
        var id = hat(bits, base);
      } while (Object.hasOwnProperty.call(hats, id));
      hats[id] = data;
      return id;
    };
    var hats = fn2.hats = {};
    fn2.get = function(id) {
      return fn2.hats[id];
    };
    fn2.set = function(id, value) {
      fn2.hats[id] = value;
      return fn2;
    };
    fn2.bits = bits || 128;
    fn2.base = base || 16;
    return fn2;
  };
});
function Ids(seed) {
  if (!(this instanceof Ids)) {
    return new Ids(seed);
  }
  seed = seed || [128, 36, 1];
  this._seed = seed.length ? hat_1.rack(seed[0], seed[1], seed[2]) : seed;
}
Ids.prototype.next = function(element) {
  return this._seed(element || true);
};
Ids.prototype.nextPrefixed = function(prefix3, element) {
  var id;
  do {
    id = prefix3 + this.next(true);
  } while (this.assigned(id));
  this.claim(id, element);
  return id;
};
Ids.prototype.claim = function(id, element) {
  this._seed.set(id, element || true);
};
Ids.prototype.assigned = function(id) {
  return this._seed.get(id) || false;
};
Ids.prototype.unclaim = function(id) {
  delete this._seed.hats[id];
};
Ids.prototype.clear = function() {
  var hats = this._seed.hats, id;
  for (id in hats) {
    this.unclaim(id);
  }
};
var index_esm_default = Ids;

// node_modules/bpmn-js/lib/draw/BpmnRenderer.js
var RENDERER_IDS = new index_esm_default();
var TASK_BORDER_RADIUS = 10;
var INNER_OUTER_DIST = 3;
var DEFAULT_FILL_OPACITY = 0.95;
var HIGH_FILL_OPACITY = 0.35;
var ELEMENT_LABEL_DISTANCE = 10;
function BpmnRenderer(config, eventBus, styles, pathMap, canvas, textRenderer, priority) {
  BaseRenderer.call(this, eventBus, priority);
  var defaultFillColor = config && config.defaultFillColor, defaultStrokeColor = config && config.defaultStrokeColor, defaultLabelColor = config && config.defaultLabelColor;
  var rendererId = RENDERER_IDS.next();
  var markers = {};
  var computeStyle = styles.computeStyle;
  function addMarker(id, options2) {
    var attrs = (0, import_min_dash4.assign)({
      fill: black,
      strokeWidth: 1,
      strokeLinecap: "round",
      strokeDasharray: "none"
    }, options2.attrs);
    var ref = options2.ref || { x: 0, y: 0 };
    var scale = options2.scale || 1;
    if (attrs.strokeDasharray === "none") {
      attrs.strokeDasharray = [1e4, 1];
    }
    var marker2 = create("marker");
    attr(options2.element, attrs);
    append(marker2, options2.element);
    attr(marker2, {
      id,
      viewBox: "0 0 20 20",
      refX: ref.x,
      refY: ref.y,
      markerWidth: 20 * scale,
      markerHeight: 20 * scale,
      orient: "auto"
    });
    var defs = query("defs", canvas._svg);
    if (!defs) {
      defs = create("defs");
      append(canvas._svg, defs);
    }
    append(defs, marker2);
    markers[id] = marker2;
  }
  function colorEscape(str) {
    return str.replace(/[^0-9a-zA-z]+/g, "_");
  }
  function marker(type, fill, stroke) {
    var id = type + "-" + colorEscape(fill) + "-" + colorEscape(stroke) + "-" + rendererId;
    if (!markers[id]) {
      createMarker(id, type, fill, stroke);
    }
    return "url(#" + id + ")";
  }
  function createMarker(id, type, fill, stroke) {
    if (type === "sequenceflow-end") {
      var sequenceflowEnd = create("path");
      attr(sequenceflowEnd, { d: "M 1 5 L 11 10 L 1 15 Z" });
      addMarker(id, {
        element: sequenceflowEnd,
        ref: { x: 11, y: 10 },
        scale: 0.5,
        attrs: {
          fill: stroke,
          stroke
        }
      });
    }
    if (type === "messageflow-start") {
      var messageflowStart = create("circle");
      attr(messageflowStart, { cx: 6, cy: 6, r: 3.5 });
      addMarker(id, {
        element: messageflowStart,
        attrs: {
          fill,
          stroke
        },
        ref: { x: 6, y: 6 }
      });
    }
    if (type === "messageflow-end") {
      var messageflowEnd = create("path");
      attr(messageflowEnd, { d: "m 1 5 l 0 -3 l 7 3 l -7 3 z" });
      addMarker(id, {
        element: messageflowEnd,
        attrs: {
          fill,
          stroke,
          strokeLinecap: "butt"
        },
        ref: { x: 8.5, y: 5 }
      });
    }
    if (type === "association-start") {
      var associationStart = create("path");
      attr(associationStart, { d: "M 11 5 L 1 10 L 11 15" });
      addMarker(id, {
        element: associationStart,
        attrs: {
          fill: "none",
          stroke,
          strokeWidth: 1.5
        },
        ref: { x: 1, y: 10 },
        scale: 0.5
      });
    }
    if (type === "association-end") {
      var associationEnd = create("path");
      attr(associationEnd, { d: "M 1 5 L 11 10 L 1 15" });
      addMarker(id, {
        element: associationEnd,
        attrs: {
          fill: "none",
          stroke,
          strokeWidth: 1.5
        },
        ref: { x: 12, y: 10 },
        scale: 0.5
      });
    }
    if (type === "conditional-flow-marker") {
      var conditionalflowMarker = create("path");
      attr(conditionalflowMarker, { d: "M 0 10 L 8 6 L 16 10 L 8 14 Z" });
      addMarker(id, {
        element: conditionalflowMarker,
        attrs: {
          fill,
          stroke
        },
        ref: { x: -1, y: 10 },
        scale: 0.5
      });
    }
    if (type === "conditional-default-flow-marker") {
      var conditionaldefaultflowMarker = create("path");
      attr(conditionaldefaultflowMarker, { d: "M 6 4 L 10 16" });
      addMarker(id, {
        element: conditionaldefaultflowMarker,
        attrs: {
          stroke
        },
        ref: { x: 0, y: 10 },
        scale: 0.5
      });
    }
  }
  function drawCircle(parentGfx, width, height, offset, attrs) {
    if ((0, import_min_dash4.isObject)(offset)) {
      attrs = offset;
      offset = 0;
    }
    offset = offset || 0;
    attrs = computeStyle(attrs, {
      stroke: black,
      strokeWidth: 2,
      fill: "white"
    });
    if (attrs.fill === "none") {
      delete attrs.fillOpacity;
    }
    var cx = width / 2, cy = height / 2;
    var circle = create("circle");
    attr(circle, {
      cx,
      cy,
      r: Math.round((width + height) / 4 - offset)
    });
    attr(circle, attrs);
    append(parentGfx, circle);
    return circle;
  }
  function drawRect(parentGfx, width, height, r6, offset, attrs) {
    if ((0, import_min_dash4.isObject)(offset)) {
      attrs = offset;
      offset = 0;
    }
    offset = offset || 0;
    attrs = computeStyle(attrs, {
      stroke: black,
      strokeWidth: 2,
      fill: "white"
    });
    var rect = create("rect");
    attr(rect, {
      x: offset,
      y: offset,
      width: width - offset * 2,
      height: height - offset * 2,
      rx: r6,
      ry: r6
    });
    attr(rect, attrs);
    append(parentGfx, rect);
    return rect;
  }
  function drawDiamond(parentGfx, width, height, attrs) {
    var x_2 = width / 2;
    var y_2 = height / 2;
    var points = [{ x: x_2, y: 0 }, { x: width, y: y_2 }, { x: x_2, y: height }, { x: 0, y: y_2 }];
    var pointsString = points.map(function(point) {
      return point.x + "," + point.y;
    }).join(" ");
    attrs = computeStyle(attrs, {
      stroke: black,
      strokeWidth: 2,
      fill: "white"
    });
    var polygon = create("polygon");
    attr(polygon, {
      points: pointsString
    });
    attr(polygon, attrs);
    append(parentGfx, polygon);
    return polygon;
  }
  function drawLine(parentGfx, waypoints, attrs) {
    attrs = computeStyle(attrs, ["no-fill"], {
      stroke: black,
      strokeWidth: 2,
      fill: "none"
    });
    var line = createLine(waypoints, attrs);
    append(parentGfx, line);
    return line;
  }
  function drawPath(parentGfx, d5, attrs) {
    attrs = computeStyle(attrs, ["no-fill"], {
      strokeWidth: 2,
      stroke: black
    });
    var path = create("path");
    attr(path, { d: d5 });
    attr(path, attrs);
    append(parentGfx, path);
    return path;
  }
  function drawMarker(type, parentGfx, path, attrs) {
    return drawPath(parentGfx, path, (0, import_min_dash4.assign)({ "data-marker": type }, attrs));
  }
  function renderer(type) {
    return handlers[type];
  }
  function as(type) {
    return function(parentGfx, element) {
      return renderer(type)(parentGfx, element);
    };
  }
  function renderEventContent(element, parentGfx) {
    var event2 = getSemantic(element);
    var isThrowing = isThrowEvent(event2);
    if (event2.eventDefinitions && event2.eventDefinitions.length > 1) {
      if (event2.parallelMultiple) {
        return renderer("bpmn:ParallelMultipleEventDefinition")(parentGfx, element, isThrowing);
      } else {
        return renderer("bpmn:MultipleEventDefinition")(parentGfx, element, isThrowing);
      }
    }
    if (isTypedEvent(event2, "bpmn:MessageEventDefinition")) {
      return renderer("bpmn:MessageEventDefinition")(parentGfx, element, isThrowing);
    }
    if (isTypedEvent(event2, "bpmn:TimerEventDefinition")) {
      return renderer("bpmn:TimerEventDefinition")(parentGfx, element, isThrowing);
    }
    if (isTypedEvent(event2, "bpmn:ConditionalEventDefinition")) {
      return renderer("bpmn:ConditionalEventDefinition")(parentGfx, element);
    }
    if (isTypedEvent(event2, "bpmn:SignalEventDefinition")) {
      return renderer("bpmn:SignalEventDefinition")(parentGfx, element, isThrowing);
    }
    if (isTypedEvent(event2, "bpmn:EscalationEventDefinition")) {
      return renderer("bpmn:EscalationEventDefinition")(parentGfx, element, isThrowing);
    }
    if (isTypedEvent(event2, "bpmn:LinkEventDefinition")) {
      return renderer("bpmn:LinkEventDefinition")(parentGfx, element, isThrowing);
    }
    if (isTypedEvent(event2, "bpmn:ErrorEventDefinition")) {
      return renderer("bpmn:ErrorEventDefinition")(parentGfx, element, isThrowing);
    }
    if (isTypedEvent(event2, "bpmn:CancelEventDefinition")) {
      return renderer("bpmn:CancelEventDefinition")(parentGfx, element, isThrowing);
    }
    if (isTypedEvent(event2, "bpmn:CompensateEventDefinition")) {
      return renderer("bpmn:CompensateEventDefinition")(parentGfx, element, isThrowing);
    }
    if (isTypedEvent(event2, "bpmn:TerminateEventDefinition")) {
      return renderer("bpmn:TerminateEventDefinition")(parentGfx, element, isThrowing);
    }
    return null;
  }
  function renderLabel(parentGfx, label, options2) {
    options2 = (0, import_min_dash4.assign)({
      size: {
        width: 100
      }
    }, options2);
    var text = textRenderer.createText(label || "", options2);
    classes(text).add("djs-label");
    append(parentGfx, text);
    return text;
  }
  function renderEmbeddedLabel(parentGfx, element, align) {
    var semantic = getSemantic(element);
    return renderLabel(parentGfx, semantic.name, {
      box: element,
      align,
      padding: 5,
      style: {
        fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor)
      }
    });
  }
  function renderExternalLabel(parentGfx, element) {
    var box = {
      width: 90,
      height: 30,
      x: element.width / 2 + element.x,
      y: element.height / 2 + element.y
    };
    return renderLabel(parentGfx, getLabel(element), {
      box,
      fitBox: true,
      style: (0, import_min_dash4.assign)({}, textRenderer.getExternalStyle(), {
        fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor)
      })
    });
  }
  function renderLaneLabel(parentGfx, text, element) {
    var textBox = renderLabel(parentGfx, text, {
      box: {
        height: 30,
        width: element.height
      },
      align: "center-middle",
      style: {
        fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor)
      }
    });
    var top = -1 * element.height;
    transform2(textBox, 0, -top, 270);
  }
  function createPathFromConnection(connection) {
    var waypoints = connection.waypoints;
    var pathData = "m  " + waypoints[0].x + "," + waypoints[0].y;
    for (var i6 = 1; i6 < waypoints.length; i6++) {
      pathData += "L" + waypoints[i6].x + "," + waypoints[i6].y + " ";
    }
    return pathData;
  }
  var handlers = this.handlers = {
    "bpmn:Event": function(parentGfx, element, attrs) {
      if (!("fillOpacity" in attrs)) {
        attrs.fillOpacity = DEFAULT_FILL_OPACITY;
      }
      return drawCircle(parentGfx, element.width, element.height, attrs);
    },
    "bpmn:StartEvent": function(parentGfx, element) {
      var attrs = {
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor(element, defaultStrokeColor)
      };
      var semantic = getSemantic(element);
      if (!semantic.isInterrupting) {
        attrs = {
          strokeDasharray: "6",
          strokeLinecap: "round",
          fill: getFillColor(element, defaultFillColor),
          stroke: getStrokeColor(element, defaultStrokeColor)
        };
      }
      var circle = renderer("bpmn:Event")(parentGfx, element, attrs);
      renderEventContent(element, parentGfx);
      return circle;
    },
    "bpmn:MessageEventDefinition": function(parentGfx, element, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_MESSAGE", {
        xScaleFactor: 0.9,
        yScaleFactor: 0.9,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.235,
          my: 0.315
        }
      });
      var fill = isThrowing ? getStrokeColor(element, defaultStrokeColor) : getFillColor(element, defaultFillColor);
      var stroke = isThrowing ? getFillColor(element, defaultFillColor) : getStrokeColor(element, defaultStrokeColor);
      var messagePath = drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill,
        stroke
      });
      return messagePath;
    },
    "bpmn:TimerEventDefinition": function(parentGfx, element) {
      var circle = drawCircle(parentGfx, element.width, element.height, 0.2 * element.height, {
        strokeWidth: 2,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
      var pathData = pathMap.getScaledPath("EVENT_TIMER_WH", {
        xScaleFactor: 0.75,
        yScaleFactor: 0.75,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.5,
          my: 0.5
        }
      });
      drawPath(parentGfx, pathData, {
        strokeWidth: 2,
        strokeLinecap: "square",
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
      for (var i6 = 0; i6 < 12; i6++) {
        var linePathData = pathMap.getScaledPath("EVENT_TIMER_LINE", {
          xScaleFactor: 0.75,
          yScaleFactor: 0.75,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0.5,
            my: 0.5
          }
        });
        var width = element.width / 2;
        var height = element.height / 2;
        drawPath(parentGfx, linePathData, {
          strokeWidth: 1,
          strokeLinecap: "square",
          transform: "rotate(" + i6 * 30 + "," + height + "," + width + ")",
          stroke: getStrokeColor(element, defaultStrokeColor)
        });
      }
      return circle;
    },
    "bpmn:EscalationEventDefinition": function(parentGfx, event2, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_ESCALATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.5,
          my: 0.2
        }
      });
      var fill = isThrowing ? getStrokeColor(event2, defaultStrokeColor) : "none";
      return drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill,
        stroke: getStrokeColor(event2, defaultStrokeColor)
      });
    },
    "bpmn:ConditionalEventDefinition": function(parentGfx, event2) {
      var pathData = pathMap.getScaledPath("EVENT_CONDITIONAL", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.5,
          my: 0.222
        }
      });
      return drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        stroke: getStrokeColor(event2, defaultStrokeColor)
      });
    },
    "bpmn:LinkEventDefinition": function(parentGfx, event2, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_LINK", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.57,
          my: 0.263
        }
      });
      var fill = isThrowing ? getStrokeColor(event2, defaultStrokeColor) : "none";
      return drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill,
        stroke: getStrokeColor(event2, defaultStrokeColor)
      });
    },
    "bpmn:ErrorEventDefinition": function(parentGfx, event2, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_ERROR", {
        xScaleFactor: 1.1,
        yScaleFactor: 1.1,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.2,
          my: 0.722
        }
      });
      var fill = isThrowing ? getStrokeColor(event2, defaultStrokeColor) : "none";
      return drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill,
        stroke: getStrokeColor(event2, defaultStrokeColor)
      });
    },
    "bpmn:CancelEventDefinition": function(parentGfx, event2, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_CANCEL_45", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.638,
          my: -0.055
        }
      });
      var fill = isThrowing ? getStrokeColor(event2, defaultStrokeColor) : "none";
      var path = drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill,
        stroke: getStrokeColor(event2, defaultStrokeColor)
      });
      rotate(path, 45);
      return path;
    },
    "bpmn:CompensateEventDefinition": function(parentGfx, event2, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_COMPENSATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.22,
          my: 0.5
        }
      });
      var fill = isThrowing ? getStrokeColor(event2, defaultStrokeColor) : "none";
      return drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill,
        stroke: getStrokeColor(event2, defaultStrokeColor)
      });
    },
    "bpmn:SignalEventDefinition": function(parentGfx, event2, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_SIGNAL", {
        xScaleFactor: 0.9,
        yScaleFactor: 0.9,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.5,
          my: 0.2
        }
      });
      var fill = isThrowing ? getStrokeColor(event2, defaultStrokeColor) : "none";
      return drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill,
        stroke: getStrokeColor(event2, defaultStrokeColor)
      });
    },
    "bpmn:MultipleEventDefinition": function(parentGfx, event2, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_MULTIPLE", {
        xScaleFactor: 1.1,
        yScaleFactor: 1.1,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.222,
          my: 0.36
        }
      });
      var fill = isThrowing ? getStrokeColor(event2, defaultStrokeColor) : "none";
      return drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill
      });
    },
    "bpmn:ParallelMultipleEventDefinition": function(parentGfx, event2) {
      var pathData = pathMap.getScaledPath("EVENT_PARALLEL_MULTIPLE", {
        xScaleFactor: 1.2,
        yScaleFactor: 1.2,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.458,
          my: 0.194
        }
      });
      return drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill: getStrokeColor(event2, defaultStrokeColor),
        stroke: getStrokeColor(event2, defaultStrokeColor)
      });
    },
    "bpmn:EndEvent": function(parentGfx, element) {
      var circle = renderer("bpmn:Event")(parentGfx, element, {
        strokeWidth: 4,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
      renderEventContent(element, parentGfx, true);
      return circle;
    },
    "bpmn:TerminateEventDefinition": function(parentGfx, element) {
      var circle = drawCircle(parentGfx, element.width, element.height, 8, {
        strokeWidth: 4,
        fill: getStrokeColor(element, defaultStrokeColor),
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
      return circle;
    },
    "bpmn:IntermediateEvent": function(parentGfx, element) {
      var outer = renderer("bpmn:Event")(parentGfx, element, {
        strokeWidth: 1,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
      drawCircle(parentGfx, element.width, element.height, INNER_OUTER_DIST, {
        strokeWidth: 1,
        fill: getFillColor(element, "none"),
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
      renderEventContent(element, parentGfx);
      return outer;
    },
    "bpmn:IntermediateCatchEvent": as("bpmn:IntermediateEvent"),
    "bpmn:IntermediateThrowEvent": as("bpmn:IntermediateEvent"),
    "bpmn:Activity": function(parentGfx, element, attrs) {
      attrs = attrs || {};
      if (!("fillOpacity" in attrs)) {
        attrs.fillOpacity = DEFAULT_FILL_OPACITY;
      }
      return drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS, attrs);
    },
    "bpmn:Task": function(parentGfx, element) {
      var attrs = {
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor(element, defaultStrokeColor)
      };
      var rect = renderer("bpmn:Activity")(parentGfx, element, attrs);
      renderEmbeddedLabel(parentGfx, element, "center-middle");
      attachTaskMarkers(parentGfx, element);
      return rect;
    },
    "bpmn:ServiceTask": function(parentGfx, element) {
      var task = renderer("bpmn:Task")(parentGfx, element);
      var pathDataBG = pathMap.getScaledPath("TASK_TYPE_SERVICE", {
        abspos: {
          x: 12,
          y: 18
        }
      });
      drawPath(parentGfx, pathDataBG, {
        strokeWidth: 1,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
      var fillPathData = pathMap.getScaledPath("TASK_TYPE_SERVICE_FILL", {
        abspos: {
          x: 17.2,
          y: 18
        }
      });
      drawPath(parentGfx, fillPathData, {
        strokeWidth: 0,
        fill: getFillColor(element, defaultFillColor)
      });
      var pathData = pathMap.getScaledPath("TASK_TYPE_SERVICE", {
        abspos: {
          x: 17,
          y: 22
        }
      });
      drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
      return task;
    },
    "bpmn:UserTask": function(parentGfx, element) {
      var task = renderer("bpmn:Task")(parentGfx, element);
      var x4 = 15;
      var y4 = 12;
      var pathData = pathMap.getScaledPath("TASK_TYPE_USER_1", {
        abspos: {
          x: x4,
          y: y4
        }
      });
      drawPath(parentGfx, pathData, {
        strokeWidth: 0.5,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
      var pathData2 = pathMap.getScaledPath("TASK_TYPE_USER_2", {
        abspos: {
          x: x4,
          y: y4
        }
      });
      drawPath(parentGfx, pathData2, {
        strokeWidth: 0.5,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
      var pathData3 = pathMap.getScaledPath("TASK_TYPE_USER_3", {
        abspos: {
          x: x4,
          y: y4
        }
      });
      drawPath(parentGfx, pathData3, {
        strokeWidth: 0.5,
        fill: getStrokeColor(element, defaultStrokeColor),
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
      return task;
    },
    "bpmn:ManualTask": function(parentGfx, element) {
      var task = renderer("bpmn:Task")(parentGfx, element);
      var pathData = pathMap.getScaledPath("TASK_TYPE_MANUAL", {
        abspos: {
          x: 17,
          y: 15
        }
      });
      drawPath(parentGfx, pathData, {
        strokeWidth: 0.5,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
      return task;
    },
    "bpmn:SendTask": function(parentGfx, element) {
      var task = renderer("bpmn:Task")(parentGfx, element);
      var pathData = pathMap.getScaledPath("TASK_TYPE_SEND", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: 21,
        containerHeight: 14,
        position: {
          mx: 0.285,
          my: 0.357
        }
      });
      drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill: getStrokeColor(element, defaultStrokeColor),
        stroke: getFillColor(element, defaultFillColor)
      });
      return task;
    },
    "bpmn:ReceiveTask": function(parentGfx, element) {
      var semantic = getSemantic(element);
      var task = renderer("bpmn:Task")(parentGfx, element);
      var pathData;
      if (semantic.instantiate) {
        drawCircle(parentGfx, 28, 28, 20 * 0.22, { strokeWidth: 1 });
        pathData = pathMap.getScaledPath("TASK_TYPE_INSTANTIATING_SEND", {
          abspos: {
            x: 7.77,
            y: 9.52
          }
        });
      } else {
        pathData = pathMap.getScaledPath("TASK_TYPE_SEND", {
          xScaleFactor: 0.9,
          yScaleFactor: 0.9,
          containerWidth: 21,
          containerHeight: 14,
          position: {
            mx: 0.3,
            my: 0.4
          }
        });
      }
      drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
      return task;
    },
    "bpmn:ScriptTask": function(parentGfx, element) {
      var task = renderer("bpmn:Task")(parentGfx, element);
      var pathData = pathMap.getScaledPath("TASK_TYPE_SCRIPT", {
        abspos: {
          x: 15,
          y: 20
        }
      });
      drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
      return task;
    },
    "bpmn:BusinessRuleTask": function(parentGfx, element) {
      var task = renderer("bpmn:Task")(parentGfx, element);
      var headerPathData = pathMap.getScaledPath("TASK_TYPE_BUSINESS_RULE_HEADER", {
        abspos: {
          x: 8,
          y: 8
        }
      });
      var businessHeaderPath = drawPath(parentGfx, headerPathData);
      attr(businessHeaderPath, {
        strokeWidth: 1,
        fill: getFillColor(element, "#aaaaaa"),
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
      var headerData = pathMap.getScaledPath("TASK_TYPE_BUSINESS_RULE_MAIN", {
        abspos: {
          x: 8,
          y: 8
        }
      });
      var businessPath = drawPath(parentGfx, headerData);
      attr(businessPath, {
        strokeWidth: 1,
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
      return task;
    },
    "bpmn:SubProcess": function(parentGfx, element, attrs) {
      attrs = (0, import_min_dash4.assign)({
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor(element, defaultStrokeColor)
      }, attrs);
      var rect = renderer("bpmn:Activity")(parentGfx, element, attrs);
      var expanded = isExpanded(element);
      if (isEventSubProcess(element)) {
        attr(rect, {
          strokeDasharray: "1,2"
        });
      }
      renderEmbeddedLabel(parentGfx, element, expanded ? "center-top" : "center-middle");
      if (expanded) {
        attachTaskMarkers(parentGfx, element);
      } else {
        attachTaskMarkers(parentGfx, element, ["SubProcessMarker"]);
      }
      return rect;
    },
    "bpmn:AdHocSubProcess": function(parentGfx, element) {
      return renderer("bpmn:SubProcess")(parentGfx, element);
    },
    "bpmn:Transaction": function(parentGfx, element) {
      var outer = renderer("bpmn:SubProcess")(parentGfx, element);
      var innerAttrs = styles.style(["no-fill", "no-events"], {
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
      drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS - 2, INNER_OUTER_DIST, innerAttrs);
      return outer;
    },
    "bpmn:CallActivity": function(parentGfx, element) {
      return renderer("bpmn:SubProcess")(parentGfx, element, {
        strokeWidth: 5
      });
    },
    "bpmn:Participant": function(parentGfx, element) {
      var attrs = {
        fillOpacity: DEFAULT_FILL_OPACITY,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor(element, defaultStrokeColor)
      };
      var lane = renderer("bpmn:Lane")(parentGfx, element, attrs);
      var expandedPool = isExpanded(element);
      if (expandedPool) {
        drawLine(parentGfx, [
          { x: 30, y: 0 },
          { x: 30, y: element.height }
        ], {
          stroke: getStrokeColor(element, defaultStrokeColor)
        });
        var text = getSemantic(element).name;
        renderLaneLabel(parentGfx, text, element);
      } else {
        var text2 = getSemantic(element).name;
        renderLabel(parentGfx, text2, {
          box: element,
          align: "center-middle",
          style: {
            fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor)
          }
        });
      }
      var participantMultiplicity = !!getSemantic(element).participantMultiplicity;
      if (participantMultiplicity) {
        renderer("ParticipantMultiplicityMarker")(parentGfx, element);
      }
      return lane;
    },
    "bpmn:Lane": function(parentGfx, element, attrs) {
      var rect = drawRect(parentGfx, element.width, element.height, 0, (0, import_min_dash4.assign)({
        fill: getFillColor(element, defaultFillColor),
        fillOpacity: HIGH_FILL_OPACITY,
        stroke: getStrokeColor(element, defaultStrokeColor)
      }, attrs));
      var semantic = getSemantic(element);
      if (semantic.$type === "bpmn:Lane") {
        var text = semantic.name;
        renderLaneLabel(parentGfx, text, element);
      }
      return rect;
    },
    "bpmn:InclusiveGateway": function(parentGfx, element) {
      var diamond = renderer("bpmn:Gateway")(parentGfx, element);
      drawCircle(parentGfx, element.width, element.height, element.height * 0.24, {
        strokeWidth: 2.5,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
      return diamond;
    },
    "bpmn:ExclusiveGateway": function(parentGfx, element) {
      var diamond = renderer("bpmn:Gateway")(parentGfx, element);
      var pathData = pathMap.getScaledPath("GATEWAY_EXCLUSIVE", {
        xScaleFactor: 0.4,
        yScaleFactor: 0.4,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.32,
          my: 0.3
        }
      });
      if (getDi(element).isMarkerVisible) {
        drawPath(parentGfx, pathData, {
          strokeWidth: 1,
          fill: getStrokeColor(element, defaultStrokeColor),
          stroke: getStrokeColor(element, defaultStrokeColor)
        });
      }
      return diamond;
    },
    "bpmn:ComplexGateway": function(parentGfx, element) {
      var diamond = renderer("bpmn:Gateway")(parentGfx, element);
      var pathData = pathMap.getScaledPath("GATEWAY_COMPLEX", {
        xScaleFactor: 0.5,
        yScaleFactor: 0.5,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.46,
          my: 0.26
        }
      });
      drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill: getStrokeColor(element, defaultStrokeColor),
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
      return diamond;
    },
    "bpmn:ParallelGateway": function(parentGfx, element) {
      var diamond = renderer("bpmn:Gateway")(parentGfx, element);
      var pathData = pathMap.getScaledPath("GATEWAY_PARALLEL", {
        xScaleFactor: 0.6,
        yScaleFactor: 0.6,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.46,
          my: 0.2
        }
      });
      drawPath(parentGfx, pathData, {
        strokeWidth: 1,
        fill: getStrokeColor(element, defaultStrokeColor),
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
      return diamond;
    },
    "bpmn:EventBasedGateway": function(parentGfx, element) {
      var semantic = getSemantic(element);
      var diamond = renderer("bpmn:Gateway")(parentGfx, element);
      drawCircle(parentGfx, element.width, element.height, element.height * 0.2, {
        strokeWidth: 1,
        fill: "none",
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
      var type = semantic.eventGatewayType;
      var instantiate = !!semantic.instantiate;
      function drawEvent() {
        var pathData2 = pathMap.getScaledPath("GATEWAY_EVENT_BASED", {
          xScaleFactor: 0.18,
          yScaleFactor: 0.18,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0.36,
            my: 0.44
          }
        });
        var attrs = {
          strokeWidth: 2,
          fill: getFillColor(element, "none"),
          stroke: getStrokeColor(element, defaultStrokeColor)
        };
        drawPath(parentGfx, pathData2, attrs);
      }
      if (type === "Parallel") {
        var pathData = pathMap.getScaledPath("GATEWAY_PARALLEL", {
          xScaleFactor: 0.4,
          yScaleFactor: 0.4,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0.474,
            my: 0.296
          }
        });
        var parallelPath = drawPath(parentGfx, pathData);
        attr(parallelPath, {
          strokeWidth: 1,
          fill: "none"
        });
      } else if (type === "Exclusive") {
        if (!instantiate) {
          var innerCircle = drawCircle(parentGfx, element.width, element.height, element.height * 0.26);
          attr(innerCircle, {
            strokeWidth: 1,
            fill: "none",
            stroke: getStrokeColor(element, defaultStrokeColor)
          });
        }
        drawEvent();
      }
      return diamond;
    },
    "bpmn:Gateway": function(parentGfx, element) {
      var attrs = {
        fill: getFillColor(element, defaultFillColor),
        fillOpacity: DEFAULT_FILL_OPACITY,
        stroke: getStrokeColor(element, defaultStrokeColor)
      };
      return drawDiamond(parentGfx, element.width, element.height, attrs);
    },
    "bpmn:SequenceFlow": function(parentGfx, element) {
      var pathData = createPathFromConnection(element);
      var fill = getFillColor(element, defaultFillColor), stroke = getStrokeColor(element, defaultStrokeColor);
      var attrs = {
        strokeLinejoin: "round",
        markerEnd: marker("sequenceflow-end", fill, stroke),
        stroke: getStrokeColor(element, defaultStrokeColor)
      };
      var path = drawPath(parentGfx, pathData, attrs);
      var sequenceFlow = getSemantic(element);
      var source;
      if (element.source) {
        source = element.source.businessObject;
        if (sequenceFlow.conditionExpression && source.$instanceOf("bpmn:Activity")) {
          attr(path, {
            markerStart: marker("conditional-flow-marker", fill, stroke)
          });
        }
        if (source.default && (source.$instanceOf("bpmn:Gateway") || source.$instanceOf("bpmn:Activity")) && source.default === sequenceFlow) {
          attr(path, {
            markerStart: marker("conditional-default-flow-marker", fill, stroke)
          });
        }
      }
      return path;
    },
    "bpmn:Association": function(parentGfx, element, attrs) {
      var semantic = getSemantic(element);
      var fill = getFillColor(element, defaultFillColor), stroke = getStrokeColor(element, defaultStrokeColor);
      attrs = (0, import_min_dash4.assign)({
        strokeDasharray: "0.5, 5",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        stroke: getStrokeColor(element, defaultStrokeColor)
      }, attrs || {});
      if (semantic.associationDirection === "One" || semantic.associationDirection === "Both") {
        attrs.markerEnd = marker("association-end", fill, stroke);
      }
      if (semantic.associationDirection === "Both") {
        attrs.markerStart = marker("association-start", fill, stroke);
      }
      return drawLine(parentGfx, element.waypoints, attrs);
    },
    "bpmn:DataInputAssociation": function(parentGfx, element) {
      var fill = getFillColor(element, defaultFillColor), stroke = getStrokeColor(element, defaultStrokeColor);
      return renderer("bpmn:Association")(parentGfx, element, {
        markerEnd: marker("association-end", fill, stroke)
      });
    },
    "bpmn:DataOutputAssociation": function(parentGfx, element) {
      var fill = getFillColor(element, defaultFillColor), stroke = getStrokeColor(element, defaultStrokeColor);
      return renderer("bpmn:Association")(parentGfx, element, {
        markerEnd: marker("association-end", fill, stroke)
      });
    },
    "bpmn:MessageFlow": function(parentGfx, element) {
      var semantic = getSemantic(element), di = getDi(element);
      var fill = getFillColor(element, defaultFillColor), stroke = getStrokeColor(element, defaultStrokeColor);
      var pathData = createPathFromConnection(element);
      var attrs = {
        markerEnd: marker("messageflow-end", fill, stroke),
        markerStart: marker("messageflow-start", fill, stroke),
        strokeDasharray: "10, 12",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        strokeWidth: "1.5px",
        stroke: getStrokeColor(element, defaultStrokeColor)
      };
      var path = drawPath(parentGfx, pathData, attrs);
      if (semantic.messageRef) {
        var midPoint = path.getPointAtLength(path.getTotalLength() / 2);
        var markerPathData = pathMap.getScaledPath("MESSAGE_FLOW_MARKER", {
          abspos: {
            x: midPoint.x,
            y: midPoint.y
          }
        });
        var messageAttrs = { strokeWidth: 1 };
        if (di.messageVisibleKind === "initiating") {
          messageAttrs.fill = "white";
          messageAttrs.stroke = black;
        } else {
          messageAttrs.fill = "#888";
          messageAttrs.stroke = "white";
        }
        var message = drawPath(parentGfx, markerPathData, messageAttrs);
        var labelText = semantic.messageRef.name;
        var label = renderLabel(parentGfx, labelText, {
          align: "center-top",
          fitBox: true,
          style: {
            fill: getStrokeColor(element, defaultLabelColor, defaultStrokeColor)
          }
        });
        var messageBounds = message.getBBox(), labelBounds = label.getBBox();
        var translateX = midPoint.x - labelBounds.width / 2, translateY = midPoint.y + messageBounds.height / 2 + ELEMENT_LABEL_DISTANCE;
        transform2(label, translateX, translateY, 0);
      }
      return path;
    },
    "bpmn:DataObject": function(parentGfx, element) {
      var pathData = pathMap.getScaledPath("DATA_OBJECT_PATH", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.474,
          my: 0.296
        }
      });
      var elementObject = drawPath(parentGfx, pathData, {
        fill: getFillColor(element, defaultFillColor),
        fillOpacity: DEFAULT_FILL_OPACITY,
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
      var semantic = getSemantic(element);
      if (isCollection(semantic)) {
        renderDataItemCollection(parentGfx, element);
      }
      return elementObject;
    },
    "bpmn:DataObjectReference": as("bpmn:DataObject"),
    "bpmn:DataInput": function(parentGfx, element) {
      var arrowPathData = pathMap.getRawPath("DATA_ARROW");
      var elementObject = renderer("bpmn:DataObject")(parentGfx, element);
      drawPath(parentGfx, arrowPathData, { strokeWidth: 1 });
      return elementObject;
    },
    "bpmn:DataOutput": function(parentGfx, element) {
      var arrowPathData = pathMap.getRawPath("DATA_ARROW");
      var elementObject = renderer("bpmn:DataObject")(parentGfx, element);
      drawPath(parentGfx, arrowPathData, {
        strokeWidth: 1,
        fill: black
      });
      return elementObject;
    },
    "bpmn:DataStoreReference": function(parentGfx, element) {
      var DATA_STORE_PATH = pathMap.getScaledPath("DATA_STORE", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0,
          my: 0.133
        }
      });
      var elementStore = drawPath(parentGfx, DATA_STORE_PATH, {
        strokeWidth: 2,
        fill: getFillColor(element, defaultFillColor),
        fillOpacity: DEFAULT_FILL_OPACITY,
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
      return elementStore;
    },
    "bpmn:BoundaryEvent": function(parentGfx, element) {
      var semantic = getSemantic(element), cancel = semantic.cancelActivity;
      var attrs = {
        strokeWidth: 1,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor(element, defaultStrokeColor)
      };
      if (!cancel) {
        attrs.strokeDasharray = "6";
        attrs.strokeLinecap = "round";
      }
      var outerAttrs = (0, import_min_dash4.assign)({}, attrs, {
        fillOpacity: 1
      });
      var innerAttrs = (0, import_min_dash4.assign)({}, attrs, {
        fill: "none"
      });
      var outer = renderer("bpmn:Event")(parentGfx, element, outerAttrs);
      drawCircle(parentGfx, element.width, element.height, INNER_OUTER_DIST, innerAttrs);
      renderEventContent(element, parentGfx);
      return outer;
    },
    "bpmn:Group": function(parentGfx, element) {
      var group = drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS, {
        stroke: getStrokeColor(element, defaultStrokeColor),
        strokeWidth: 1,
        strokeDasharray: "8,3,1,3",
        fill: "none",
        pointerEvents: "none"
      });
      return group;
    },
    "label": function(parentGfx, element) {
      return renderExternalLabel(parentGfx, element);
    },
    "bpmn:TextAnnotation": function(parentGfx, element) {
      var style = {
        "fill": "none",
        "stroke": "none"
      };
      var textElement = drawRect(parentGfx, element.width, element.height, 0, 0, style);
      var textPathData = pathMap.getScaledPath("TEXT_ANNOTATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0,
          my: 0
        }
      });
      drawPath(parentGfx, textPathData, {
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
      var text = getSemantic(element).text || "";
      renderLabel(parentGfx, text, {
        box: element,
        align: "left-top",
        padding: 5,
        style: {
          fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor)
        }
      });
      return textElement;
    },
    "ParticipantMultiplicityMarker": function(parentGfx, element) {
      var markerPath = pathMap.getScaledPath("MARKER_PARALLEL", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: element.width / 2 / element.width,
          my: (element.height - 15) / element.height
        }
      });
      drawMarker("participant-multiplicity", parentGfx, markerPath, {
        strokeWidth: 2,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
    },
    "SubProcessMarker": function(parentGfx, element) {
      var markerRect = drawRect(parentGfx, 14, 14, 0, {
        strokeWidth: 1,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
      translate(markerRect, element.width / 2 - 7.5, element.height - 20);
      var markerPath = pathMap.getScaledPath("MARKER_SUB_PROCESS", {
        xScaleFactor: 1.5,
        yScaleFactor: 1.5,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: (element.width / 2 - 7.5) / element.width,
          my: (element.height - 20) / element.height
        }
      });
      drawMarker("sub-process", parentGfx, markerPath, {
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
    },
    "ParallelMarker": function(parentGfx, element, position) {
      var markerPath = pathMap.getScaledPath("MARKER_PARALLEL", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: (element.width / 2 + position.parallel) / element.width,
          my: (element.height - 20) / element.height
        }
      });
      drawMarker("parallel", parentGfx, markerPath, {
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
    },
    "SequentialMarker": function(parentGfx, element, position) {
      var markerPath = pathMap.getScaledPath("MARKER_SEQUENTIAL", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: (element.width / 2 + position.seq) / element.width,
          my: (element.height - 19) / element.height
        }
      });
      drawMarker("sequential", parentGfx, markerPath, {
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
    },
    "CompensationMarker": function(parentGfx, element, position) {
      var markerMath = pathMap.getScaledPath("MARKER_COMPENSATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: (element.width / 2 + position.compensation) / element.width,
          my: (element.height - 13) / element.height
        }
      });
      drawMarker("compensation", parentGfx, markerMath, {
        strokeWidth: 1,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
    },
    "LoopMarker": function(parentGfx, element, position) {
      var markerPath = pathMap.getScaledPath("MARKER_LOOP", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: (element.width / 2 + position.loop) / element.width,
          my: (element.height - 7) / element.height
        }
      });
      drawMarker("loop", parentGfx, markerPath, {
        strokeWidth: 1,
        fill: getFillColor(element, defaultFillColor),
        stroke: getStrokeColor(element, defaultStrokeColor),
        strokeLinecap: "round",
        strokeMiterlimit: 0.5
      });
    },
    "AdhocMarker": function(parentGfx, element, position) {
      var markerPath = pathMap.getScaledPath("MARKER_ADHOC", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: (element.width / 2 + position.adhoc) / element.width,
          my: (element.height - 15) / element.height
        }
      });
      drawMarker("adhoc", parentGfx, markerPath, {
        strokeWidth: 1,
        fill: getStrokeColor(element, defaultStrokeColor),
        stroke: getStrokeColor(element, defaultStrokeColor)
      });
    }
  };
  function attachTaskMarkers(parentGfx, element, taskMarkers) {
    var obj = getSemantic(element);
    var subprocess = taskMarkers && taskMarkers.indexOf("SubProcessMarker") !== -1;
    var position;
    if (subprocess) {
      position = {
        seq: -21,
        parallel: -22,
        compensation: -42,
        loop: -18,
        adhoc: 10
      };
    } else {
      position = {
        seq: -3,
        parallel: -6,
        compensation: -27,
        loop: 0,
        adhoc: 10
      };
    }
    (0, import_min_dash4.forEach)(taskMarkers, function(marker2) {
      renderer(marker2)(parentGfx, element, position);
    });
    if (obj.isForCompensation) {
      renderer("CompensationMarker")(parentGfx, element, position);
    }
    if (obj.$type === "bpmn:AdHocSubProcess") {
      renderer("AdhocMarker")(parentGfx, element, position);
    }
    var loopCharacteristics = obj.loopCharacteristics, isSequential = loopCharacteristics && loopCharacteristics.isSequential;
    if (loopCharacteristics) {
      if (isSequential === void 0) {
        renderer("LoopMarker")(parentGfx, element, position);
      }
      if (isSequential === false) {
        renderer("ParallelMarker")(parentGfx, element, position);
      }
      if (isSequential === true) {
        renderer("SequentialMarker")(parentGfx, element, position);
      }
    }
  }
  function renderDataItemCollection(parentGfx, element) {
    var yPosition = (element.height - 18) / element.height;
    var pathData = pathMap.getScaledPath("DATA_OBJECT_COLLECTION_PATH", {
      xScaleFactor: 1,
      yScaleFactor: 1,
      containerWidth: element.width,
      containerHeight: element.height,
      position: {
        mx: 0.33,
        my: yPosition
      }
    });
    drawPath(parentGfx, pathData, {
      strokeWidth: 2
    });
  }
  this._drawPath = drawPath;
  this._renderer = renderer;
}
e(BpmnRenderer, BaseRenderer);
BpmnRenderer.$inject = [
  "config.bpmnRenderer",
  "eventBus",
  "styles",
  "pathMap",
  "canvas",
  "textRenderer"
];
BpmnRenderer.prototype.canRender = function(element) {
  return is(element, "bpmn:BaseElement");
};
BpmnRenderer.prototype.drawShape = function(parentGfx, element) {
  var type = element.type;
  var h5 = this._renderer(type);
  return h5(parentGfx, element);
};
BpmnRenderer.prototype.drawConnection = function(parentGfx, element) {
  var type = element.type;
  var h5 = this._renderer(type);
  return h5(parentGfx, element);
};
BpmnRenderer.prototype.getShapePath = function(element) {
  if (is(element, "bpmn:Event")) {
    return getCirclePath(element);
  }
  if (is(element, "bpmn:Activity")) {
    return getRoundRectPath(element, TASK_BORDER_RADIUS);
  }
  if (is(element, "bpmn:Gateway")) {
    return getDiamondPath(element);
  }
  return getRectPath(element);
};

// node_modules/bpmn-js/lib/draw/TextRenderer.js
var import_min_dash6 = __toESM(require_dist());

// node_modules/diagram-js/lib/util/Text.js
var import_min_dash5 = __toESM(require_dist());
var DEFAULT_BOX_PADDING = 0;
var DEFAULT_LABEL_SIZE = {
  width: 150,
  height: 50
};
function parseAlign(align) {
  var parts = align.split("-");
  return {
    horizontal: parts[0] || "center",
    vertical: parts[1] || "top"
  };
}
function parsePadding(padding) {
  if ((0, import_min_dash5.isObject)(padding)) {
    return (0, import_min_dash5.assign)({ top: 0, left: 0, right: 0, bottom: 0 }, padding);
  } else {
    return {
      top: padding,
      left: padding,
      right: padding,
      bottom: padding
    };
  }
}
function getTextBBox(text, fakeText) {
  fakeText.textContent = text;
  var textBBox;
  try {
    var bbox, emptyLine = text === "";
    fakeText.textContent = emptyLine ? "dummy" : text;
    textBBox = fakeText.getBBox();
    bbox = {
      width: textBBox.width + textBBox.x * 2,
      height: textBBox.height
    };
    if (emptyLine) {
      bbox.width = 0;
    }
    return bbox;
  } catch (e7) {
    return { width: 0, height: 0 };
  }
}
function layoutNext(lines, maxWidth, fakeText) {
  var originalLine = lines.shift(), fitLine = originalLine;
  var textBBox;
  for (; ; ) {
    textBBox = getTextBBox(fitLine, fakeText);
    textBBox.width = fitLine ? textBBox.width : 0;
    if (fitLine === " " || fitLine === "" || textBBox.width < Math.round(maxWidth) || fitLine.length < 2) {
      return fit(lines, fitLine, originalLine, textBBox);
    }
    fitLine = shortenLine(fitLine, textBBox.width, maxWidth);
  }
}
function fit(lines, fitLine, originalLine, textBBox) {
  if (fitLine.length < originalLine.length) {
    var remainder = originalLine.slice(fitLine.length).trim();
    lines.unshift(remainder);
  }
  return {
    width: textBBox.width,
    height: textBBox.height,
    text: fitLine
  };
}
var SOFT_BREAK = "\xAD";
function semanticShorten(line, maxLength) {
  var parts = line.split(/(\s|-|\u00AD)/g), part, shortenedParts = [], length2 = 0;
  if (parts.length > 1) {
    while (part = parts.shift()) {
      if (part.length + length2 < maxLength) {
        shortenedParts.push(part);
        length2 += part.length;
      } else {
        if (part === "-" || part === SOFT_BREAK) {
          shortenedParts.pop();
        }
        break;
      }
    }
  }
  var last2 = shortenedParts[shortenedParts.length - 1];
  if (last2 && last2 === SOFT_BREAK) {
    shortenedParts[shortenedParts.length - 1] = "-";
  }
  return shortenedParts.join("");
}
function shortenLine(line, width, maxWidth) {
  var length2 = Math.max(line.length * (maxWidth / width), 1);
  var shortenedLine = semanticShorten(line, length2);
  if (!shortenedLine) {
    shortenedLine = line.slice(0, Math.max(Math.round(length2 - 1), 1));
  }
  return shortenedLine;
}
function getHelperSvg() {
  var helperSvg = document.getElementById("helper-svg");
  if (!helperSvg) {
    helperSvg = create("svg");
    attr(helperSvg, {
      id: "helper-svg"
    });
    assign(helperSvg, {
      visibility: "hidden",
      position: "fixed",
      width: 0,
      height: 0
    });
    document.body.appendChild(helperSvg);
  }
  return helperSvg;
}
function Text(config) {
  this._config = (0, import_min_dash5.assign)({}, {
    size: DEFAULT_LABEL_SIZE,
    padding: DEFAULT_BOX_PADDING,
    style: {},
    align: "center-top"
  }, config || {});
}
Text.prototype.createText = function(text, options2) {
  return this.layoutText(text, options2).element;
};
Text.prototype.getDimensions = function(text, options2) {
  return this.layoutText(text, options2).dimensions;
};
Text.prototype.layoutText = function(text, options2) {
  var box = (0, import_min_dash5.assign)({}, this._config.size, options2.box), style = (0, import_min_dash5.assign)({}, this._config.style, options2.style), align = parseAlign(options2.align || this._config.align), padding = parsePadding(options2.padding !== void 0 ? options2.padding : this._config.padding), fitBox = options2.fitBox || false;
  var lineHeight = getLineHeight(style);
  var lines = text.split(/\u00AD?\r?\n/), layouted = [];
  var maxWidth = box.width - padding.left - padding.right;
  var helperText = create("text");
  attr(helperText, { x: 0, y: 0 });
  attr(helperText, style);
  var helperSvg = getHelperSvg();
  append(helperSvg, helperText);
  while (lines.length) {
    layouted.push(layoutNext(lines, maxWidth, helperText));
  }
  if (align.vertical === "middle") {
    padding.top = padding.bottom = 0;
  }
  var totalHeight = (0, import_min_dash5.reduce)(layouted, function(sum, line, idx) {
    return sum + (lineHeight || line.height);
  }, 0) + padding.top + padding.bottom;
  var maxLineWidth = (0, import_min_dash5.reduce)(layouted, function(sum, line, idx) {
    return line.width > sum ? line.width : sum;
  }, 0);
  var y4 = padding.top;
  if (align.vertical === "middle") {
    y4 += (box.height - totalHeight) / 2;
  }
  y4 -= (lineHeight || layouted[0].height) / 4;
  var textElement = create("text");
  attr(textElement, style);
  (0, import_min_dash5.forEach)(layouted, function(line) {
    var x4;
    y4 += lineHeight || line.height;
    switch (align.horizontal) {
      case "left":
        x4 = padding.left;
        break;
      case "right":
        x4 = (fitBox ? maxLineWidth : maxWidth) - padding.right - line.width;
        break;
      default:
        x4 = Math.max(((fitBox ? maxLineWidth : maxWidth) - line.width) / 2 + padding.left, 0);
    }
    var tspan = create("tspan");
    attr(tspan, { x: x4, y: y4 });
    tspan.textContent = line.text;
    append(textElement, tspan);
  });
  remove(helperText);
  var dimensions = {
    width: maxLineWidth,
    height: totalHeight
  };
  return {
    dimensions,
    element: textElement
  };
};
function getLineHeight(style) {
  if ("fontSize" in style && "lineHeight" in style) {
    return style.lineHeight * parseInt(style.fontSize, 10);
  }
}

// node_modules/bpmn-js/lib/draw/TextRenderer.js
var DEFAULT_FONT_SIZE = 12;
var LINE_HEIGHT_RATIO = 1.2;
var MIN_TEXT_ANNOTATION_HEIGHT = 30;
function TextRenderer(config) {
  var defaultStyle = (0, import_min_dash6.assign)({
    fontFamily: "Arial, sans-serif",
    fontSize: DEFAULT_FONT_SIZE,
    fontWeight: "normal",
    lineHeight: LINE_HEIGHT_RATIO
  }, config && config.defaultStyle || {});
  var fontSize = parseInt(defaultStyle.fontSize, 10) - 1;
  var externalStyle = (0, import_min_dash6.assign)({}, defaultStyle, {
    fontSize
  }, config && config.externalStyle || {});
  var textUtil = new Text({
    style: defaultStyle
  });
  this.getExternalLabelBounds = function(bounds, text) {
    var layoutedDimensions = textUtil.getDimensions(text, {
      box: {
        width: 90,
        height: 30,
        x: bounds.width / 2 + bounds.x,
        y: bounds.height / 2 + bounds.y
      },
      style: externalStyle
    });
    return {
      x: Math.round(bounds.x + bounds.width / 2 - layoutedDimensions.width / 2),
      y: Math.round(bounds.y),
      width: Math.ceil(layoutedDimensions.width),
      height: Math.ceil(layoutedDimensions.height)
    };
  };
  this.getTextAnnotationBounds = function(bounds, text) {
    var layoutedDimensions = textUtil.getDimensions(text, {
      box: bounds,
      style: defaultStyle,
      align: "left-top",
      padding: 5
    });
    return {
      x: bounds.x,
      y: bounds.y,
      width: bounds.width,
      height: Math.max(MIN_TEXT_ANNOTATION_HEIGHT, Math.round(layoutedDimensions.height))
    };
  };
  this.createText = function(text, options2) {
    return textUtil.createText(text, options2 || {});
  };
  this.getDefaultStyle = function() {
    return defaultStyle;
  };
  this.getExternalStyle = function() {
    return externalStyle;
  };
}
TextRenderer.$inject = [
  "config.textRenderer"
];

// node_modules/bpmn-js/lib/draw/PathMap.js
function PathMap() {
  this.pathMap = {
    "EVENT_MESSAGE": {
      d: "m {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}",
      height: 36,
      width: 36,
      heightElements: [6, 14],
      widthElements: [10.5, 21]
    },
    "EVENT_SIGNAL": {
      d: "M {mx},{my} l {e.x0},{e.y0} l -{e.x1},0 Z",
      height: 36,
      width: 36,
      heightElements: [18],
      widthElements: [10, 20]
    },
    "EVENT_ESCALATION": {
      d: "M {mx},{my} l {e.x0},{e.y0} l -{e.x0},-{e.y1} l -{e.x0},{e.y1} Z",
      height: 36,
      width: 36,
      heightElements: [20, 7],
      widthElements: [8]
    },
    "EVENT_CONDITIONAL": {
      d: "M {e.x0},{e.y0} l {e.x1},0 l 0,{e.y2} l -{e.x1},0 Z M {e.x2},{e.y3} l {e.x0},0 M {e.x2},{e.y4} l {e.x0},0 M {e.x2},{e.y5} l {e.x0},0 M {e.x2},{e.y6} l {e.x0},0 M {e.x2},{e.y7} l {e.x0},0 M {e.x2},{e.y8} l {e.x0},0 ",
      height: 36,
      width: 36,
      heightElements: [8.5, 14.5, 18, 11.5, 14.5, 17.5, 20.5, 23.5, 26.5],
      widthElements: [10.5, 14.5, 12.5]
    },
    "EVENT_LINK": {
      d: "m {mx},{my} 0,{e.y0} -{e.x1},0 0,{e.y1} {e.x1},0 0,{e.y0} {e.x0},-{e.y2} -{e.x0},-{e.y2} z",
      height: 36,
      width: 36,
      heightElements: [4.4375, 6.75, 7.8125],
      widthElements: [9.84375, 13.5]
    },
    "EVENT_ERROR": {
      d: "m {mx},{my} {e.x0},-{e.y0} {e.x1},-{e.y1} {e.x2},{e.y2} {e.x3},-{e.y3} -{e.x4},{e.y4} -{e.x5},-{e.y5} z",
      height: 36,
      width: 36,
      heightElements: [0.023, 8.737, 8.151, 16.564, 10.591, 8.714],
      widthElements: [0.085, 6.672, 6.97, 4.273, 5.337, 6.636]
    },
    "EVENT_CANCEL_45": {
      d: "m {mx},{my} -{e.x1},0 0,{e.x0} {e.x1},0 0,{e.y1} {e.x0},0 0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z",
      height: 36,
      width: 36,
      heightElements: [4.75, 8.5],
      widthElements: [4.75, 8.5]
    },
    "EVENT_COMPENSATION": {
      d: "m {mx},{my} {e.x0},-{e.y0} 0,{e.y1} z m {e.x1},-{e.y2} {e.x2},-{e.y3} 0,{e.y1} -{e.x2},-{e.y3} z",
      height: 36,
      width: 36,
      heightElements: [6.5, 13, 0.4, 6.1],
      widthElements: [9, 9.3, 8.7]
    },
    "EVENT_TIMER_WH": {
      d: "M {mx},{my} l {e.x0},-{e.y0} m -{e.x0},{e.y0} l {e.x1},{e.y1} ",
      height: 36,
      width: 36,
      heightElements: [10, 2],
      widthElements: [3, 7]
    },
    "EVENT_TIMER_LINE": {
      d: "M {mx},{my} m {e.x0},{e.y0} l -{e.x1},{e.y1} ",
      height: 36,
      width: 36,
      heightElements: [10, 3],
      widthElements: [0, 0]
    },
    "EVENT_MULTIPLE": {
      d: "m {mx},{my} {e.x1},-{e.y0} {e.x1},{e.y0} -{e.x0},{e.y1} -{e.x2},0 z",
      height: 36,
      width: 36,
      heightElements: [6.28099, 12.56199],
      widthElements: [3.1405, 9.42149, 12.56198]
    },
    "EVENT_PARALLEL_MULTIPLE": {
      d: "m {mx},{my} {e.x0},0 0,{e.y1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} -{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z",
      height: 36,
      width: 36,
      heightElements: [2.56228, 7.68683],
      widthElements: [2.56228, 7.68683]
    },
    "GATEWAY_EXCLUSIVE": {
      d: "m {mx},{my} {e.x0},{e.y0} {e.x1},{e.y0} {e.x2},0 {e.x4},{e.y2} {e.x4},{e.y1} {e.x2},0 {e.x1},{e.y3} {e.x0},{e.y3} {e.x3},0 {e.x5},{e.y1} {e.x5},{e.y2} {e.x3},0 z",
      height: 17.5,
      width: 17.5,
      heightElements: [8.5, 6.5312, -6.5312, -8.5],
      widthElements: [6.5, -6.5, 3, -3, 5, -5]
    },
    "GATEWAY_PARALLEL": {
      d: "m {mx},{my} 0,{e.y1} -{e.x1},0 0,{e.y0} {e.x1},0 0,{e.y1} {e.x0},0 0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z",
      height: 30,
      width: 30,
      heightElements: [5, 12.5],
      widthElements: [5, 12.5]
    },
    "GATEWAY_EVENT_BASED": {
      d: "m {mx},{my} {e.x0},{e.y0} {e.x0},{e.y1} {e.x1},{e.y2} {e.x2},0 z",
      height: 11,
      width: 11,
      heightElements: [-6, 6, 12, -12],
      widthElements: [9, -3, -12]
    },
    "GATEWAY_COMPLEX": {
      d: "m {mx},{my} 0,{e.y0} -{e.x0},-{e.y1} -{e.x1},{e.y2} {e.x0},{e.y1} -{e.x2},0 0,{e.y3} {e.x2},0  -{e.x0},{e.y1} l {e.x1},{e.y2} {e.x0},-{e.y1} 0,{e.y0} {e.x3},0 0,-{e.y0} {e.x0},{e.y1} {e.x1},-{e.y2} -{e.x0},-{e.y1} {e.x2},0 0,-{e.y3} -{e.x2},0 {e.x0},-{e.y1} -{e.x1},-{e.y2} -{e.x0},{e.y1} 0,-{e.y0} -{e.x3},0 z",
      height: 17.125,
      width: 17.125,
      heightElements: [4.875, 3.4375, 2.125, 3],
      widthElements: [3.4375, 2.125, 4.875, 3]
    },
    "DATA_OBJECT_PATH": {
      d: "m 0,0 {e.x1},0 {e.x0},{e.y0} 0,{e.y1} -{e.x2},0 0,-{e.y2} {e.x1},0 0,{e.y0} {e.x0},0",
      height: 61,
      width: 51,
      heightElements: [10, 50, 60],
      widthElements: [10, 40, 50, 60]
    },
    "DATA_OBJECT_COLLECTION_PATH": {
      d: "m{mx},{my} m 3,2 l 0,10 m 3,-10 l 0,10 m 3,-10 l 0,10",
      height: 10,
      width: 10,
      heightElements: [],
      widthElements: []
    },
    "DATA_ARROW": {
      d: "m 5,9 9,0 0,-3 5,5 -5,5 0,-3 -9,0 z",
      height: 61,
      width: 51,
      heightElements: [],
      widthElements: []
    },
    "DATA_STORE": {
      d: "m  {mx},{my} l  0,{e.y2} c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 l  0,-{e.y2} c -{e.x0},-{e.y1} -{e.x1},-{e.y1} -{e.x2},0c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 m  -{e.x2},{e.y0}c  {e.x0},{e.y1} {e.x1},{e.y1} {e.x2},0m  -{e.x2},{e.y0}c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0",
      height: 61,
      width: 61,
      heightElements: [7, 10, 45],
      widthElements: [2, 58, 60]
    },
    "TEXT_ANNOTATION": {
      d: "m {mx}, {my} m 10,0 l -10,0 l 0,{e.y0} l 10,0",
      height: 30,
      width: 10,
      heightElements: [30],
      widthElements: [10]
    },
    "MARKER_SUB_PROCESS": {
      d: "m{mx},{my} m 7,2 l 0,10 m -5,-5 l 10,0",
      height: 10,
      width: 10,
      heightElements: [],
      widthElements: []
    },
    "MARKER_PARALLEL": {
      d: "m{mx},{my} m 3,2 l 0,10 m 3,-10 l 0,10 m 3,-10 l 0,10",
      height: 10,
      width: 10,
      heightElements: [],
      widthElements: []
    },
    "MARKER_SEQUENTIAL": {
      d: "m{mx},{my} m 0,3 l 10,0 m -10,3 l 10,0 m -10,3 l 10,0",
      height: 10,
      width: 10,
      heightElements: [],
      widthElements: []
    },
    "MARKER_COMPENSATION": {
      d: "m {mx},{my} 7,-5 0,10 z m 7.1,-0.3 6.9,-4.7 0,10 -6.9,-4.7 z",
      height: 10,
      width: 21,
      heightElements: [],
      widthElements: []
    },
    "MARKER_LOOP": {
      d: "m {mx},{my} c 3.526979,0 6.386161,-2.829858 6.386161,-6.320661 0,-3.490806 -2.859182,-6.320661 -6.386161,-6.320661 -3.526978,0 -6.38616,2.829855 -6.38616,6.320661 0,1.745402 0.714797,3.325567 1.870463,4.469381 0.577834,0.571908 1.265885,1.034728 2.029916,1.35457 l -0.718163,-3.909793 m 0.718163,3.909793 -3.885211,0.802902",
      height: 13.9,
      width: 13.7,
      heightElements: [],
      widthElements: []
    },
    "MARKER_ADHOC": {
      d: "m {mx},{my} m 0.84461,2.64411 c 1.05533,-1.23780996 2.64337,-2.07882 4.29653,-1.97997996 2.05163,0.0805 3.85579,1.15803 5.76082,1.79107 1.06385,0.34139996 2.24454,0.1438 3.18759,-0.43767 0.61743,-0.33642 1.2775,-0.64078 1.7542,-1.17511 0,0.56023 0,1.12046 0,1.6807 -0.98706,0.96237996 -2.29792,1.62393996 -3.6918,1.66181996 -1.24459,0.0927 -2.46671,-0.2491 -3.59505,-0.74812 -1.35789,-0.55965 -2.75133,-1.33436996 -4.27027,-1.18121996 -1.37741,0.14601 -2.41842,1.13685996 -3.44288,1.96782996 z",
      height: 4,
      width: 15,
      heightElements: [],
      widthElements: []
    },
    "TASK_TYPE_SEND": {
      d: "m {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}",
      height: 14,
      width: 21,
      heightElements: [6, 14],
      widthElements: [10.5, 21]
    },
    "TASK_TYPE_SCRIPT": {
      d: "m {mx},{my} c 9.966553,-6.27276 -8.000926,-7.91932 2.968968,-14.938 l -8.802728,0 c -10.969894,7.01868 6.997585,8.66524 -2.968967,14.938 z m -7,-12 l 5,0 m -4.5,3 l 4.5,0 m -3,3 l 5,0m -4,3 l 5,0",
      height: 15,
      width: 12.6,
      heightElements: [6, 14],
      widthElements: [10.5, 21]
    },
    "TASK_TYPE_USER_1": {
      d: "m {mx},{my} c 0.909,-0.845 1.594,-2.049 1.594,-3.385 0,-2.554 -1.805,-4.62199999 -4.357,-4.62199999 -2.55199998,0 -4.28799998,2.06799999 -4.28799998,4.62199999 0,1.348 0.974,2.562 1.89599998,3.405 -0.52899998,0.187 -5.669,2.097 -5.794,4.7560005 v 6.718 h 17 v -6.718 c 0,-2.2980005 -5.5279996,-4.5950005 -6.0509996,-4.7760005 zm -8,6 l 0,5.5 m 11,0 l 0,-5"
    },
    "TASK_TYPE_USER_2": {
      d: "m {mx},{my} m 2.162,1.009 c 0,2.4470005 -2.158,4.4310005 -4.821,4.4310005 -2.66499998,0 -4.822,-1.981 -4.822,-4.4310005 "
    },
    "TASK_TYPE_USER_3": {
      d: "m {mx},{my} m -6.9,-3.80 c 0,0 2.25099998,-2.358 4.27399998,-1.177 2.024,1.181 4.221,1.537 4.124,0.965 -0.098,-0.57 -0.117,-3.79099999 -4.191,-4.13599999 -3.57499998,0.001 -4.20799998,3.36699999 -4.20699998,4.34799999 z"
    },
    "TASK_TYPE_MANUAL": {
      d: "m {mx},{my} c 0.234,-0.01 5.604,0.008 8.029,0.004 0.808,0 1.271,-0.172 1.417,-0.752 0.227,-0.898 -0.334,-1.314 -1.338,-1.316 -2.467,-0.01 -7.886,-0.004 -8.108,-0.004 -0.014,-0.079 0.016,-0.533 0,-0.61 0.195,-0.042 8.507,0.006 9.616,0.002 0.877,-0.007 1.35,-0.438 1.353,-1.208 0.003,-0.768 -0.479,-1.09 -1.35,-1.091 -2.968,-0.002 -9.619,-0.013 -9.619,-0.013 v -0.591 c 0,0 5.052,-0.016 7.225,-0.016 0.888,-0.002 1.354,-0.416 1.351,-1.193 -0.006,-0.761 -0.492,-1.196 -1.361,-1.196 -3.473,-0.005 -10.86,-0.003 -11.0829995,-0.003 -0.022,-0.047 -0.045,-0.094 -0.069,-0.139 0.3939995,-0.319 2.0409995,-1.626 2.4149995,-2.017 0.469,-0.4870005 0.519,-1.1650005 0.162,-1.6040005 -0.414,-0.511 -0.973,-0.5 -1.48,-0.236 -1.4609995,0.764 -6.5999995,3.6430005 -7.7329995,4.2710005 -0.9,0.499 -1.516,1.253 -1.882,2.19 -0.37000002,0.95 -0.17,2.01 -0.166,2.979 0.004,0.718 -0.27300002,1.345 -0.055,2.063 0.629,2.087 2.425,3.312 4.859,3.318 4.6179995,0.014 9.2379995,-0.139 13.8569995,-0.158 0.755,-0.004 1.171,-0.301 1.182,-1.033 0.012,-0.754 -0.423,-0.969 -1.183,-0.973 -1.778,-0.01 -5.824,-0.004 -6.04,-0.004 10e-4,-0.084 0.003,-0.586 10e-4,-0.67 z"
    },
    "TASK_TYPE_INSTANTIATING_SEND": {
      d: "m {mx},{my} l 0,8.4 l 12.6,0 l 0,-8.4 z l 6.3,3.6 l 6.3,-3.6"
    },
    "TASK_TYPE_SERVICE": {
      d: "m {mx},{my} v -1.71335 c 0.352326,-0.0705 0.703932,-0.17838 1.047628,-0.32133 0.344416,-0.14465 0.665822,-0.32133 0.966377,-0.52145 l 1.19431,1.18005 1.567487,-1.57688 -1.195028,-1.18014 c 0.403376,-0.61394 0.683079,-1.29908 0.825447,-2.01824 l 1.622133,-0.01 v -2.2196 l -1.636514,0.01 c -0.07333,-0.35153 -0.178319,-0.70024 -0.323564,-1.04372 -0.145244,-0.34406 -0.321407,-0.6644 -0.522735,-0.96217 l 1.131035,-1.13631 -1.583305,-1.56293 -1.129598,1.13589 c -0.614052,-0.40108 -1.302883,-0.68093 -2.022633,-0.82247 l 0.0093,-1.61852 h -2.241173 l 0.0042,1.63124 c -0.353763,0.0736 -0.705369,0.17977 -1.049785,0.32371 -0.344415,0.14437 -0.665102,0.32092 -0.9635006,0.52046 l -1.1698628,-1.15823 -1.5667691,1.5792 1.1684265,1.15669 c -0.4026573,0.61283 -0.68308,1.29797 -0.8247287,2.01713 l -1.6588041,0.003 v 2.22174 l 1.6724648,-0.006 c 0.073327,0.35077 0.1797598,0.70243 0.3242851,1.04472 0.1452428,0.34448 0.3214064,0.6644 0.5227339,0.96066 l -1.1993431,1.19723 1.5840256,1.56011 1.1964668,-1.19348 c 0.6140517,0.40346 1.3028827,0.68232 2.0233517,0.82331 l 7.19e-4,1.69892 h 2.226848 z m 0.221462,-3.9957 c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z"
    },
    "TASK_TYPE_SERVICE_FILL": {
      d: "m {mx},{my} c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z"
    },
    "TASK_TYPE_BUSINESS_RULE_HEADER": {
      d: "m {mx},{my} 0,4 20,0 0,-4 z"
    },
    "TASK_TYPE_BUSINESS_RULE_MAIN": {
      d: "m {mx},{my} 0,12 20,0 0,-12 zm 0,8 l 20,0 m -13,-4 l 0,8"
    },
    "MESSAGE_FLOW_MARKER": {
      d: "m {mx},{my} m -10.5 ,-7 l 0,14 l 21,0 l 0,-14 z l 10.5,6 l 10.5,-6"
    }
  };
  this.getRawPath = function getRawPath(pathId) {
    return this.pathMap[pathId].d;
  };
  this.getScaledPath = function getScaledPath(pathId, param) {
    var rawPath = this.pathMap[pathId];
    var mx, my;
    if (param.abspos) {
      mx = param.abspos.x;
      my = param.abspos.y;
    } else {
      mx = param.containerWidth * param.position.mx;
      my = param.containerHeight * param.position.my;
    }
    var coordinates = {};
    if (param.position) {
      var heightRatio = param.containerHeight / rawPath.height * param.yScaleFactor;
      var widthRatio = param.containerWidth / rawPath.width * param.xScaleFactor;
      for (var heightIndex = 0; heightIndex < rawPath.heightElements.length; heightIndex++) {
        coordinates["y" + heightIndex] = rawPath.heightElements[heightIndex] * heightRatio;
      }
      for (var widthIndex = 0; widthIndex < rawPath.widthElements.length; widthIndex++) {
        coordinates["x" + widthIndex] = rawPath.widthElements[widthIndex] * widthRatio;
      }
    }
    var path = format(rawPath.d, {
      mx,
      my,
      e: coordinates
    });
    return path;
  };
}
var tokenRegex = /\{([^{}]+)\}/g;
var objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g;
function replacer(all2, key, obj) {
  var res = obj;
  key.replace(objNotationRegex, function(all3, name3, quote, quotedName, isFunc) {
    name3 = name3 || quotedName;
    if (res) {
      if (name3 in res) {
        res = res[name3];
      }
      typeof res == "function" && isFunc && (res = res());
    }
  });
  res = (res == null || res == obj ? all2 : res) + "";
  return res;
}
function format(str, obj) {
  return String(str).replace(tokenRegex, function(all2, key) {
    return replacer(all2, key, obj);
  });
}

// node_modules/bpmn-js/lib/draw/index.js
var draw_default = {
  __init__: ["bpmnRenderer"],
  bpmnRenderer: ["type", BpmnRenderer],
  textRenderer: ["type", TextRenderer],
  pathMap: ["type", PathMap]
};

// node_modules/diagram-js/lib/i18n/translate/translate.js
function translate2(template, replacements) {
  replacements = replacements || {};
  return template.replace(/{([^}]+)}/g, function(_5, key) {
    return replacements[key] || "{" + key + "}";
  });
}

// node_modules/diagram-js/lib/i18n/translate/index.js
var translate_default = {
  translate: ["value", translate2]
};

// node_modules/bpmn-js/lib/import/BpmnImporter.js
var import_min_dash10 = __toESM(require_dist());

// node_modules/bpmn-js/lib/util/LabelUtil.js
var import_min_dash7 = __toESM(require_dist());
var DEFAULT_LABEL_SIZE2 = {
  width: 90,
  height: 20
};
var FLOW_LABEL_INDENT = 15;
function isLabelExternal(semantic) {
  return is(semantic, "bpmn:Event") || is(semantic, "bpmn:Gateway") || is(semantic, "bpmn:DataStoreReference") || is(semantic, "bpmn:DataObjectReference") || is(semantic, "bpmn:DataInput") || is(semantic, "bpmn:DataOutput") || is(semantic, "bpmn:SequenceFlow") || is(semantic, "bpmn:MessageFlow") || is(semantic, "bpmn:Group");
}
function hasExternalLabel(element) {
  return isLabel(element.label);
}
function getFlowLabelPosition(waypoints) {
  var mid4 = waypoints.length / 2 - 1;
  var first = waypoints[Math.floor(mid4)];
  var second = waypoints[Math.ceil(mid4 + 0.01)];
  var position = getWaypointsMid(waypoints);
  var angle = Math.atan((second.y - first.y) / (second.x - first.x));
  var x4 = position.x, y4 = position.y;
  if (Math.abs(angle) < Math.PI / 2) {
    y4 -= FLOW_LABEL_INDENT;
  } else {
    x4 += FLOW_LABEL_INDENT;
  }
  return { x: x4, y: y4 };
}
function getWaypointsMid(waypoints) {
  var mid4 = waypoints.length / 2 - 1;
  var first = waypoints[Math.floor(mid4)];
  var second = waypoints[Math.ceil(mid4 + 0.01)];
  return {
    x: first.x + (second.x - first.x) / 2,
    y: first.y + (second.y - first.y) / 2
  };
}
function getExternalLabelMid(element) {
  if (element.waypoints) {
    return getFlowLabelPosition(element.waypoints);
  } else if (is(element, "bpmn:Group")) {
    return {
      x: element.x + element.width / 2,
      y: element.y + DEFAULT_LABEL_SIZE2.height / 2
    };
  } else {
    return {
      x: element.x + element.width / 2,
      y: element.y + element.height + DEFAULT_LABEL_SIZE2.height / 2
    };
  }
}
function getExternalLabelBounds(di, element) {
  var mid4, size2, bounds, label = di.label;
  if (label && label.bounds) {
    bounds = label.bounds;
    size2 = {
      width: Math.max(DEFAULT_LABEL_SIZE2.width, bounds.width),
      height: bounds.height
    };
    mid4 = {
      x: bounds.x + bounds.width / 2,
      y: bounds.y + bounds.height / 2
    };
  } else {
    mid4 = getExternalLabelMid(element);
    size2 = DEFAULT_LABEL_SIZE2;
  }
  return (0, import_min_dash7.assign)({
    x: mid4.x - size2.width / 2,
    y: mid4.y - size2.height / 2
  }, size2);
}
function isLabel(element) {
  return element && !!element.labelTarget;
}

// node_modules/diagram-js/lib/layout/LayoutUtil.js
var import_min_dash9 = __toESM(require_dist());

// node_modules/diagram-js/lib/util/Geometry.js
var import_min_dash8 = __toESM(require_dist());
function pointDistance(a6, b5) {
  if (!a6 || !b5) {
    return -1;
  }
  return Math.sqrt(Math.pow(a6.x - b5.x, 2) + Math.pow(a6.y - b5.y, 2));
}
function pointsOnLine(p6, q3, r6, accuracy) {
  if (typeof accuracy === "undefined") {
    accuracy = 5;
  }
  if (!p6 || !q3 || !r6) {
    return false;
  }
  var val = (q3.x - p6.x) * (r6.y - p6.y) - (q3.y - p6.y) * (r6.x - p6.x), dist = pointDistance(p6, q3);
  return Math.abs(val / dist) <= accuracy;
}
var ALIGNED_THRESHOLD = 2;
function pointsAligned(a6, b5) {
  var points;
  if ((0, import_min_dash8.isArray)(a6)) {
    points = a6;
  } else {
    points = [a6, b5];
  }
  if (pointsAlignedHorizontally(points)) {
    return "h";
  }
  if (pointsAlignedVertically(points)) {
    return "v";
  }
  return false;
}
function pointsAlignedHorizontally(a6, b5) {
  var points;
  if ((0, import_min_dash8.isArray)(a6)) {
    points = a6;
  } else {
    points = [a6, b5];
  }
  var firstPoint = points.slice().shift();
  return (0, import_min_dash8.every)(points, function(point) {
    return Math.abs(firstPoint.y - point.y) <= ALIGNED_THRESHOLD;
  });
}
function pointsAlignedVertically(a6, b5) {
  var points;
  if ((0, import_min_dash8.isArray)(a6)) {
    points = a6;
  } else {
    points = [a6, b5];
  }
  var firstPoint = points.slice().shift();
  return (0, import_min_dash8.every)(points, function(point) {
    return Math.abs(firstPoint.x - point.x) <= ALIGNED_THRESHOLD;
  });
}
function pointInRect(p6, rect, tolerance) {
  tolerance = tolerance || 0;
  return p6.x > rect.x - tolerance && p6.y > rect.y - tolerance && p6.x < rect.x + rect.width + tolerance && p6.y < rect.y + rect.height + tolerance;
}
function getMidPoint(p6, q3) {
  return {
    x: Math.round(p6.x + (q3.x - p6.x) / 2),
    y: Math.round(p6.y + (q3.y - p6.y) / 2)
  };
}

// node_modules/diagram-js/lib/layout/LayoutUtil.js
var import_path_intersection = __toESM(require_intersect());
function roundBounds(bounds) {
  return {
    x: Math.round(bounds.x),
    y: Math.round(bounds.y),
    width: Math.round(bounds.width),
    height: Math.round(bounds.height)
  };
}
function roundPoint(point) {
  return {
    x: Math.round(point.x),
    y: Math.round(point.y)
  };
}
function asTRBL(bounds) {
  return {
    top: bounds.y,
    right: bounds.x + (bounds.width || 0),
    bottom: bounds.y + (bounds.height || 0),
    left: bounds.x
  };
}
function asBounds(trbl) {
  return {
    x: trbl.left,
    y: trbl.top,
    width: trbl.right - trbl.left,
    height: trbl.bottom - trbl.top
  };
}
function getBoundsMid(bounds) {
  return roundPoint({
    x: bounds.x + (bounds.width || 0) / 2,
    y: bounds.y + (bounds.height || 0) / 2
  });
}
function getConnectionMid(connection) {
  var waypoints = connection.waypoints;
  var parts = waypoints.reduce(function(parts2, point, index2) {
    var lastPoint = waypoints[index2 - 1];
    if (lastPoint) {
      var lastPart = parts2[parts2.length - 1];
      var startLength = lastPart && lastPart.endLength || 0;
      var length2 = distance(lastPoint, point);
      parts2.push({
        start: lastPoint,
        end: point,
        startLength,
        endLength: startLength + length2,
        length: length2
      });
    }
    return parts2;
  }, []);
  var totalLength = parts.reduce(function(length2, part) {
    return length2 + part.length;
  }, 0);
  var midLength = totalLength / 2;
  var i6 = 0;
  var midSegment = parts[i6];
  while (midSegment.endLength < midLength) {
    midSegment = parts[++i6];
  }
  var segmentProgress = (midLength - midSegment.startLength) / midSegment.length;
  var midPoint = {
    x: midSegment.start.x + (midSegment.end.x - midSegment.start.x) * segmentProgress,
    y: midSegment.start.y + (midSegment.end.y - midSegment.start.y) * segmentProgress
  };
  return midPoint;
}
function getMid(element) {
  if (isConnection(element)) {
    return getConnectionMid(element);
  }
  return getBoundsMid(element);
}
function getOrientation(rect, reference, padding) {
  padding = padding || 0;
  if (!(0, import_min_dash9.isObject)(padding)) {
    padding = { x: padding, y: padding };
  }
  var rectOrientation = asTRBL(rect), referenceOrientation = asTRBL(reference);
  var top = rectOrientation.bottom + padding.y <= referenceOrientation.top, right = rectOrientation.left - padding.x >= referenceOrientation.right, bottom = rectOrientation.top - padding.y >= referenceOrientation.bottom, left = rectOrientation.right + padding.x <= referenceOrientation.left;
  var vertical = top ? "top" : bottom ? "bottom" : null, horizontal = left ? "left" : right ? "right" : null;
  if (horizontal && vertical) {
    return vertical + "-" + horizontal;
  } else {
    return horizontal || vertical || "intersect";
  }
}
function getElementLineIntersection(elementPath, linePath2, cropStart) {
  var intersections = getIntersections(elementPath, linePath2);
  if (intersections.length === 1) {
    return roundPoint(intersections[0]);
  } else if (intersections.length === 2 && pointDistance(intersections[0], intersections[1]) < 1) {
    return roundPoint(intersections[0]);
  } else if (intersections.length > 1) {
    intersections = (0, import_min_dash9.sortBy)(intersections, function(i6) {
      var distance2 = Math.floor(i6.t2 * 100) || 1;
      distance2 = 100 - distance2;
      distance2 = (distance2 < 10 ? "0" : "") + distance2;
      return i6.segment2 + "#" + distance2;
    });
    return roundPoint(intersections[cropStart ? 0 : intersections.length - 1]);
  }
  return null;
}
function getIntersections(a6, b5) {
  return (0, import_path_intersection.default)(a6, b5);
}
function filterRedundantWaypoints(waypoints) {
  waypoints = waypoints.slice();
  var idx = 0, point, previousPoint, nextPoint;
  while (waypoints[idx]) {
    point = waypoints[idx];
    previousPoint = waypoints[idx - 1];
    nextPoint = waypoints[idx + 1];
    if (pointDistance(point, nextPoint) === 0 || pointsOnLine(previousPoint, nextPoint, point)) {
      waypoints.splice(idx, 1);
    } else {
      idx++;
    }
  }
  return waypoints;
}
function distance(a6, b5) {
  return Math.sqrt(Math.pow(a6.x - b5.x, 2) + Math.pow(a6.y - b5.y, 2));
}
function isConnection(element) {
  return !!element.waypoints;
}

// node_modules/bpmn-js/lib/import/Util.js
function elementToString(e7) {
  if (!e7) {
    return "<null>";
  }
  return "<" + e7.$type + (e7.id ? ' id="' + e7.id : "") + '" />';
}

// node_modules/bpmn-js/lib/import/BpmnImporter.js
function elementData(semantic, di, attrs) {
  return (0, import_min_dash10.assign)({
    id: semantic.id,
    type: semantic.$type,
    businessObject: semantic,
    di
  }, attrs);
}
function getWaypoints(di, source, target) {
  var waypoints = di.waypoint;
  if (!waypoints || waypoints.length < 2) {
    return [getMid(source), getMid(target)];
  }
  return waypoints.map(function(p6) {
    return { x: p6.x, y: p6.y };
  });
}
function notYetDrawn(translate3, semantic, refSemantic, property) {
  return new Error(translate3("element {element} referenced by {referenced}#{property} not yet drawn", {
    element: elementToString(refSemantic),
    referenced: elementToString(semantic),
    property
  }));
}
function BpmnImporter(eventBus, canvas, elementFactory, elementRegistry, translate3, textRenderer) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  this._elementFactory = elementFactory;
  this._elementRegistry = elementRegistry;
  this._translate = translate3;
  this._textRenderer = textRenderer;
}
BpmnImporter.$inject = [
  "eventBus",
  "canvas",
  "elementFactory",
  "elementRegistry",
  "translate",
  "textRenderer"
];
BpmnImporter.prototype.add = function(semantic, di, parentElement) {
  var element, translate3 = this._translate, hidden;
  var parentIndex;
  if (is(di, "bpmndi:BPMNPlane")) {
    var attrs = is(semantic, "bpmn:SubProcess") ? { id: semantic.id + "_plane" } : {};
    element = this._elementFactory.createRoot(elementData(semantic, di, attrs));
    this._canvas.addRootElement(element);
  } else if (is(di, "bpmndi:BPMNShape")) {
    var collapsed = !isExpanded(semantic, di), isFrame = isFrameElement(semantic);
    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);
    var bounds = di.bounds;
    element = this._elementFactory.createShape(elementData(semantic, di, {
      collapsed,
      hidden,
      x: Math.round(bounds.x),
      y: Math.round(bounds.y),
      width: Math.round(bounds.width),
      height: Math.round(bounds.height),
      isFrame
    }));
    if (is(semantic, "bpmn:BoundaryEvent")) {
      this._attachBoundary(semantic, element);
    }
    if (is(semantic, "bpmn:Lane")) {
      parentIndex = 0;
    }
    if (is(semantic, "bpmn:DataStoreReference")) {
      if (!isPointInsideBBox(parentElement, getMid(bounds))) {
        parentElement = this._canvas.findRoot(parentElement);
      }
    }
    this._canvas.addShape(element, parentElement, parentIndex);
  } else if (is(di, "bpmndi:BPMNEdge")) {
    var source = this._getSource(semantic), target = this._getTarget(semantic);
    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);
    element = this._elementFactory.createConnection(elementData(semantic, di, {
      hidden,
      source,
      target,
      waypoints: getWaypoints(di, source, target)
    }));
    if (is(semantic, "bpmn:DataAssociation")) {
      parentElement = this._canvas.findRoot(parentElement);
    }
    this._canvas.addConnection(element, parentElement, parentIndex);
  } else {
    throw new Error(translate3("unknown di {di} for element {semantic}", {
      di: elementToString(di),
      semantic: elementToString(semantic)
    }));
  }
  if (isLabelExternal(semantic) && getLabel(element)) {
    this.addLabel(semantic, di, element);
  }
  this._eventBus.fire("bpmnElement.added", { element });
  return element;
};
BpmnImporter.prototype._attachBoundary = function(boundarySemantic, boundaryElement) {
  var translate3 = this._translate;
  var hostSemantic = boundarySemantic.attachedToRef;
  if (!hostSemantic) {
    throw new Error(translate3("missing {semantic}#attachedToRef", {
      semantic: elementToString(boundarySemantic)
    }));
  }
  var host = this._elementRegistry.get(hostSemantic.id), attachers = host && host.attachers;
  if (!host) {
    throw notYetDrawn(translate3, boundarySemantic, hostSemantic, "attachedToRef");
  }
  boundaryElement.host = host;
  if (!attachers) {
    host.attachers = attachers = [];
  }
  if (attachers.indexOf(boundaryElement) === -1) {
    attachers.push(boundaryElement);
  }
};
BpmnImporter.prototype.addLabel = function(semantic, di, element) {
  var bounds, text, label;
  bounds = getExternalLabelBounds(di, element);
  text = getLabel(element);
  if (text) {
    bounds = this._textRenderer.getExternalLabelBounds(bounds, text);
  }
  label = this._elementFactory.createLabel(elementData(semantic, di, {
    id: semantic.id + "_label",
    labelTarget: element,
    type: "label",
    hidden: element.hidden || !getLabel(element),
    x: Math.round(bounds.x),
    y: Math.round(bounds.y),
    width: Math.round(bounds.width),
    height: Math.round(bounds.height)
  }));
  return this._canvas.addShape(label, element.parent);
};
BpmnImporter.prototype._getEnd = function(semantic, side) {
  var element, refSemantic, type = semantic.$type, translate3 = this._translate;
  refSemantic = semantic[side + "Ref"];
  if (side === "source" && type === "bpmn:DataInputAssociation") {
    refSemantic = refSemantic && refSemantic[0];
  }
  if (side === "source" && type === "bpmn:DataOutputAssociation" || side === "target" && type === "bpmn:DataInputAssociation") {
    refSemantic = semantic.$parent;
  }
  element = refSemantic && this._getElement(refSemantic);
  if (element) {
    return element;
  }
  if (refSemantic) {
    throw notYetDrawn(translate3, semantic, refSemantic, side + "Ref");
  } else {
    throw new Error(translate3("{semantic}#{side} Ref not specified", {
      semantic: elementToString(semantic),
      side
    }));
  }
};
BpmnImporter.prototype._getSource = function(semantic) {
  return this._getEnd(semantic, "source");
};
BpmnImporter.prototype._getTarget = function(semantic) {
  return this._getEnd(semantic, "target");
};
BpmnImporter.prototype._getElement = function(semantic) {
  return this._elementRegistry.get(semantic.id);
};
function isPointInsideBBox(bbox, point) {
  var x4 = point.x, y4 = point.y;
  return x4 >= bbox.x && x4 <= bbox.x + bbox.width && y4 >= bbox.y && y4 <= bbox.y + bbox.height;
}
function isFrameElement(semantic) {
  return is(semantic, "bpmn:Group");
}

// node_modules/bpmn-js/lib/import/index.js
var import_default = {
  __depends__: [
    translate_default
  ],
  bpmnImporter: ["type", BpmnImporter]
};

// node_modules/bpmn-js/lib/core/index.js
var core_default = {
  __depends__: [
    draw_default,
    import_default
  ]
};

// node_modules/diagram-js/lib/features/interaction-events/InteractionEvents.js
var import_min_dash11 = __toESM(require_dist());

// node_modules/diagram-js/lib/util/Event.js
function __stopPropagation(event2) {
  if (!event2 || typeof event2.stopPropagation !== "function") {
    return;
  }
  event2.stopPropagation();
}
function getOriginal(event2) {
  return event2.originalEvent || event2.srcEvent;
}
function stopPropagation(event2, immediate) {
  __stopPropagation(event2, immediate);
  __stopPropagation(getOriginal(event2), immediate);
}
function toPoint(event2) {
  if (event2.pointers && event2.pointers.length) {
    event2 = event2.pointers[0];
  }
  if (event2.touches && event2.touches.length) {
    event2 = event2.touches[0];
  }
  return event2 ? {
    x: event2.clientX,
    y: event2.clientY
  } : null;
}

// node_modules/diagram-js/lib/util/Platform.js
function isMac() {
  return /mac/i.test(navigator.platform);
}

// node_modules/diagram-js/lib/util/Mouse.js
function isButton(event2, button) {
  return (getOriginal(event2) || event2).button === button;
}
function isPrimaryButton(event2) {
  return isButton(event2, 0);
}
function isAuxiliaryButton(event2) {
  return isButton(event2, 1);
}
function hasPrimaryModifier(event2) {
  var originalEvent = getOriginal(event2) || event2;
  if (!isPrimaryButton(event2)) {
    return false;
  }
  if (isMac()) {
    return originalEvent.metaKey;
  } else {
    return originalEvent.ctrlKey;
  }
}
function hasSecondaryModifier(event2) {
  var originalEvent = getOriginal(event2) || event2;
  return isPrimaryButton(event2) && originalEvent.shiftKey;
}

// node_modules/diagram-js/lib/features/interaction-events/InteractionEvents.js
function allowAll(event2) {
  return true;
}
function allowPrimaryAndAuxiliary(event2) {
  return isPrimaryButton(event2) || isAuxiliaryButton(event2);
}
var LOW_PRIORITY = 500;
function InteractionEvents(eventBus, elementRegistry, styles) {
  var self2 = this;
  function fire(type, event2, element) {
    if (isIgnored(type, event2)) {
      return;
    }
    var target, gfx, returnValue;
    if (!element) {
      target = event2.delegateTarget || event2.target;
      if (target) {
        gfx = target;
        element = elementRegistry.get(gfx);
      }
    } else {
      gfx = elementRegistry.getGraphics(element);
    }
    if (!gfx || !element) {
      return;
    }
    returnValue = eventBus.fire(type, {
      element,
      gfx,
      originalEvent: event2
    });
    if (returnValue === false) {
      event2.stopPropagation();
      event2.preventDefault();
    }
  }
  var handlers = {};
  function mouseHandler(localEventName) {
    return handlers[localEventName];
  }
  function isIgnored(localEventName, event2) {
    var filter28 = ignoredFilters[localEventName] || isPrimaryButton;
    return !filter28(event2);
  }
  var bindings = {
    click: "element.click",
    contextmenu: "element.contextmenu",
    dblclick: "element.dblclick",
    mousedown: "element.mousedown",
    mousemove: "element.mousemove",
    mouseover: "element.hover",
    mouseout: "element.out",
    mouseup: "element.mouseup"
  };
  var ignoredFilters = {
    "element.contextmenu": allowAll,
    "element.mousedown": allowPrimaryAndAuxiliary,
    "element.mouseup": allowPrimaryAndAuxiliary,
    "element.click": allowPrimaryAndAuxiliary,
    "element.dblclick": allowPrimaryAndAuxiliary
  };
  function triggerMouseEvent(eventName, event2, targetElement) {
    var localEventName = bindings[eventName];
    if (!localEventName) {
      throw new Error("unmapped DOM event name <" + eventName + ">");
    }
    return fire(localEventName, event2, targetElement);
  }
  var ELEMENT_SELECTOR2 = "svg, .djs-element";
  function registerEvent(node2, event2, localEvent, ignoredFilter) {
    var handler = handlers[localEvent] = function(event3) {
      fire(localEvent, event3);
    };
    if (ignoredFilter) {
      ignoredFilters[localEvent] = ignoredFilter;
    }
    handler.$delegate = delegate.bind(node2, ELEMENT_SELECTOR2, event2, handler);
  }
  function unregisterEvent(node2, event2, localEvent) {
    var handler = mouseHandler(localEvent);
    if (!handler) {
      return;
    }
    delegate.unbind(node2, event2, handler.$delegate);
  }
  function registerEvents(svg) {
    (0, import_min_dash11.forEach)(bindings, function(val, key) {
      registerEvent(svg, key, val);
    });
  }
  function unregisterEvents(svg) {
    (0, import_min_dash11.forEach)(bindings, function(val, key) {
      unregisterEvent(svg, key, val);
    });
  }
  eventBus.on("canvas.destroy", function(event2) {
    unregisterEvents(event2.svg);
  });
  eventBus.on("canvas.init", function(event2) {
    registerEvents(event2.svg);
  });
  eventBus.on(["shape.added", "connection.added"], function(event2) {
    var element = event2.element, gfx = event2.gfx;
    eventBus.fire("interactionEvents.createHit", { element, gfx });
  });
  eventBus.on([
    "shape.changed",
    "connection.changed"
  ], LOW_PRIORITY, function(event2) {
    var element = event2.element, gfx = event2.gfx;
    eventBus.fire("interactionEvents.updateHit", { element, gfx });
  });
  eventBus.on("interactionEvents.createHit", LOW_PRIORITY, function(event2) {
    var element = event2.element, gfx = event2.gfx;
    self2.createDefaultHit(element, gfx);
  });
  eventBus.on("interactionEvents.updateHit", function(event2) {
    var element = event2.element, gfx = event2.gfx;
    self2.updateDefaultHit(element, gfx);
  });
  var STROKE_HIT_STYLE = createHitStyle("djs-hit djs-hit-stroke");
  var CLICK_STROKE_HIT_STYLE = createHitStyle("djs-hit djs-hit-click-stroke");
  var ALL_HIT_STYLE = createHitStyle("djs-hit djs-hit-all");
  var NO_MOVE_HIT_STYLE = createHitStyle("djs-hit djs-hit-no-move");
  var HIT_TYPES = {
    "all": ALL_HIT_STYLE,
    "click-stroke": CLICK_STROKE_HIT_STYLE,
    "stroke": STROKE_HIT_STYLE,
    "no-move": NO_MOVE_HIT_STYLE
  };
  function createHitStyle(classNames, attrs) {
    attrs = (0, import_min_dash11.assign)({
      stroke: "white",
      strokeWidth: 15
    }, attrs || {});
    return styles.cls(classNames, ["no-fill", "no-border"], attrs);
  }
  function applyStyle(hit, type) {
    var attrs = HIT_TYPES[type];
    if (!attrs) {
      throw new Error("invalid hit type <" + type + ">");
    }
    attr(hit, attrs);
    return hit;
  }
  function appendHit(gfx, hit) {
    append(gfx, hit);
  }
  this.removeHits = function(gfx) {
    var hits = all(".djs-hit", gfx);
    (0, import_min_dash11.forEach)(hits, remove);
  };
  this.createDefaultHit = function(element, gfx) {
    var waypoints = element.waypoints, isFrame = element.isFrame, boxType;
    if (waypoints) {
      return this.createWaypointsHit(gfx, waypoints);
    } else {
      boxType = isFrame ? "stroke" : "all";
      return this.createBoxHit(gfx, boxType, {
        width: element.width,
        height: element.height
      });
    }
  };
  this.createWaypointsHit = function(gfx, waypoints) {
    var hit = createLine(waypoints);
    applyStyle(hit, "stroke");
    appendHit(gfx, hit);
    return hit;
  };
  this.createBoxHit = function(gfx, type, attrs) {
    attrs = (0, import_min_dash11.assign)({
      x: 0,
      y: 0
    }, attrs);
    var hit = create("rect");
    applyStyle(hit, type);
    attr(hit, attrs);
    appendHit(gfx, hit);
    return hit;
  };
  this.updateDefaultHit = function(element, gfx) {
    var hit = query(".djs-hit", gfx);
    if (!hit) {
      return;
    }
    if (element.waypoints) {
      updateLine(hit, element.waypoints);
    } else {
      attr(hit, {
        width: element.width,
        height: element.height
      });
    }
    return hit;
  };
  this.fire = fire;
  this.triggerMouseEvent = triggerMouseEvent;
  this.mouseHandler = mouseHandler;
  this.registerEvent = registerEvent;
  this.unregisterEvent = unregisterEvent;
}
InteractionEvents.$inject = [
  "eventBus",
  "elementRegistry",
  "styles"
];

// node_modules/diagram-js/lib/features/interaction-events/index.js
var interaction_events_default = {
  __init__: ["interactionEvents"],
  interactionEvents: ["type", InteractionEvents]
};

// node_modules/diagram-js/lib/util/Elements.js
var import_min_dash12 = __toESM(require_dist());
function getParents(elements) {
  return (0, import_min_dash12.filter)(elements, function(element) {
    return !(0, import_min_dash12.find)(elements, function(e7) {
      return e7 !== element && getParent(element, e7);
    });
  });
}
function getParent(element, parent) {
  if (!parent) {
    return;
  }
  if (element === parent) {
    return parent;
  }
  if (!element.parent) {
    return;
  }
  return getParent(element.parent, parent);
}
function add(elements, e7, unique) {
  var canAdd = !unique || elements.indexOf(e7) === -1;
  if (canAdd) {
    elements.push(e7);
  }
  return canAdd;
}
function eachElement(elements, fn2, depth) {
  depth = depth || 0;
  if (!(0, import_min_dash12.isArray)(elements)) {
    elements = [elements];
  }
  (0, import_min_dash12.forEach)(elements, function(s5, i6) {
    var filter28 = fn2(s5, i6, depth);
    if ((0, import_min_dash12.isArray)(filter28) && filter28.length) {
      eachElement(filter28, fn2, depth + 1);
    }
  });
}
function selfAndChildren(elements, unique, maxDepth) {
  var result = [], processedChildren = [];
  eachElement(elements, function(element, i6, depth) {
    add(result, element, unique);
    var children = element.children;
    if (maxDepth === -1 || depth < maxDepth) {
      if (children && add(processedChildren, children, unique)) {
        return children;
      }
    }
  });
  return result;
}
function selfAndAllChildren(elements, allowDuplicates) {
  return selfAndChildren(elements, !allowDuplicates, -1);
}
function getClosure(elements, isTopLevel, closure) {
  if ((0, import_min_dash12.isUndefined)(isTopLevel)) {
    isTopLevel = true;
  }
  if ((0, import_min_dash12.isObject)(isTopLevel)) {
    closure = isTopLevel;
    isTopLevel = true;
  }
  closure = closure || {};
  var allShapes = copyObject(closure.allShapes), allConnections = copyObject(closure.allConnections), enclosedElements = copyObject(closure.enclosedElements), enclosedConnections = copyObject(closure.enclosedConnections);
  var topLevel = copyObject(closure.topLevel, isTopLevel && (0, import_min_dash12.groupBy)(elements, function(e7) {
    return e7.id;
  }));
  function handleConnection(c5) {
    if (topLevel[c5.source.id] && topLevel[c5.target.id]) {
      topLevel[c5.id] = [c5];
    }
    if (allShapes[c5.source.id] && allShapes[c5.target.id]) {
      enclosedConnections[c5.id] = enclosedElements[c5.id] = c5;
    }
    allConnections[c5.id] = c5;
  }
  function handleElement(element) {
    enclosedElements[element.id] = element;
    if (element.waypoints) {
      enclosedConnections[element.id] = allConnections[element.id] = element;
    } else {
      allShapes[element.id] = element;
      (0, import_min_dash12.forEach)(element.incoming, handleConnection);
      (0, import_min_dash12.forEach)(element.outgoing, handleConnection);
      return element.children;
    }
  }
  eachElement(elements, handleElement);
  return {
    allShapes,
    allConnections,
    topLevel,
    enclosedConnections,
    enclosedElements
  };
}
function getBBox(elements, stopRecursion) {
  stopRecursion = !!stopRecursion;
  if (!(0, import_min_dash12.isArray)(elements)) {
    elements = [elements];
  }
  var minX, minY, maxX, maxY;
  (0, import_min_dash12.forEach)(elements, function(element) {
    var bbox = element;
    if (element.waypoints && !stopRecursion) {
      bbox = getBBox(element.waypoints, true);
    }
    var x4 = bbox.x, y4 = bbox.y, height = bbox.height || 0, width = bbox.width || 0;
    if (x4 < minX || minX === void 0) {
      minX = x4;
    }
    if (y4 < minY || minY === void 0) {
      minY = y4;
    }
    if (x4 + width > maxX || maxX === void 0) {
      maxX = x4 + width;
    }
    if (y4 + height > maxY || maxY === void 0) {
      maxY = y4 + height;
    }
  });
  return {
    x: minX,
    y: minY,
    height: maxY - minY,
    width: maxX - minX
  };
}
function getEnclosedElements(elements, bbox) {
  var filteredElements = {};
  (0, import_min_dash12.forEach)(elements, function(element) {
    var e7 = element;
    if (e7.waypoints) {
      e7 = getBBox(e7);
    }
    if (!(0, import_min_dash12.isNumber)(bbox.y) && e7.x > bbox.x) {
      filteredElements[element.id] = element;
    }
    if (!(0, import_min_dash12.isNumber)(bbox.x) && e7.y > bbox.y) {
      filteredElements[element.id] = element;
    }
    if (e7.x > bbox.x && e7.y > bbox.y) {
      if ((0, import_min_dash12.isNumber)(bbox.width) && (0, import_min_dash12.isNumber)(bbox.height) && e7.width + e7.x < bbox.width + bbox.x && e7.height + e7.y < bbox.height + bbox.y) {
        filteredElements[element.id] = element;
      } else if (!(0, import_min_dash12.isNumber)(bbox.width) || !(0, import_min_dash12.isNumber)(bbox.height)) {
        filteredElements[element.id] = element;
      }
    }
  });
  return filteredElements;
}
function getType(element) {
  if ("waypoints" in element) {
    return "connection";
  }
  if ("x" in element) {
    return "shape";
  }
  return "root";
}
function isFrameElement2(element) {
  return !!(element && element.isFrame);
}
function copyObject(src1, src2) {
  return (0, import_min_dash12.assign)({}, src1 || {}, src2 || {});
}

// node_modules/diagram-js/lib/features/outline/Outline.js
var import_min_dash13 = __toESM(require_dist());
var LOW_PRIORITY2 = 500;
function Outline(eventBus, styles, elementRegistry) {
  this.offset = 6;
  var OUTLINE_STYLE = styles.cls("djs-outline", ["no-fill"]);
  var self2 = this;
  function createOutline(gfx, bounds) {
    var outline = create("rect");
    attr(outline, (0, import_min_dash13.assign)({
      x: 10,
      y: 10,
      rx: 3,
      width: 100,
      height: 100
    }, OUTLINE_STYLE));
    append(gfx, outline);
    return outline;
  }
  eventBus.on(["shape.added", "shape.changed"], LOW_PRIORITY2, function(event2) {
    var element = event2.element, gfx = event2.gfx;
    var outline = query(".djs-outline", gfx);
    if (!outline) {
      outline = createOutline(gfx, element);
    }
    self2.updateShapeOutline(outline, element);
  });
  eventBus.on(["connection.added", "connection.changed"], function(event2) {
    var element = event2.element, gfx = event2.gfx;
    var outline = query(".djs-outline", gfx);
    if (!outline) {
      outline = createOutline(gfx, element);
    }
    self2.updateConnectionOutline(outline, element);
  });
}
Outline.prototype.updateShapeOutline = function(outline, element) {
  attr(outline, {
    x: -this.offset,
    y: -this.offset,
    width: element.width + this.offset * 2,
    height: element.height + this.offset * 2
  });
};
Outline.prototype.updateConnectionOutline = function(outline, connection) {
  var bbox = getBBox(connection);
  attr(outline, {
    x: bbox.x - this.offset,
    y: bbox.y - this.offset,
    width: bbox.width + this.offset * 2,
    height: bbox.height + this.offset * 2
  });
};
Outline.$inject = ["eventBus", "styles", "elementRegistry"];

// node_modules/diagram-js/lib/features/outline/index.js
var outline_default = {
  __init__: ["outline"],
  outline: ["type", Outline]
};

// node_modules/diagram-js/lib/features/selection/Selection.js
var import_min_dash14 = __toESM(require_dist());
function Selection(eventBus, canvas) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  this._selectedElements = [];
  var self2 = this;
  eventBus.on(["shape.remove", "connection.remove"], function(e7) {
    var element = e7.element;
    self2.deselect(element);
  });
  eventBus.on(["diagram.clear", "root.set"], function(e7) {
    self2.select(null);
  });
}
Selection.$inject = ["eventBus", "canvas"];
Selection.prototype.deselect = function(element) {
  var selectedElements = this._selectedElements;
  var idx = selectedElements.indexOf(element);
  if (idx !== -1) {
    var oldSelection = selectedElements.slice();
    selectedElements.splice(idx, 1);
    this._eventBus.fire("selection.changed", { oldSelection, newSelection: selectedElements });
  }
};
Selection.prototype.get = function() {
  return this._selectedElements;
};
Selection.prototype.isSelected = function(element) {
  return this._selectedElements.indexOf(element) !== -1;
};
Selection.prototype.select = function(elements, add3) {
  var selectedElements = this._selectedElements, oldSelection = selectedElements.slice();
  if (!(0, import_min_dash14.isArray)(elements)) {
    elements = elements ? [elements] : [];
  }
  var canvas = this._canvas;
  var rootElement = canvas.getRootElement();
  elements = elements.filter(function(element) {
    var elementRoot = canvas.findRoot(element);
    return rootElement === elementRoot;
  });
  if (add3) {
    (0, import_min_dash14.forEach)(elements, function(element) {
      if (selectedElements.indexOf(element) !== -1) {
        return;
      } else {
        selectedElements.push(element);
      }
    });
  } else {
    this._selectedElements = selectedElements = elements.slice();
  }
  this._eventBus.fire("selection.changed", { oldSelection, newSelection: selectedElements });
};

// node_modules/diagram-js/lib/features/selection/SelectionVisuals.js
var import_min_dash15 = __toESM(require_dist());
var MARKER_HOVER = "hover";
var MARKER_SELECTED = "selected";
var SELECTION_OUTLINE_PADDING = 6;
function SelectionVisuals(canvas, eventBus, selection) {
  this._canvas = canvas;
  var self2 = this;
  this._multiSelectionBox = null;
  function addMarker(e7, cls) {
    canvas.addMarker(e7, cls);
  }
  function removeMarker(e7, cls) {
    canvas.removeMarker(e7, cls);
  }
  eventBus.on("element.hover", function(event2) {
    addMarker(event2.element, MARKER_HOVER);
  });
  eventBus.on("element.out", function(event2) {
    removeMarker(event2.element, MARKER_HOVER);
  });
  eventBus.on("selection.changed", function(event2) {
    function deselect(s5) {
      removeMarker(s5, MARKER_SELECTED);
    }
    function select(s5) {
      addMarker(s5, MARKER_SELECTED);
    }
    var oldSelection = event2.oldSelection, newSelection = event2.newSelection;
    (0, import_min_dash15.forEach)(oldSelection, function(e7) {
      if (newSelection.indexOf(e7) === -1) {
        deselect(e7);
      }
    });
    (0, import_min_dash15.forEach)(newSelection, function(e7) {
      if (oldSelection.indexOf(e7) === -1) {
        select(e7);
      }
    });
    self2._updateSelectionOutline(newSelection);
  });
  eventBus.on("element.changed", function(event2) {
    if (selection.isSelected(event2.element)) {
      self2._updateSelectionOutline(selection.get());
    }
  });
}
SelectionVisuals.$inject = [
  "canvas",
  "eventBus",
  "selection"
];
SelectionVisuals.prototype._updateSelectionOutline = function(selection) {
  var layer = this._canvas.getLayer("selectionOutline");
  clear(layer);
  var enabled = selection.length > 1;
  var container = this._canvas.getContainer();
  classes(container)[enabled ? "add" : "remove"]("djs-multi-select");
  if (!enabled) {
    return;
  }
  var bBox = addSelectionOutlinePadding(getBBox(selection));
  var rect = create("rect");
  attr(rect, (0, import_min_dash15.assign)({
    rx: 3
  }, bBox));
  classes(rect).add("djs-selection-outline");
  append(layer, rect);
};
function addSelectionOutlinePadding(bBox) {
  return {
    x: bBox.x - SELECTION_OUTLINE_PADDING,
    y: bBox.y - SELECTION_OUTLINE_PADDING,
    width: bBox.width + SELECTION_OUTLINE_PADDING * 2,
    height: bBox.height + SELECTION_OUTLINE_PADDING * 2
  };
}

// node_modules/diagram-js/lib/features/selection/SelectionBehavior.js
var import_min_dash16 = __toESM(require_dist());
function SelectionBehavior(eventBus, selection, canvas, elementRegistry) {
  eventBus.on("create.end", 500, function(event2) {
    var context = event2.context, canExecute = context.canExecute, elements = context.elements, hints = context.hints || {}, autoSelect = hints.autoSelect;
    if (canExecute) {
      if (autoSelect === false) {
        return;
      }
      if ((0, import_min_dash16.isArray)(autoSelect)) {
        selection.select(autoSelect);
      } else {
        selection.select(elements.filter(isShown));
      }
    }
  });
  eventBus.on("connect.end", 500, function(event2) {
    var context = event2.context, connection = context.connection;
    if (connection) {
      selection.select(connection);
    }
  });
  eventBus.on("shape.move.end", 500, function(event2) {
    var previousSelection = event2.previousSelection || [];
    var shape = elementRegistry.get(event2.context.shape.id);
    var isSelected = (0, import_min_dash16.find)(previousSelection, function(selectedShape) {
      return shape.id === selectedShape.id;
    });
    if (!isSelected) {
      selection.select(shape);
    }
  });
  eventBus.on("element.click", function(event2) {
    if (!isPrimaryButton(event2)) {
      return;
    }
    var element = event2.element;
    if (element === canvas.getRootElement()) {
      element = null;
    }
    var isSelected = selection.isSelected(element), isMultiSelect = selection.get().length > 1;
    var add3 = hasPrimaryModifier(event2) || hasSecondaryModifier(event2);
    if (isSelected && isMultiSelect) {
      if (add3) {
        return selection.deselect(element);
      } else {
        return selection.select(element);
      }
    } else if (!isSelected) {
      selection.select(element, add3);
    } else {
      selection.deselect(element);
    }
  });
}
SelectionBehavior.$inject = [
  "eventBus",
  "selection",
  "canvas",
  "elementRegistry"
];
function isShown(element) {
  return !element.hidden;
}

// node_modules/diagram-js/lib/features/selection/index.js
var selection_default = {
  __init__: ["selectionVisuals", "selectionBehavior"],
  __depends__: [
    interaction_events_default,
    outline_default
  ],
  selection: ["type", Selection],
  selectionVisuals: ["type", SelectionVisuals],
  selectionBehavior: ["type", SelectionBehavior]
};

// node_modules/diagram-js/lib/features/overlays/Overlays.js
var import_min_dash17 = __toESM(require_dist());

// node_modules/diagram-js/lib/util/IdGenerator.js
function IdGenerator(prefix3) {
  this._counter = 0;
  this._prefix = (prefix3 ? prefix3 + "-" : "") + Math.floor(Math.random() * 1e9) + "-";
}
IdGenerator.prototype.next = function() {
  return this._prefix + ++this._counter;
};

// node_modules/diagram-js/lib/features/overlays/Overlays.js
var ids = new IdGenerator("ov");
var LOW_PRIORITY3 = 500;
function Overlays(config, eventBus, canvas, elementRegistry) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  this._elementRegistry = elementRegistry;
  this._ids = ids;
  this._overlayDefaults = (0, import_min_dash17.assign)({
    show: null,
    scale: true
  }, config && config.defaults);
  this._overlays = {};
  this._overlayContainers = [];
  this._overlayRoot = createRoot(canvas.getContainer());
  this._init();
}
Overlays.$inject = [
  "config.overlays",
  "eventBus",
  "canvas",
  "elementRegistry"
];
Overlays.prototype.get = function(search) {
  if ((0, import_min_dash17.isString)(search)) {
    search = { id: search };
  }
  if ((0, import_min_dash17.isString)(search.element)) {
    search.element = this._elementRegistry.get(search.element);
  }
  if (search.element) {
    var container = this._getOverlayContainer(search.element, true);
    if (container) {
      return search.type ? (0, import_min_dash17.filter)(container.overlays, (0, import_min_dash17.matchPattern)({ type: search.type })) : container.overlays.slice();
    } else {
      return [];
    }
  } else if (search.type) {
    return (0, import_min_dash17.filter)(this._overlays, (0, import_min_dash17.matchPattern)({ type: search.type }));
  } else {
    return search.id ? this._overlays[search.id] : null;
  }
};
Overlays.prototype.add = function(element, type, overlay) {
  if ((0, import_min_dash17.isObject)(type)) {
    overlay = type;
    type = null;
  }
  if (!element.id) {
    element = this._elementRegistry.get(element);
  }
  if (!overlay.position) {
    throw new Error("must specifiy overlay position");
  }
  if (!overlay.html) {
    throw new Error("must specifiy overlay html");
  }
  if (!element) {
    throw new Error("invalid element specified");
  }
  var id = this._ids.next();
  overlay = (0, import_min_dash17.assign)({}, this._overlayDefaults, overlay, {
    id,
    type,
    element,
    html: overlay.html
  });
  this._addOverlay(overlay);
  return id;
};
Overlays.prototype.remove = function(filter28) {
  var overlays = this.get(filter28) || [];
  if (!(0, import_min_dash17.isArray)(overlays)) {
    overlays = [overlays];
  }
  var self2 = this;
  (0, import_min_dash17.forEach)(overlays, function(overlay) {
    var container = self2._getOverlayContainer(overlay.element, true);
    if (overlay) {
      remove2(overlay.html);
      remove2(overlay.htmlContainer);
      delete overlay.htmlContainer;
      delete overlay.element;
      delete self2._overlays[overlay.id];
    }
    if (container) {
      var idx = container.overlays.indexOf(overlay);
      if (idx !== -1) {
        container.overlays.splice(idx, 1);
      }
    }
  });
};
Overlays.prototype.isShown = function() {
  return this._overlayRoot.style.display !== "none";
};
Overlays.prototype.show = function() {
  setVisible(this._overlayRoot);
};
Overlays.prototype.hide = function() {
  setVisible(this._overlayRoot, false);
};
Overlays.prototype.clear = function() {
  this._overlays = {};
  this._overlayContainers = [];
  clear2(this._overlayRoot);
};
Overlays.prototype._updateOverlayContainer = function(container) {
  var element = container.element, html = container.html;
  var x4 = element.x, y4 = element.y;
  if (element.waypoints) {
    var bbox = getBBox(element);
    x4 = bbox.x;
    y4 = bbox.y;
  }
  setPosition(html, x4, y4);
  attr2(container.html, "data-container-id", element.id);
};
Overlays.prototype._updateOverlay = function(overlay) {
  var position = overlay.position, htmlContainer = overlay.htmlContainer, element = overlay.element;
  var left = position.left, top = position.top;
  if (position.right !== void 0) {
    var width;
    if (element.waypoints) {
      width = getBBox(element).width;
    } else {
      width = element.width;
    }
    left = position.right * -1 + width;
  }
  if (position.bottom !== void 0) {
    var height;
    if (element.waypoints) {
      height = getBBox(element).height;
    } else {
      height = element.height;
    }
    top = position.bottom * -1 + height;
  }
  setPosition(htmlContainer, left || 0, top || 0);
  this._updateOverlayVisibilty(overlay, this._canvas.viewbox());
};
Overlays.prototype._createOverlayContainer = function(element) {
  var html = domify$1('<div class="djs-overlays" />');
  assign(html, { position: "absolute" });
  this._overlayRoot.appendChild(html);
  var container = {
    html,
    element,
    overlays: []
  };
  this._updateOverlayContainer(container);
  this._overlayContainers.push(container);
  return container;
};
Overlays.prototype._updateRoot = function(viewbox) {
  var scale = viewbox.scale || 1;
  var matrix = "matrix(" + [
    scale,
    0,
    0,
    scale,
    -1 * viewbox.x * scale,
    -1 * viewbox.y * scale
  ].join(",") + ")";
  setTransform(this._overlayRoot, matrix);
};
Overlays.prototype._getOverlayContainer = function(element, raw) {
  var container = (0, import_min_dash17.find)(this._overlayContainers, function(c5) {
    return c5.element === element;
  });
  if (!container && !raw) {
    return this._createOverlayContainer(element);
  }
  return container;
};
Overlays.prototype._addOverlay = function(overlay) {
  var id = overlay.id, element = overlay.element, html = overlay.html, htmlContainer, overlayContainer;
  if (html.get && html.constructor.prototype.jquery) {
    html = html.get(0);
  }
  if ((0, import_min_dash17.isString)(html)) {
    html = domify$1(html);
  }
  overlayContainer = this._getOverlayContainer(element);
  htmlContainer = domify$1('<div class="djs-overlay" data-overlay-id="' + id + '">');
  assign(htmlContainer, { position: "absolute" });
  htmlContainer.appendChild(html);
  if (overlay.type) {
    classes2(htmlContainer).add("djs-overlay-" + overlay.type);
  }
  var elementRoot = this._canvas.findRoot(element);
  var activeRoot = this._canvas.getRootElement();
  setVisible(htmlContainer, elementRoot === activeRoot);
  overlay.htmlContainer = htmlContainer;
  overlayContainer.overlays.push(overlay);
  overlayContainer.html.appendChild(htmlContainer);
  this._overlays[id] = overlay;
  this._updateOverlay(overlay);
  this._updateOverlayVisibilty(overlay, this._canvas.viewbox());
};
Overlays.prototype._updateOverlayVisibilty = function(overlay, viewbox) {
  var show = overlay.show, rootElement = this._canvas.findRoot(overlay.element), minZoom = show && show.minZoom, maxZoom = show && show.maxZoom, htmlContainer = overlay.htmlContainer, activeRootElement = this._canvas.getRootElement(), visible = true;
  if (rootElement !== activeRootElement) {
    visible = false;
  } else if (show) {
    if ((0, import_min_dash17.isDefined)(minZoom) && minZoom > viewbox.scale || (0, import_min_dash17.isDefined)(maxZoom) && maxZoom < viewbox.scale) {
      visible = false;
    }
  }
  setVisible(htmlContainer, visible);
  this._updateOverlayScale(overlay, viewbox);
};
Overlays.prototype._updateOverlayScale = function(overlay, viewbox) {
  var shouldScale = overlay.scale, minScale, maxScale, htmlContainer = overlay.htmlContainer;
  var scale, transform3 = "";
  if (shouldScale !== true) {
    if (shouldScale === false) {
      minScale = 1;
      maxScale = 1;
    } else {
      minScale = shouldScale.min;
      maxScale = shouldScale.max;
    }
    if ((0, import_min_dash17.isDefined)(minScale) && viewbox.scale < minScale) {
      scale = (1 / viewbox.scale || 1) * minScale;
    }
    if ((0, import_min_dash17.isDefined)(maxScale) && viewbox.scale > maxScale) {
      scale = (1 / viewbox.scale || 1) * maxScale;
    }
  }
  if ((0, import_min_dash17.isDefined)(scale)) {
    transform3 = "scale(" + scale + "," + scale + ")";
  }
  setTransform(htmlContainer, transform3);
};
Overlays.prototype._updateOverlaysVisibilty = function(viewbox) {
  var self2 = this;
  (0, import_min_dash17.forEach)(this._overlays, function(overlay) {
    self2._updateOverlayVisibilty(overlay, viewbox);
  });
};
Overlays.prototype._init = function() {
  var eventBus = this._eventBus;
  var self2 = this;
  function updateViewbox(viewbox) {
    self2._updateRoot(viewbox);
    self2._updateOverlaysVisibilty(viewbox);
    self2.show();
  }
  eventBus.on("canvas.viewbox.changing", function(event2) {
    self2.hide();
  });
  eventBus.on("canvas.viewbox.changed", function(event2) {
    updateViewbox(event2.viewbox);
  });
  eventBus.on(["shape.remove", "connection.remove"], function(e7) {
    var element = e7.element;
    var overlays = self2.get({ element });
    (0, import_min_dash17.forEach)(overlays, function(o7) {
      self2.remove(o7.id);
    });
    var container = self2._getOverlayContainer(element);
    if (container) {
      remove2(container.html);
      var i6 = self2._overlayContainers.indexOf(container);
      if (i6 !== -1) {
        self2._overlayContainers.splice(i6, 1);
      }
    }
  });
  eventBus.on("element.changed", LOW_PRIORITY3, function(e7) {
    var element = e7.element;
    var container = self2._getOverlayContainer(element, true);
    if (container) {
      (0, import_min_dash17.forEach)(container.overlays, function(overlay) {
        self2._updateOverlay(overlay);
      });
      self2._updateOverlayContainer(container);
    }
  });
  eventBus.on("element.marker.update", function(e7) {
    var container = self2._getOverlayContainer(e7.element, true);
    if (container) {
      classes2(container.html)[e7.add ? "add" : "remove"](e7.marker);
    }
  });
  eventBus.on("root.set", function() {
    self2._updateOverlaysVisibilty(self2._canvas.viewbox());
  });
  eventBus.on("diagram.clear", this.clear, this);
};
function createRoot(parentNode) {
  var root = domify$1('<div class="djs-overlay-container" />');
  assign(root, {
    position: "absolute",
    width: 0,
    height: 0
  });
  parentNode.insertBefore(root, parentNode.firstChild);
  return root;
}
function setPosition(el, x4, y4) {
  assign(el, { left: x4 + "px", top: y4 + "px" });
}
function setVisible(el, visible) {
  el.style.display = visible === false ? "none" : "";
}
function setTransform(el, transform3) {
  el.style["transform-origin"] = "top left";
  ["", "-ms-", "-webkit-"].forEach(function(prefix3) {
    el.style[prefix3 + "transform"] = transform3;
  });
}

// node_modules/diagram-js/lib/features/overlays/index.js
var overlays_default = {
  __init__: ["overlays"],
  overlays: ["type", Overlays]
};

// node_modules/diagram-js/lib/features/change-support/ChangeSupport.js
function ChangeSupport(eventBus, canvas, elementRegistry, graphicsFactory) {
  eventBus.on("element.changed", function(event2) {
    var element = event2.element;
    if (element.parent || element === canvas.getRootElement()) {
      event2.gfx = elementRegistry.getGraphics(element);
    }
    if (!event2.gfx) {
      return;
    }
    eventBus.fire(getType(element) + ".changed", event2);
  });
  eventBus.on("elements.changed", function(event2) {
    var elements = event2.elements;
    elements.forEach(function(e7) {
      eventBus.fire("element.changed", { element: e7 });
    });
    graphicsFactory.updateContainments(elements);
  });
  eventBus.on("shape.changed", function(event2) {
    graphicsFactory.update("shape", event2.element, event2.gfx);
  });
  eventBus.on("connection.changed", function(event2) {
    graphicsFactory.update("connection", event2.element, event2.gfx);
  });
}
ChangeSupport.$inject = [
  "eventBus",
  "canvas",
  "elementRegistry",
  "graphicsFactory"
];

// node_modules/diagram-js/lib/features/change-support/index.js
var change_support_default = {
  __init__: ["changeSupport"],
  changeSupport: ["type", ChangeSupport]
};

// node_modules/diagram-js/lib/command/CommandInterceptor.js
var import_min_dash18 = __toESM(require_dist());
var DEFAULT_PRIORITY = 1e3;
function CommandInterceptor(eventBus) {
  this._eventBus = eventBus;
}
CommandInterceptor.$inject = ["eventBus"];
function unwrapEvent(fn2, that) {
  return function(event2) {
    return fn2.call(that || null, event2.context, event2.command, event2);
  };
}
CommandInterceptor.prototype.on = function(events, hook, priority, handlerFn, unwrap, that) {
  if ((0, import_min_dash18.isFunction)(hook) || (0, import_min_dash18.isNumber)(hook)) {
    that = unwrap;
    unwrap = handlerFn;
    handlerFn = priority;
    priority = hook;
    hook = null;
  }
  if ((0, import_min_dash18.isFunction)(priority)) {
    that = unwrap;
    unwrap = handlerFn;
    handlerFn = priority;
    priority = DEFAULT_PRIORITY;
  }
  if ((0, import_min_dash18.isObject)(unwrap)) {
    that = unwrap;
    unwrap = false;
  }
  if (!(0, import_min_dash18.isFunction)(handlerFn)) {
    throw new Error("handlerFn must be a function");
  }
  if (!(0, import_min_dash18.isArray)(events)) {
    events = [events];
  }
  var eventBus = this._eventBus;
  (0, import_min_dash18.forEach)(events, function(event2) {
    var fullEvent = ["commandStack", event2, hook].filter(function(e7) {
      return e7;
    }).join(".");
    eventBus.on(fullEvent, priority, unwrap ? unwrapEvent(handlerFn, that) : handlerFn, that);
  });
};
var hooks = [
  "canExecute",
  "preExecute",
  "preExecuted",
  "execute",
  "executed",
  "postExecute",
  "postExecuted",
  "revert",
  "reverted"
];
(0, import_min_dash18.forEach)(hooks, function(hook) {
  CommandInterceptor.prototype[hook] = function(events, priority, handlerFn, unwrap, that) {
    if ((0, import_min_dash18.isFunction)(events) || (0, import_min_dash18.isNumber)(events)) {
      that = unwrap;
      unwrap = handlerFn;
      handlerFn = priority;
      priority = events;
      events = null;
    }
    this.on(events, hook, priority, handlerFn, unwrap, that);
  };
});

// node_modules/diagram-js/lib/features/root-elements/RootElementsBehavior.js
function RootElementsBehavior(canvas, injector) {
  injector.invoke(CommandInterceptor, this);
  this.executed(function(event2) {
    var context = event2.context;
    if (context.rootElement) {
      canvas.setRootElement(context.rootElement);
    } else {
      context.rootElement = canvas.getRootElement();
    }
  });
  this.revert(function(event2) {
    var context = event2.context;
    if (context.rootElement) {
      canvas.setRootElement(context.rootElement);
    }
  });
}
e(RootElementsBehavior, CommandInterceptor);
RootElementsBehavior.$inject = ["canvas", "injector"];

// node_modules/diagram-js/lib/features/root-elements/index.js
var root_elements_default = {
  __init__: ["rootElementsBehavior"],
  rootElementsBehavior: ["type", RootElementsBehavior]
};

// node_modules/bpmn-js/lib/features/drilldown/DrilldownBreadcrumbs.js
var import_min_dash19 = __toESM(require_dist());

// node_modules/diagram-js/lib/util/EscapeUtil.js
var import_css = __toESM(require_css_escape());
var HTML_ESCAPE_MAP = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function escapeHTML(str) {
  str = "" + str;
  return str && str.replace(/[&<>"']/g, function(match) {
    return HTML_ESCAPE_MAP[match];
  });
}

// node_modules/bpmn-js/lib/util/DrilldownUtil.js
var planeSuffix = "_plane";
function getShapeIdFromPlane(element) {
  var id = element.id;
  return removePlaneSuffix(id);
}
function getPlaneIdFromShape(element) {
  var id = element.id;
  if (is(element, "bpmn:SubProcess")) {
    return addPlaneSuffix(id);
  }
  return id;
}
function toPlaneId(id) {
  return addPlaneSuffix(id);
}
function isPlane(element) {
  var di = getDi(element);
  return is(di, "bpmndi:BPMNPlane");
}
function addPlaneSuffix(id) {
  return id + planeSuffix;
}
function removePlaneSuffix(id) {
  return id.replace(new RegExp(planeSuffix + "$"), "");
}

// node_modules/bpmn-js/lib/features/drilldown/DrilldownBreadcrumbs.js
var OPEN_CLASS = "bjs-breadcrumbs-shown";
function DrilldownBreadcrumbs(eventBus, elementRegistry, overlays, canvas) {
  var breadcrumbs = domify$1('<ul class="bjs-breadcrumbs"></ul>');
  var container = canvas.getContainer();
  var containerClasses = classes2(container);
  container.appendChild(breadcrumbs);
  var boParents = [];
  eventBus.on("element.changed", function(e7) {
    var shape = e7.element, bo = getBusinessObject(shape);
    var isPresent = (0, import_min_dash19.find)(boParents, function(el) {
      return el === bo;
    });
    if (!isPresent) {
      return;
    }
    updateBreadcrumbs();
  });
  function updateBreadcrumbs(element) {
    if (element) {
      boParents = getBoParentChain(element);
    }
    var path = boParents.map(function(parent) {
      var title = escapeHTML(parent.name || parent.id);
      var link = domify$1('<li><span class="bjs-crumb"><a title="' + title + '">' + title + "</a></span></li>");
      var parentPlane = canvas.findRoot(getPlaneIdFromShape(parent)) || canvas.findRoot(parent.id);
      if (!parentPlane && is(parent, "bpmn:Process")) {
        var participant = elementRegistry.find(function(element2) {
          var bo = getBusinessObject(element2);
          return bo && bo.processRef && bo.processRef === parent;
        });
        parentPlane = canvas.findRoot(participant.id);
      }
      link.addEventListener("click", function() {
        canvas.setRootElement(parentPlane);
      });
      return link;
    });
    breadcrumbs.innerHTML = "";
    var visible = path.length > 1;
    containerClasses.toggle(OPEN_CLASS, visible);
    path.forEach(function(el) {
      breadcrumbs.appendChild(el);
    });
  }
  eventBus.on("root.set", function(event2) {
    updateBreadcrumbs(event2.element);
  });
}
DrilldownBreadcrumbs.$inject = ["eventBus", "elementRegistry", "overlays", "canvas"];
function getBoParentChain(child) {
  var bo = getBusinessObject(child);
  var parents = [];
  for (var element = bo; element; element = element.$parent) {
    if (is(element, "bpmn:SubProcess") || is(element, "bpmn:Process")) {
      parents.push(element);
    }
  }
  return parents.reverse();
}

// node_modules/bpmn-js/lib/features/drilldown/DrilldownCentering.js
function DrilldownCentering(eventBus, canvas) {
  var currentRoot = null;
  var positionMap = new Map2();
  eventBus.on("root.set", function(event2) {
    var newRoot = event2.element;
    var currentViewbox = canvas.viewbox();
    var storedViewbox = positionMap.get(newRoot);
    positionMap.set(currentRoot, {
      x: currentViewbox.x,
      y: currentViewbox.y,
      zoom: currentViewbox.scale
    });
    currentRoot = newRoot;
    if (is(newRoot, "bpmn:Collaboration") && !storedViewbox) {
      return;
    }
    storedViewbox = storedViewbox || { x: 0, y: 0, zoom: 1 };
    var dx = (currentViewbox.x - storedViewbox.x) * currentViewbox.scale, dy = (currentViewbox.y - storedViewbox.y) * currentViewbox.scale;
    if (dx !== 0 || dy !== 0) {
      canvas.scroll({
        dx,
        dy
      });
    }
    if (storedViewbox.zoom !== currentViewbox.scale) {
      canvas.zoom(storedViewbox.zoom, { x: 0, y: 0 });
    }
  });
  eventBus.on("diagram.clear", function() {
    positionMap.clear();
    currentRoot = null;
  });
}
DrilldownCentering.$inject = ["eventBus", "canvas"];
function Map2() {
  this._entries = [];
  this.set = function(key, value) {
    var found = false;
    for (var k6 in this._entries) {
      if (this._entries[k6][0] === key) {
        this._entries[k6][1] = value;
        found = true;
        break;
      }
    }
    if (!found) {
      this._entries.push([key, value]);
    }
  };
  this.get = function(key) {
    for (var k6 in this._entries) {
      if (this._entries[k6][0] === key) {
        return this._entries[k6][1];
      }
    }
    return null;
  };
  this.clear = function() {
    this._entries.length = 0;
  };
  this.remove = function(key) {
    var idx = -1;
    for (var k6 in this._entries) {
      if (this._entries[k6][0] === key) {
        idx = k6;
        break;
      }
    }
    if (idx !== -1) {
      this._entries.splice(idx, 1);
    }
  };
}

// node_modules/bpmn-js/lib/features/drilldown/SubprocessCompatibility.js
var DEFAULT_POSITION = {
  x: 180,
  y: 160
};
function SubprocessCompatibility(eventBus, moddle) {
  this._eventBus = eventBus;
  this._moddle = moddle;
  var self2 = this;
  eventBus.on("import.render.start", 1500, function(e7, context) {
    self2.handleImport(context.definitions);
  });
}
SubprocessCompatibility.prototype.handleImport = function(definitions) {
  if (!definitions.diagrams) {
    return;
  }
  var self2 = this;
  this._definitions = definitions;
  this._processToDiagramMap = {};
  definitions.diagrams.forEach(function(diagram) {
    if (!diagram.plane || !diagram.plane.bpmnElement) {
      return;
    }
    self2._processToDiagramMap[diagram.plane.bpmnElement.id] = diagram;
  });
  var newDiagrams = [];
  definitions.diagrams.forEach(function(diagram) {
    var createdDiagrams = self2.createNewDiagrams(diagram.plane);
    Array.prototype.push.apply(newDiagrams, createdDiagrams);
  });
  newDiagrams.forEach(function(diagram) {
    self2.movePlaneElementsToOrigin(diagram.plane);
  });
};
SubprocessCompatibility.prototype.createNewDiagrams = function(plane) {
  var self2 = this;
  var collapsedElements = [];
  var elementsToMove = [];
  plane.get("planeElement").forEach(function(diElement) {
    var bo = diElement.bpmnElement;
    if (!bo) {
      return;
    }
    var parent = bo.$parent;
    if (is(bo, "bpmn:SubProcess") && !diElement.isExpanded) {
      collapsedElements.push(bo);
    }
    if (shouldMoveToPlane(bo, plane)) {
      elementsToMove.push({ diElement, parent });
    }
  });
  var newDiagrams = [];
  collapsedElements.forEach(function(element) {
    if (!self2._processToDiagramMap[element.id]) {
      var diagram = self2.createDiagram(element);
      self2._processToDiagramMap[element.id] = diagram;
      newDiagrams.push(diagram);
    }
  });
  elementsToMove.forEach(function(element) {
    var diElement = element.diElement;
    var parent = element.parent;
    while (parent && collapsedElements.indexOf(parent) === -1) {
      parent = parent.$parent;
    }
    if (!parent) {
      return;
    }
    var diagram = self2._processToDiagramMap[parent.id];
    self2.moveToDiPlane(diElement, diagram.plane);
  });
  return newDiagrams;
};
SubprocessCompatibility.prototype.movePlaneElementsToOrigin = function(plane) {
  var elements = plane.get("planeElement");
  var planeBounds = getPlaneBounds(plane);
  var offset = {
    x: planeBounds.x - DEFAULT_POSITION.x,
    y: planeBounds.y - DEFAULT_POSITION.y
  };
  elements.forEach(function(diElement) {
    if (diElement.waypoint) {
      diElement.waypoint.forEach(function(waypoint) {
        waypoint.x = waypoint.x - offset.x;
        waypoint.y = waypoint.y - offset.y;
      });
    } else if (diElement.bounds) {
      diElement.bounds.x = diElement.bounds.x - offset.x;
      diElement.bounds.y = diElement.bounds.y - offset.y;
    }
  });
};
SubprocessCompatibility.prototype.moveToDiPlane = function(diElement, newPlane) {
  var containingDiagram = findRootDiagram(diElement);
  var parentPlaneElement = containingDiagram.plane.get("planeElement");
  parentPlaneElement.splice(parentPlaneElement.indexOf(diElement), 1);
  newPlane.get("planeElement").push(diElement);
};
SubprocessCompatibility.prototype.createDiagram = function(bo) {
  var plane = this._moddle.create("bpmndi:BPMNPlane", { bpmnElement: bo });
  var diagram = this._moddle.create("bpmndi:BPMNDiagram", {
    plane
  });
  plane.$parent = diagram;
  plane.bpmnElement = bo;
  diagram.$parent = this._definitions;
  this._definitions.diagrams.push(diagram);
  return diagram;
};
SubprocessCompatibility.$inject = ["eventBus", "moddle"];
function findRootDiagram(element) {
  if (is(element, "bpmndi:BPMNDiagram")) {
    return element;
  } else {
    return findRootDiagram(element.$parent);
  }
}
function getPlaneBounds(plane) {
  var planeTrbl = {
    top: Infinity,
    right: -Infinity,
    bottom: -Infinity,
    left: Infinity
  };
  plane.planeElement.forEach(function(element) {
    if (!element.bounds) {
      return;
    }
    var trbl = asTRBL(element.bounds);
    planeTrbl.top = Math.min(trbl.top, planeTrbl.top);
    planeTrbl.left = Math.min(trbl.left, planeTrbl.left);
  });
  return asBounds(planeTrbl);
}
function shouldMoveToPlane(bo, plane) {
  var parent = bo.$parent;
  if (!is(parent, "bpmn:SubProcess") || parent === plane.bpmnElement) {
    return false;
  }
  if (isAny(bo, ["bpmn:DataInputAssociation", "bpmn:DataOutputAssociation"])) {
    return false;
  }
  return true;
}

// node_modules/bpmn-js/lib/features/drilldown/DrilldownOverlayBehavior.js
var LOW_PRIORITY4 = 250;
var ARROW_DOWN_SVG = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4.81801948,3.50735931 L10.4996894,9.1896894 L10.5,4 L12,4 L12,12 L4,12 L4,10.5 L9.6896894,10.4996894 L3.75735931,4.56801948 C3.46446609,4.27512627 3.46446609,3.80025253 3.75735931,3.50735931 C4.05025253,3.21446609 4.52512627,3.21446609 4.81801948,3.50735931 Z"/></svg>';
var EMPTY_MARKER = "bjs-drilldown-empty";
function DrilldownOverlayBehavior(canvas, eventBus, elementRegistry, overlays) {
  CommandInterceptor.call(this, eventBus);
  this._canvas = canvas;
  this._eventBus = eventBus;
  this._elementRegistry = elementRegistry;
  this._overlays = overlays;
  var self2 = this;
  this.executed("shape.toggleCollapse", LOW_PRIORITY4, function(context) {
    var shape = context.shape;
    if (self2.canDrillDown(shape)) {
      self2.addOverlay(shape);
    } else {
      self2.removeOverlay(shape);
    }
  }, true);
  this.reverted("shape.toggleCollapse", LOW_PRIORITY4, function(context) {
    var shape = context.shape;
    if (self2.canDrillDown(shape)) {
      self2.addOverlay(shape);
    } else {
      self2.removeOverlay(shape);
    }
  }, true);
  this.executed(["shape.create", "shape.move", "shape.delete"], LOW_PRIORITY4, function(context) {
    var oldParent = context.oldParent, newParent = context.newParent || context.parent, shape = context.shape;
    if (self2.canDrillDown(shape)) {
      self2.addOverlay(shape);
    }
    self2.updateDrilldownOverlay(oldParent);
    self2.updateDrilldownOverlay(newParent);
    self2.updateDrilldownOverlay(shape);
  }, true);
  this.reverted(["shape.create", "shape.move", "shape.delete"], LOW_PRIORITY4, function(context) {
    var oldParent = context.oldParent, newParent = context.newParent || context.parent, shape = context.shape;
    if (self2.canDrillDown(shape)) {
      self2.addOverlay(shape);
    }
    self2.updateDrilldownOverlay(oldParent);
    self2.updateDrilldownOverlay(newParent);
    self2.updateDrilldownOverlay(shape);
  }, true);
  eventBus.on("import.render.complete", function() {
    elementRegistry.filter(function(e7) {
      return self2.canDrillDown(e7);
    }).map(function(el) {
      self2.addOverlay(el);
    });
  });
}
e(DrilldownOverlayBehavior, CommandInterceptor);
DrilldownOverlayBehavior.prototype.updateDrilldownOverlay = function(shape) {
  var canvas = this._canvas;
  if (!shape) {
    return;
  }
  var root = canvas.findRoot(shape);
  if (root) {
    this.updateOverlayVisibility(root);
  }
};
DrilldownOverlayBehavior.prototype.canDrillDown = function(element) {
  var canvas = this._canvas;
  return is(element, "bpmn:SubProcess") && canvas.findRoot(getPlaneIdFromShape(element));
};
DrilldownOverlayBehavior.prototype.updateOverlayVisibility = function(element) {
  var overlays = this._overlays;
  var bo = element.businessObject;
  var overlay = overlays.get({ element: bo.id, type: "drilldown" })[0];
  if (!overlay) {
    return;
  }
  var hasContent = bo && bo.flowElements && bo.flowElements.length;
  classes2(overlay.html).toggle(EMPTY_MARKER, !hasContent);
};
DrilldownOverlayBehavior.prototype.addOverlay = function(element) {
  var canvas = this._canvas;
  var overlays = this._overlays;
  var existingOverlays = overlays.get({ element, type: "drilldown" });
  if (existingOverlays.length) {
    this.removeOverlay(element);
  }
  var button = domify$1('<button class="bjs-drilldown">' + ARROW_DOWN_SVG + "</button>");
  button.addEventListener("click", function() {
    canvas.setRootElement(canvas.findRoot(getPlaneIdFromShape(element)));
  });
  overlays.add(element, "drilldown", {
    position: {
      bottom: -7,
      right: -8
    },
    html: button
  });
  this.updateOverlayVisibility(element);
};
DrilldownOverlayBehavior.prototype.removeOverlay = function(element) {
  var overlays = this._overlays;
  overlays.remove({
    element,
    type: "drilldown"
  });
};
DrilldownOverlayBehavior.$inject = [
  "canvas",
  "eventBus",
  "elementRegistry",
  "overlays"
];

// node_modules/bpmn-js/lib/features/drilldown/index.js
var drilldown_default = {
  __depends__: [overlays_default, change_support_default, root_elements_default],
  __init__: ["drilldownBreadcrumbs", "drilldownOverlayBehavior", "drilldownCentering", "subprocessCompatibility"],
  drilldownBreadcrumbs: ["type", DrilldownBreadcrumbs],
  drilldownCentering: ["type", DrilldownCentering],
  drilldownOverlayBehavior: ["type", DrilldownOverlayBehavior],
  subprocessCompatibility: ["type", SubprocessCompatibility]
};

// node_modules/bpmn-js/lib/BaseViewer.js
var import_min_dash33 = __toESM(require_dist());

// node_modules/didi/dist/index.esm.js
var CLASS_PATTERN = /^class[ {]/;
function isClass(fn2) {
  return CLASS_PATTERN.test(fn2.toString());
}
function isArray8(obj) {
  return Array.isArray(obj);
}
function hasOwnProp(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function annotate(...args) {
  if (args.length === 1 && isArray8(args[0])) {
    args = args[0];
  }
  args = [...args];
  const fn2 = args.pop();
  fn2.$inject = args;
  return fn2;
}
var CONSTRUCTOR_ARGS = /constructor\s*[^(]*\(\s*([^)]*)\)/m;
var FN_ARGS = /^(?:async\s+)?(?:function\s*[^(]*)?(?:\(\s*([^)]*)\)|(\w+))/m;
var FN_ARG = /\/\*([^*]*)\*\//m;
function parseAnnotations(fn2) {
  if (typeof fn2 !== "function") {
    throw new Error(`Cannot annotate "${fn2}". Expected a function!`);
  }
  const match = fn2.toString().match(isClass(fn2) ? CONSTRUCTOR_ARGS : FN_ARGS);
  if (!match) {
    return [];
  }
  const args = match[1] || match[2];
  return args && args.split(",").map((arg) => {
    const argMatch = arg.match(FN_ARG);
    return (argMatch && argMatch[1] || arg).trim();
  }) || [];
}
function Injector(modules, parent) {
  parent = parent || {
    get: function(name3, strict) {
      currentlyResolving.push(name3);
      if (strict === false) {
        return null;
      } else {
        throw error4(`No provider for "${name3}"!`);
      }
    }
  };
  const currentlyResolving = [];
  const providers = this._providers = Object.create(parent._providers || null);
  const instances = this._instances = /* @__PURE__ */ Object.create(null);
  const self2 = instances.injector = this;
  const error4 = function(msg) {
    const stack = currentlyResolving.join(" -> ");
    currentlyResolving.length = 0;
    return new Error(stack ? `${msg} (Resolving: ${stack})` : msg);
  };
  function get4(name3, strict) {
    if (!providers[name3] && name3.indexOf(".") !== -1) {
      const parts = name3.split(".");
      let pivot = get4(parts.shift());
      while (parts.length) {
        pivot = pivot[parts.shift()];
      }
      return pivot;
    }
    if (hasOwnProp(instances, name3)) {
      return instances[name3];
    }
    if (hasOwnProp(providers, name3)) {
      if (currentlyResolving.indexOf(name3) !== -1) {
        currentlyResolving.push(name3);
        throw error4("Cannot resolve circular dependency!");
      }
      currentlyResolving.push(name3);
      instances[name3] = providers[name3][0](providers[name3][1]);
      currentlyResolving.pop();
      return instances[name3];
    }
    return parent.get(name3, strict);
  }
  function fnDef(fn2, locals) {
    if (typeof locals === "undefined") {
      locals = {};
    }
    if (typeof fn2 !== "function") {
      if (isArray8(fn2)) {
        fn2 = annotate(fn2.slice());
      } else {
        throw error4(`Cannot invoke "${fn2}". Expected a function!`);
      }
    }
    const inject = fn2.$inject || parseAnnotations(fn2);
    const dependencies = inject.map((dep) => {
      if (hasOwnProp(locals, dep)) {
        return locals[dep];
      } else {
        return get4(dep);
      }
    });
    return {
      fn: fn2,
      dependencies
    };
  }
  function instantiate(Type2) {
    const {
      fn: fn2,
      dependencies
    } = fnDef(Type2);
    const Constructor = Function.prototype.bind.apply(fn2, [null].concat(dependencies));
    return new Constructor();
  }
  function invoke(func, context, locals) {
    const {
      fn: fn2,
      dependencies
    } = fnDef(func, locals);
    return fn2.apply(context, dependencies);
  }
  function createPrivateInjectorFactory(childInjector) {
    return annotate((key) => childInjector.get(key));
  }
  function createChild(modules2, forceNewInstances) {
    if (forceNewInstances && forceNewInstances.length) {
      const fromParentModule = /* @__PURE__ */ Object.create(null);
      const matchedScopes = /* @__PURE__ */ Object.create(null);
      const privateInjectorsCache = [];
      const privateChildInjectors = [];
      const privateChildFactories = [];
      let provider;
      let cacheIdx;
      let privateChildInjector;
      let privateChildInjectorFactory;
      for (let name3 in providers) {
        provider = providers[name3];
        if (forceNewInstances.indexOf(name3) !== -1) {
          if (provider[2] === "private") {
            cacheIdx = privateInjectorsCache.indexOf(provider[3]);
            if (cacheIdx === -1) {
              privateChildInjector = provider[3].createChild([], forceNewInstances);
              privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);
              privateInjectorsCache.push(provider[3]);
              privateChildInjectors.push(privateChildInjector);
              privateChildFactories.push(privateChildInjectorFactory);
              fromParentModule[name3] = [privateChildInjectorFactory, name3, "private", privateChildInjector];
            } else {
              fromParentModule[name3] = [privateChildFactories[cacheIdx], name3, "private", privateChildInjectors[cacheIdx]];
            }
          } else {
            fromParentModule[name3] = [provider[2], provider[1]];
          }
          matchedScopes[name3] = true;
        }
        if ((provider[2] === "factory" || provider[2] === "type") && provider[1].$scope) {
          forceNewInstances.forEach((scope) => {
            if (provider[1].$scope.indexOf(scope) !== -1) {
              fromParentModule[name3] = [provider[2], provider[1]];
              matchedScopes[scope] = true;
            }
          });
        }
      }
      forceNewInstances.forEach((scope) => {
        if (!matchedScopes[scope]) {
          throw new Error('No provider for "' + scope + '". Cannot use provider from the parent!');
        }
      });
      modules2.unshift(fromParentModule);
    }
    return new Injector(modules2, self2);
  }
  const factoryMap = {
    factory: invoke,
    type: instantiate,
    value: function(value) {
      return value;
    }
  };
  function createInitializer(moduleDefinition, injector) {
    const initializers = moduleDefinition.__init__ || [];
    return function() {
      initializers.forEach((initializer) => {
        if (typeof initializer === "string") {
          injector.get(initializer);
        } else {
          injector.invoke(initializer);
        }
      });
    };
  }
  function loadModule(moduleDefinition) {
    const moduleExports = moduleDefinition.__exports__;
    if (moduleExports) {
      const nestedModules = moduleDefinition.__modules__;
      const clonedModule = Object.keys(moduleDefinition).reduce((clonedModule2, key) => {
        if (key !== "__exports__" && key !== "__modules__" && key !== "__init__" && key !== "__depends__") {
          clonedModule2[key] = moduleDefinition[key];
        }
        return clonedModule2;
      }, /* @__PURE__ */ Object.create(null));
      const childModules = (nestedModules || []).concat(clonedModule);
      const privateInjector = createChild(childModules);
      const getFromPrivateInjector = annotate(function(key) {
        return privateInjector.get(key);
      });
      moduleExports.forEach(function(key) {
        providers[key] = [getFromPrivateInjector, key, "private", privateInjector];
      });
      const initializers = (moduleDefinition.__init__ || []).slice();
      initializers.unshift(function() {
        privateInjector.init();
      });
      moduleDefinition = Object.assign({}, moduleDefinition, {
        __init__: initializers
      });
      return createInitializer(moduleDefinition, privateInjector);
    }
    Object.keys(moduleDefinition).forEach(function(key) {
      if (key === "__init__" || key === "__depends__") {
        return;
      }
      if (moduleDefinition[key][2] === "private") {
        providers[key] = moduleDefinition[key];
        return;
      }
      const type = moduleDefinition[key][0];
      const value = moduleDefinition[key][1];
      providers[key] = [factoryMap[type], arrayUnwrap(type, value), type];
    });
    return createInitializer(moduleDefinition, self2);
  }
  function resolveDependencies(moduleDefinitions, moduleDefinition) {
    if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {
      return moduleDefinitions;
    }
    moduleDefinitions = (moduleDefinition.__depends__ || []).reduce(resolveDependencies, moduleDefinitions);
    if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {
      return moduleDefinitions;
    }
    return moduleDefinitions.concat(moduleDefinition);
  }
  function bootstrap2(moduleDefinitions) {
    const initializers = moduleDefinitions.reduce(resolveDependencies, []).map(loadModule);
    let initialized = false;
    return function() {
      if (initialized) {
        return;
      }
      initialized = true;
      initializers.forEach((initializer) => initializer());
    };
  }
  this.get = get4;
  this.invoke = invoke;
  this.instantiate = instantiate;
  this.createChild = createChild;
  this.init = bootstrap2(modules);
}
function arrayUnwrap(type, value) {
  if (type !== "value" && isArray8(value)) {
    value = annotate(value.slice());
  }
  return value;
}

// node_modules/diagram-js/lib/draw/DefaultRenderer.js
var import_min_dash20 = __toESM(require_dist());
var DEFAULT_RENDER_PRIORITY2 = 1;
function DefaultRenderer(eventBus, styles) {
  BaseRenderer.call(this, eventBus, DEFAULT_RENDER_PRIORITY2);
  this.CONNECTION_STYLE = styles.style(["no-fill"], { strokeWidth: 5, stroke: "fuchsia" });
  this.SHAPE_STYLE = styles.style({ fill: "white", stroke: "fuchsia", strokeWidth: 2 });
  this.FRAME_STYLE = styles.style(["no-fill"], { stroke: "fuchsia", strokeDasharray: 4, strokeWidth: 2 });
}
e(DefaultRenderer, BaseRenderer);
DefaultRenderer.prototype.canRender = function() {
  return true;
};
DefaultRenderer.prototype.drawShape = function drawShape(visuals, element, attrs) {
  var rect = create("rect");
  attr(rect, {
    x: 0,
    y: 0,
    width: element.width || 0,
    height: element.height || 0
  });
  if (isFrameElement2(element)) {
    attr(rect, (0, import_min_dash20.assign)({}, this.FRAME_STYLE, attrs || {}));
  } else {
    attr(rect, (0, import_min_dash20.assign)({}, this.SHAPE_STYLE, attrs || {}));
  }
  append(visuals, rect);
  return rect;
};
DefaultRenderer.prototype.drawConnection = function drawConnection(visuals, connection, attrs) {
  var line = createLine(connection.waypoints, (0, import_min_dash20.assign)({}, this.CONNECTION_STYLE, attrs || {}));
  append(visuals, line);
  return line;
};
DefaultRenderer.prototype.getShapePath = function getShapePath(shape) {
  var x4 = shape.x, y4 = shape.y, width = shape.width, height = shape.height;
  var shapePath = [
    ["M", x4, y4],
    ["l", width, 0],
    ["l", 0, height],
    ["l", -width, 0],
    ["z"]
  ];
  return componentsToPath(shapePath);
};
DefaultRenderer.prototype.getConnectionPath = function getConnectionPath(connection) {
  var waypoints = connection.waypoints;
  var idx, point, connectionPath = [];
  for (idx = 0; point = waypoints[idx]; idx++) {
    point = point.original || point;
    connectionPath.push([idx === 0 ? "M" : "L", point.x, point.y]);
  }
  return componentsToPath(connectionPath);
};
DefaultRenderer.$inject = ["eventBus", "styles"];

// node_modules/diagram-js/lib/draw/Styles.js
var import_min_dash21 = __toESM(require_dist());
function Styles() {
  var defaultTraits = {
    "no-fill": {
      fill: "none"
    },
    "no-border": {
      strokeOpacity: 0
    },
    "no-events": {
      pointerEvents: "none"
    }
  };
  var self2 = this;
  this.cls = function(className, traits, additionalAttrs) {
    var attrs = this.style(traits, additionalAttrs);
    return (0, import_min_dash21.assign)(attrs, { "class": className });
  };
  this.style = function(traits, additionalAttrs) {
    if (!(0, import_min_dash21.isArray)(traits) && !additionalAttrs) {
      additionalAttrs = traits;
      traits = [];
    }
    var attrs = (0, import_min_dash21.reduce)(traits, function(attrs2, t6) {
      return (0, import_min_dash21.assign)(attrs2, defaultTraits[t6] || {});
    }, {});
    return additionalAttrs ? (0, import_min_dash21.assign)(attrs, additionalAttrs) : attrs;
  };
  this.computeStyle = function(custom, traits, defaultStyles) {
    if (!(0, import_min_dash21.isArray)(traits)) {
      defaultStyles = traits;
      traits = [];
    }
    return self2.style(traits || [], (0, import_min_dash21.assign)({}, defaultStyles, custom || {}));
  };
}

// node_modules/diagram-js/lib/draw/index.js
var draw_default2 = {
  __init__: ["defaultRenderer"],
  defaultRenderer: ["type", DefaultRenderer],
  styles: ["type", Styles]
};

// node_modules/diagram-js/lib/core/Canvas.js
var import_min_dash22 = __toESM(require_dist());

// node_modules/diagram-js/lib/util/Collections.js
function remove3(collection, element) {
  if (!collection || !element) {
    return -1;
  }
  var idx = collection.indexOf(element);
  if (idx !== -1) {
    collection.splice(idx, 1);
  }
  return idx;
}
function add2(collection, element, idx) {
  if (!collection || !element) {
    return;
  }
  if (typeof idx !== "number") {
    idx = -1;
  }
  var currentIdx = collection.indexOf(element);
  if (currentIdx !== -1) {
    if (currentIdx === idx) {
      return;
    } else {
      if (idx !== -1) {
        collection.splice(currentIdx, 1);
      } else {
        return;
      }
    }
  }
  if (idx !== -1) {
    collection.splice(idx, 0, element);
  } else {
    collection.push(element);
  }
}
function indexOf(collection, element) {
  if (!collection || !element) {
    return -1;
  }
  return collection.indexOf(element);
}

// node_modules/diagram-js/lib/core/Canvas.js
function round(number, resolution) {
  return Math.round(number * resolution) / resolution;
}
function ensurePx(number) {
  return (0, import_min_dash22.isNumber)(number) ? number + "px" : number;
}
function findRoot(element) {
  while (element.parent) {
    element = element.parent;
  }
  return element;
}
function createContainer(options2) {
  options2 = (0, import_min_dash22.assign)({}, { width: "100%", height: "100%" }, options2);
  const container = options2.container || document.body;
  const parent = document.createElement("div");
  parent.setAttribute("class", "djs-container djs-parent");
  assign(parent, {
    position: "relative",
    overflow: "hidden",
    width: ensurePx(options2.width),
    height: ensurePx(options2.height)
  });
  container.appendChild(parent);
  return parent;
}
function createGroup(parent, cls, childIndex) {
  const group = create("g");
  classes(group).add(cls);
  const index2 = childIndex !== void 0 ? childIndex : parent.childNodes.length - 1;
  parent.insertBefore(group, parent.childNodes[index2] || null);
  return group;
}
var BASE_LAYER = "base";
var PLANE_LAYER_INDEX = 0;
var UTILITY_LAYER_INDEX = 1;
var REQUIRED_MODEL_ATTRS = {
  shape: ["x", "y", "width", "height"],
  connection: ["waypoints"]
};
function Canvas(config, eventBus, graphicsFactory, elementRegistry) {
  this._eventBus = eventBus;
  this._elementRegistry = elementRegistry;
  this._graphicsFactory = graphicsFactory;
  this._rootsIdx = 0;
  this._layers = {};
  this._planes = [];
  this._rootElement = null;
  this._init(config || {});
}
Canvas.$inject = [
  "config.canvas",
  "eventBus",
  "graphicsFactory",
  "elementRegistry"
];
Canvas.prototype._init = function(config) {
  const eventBus = this._eventBus;
  const container = this._container = createContainer(config);
  const svg = this._svg = create("svg");
  attr(svg, { width: "100%", height: "100%" });
  append(container, svg);
  const viewport = this._viewport = createGroup(svg, "viewport");
  if (config.deferUpdate !== false) {
    this._viewboxChanged = (0, import_min_dash22.debounce)((0, import_min_dash22.bind)(this._viewboxChanged, this), 300);
  }
  eventBus.on("diagram.init", function() {
    eventBus.fire("canvas.init", {
      svg,
      viewport
    });
  }, this);
  eventBus.on([
    "shape.added",
    "connection.added",
    "shape.removed",
    "connection.removed",
    "elements.changed",
    "root.set"
  ], function() {
    delete this._cachedViewbox;
  }, this);
  eventBus.on("diagram.destroy", 500, this._destroy, this);
  eventBus.on("diagram.clear", 500, this._clear, this);
};
Canvas.prototype._destroy = function(emit) {
  this._eventBus.fire("canvas.destroy", {
    svg: this._svg,
    viewport: this._viewport
  });
  const parent = this._container.parentNode;
  if (parent) {
    parent.removeChild(this._container);
  }
  delete this._svg;
  delete this._container;
  delete this._layers;
  delete this._planes;
  delete this._rootElement;
  delete this._viewport;
};
Canvas.prototype._clear = function() {
  const allElements = this._elementRegistry.getAll();
  allElements.forEach((element) => {
    const type = getType(element);
    if (type === "root") {
      this.removeRootElement(element);
    } else {
      this._removeElement(element, type);
    }
  });
  this._planes = [];
  this._rootElement = null;
  delete this._cachedViewbox;
};
Canvas.prototype.getDefaultLayer = function() {
  return this.getLayer(BASE_LAYER, PLANE_LAYER_INDEX);
};
Canvas.prototype.getLayer = function(name3, index2) {
  if (!name3) {
    throw new Error("must specify a name");
  }
  let layer = this._layers[name3];
  if (!layer) {
    layer = this._layers[name3] = this._createLayer(name3, index2);
  }
  if (typeof index2 !== "undefined" && layer.index !== index2) {
    throw new Error("layer <" + name3 + "> already created at index <" + index2 + ">");
  }
  return layer.group;
};
Canvas.prototype._getChildIndex = function(index2) {
  return (0, import_min_dash22.reduce)(this._layers, function(childIndex, layer) {
    if (layer.visible && index2 >= layer.index) {
      childIndex++;
    }
    return childIndex;
  }, 0);
};
Canvas.prototype._createLayer = function(name3, index2) {
  if (typeof index2 === "undefined") {
    index2 = UTILITY_LAYER_INDEX;
  }
  const childIndex = this._getChildIndex(index2);
  return {
    group: createGroup(this._viewport, "layer-" + name3, childIndex),
    index: index2,
    visible: true
  };
};
Canvas.prototype.showLayer = function(name3) {
  if (!name3) {
    throw new Error("must specify a name");
  }
  const layer = this._layers[name3];
  if (!layer) {
    throw new Error("layer <" + name3 + "> does not exist");
  }
  const viewport = this._viewport;
  const group = layer.group;
  const index2 = layer.index;
  if (layer.visible) {
    return group;
  }
  const childIndex = this._getChildIndex(index2);
  viewport.insertBefore(group, viewport.childNodes[childIndex] || null);
  layer.visible = true;
  return group;
};
Canvas.prototype.hideLayer = function(name3) {
  if (!name3) {
    throw new Error("must specify a name");
  }
  const layer = this._layers[name3];
  if (!layer) {
    throw new Error("layer <" + name3 + "> does not exist");
  }
  const group = layer.group;
  if (!layer.visible) {
    return group;
  }
  remove(group);
  layer.visible = false;
  return group;
};
Canvas.prototype._removeLayer = function(name3) {
  const layer = this._layers[name3];
  if (layer) {
    delete this._layers[name3];
    remove(layer.group);
  }
};
Canvas.prototype.getActiveLayer = function() {
  const plane = this._findPlaneForRoot(this.getRootElement());
  if (!plane) {
    return null;
  }
  return plane.layer;
};
Canvas.prototype.findRoot = function(element) {
  if (typeof element === "string") {
    element = this._elementRegistry.get(element);
  }
  if (!element) {
    return;
  }
  const plane = this._findPlaneForRoot(findRoot(element)) || {};
  return plane.rootElement;
};
Canvas.prototype.getRootElements = function() {
  return this._planes.map(function(plane) {
    return plane.rootElement;
  });
};
Canvas.prototype._findPlaneForRoot = function(rootElement) {
  return (0, import_min_dash22.find)(this._planes, function(plane) {
    return plane.rootElement === rootElement;
  });
};
Canvas.prototype.getContainer = function() {
  return this._container;
};
Canvas.prototype._updateMarker = function(element, marker, add3) {
  let container;
  if (!element.id) {
    element = this._elementRegistry.get(element);
  }
  container = this._elementRegistry._elements[element.id];
  if (!container) {
    return;
  }
  (0, import_min_dash22.forEach)([container.gfx, container.secondaryGfx], function(gfx) {
    if (gfx) {
      if (add3) {
        classes(gfx).add(marker);
      } else {
        classes(gfx).remove(marker);
      }
    }
  });
  this._eventBus.fire("element.marker.update", { element, gfx: container.gfx, marker, add: !!add3 });
};
Canvas.prototype.addMarker = function(element, marker) {
  this._updateMarker(element, marker, true);
};
Canvas.prototype.removeMarker = function(element, marker) {
  this._updateMarker(element, marker, false);
};
Canvas.prototype.hasMarker = function(element, marker) {
  if (!element.id) {
    element = this._elementRegistry.get(element);
  }
  const gfx = this.getGraphics(element);
  return classes(gfx).has(marker);
};
Canvas.prototype.toggleMarker = function(element, marker) {
  if (this.hasMarker(element, marker)) {
    this.removeMarker(element, marker);
  } else {
    this.addMarker(element, marker);
  }
};
Canvas.prototype.getRootElement = function() {
  const rootElement = this._rootElement;
  if (rootElement || this._planes.length) {
    return rootElement;
  }
  return this.setRootElement(this.addRootElement(null));
};
Canvas.prototype.addRootElement = function(rootElement) {
  const idx = this._rootsIdx++;
  if (!rootElement) {
    rootElement = {
      id: "__implicitroot_" + idx,
      children: [],
      isImplicit: true
    };
  }
  const layerName = rootElement.layer = "root-" + idx;
  this._ensureValid("root", rootElement);
  const layer = this.getLayer(layerName, PLANE_LAYER_INDEX);
  this.hideLayer(layerName);
  this._addRoot(rootElement, layer);
  this._planes.push({
    rootElement,
    layer
  });
  return rootElement;
};
Canvas.prototype.removeRootElement = function(rootElement) {
  if (typeof rootElement === "string") {
    rootElement = this._elementRegistry.get(rootElement);
  }
  const plane = this._findPlaneForRoot(rootElement);
  if (!plane) {
    return;
  }
  this._removeRoot(rootElement);
  this._removeLayer(rootElement.layer);
  this._planes = this._planes.filter(function(plane2) {
    return plane2.rootElement !== rootElement;
  });
  if (this._rootElement === rootElement) {
    this._rootElement = null;
  }
  return rootElement;
};
Canvas.prototype.setRootElement = function(rootElement, override) {
  if ((0, import_min_dash22.isDefined)(override)) {
    throw new Error("override not supported");
  }
  if (rootElement === this._rootElement) {
    return;
  }
  let plane;
  if (!rootElement) {
    throw new Error("rootElement required");
  }
  plane = this._findPlaneForRoot(rootElement);
  if (!plane) {
    rootElement = this.addRootElement(rootElement);
  }
  this._setRoot(rootElement);
  return rootElement;
};
Canvas.prototype._removeRoot = function(element) {
  const elementRegistry = this._elementRegistry, eventBus = this._eventBus;
  eventBus.fire("root.remove", { element });
  eventBus.fire("root.removed", { element });
  elementRegistry.remove(element);
};
Canvas.prototype._addRoot = function(element, gfx) {
  const elementRegistry = this._elementRegistry, eventBus = this._eventBus;
  eventBus.fire("root.add", { element });
  elementRegistry.add(element, gfx);
  eventBus.fire("root.added", { element, gfx });
};
Canvas.prototype._setRoot = function(rootElement, layer) {
  const currentRoot = this._rootElement;
  if (currentRoot) {
    this._elementRegistry.updateGraphics(currentRoot, null, true);
    this.hideLayer(currentRoot.layer);
  }
  if (rootElement) {
    if (!layer) {
      layer = this._findPlaneForRoot(rootElement).layer;
    }
    this._elementRegistry.updateGraphics(rootElement, this._svg, true);
    this.showLayer(rootElement.layer);
  }
  this._rootElement = rootElement;
  this._eventBus.fire("root.set", { element: rootElement });
};
Canvas.prototype._ensureValid = function(type, element) {
  if (!element.id) {
    throw new Error("element must have an id");
  }
  if (this._elementRegistry.get(element.id)) {
    throw new Error("element <" + element.id + "> already exists");
  }
  const requiredAttrs = REQUIRED_MODEL_ATTRS[type];
  const valid = (0, import_min_dash22.every)(requiredAttrs, function(attr3) {
    return typeof element[attr3] !== "undefined";
  });
  if (!valid) {
    throw new Error("must supply { " + requiredAttrs.join(", ") + " } with " + type);
  }
};
Canvas.prototype._setParent = function(element, parent, parentIndex) {
  add2(parent.children, element, parentIndex);
  element.parent = parent;
};
Canvas.prototype._addElement = function(type, element, parent, parentIndex) {
  parent = parent || this.getRootElement();
  const eventBus = this._eventBus, graphicsFactory = this._graphicsFactory;
  this._ensureValid(type, element);
  eventBus.fire(type + ".add", { element, parent });
  this._setParent(element, parent, parentIndex);
  const gfx = graphicsFactory.create(type, element, parentIndex);
  this._elementRegistry.add(element, gfx);
  graphicsFactory.update(type, element, gfx);
  eventBus.fire(type + ".added", { element, gfx });
  return element;
};
Canvas.prototype.addShape = function(shape, parent, parentIndex) {
  return this._addElement("shape", shape, parent, parentIndex);
};
Canvas.prototype.addConnection = function(connection, parent, parentIndex) {
  return this._addElement("connection", connection, parent, parentIndex);
};
Canvas.prototype._removeElement = function(element, type) {
  const elementRegistry = this._elementRegistry, graphicsFactory = this._graphicsFactory, eventBus = this._eventBus;
  element = elementRegistry.get(element.id || element);
  if (!element) {
    return;
  }
  eventBus.fire(type + ".remove", { element });
  graphicsFactory.remove(element);
  remove3(element.parent && element.parent.children, element);
  element.parent = null;
  eventBus.fire(type + ".removed", { element });
  elementRegistry.remove(element);
  return element;
};
Canvas.prototype.removeShape = function(shape) {
  return this._removeElement(shape, "shape");
};
Canvas.prototype.removeConnection = function(connection) {
  return this._removeElement(connection, "connection");
};
Canvas.prototype.getGraphics = function(element, secondary) {
  return this._elementRegistry.getGraphics(element, secondary);
};
Canvas.prototype._changeViewbox = function(changeFn) {
  this._eventBus.fire("canvas.viewbox.changing");
  changeFn.apply(this);
  this._cachedViewbox = null;
  this._viewboxChanged();
};
Canvas.prototype._viewboxChanged = function() {
  this._eventBus.fire("canvas.viewbox.changed", { viewbox: this.viewbox() });
};
Canvas.prototype.viewbox = function(box) {
  if (box === void 0 && this._cachedViewbox) {
    return this._cachedViewbox;
  }
  const viewport = this._viewport, outerBox = this.getSize();
  let innerBox, matrix, activeLayer, transform3, scale, x4, y4;
  if (!box) {
    activeLayer = this._rootElement ? this.getActiveLayer() : null;
    innerBox = activeLayer && activeLayer.getBBox() || {};
    transform3 = transform(viewport);
    matrix = transform3 ? transform3.matrix : createMatrix();
    scale = round(matrix.a, 1e3);
    x4 = round(-matrix.e || 0, 1e3);
    y4 = round(-matrix.f || 0, 1e3);
    box = this._cachedViewbox = {
      x: x4 ? x4 / scale : 0,
      y: y4 ? y4 / scale : 0,
      width: outerBox.width / scale,
      height: outerBox.height / scale,
      scale,
      inner: {
        width: innerBox.width || 0,
        height: innerBox.height || 0,
        x: innerBox.x || 0,
        y: innerBox.y || 0
      },
      outer: outerBox
    };
    return box;
  } else {
    this._changeViewbox(function() {
      scale = Math.min(outerBox.width / box.width, outerBox.height / box.height);
      const matrix2 = this._svg.createSVGMatrix().scale(scale).translate(-box.x, -box.y);
      transform(viewport, matrix2);
    });
  }
  return box;
};
Canvas.prototype.scroll = function(delta2) {
  const node2 = this._viewport;
  let matrix = node2.getCTM();
  if (delta2) {
    this._changeViewbox(function() {
      delta2 = (0, import_min_dash22.assign)({ dx: 0, dy: 0 }, delta2 || {});
      matrix = this._svg.createSVGMatrix().translate(delta2.dx, delta2.dy).multiply(matrix);
      setCTM(node2, matrix);
    });
  }
  return { x: matrix.e, y: matrix.f };
};
Canvas.prototype.scrollToElement = function(element, padding) {
  let defaultPadding = 100;
  if (typeof element === "string") {
    element = this._elementRegistry.get(element);
  }
  const rootElement = this.findRoot(element);
  if (rootElement !== this.getRootElement()) {
    this.setRootElement(rootElement);
  }
  if (!padding) {
    padding = {};
  }
  if (typeof padding === "number") {
    defaultPadding = padding;
  }
  padding = {
    top: padding.top || defaultPadding,
    right: padding.right || defaultPadding,
    bottom: padding.bottom || defaultPadding,
    left: padding.left || defaultPadding
  };
  const elementBounds = getBBox(element), elementTrbl = asTRBL(elementBounds), viewboxBounds = this.viewbox(), zoom2 = this.zoom();
  let dx, dy;
  viewboxBounds.y += padding.top / zoom2;
  viewboxBounds.x += padding.left / zoom2;
  viewboxBounds.width -= (padding.right + padding.left) / zoom2;
  viewboxBounds.height -= (padding.bottom + padding.top) / zoom2;
  const viewboxTrbl = asTRBL(viewboxBounds);
  const canFit = elementBounds.width < viewboxBounds.width && elementBounds.height < viewboxBounds.height;
  if (!canFit) {
    dx = elementBounds.x - viewboxBounds.x;
    dy = elementBounds.y - viewboxBounds.y;
  } else {
    const dRight = Math.max(0, elementTrbl.right - viewboxTrbl.right), dLeft = Math.min(0, elementTrbl.left - viewboxTrbl.left), dBottom = Math.max(0, elementTrbl.bottom - viewboxTrbl.bottom), dTop = Math.min(0, elementTrbl.top - viewboxTrbl.top);
    dx = dRight || dLeft;
    dy = dBottom || dTop;
  }
  this.scroll({ dx: -dx * zoom2, dy: -dy * zoom2 });
};
Canvas.prototype.zoom = function(newScale, center2) {
  if (!newScale) {
    return this.viewbox(newScale).scale;
  }
  if (newScale === "fit-viewport") {
    return this._fitViewport(center2);
  }
  let outer, matrix;
  this._changeViewbox(function() {
    if (typeof center2 !== "object") {
      outer = this.viewbox().outer;
      center2 = {
        x: outer.width / 2,
        y: outer.height / 2
      };
    }
    matrix = this._setZoom(newScale, center2);
  });
  return round(matrix.a, 1e3);
};
function setCTM(node2, m6) {
  const mstr = "matrix(" + m6.a + "," + m6.b + "," + m6.c + "," + m6.d + "," + m6.e + "," + m6.f + ")";
  node2.setAttribute("transform", mstr);
}
Canvas.prototype._fitViewport = function(center2) {
  const vbox = this.viewbox(), outer = vbox.outer, inner = vbox.inner;
  let newScale, newViewbox;
  if (inner.x >= 0 && inner.y >= 0 && inner.x + inner.width <= outer.width && inner.y + inner.height <= outer.height && !center2) {
    newViewbox = {
      x: 0,
      y: 0,
      width: Math.max(inner.width + inner.x, outer.width),
      height: Math.max(inner.height + inner.y, outer.height)
    };
  } else {
    newScale = Math.min(1, outer.width / inner.width, outer.height / inner.height);
    newViewbox = {
      x: inner.x + (center2 ? inner.width / 2 - outer.width / newScale / 2 : 0),
      y: inner.y + (center2 ? inner.height / 2 - outer.height / newScale / 2 : 0),
      width: outer.width / newScale,
      height: outer.height / newScale
    };
  }
  this.viewbox(newViewbox);
  return this.viewbox(false).scale;
};
Canvas.prototype._setZoom = function(scale, center2) {
  const svg = this._svg, viewport = this._viewport;
  const matrix = svg.createSVGMatrix();
  const point = svg.createSVGPoint();
  let centerPoint, originalPoint, currentMatrix, scaleMatrix, newMatrix;
  currentMatrix = viewport.getCTM();
  const currentScale = currentMatrix.a;
  if (center2) {
    centerPoint = (0, import_min_dash22.assign)(point, center2);
    originalPoint = centerPoint.matrixTransform(currentMatrix.inverse());
    scaleMatrix = matrix.translate(originalPoint.x, originalPoint.y).scale(1 / currentScale * scale).translate(-originalPoint.x, -originalPoint.y);
    newMatrix = currentMatrix.multiply(scaleMatrix);
  } else {
    newMatrix = matrix.scale(scale);
  }
  setCTM(this._viewport, newMatrix);
  return newMatrix;
};
Canvas.prototype.getSize = function() {
  return {
    width: this._container.clientWidth,
    height: this._container.clientHeight
  };
};
Canvas.prototype.getAbsoluteBBox = function(element) {
  const vbox = this.viewbox();
  let bbox;
  if (element.waypoints) {
    const gfx = this.getGraphics(element);
    bbox = gfx.getBBox();
  } else {
    bbox = element;
  }
  const x4 = bbox.x * vbox.scale - vbox.x * vbox.scale;
  const y4 = bbox.y * vbox.scale - vbox.y * vbox.scale;
  const width = bbox.width * vbox.scale;
  const height = bbox.height * vbox.scale;
  return {
    x: x4,
    y: y4,
    width,
    height
  };
};
Canvas.prototype.resized = function() {
  delete this._cachedViewbox;
  this._eventBus.fire("canvas.resized");
};

// node_modules/diagram-js/lib/core/ElementRegistry.js
var ELEMENT_ID = "data-element-id";
function ElementRegistry(eventBus) {
  this._elements = {};
  this._eventBus = eventBus;
}
ElementRegistry.$inject = ["eventBus"];
ElementRegistry.prototype.add = function(element, gfx, secondaryGfx) {
  var id = element.id;
  this._validateId(id);
  attr(gfx, ELEMENT_ID, id);
  if (secondaryGfx) {
    attr(secondaryGfx, ELEMENT_ID, id);
  }
  this._elements[id] = { element, gfx, secondaryGfx };
};
ElementRegistry.prototype.remove = function(element) {
  var elements = this._elements, id = element.id || element, container = id && elements[id];
  if (container) {
    attr(container.gfx, ELEMENT_ID, "");
    if (container.secondaryGfx) {
      attr(container.secondaryGfx, ELEMENT_ID, "");
    }
    delete elements[id];
  }
};
ElementRegistry.prototype.updateId = function(element, newId) {
  this._validateId(newId);
  if (typeof element === "string") {
    element = this.get(element);
  }
  this._eventBus.fire("element.updateId", {
    element,
    newId
  });
  var gfx = this.getGraphics(element), secondaryGfx = this.getGraphics(element, true);
  this.remove(element);
  element.id = newId;
  this.add(element, gfx, secondaryGfx);
};
ElementRegistry.prototype.updateGraphics = function(filter28, gfx, secondary) {
  var id = filter28.id || filter28;
  var container = this._elements[id];
  if (secondary) {
    container.secondaryGfx = gfx;
  } else {
    container.gfx = gfx;
  }
  if (gfx) {
    attr(gfx, ELEMENT_ID, id);
  }
  return gfx;
};
ElementRegistry.prototype.get = function(filter28) {
  var id;
  if (typeof filter28 === "string") {
    id = filter28;
  } else {
    id = filter28 && attr(filter28, ELEMENT_ID);
  }
  var container = this._elements[id];
  return container && container.element;
};
ElementRegistry.prototype.filter = function(fn2) {
  var filtered = [];
  this.forEach(function(element, gfx) {
    if (fn2(element, gfx)) {
      filtered.push(element);
    }
  });
  return filtered;
};
ElementRegistry.prototype.find = function(fn2) {
  var map14 = this._elements, keys4 = Object.keys(map14);
  for (var i6 = 0; i6 < keys4.length; i6++) {
    var id = keys4[i6], container = map14[id], element = container.element, gfx = container.gfx;
    if (fn2(element, gfx)) {
      return element;
    }
  }
};
ElementRegistry.prototype.getAll = function() {
  return this.filter(function(e7) {
    return e7;
  });
};
ElementRegistry.prototype.forEach = function(fn2) {
  var map14 = this._elements;
  Object.keys(map14).forEach(function(id) {
    var container = map14[id], element = container.element, gfx = container.gfx;
    return fn2(element, gfx);
  });
};
ElementRegistry.prototype.getGraphics = function(filter28, secondary) {
  var id = filter28.id || filter28;
  var container = this._elements[id];
  return container && (secondary ? container.secondaryGfx : container.gfx);
};
ElementRegistry.prototype._validateId = function(id) {
  if (!id) {
    throw new Error("element must have an id");
  }
  if (this._elements[id]) {
    throw new Error("element with id " + id + " already added");
  }
};

// node_modules/diagram-js/lib/model/index.js
var import_min_dash23 = __toESM(require_dist());
var import_object_refs = __toESM(require_object_refs());
var parentRefs = new import_object_refs.default({ name: "children", enumerable: true, collection: true }, { name: "parent" });
var labelRefs = new import_object_refs.default({ name: "labels", enumerable: true, collection: true }, { name: "labelTarget" });
var attacherRefs = new import_object_refs.default({ name: "attachers", collection: true }, { name: "host" });
var outgoingRefs = new import_object_refs.default({ name: "outgoing", collection: true }, { name: "source" });
var incomingRefs = new import_object_refs.default({ name: "incoming", collection: true }, { name: "target" });
function Base() {
  Object.defineProperty(this, "businessObject", {
    writable: true
  });
  Object.defineProperty(this, "label", {
    get: function() {
      return this.labels[0];
    },
    set: function(newLabel) {
      var label = this.label, labels = this.labels;
      if (!newLabel && label) {
        labels.remove(label);
      } else {
        labels.add(newLabel, 0);
      }
    }
  });
  parentRefs.bind(this, "parent");
  labelRefs.bind(this, "labels");
  outgoingRefs.bind(this, "outgoing");
  incomingRefs.bind(this, "incoming");
}
function Shape() {
  Base.call(this);
  parentRefs.bind(this, "children");
  attacherRefs.bind(this, "host");
  attacherRefs.bind(this, "attachers");
}
e(Shape, Base);
function Root() {
  Shape.call(this);
}
e(Root, Shape);
function Label() {
  Shape.call(this);
  labelRefs.bind(this, "labelTarget");
}
e(Label, Shape);
function Connection() {
  Base.call(this);
  outgoingRefs.bind(this, "source");
  incomingRefs.bind(this, "target");
}
e(Connection, Base);
var types = {
  connection: Connection,
  shape: Shape,
  label: Label,
  root: Root
};
function create2(type, attrs) {
  var Type2 = types[type];
  if (!Type2) {
    throw new Error("unknown type: <" + type + ">");
  }
  return (0, import_min_dash23.assign)(new Type2(), attrs);
}

// node_modules/diagram-js/lib/core/ElementFactory.js
var import_min_dash24 = __toESM(require_dist());
function ElementFactory() {
  this._uid = 12;
}
ElementFactory.prototype.createRoot = function(attrs) {
  return this.create("root", attrs);
};
ElementFactory.prototype.createLabel = function(attrs) {
  return this.create("label", attrs);
};
ElementFactory.prototype.createShape = function(attrs) {
  return this.create("shape", attrs);
};
ElementFactory.prototype.createConnection = function(attrs) {
  return this.create("connection", attrs);
};
ElementFactory.prototype.create = function(type, attrs) {
  attrs = (0, import_min_dash24.assign)({}, attrs || {});
  if (!attrs.id) {
    attrs.id = type + "_" + this._uid++;
  }
  return create2(type, attrs);
};

// node_modules/diagram-js/lib/core/EventBus.js
var import_min_dash25 = __toESM(require_dist());
var FN_REF = "__fn";
var DEFAULT_PRIORITY2 = 1e3;
var slice2 = Array.prototype.slice;
function EventBus() {
  this._listeners = {};
  this.on("diagram.destroy", 1, this._destroy, this);
}
EventBus.prototype.on = function(events, priority, callback, that) {
  events = (0, import_min_dash25.isArray)(events) ? events : [events];
  if ((0, import_min_dash25.isFunction)(priority)) {
    that = callback;
    callback = priority;
    priority = DEFAULT_PRIORITY2;
  }
  if (!(0, import_min_dash25.isNumber)(priority)) {
    throw new Error("priority must be a number");
  }
  var actualCallback = callback;
  if (that) {
    actualCallback = (0, import_min_dash25.bind)(callback, that);
    actualCallback[FN_REF] = callback[FN_REF] || callback;
  }
  var self2 = this;
  events.forEach(function(e7) {
    self2._addListener(e7, {
      priority,
      callback: actualCallback,
      next: null
    });
  });
};
EventBus.prototype.once = function(event2, priority, callback, that) {
  var self2 = this;
  if ((0, import_min_dash25.isFunction)(priority)) {
    that = callback;
    callback = priority;
    priority = DEFAULT_PRIORITY2;
  }
  if (!(0, import_min_dash25.isNumber)(priority)) {
    throw new Error("priority must be a number");
  }
  function wrappedCallback() {
    wrappedCallback.__isTomb = true;
    var result = callback.apply(that, arguments);
    self2.off(event2, wrappedCallback);
    return result;
  }
  wrappedCallback[FN_REF] = callback;
  this.on(event2, priority, wrappedCallback);
};
EventBus.prototype.off = function(events, callback) {
  events = (0, import_min_dash25.isArray)(events) ? events : [events];
  var self2 = this;
  events.forEach(function(event2) {
    self2._removeListener(event2, callback);
  });
};
EventBus.prototype.createEvent = function(data) {
  var event2 = new InternalEvent();
  event2.init(data);
  return event2;
};
EventBus.prototype.fire = function(type, data) {
  var event2, firstListener, returnValue, args;
  args = slice2.call(arguments);
  if (typeof type === "object") {
    data = type;
    type = data.type;
  }
  if (!type) {
    throw new Error("no event type specified");
  }
  firstListener = this._listeners[type];
  if (!firstListener) {
    return;
  }
  if (data instanceof InternalEvent) {
    event2 = data;
  } else {
    event2 = this.createEvent(data);
  }
  args[0] = event2;
  var originalType = event2.type;
  if (type !== originalType) {
    event2.type = type;
  }
  try {
    returnValue = this._invokeListeners(event2, args, firstListener);
  } finally {
    if (type !== originalType) {
      event2.type = originalType;
    }
  }
  if (returnValue === void 0 && event2.defaultPrevented) {
    returnValue = false;
  }
  return returnValue;
};
EventBus.prototype.handleError = function(error4) {
  return this.fire("error", { error: error4 }) === false;
};
EventBus.prototype._destroy = function() {
  this._listeners = {};
};
EventBus.prototype._invokeListeners = function(event2, args, listener) {
  var returnValue;
  while (listener) {
    if (event2.cancelBubble) {
      break;
    }
    returnValue = this._invokeListener(event2, args, listener);
    listener = listener.next;
  }
  return returnValue;
};
EventBus.prototype._invokeListener = function(event2, args, listener) {
  var returnValue;
  if (listener.callback.__isTomb) {
    return returnValue;
  }
  try {
    returnValue = invokeFunction(listener.callback, args);
    if (returnValue !== void 0) {
      event2.returnValue = returnValue;
      event2.stopPropagation();
    }
    if (returnValue === false) {
      event2.preventDefault();
    }
  } catch (error4) {
    if (!this.handleError(error4)) {
      console.error("unhandled error in event listener", error4);
      throw error4;
    }
  }
  return returnValue;
};
EventBus.prototype._addListener = function(event2, newListener) {
  var listener = this._getListeners(event2), previousListener;
  if (!listener) {
    this._setListeners(event2, newListener);
    return;
  }
  while (listener) {
    if (listener.priority < newListener.priority) {
      newListener.next = listener;
      if (previousListener) {
        previousListener.next = newListener;
      } else {
        this._setListeners(event2, newListener);
      }
      return;
    }
    previousListener = listener;
    listener = listener.next;
  }
  previousListener.next = newListener;
};
EventBus.prototype._getListeners = function(name3) {
  return this._listeners[name3];
};
EventBus.prototype._setListeners = function(name3, listener) {
  this._listeners[name3] = listener;
};
EventBus.prototype._removeListener = function(event2, callback) {
  var listener = this._getListeners(event2), nextListener, previousListener, listenerCallback;
  if (!callback) {
    this._setListeners(event2, null);
    return;
  }
  while (listener) {
    nextListener = listener.next;
    listenerCallback = listener.callback;
    if (listenerCallback === callback || listenerCallback[FN_REF] === callback) {
      if (previousListener) {
        previousListener.next = nextListener;
      } else {
        this._setListeners(event2, nextListener);
      }
    }
    previousListener = listener;
    listener = nextListener;
  }
};
function InternalEvent() {
}
InternalEvent.prototype.stopPropagation = function() {
  this.cancelBubble = true;
};
InternalEvent.prototype.preventDefault = function() {
  this.defaultPrevented = true;
};
InternalEvent.prototype.init = function(data) {
  (0, import_min_dash25.assign)(this, data || {});
};
function invokeFunction(fn2, args) {
  return fn2.apply(null, args);
}

// node_modules/diagram-js/lib/core/GraphicsFactory.js
var import_min_dash26 = __toESM(require_dist());

// node_modules/diagram-js/lib/util/GraphicsUtil.js
function getVisual(gfx) {
  return gfx.childNodes[0];
}
function getChildren(gfx) {
  return gfx.parentNode.childNodes[1];
}

// node_modules/diagram-js/lib/core/GraphicsFactory.js
function GraphicsFactory(eventBus, elementRegistry) {
  this._eventBus = eventBus;
  this._elementRegistry = elementRegistry;
}
GraphicsFactory.$inject = ["eventBus", "elementRegistry"];
GraphicsFactory.prototype._getChildrenContainer = function(element) {
  var gfx = this._elementRegistry.getGraphics(element);
  var childrenGfx;
  if (!element.parent) {
    childrenGfx = gfx;
  } else {
    childrenGfx = getChildren(gfx);
    if (!childrenGfx) {
      childrenGfx = create("g");
      classes(childrenGfx).add("djs-children");
      append(gfx.parentNode, childrenGfx);
    }
  }
  return childrenGfx;
};
GraphicsFactory.prototype._clear = function(gfx) {
  var visual = getVisual(gfx);
  clear2(visual);
  return visual;
};
GraphicsFactory.prototype._createContainer = function(type, childrenGfx, parentIndex, isFrame) {
  var outerGfx = create("g");
  classes(outerGfx).add("djs-group");
  if (typeof parentIndex !== "undefined") {
    prependTo(outerGfx, childrenGfx, childrenGfx.childNodes[parentIndex]);
  } else {
    append(childrenGfx, outerGfx);
  }
  var gfx = create("g");
  classes(gfx).add("djs-element");
  classes(gfx).add("djs-" + type);
  if (isFrame) {
    classes(gfx).add("djs-frame");
  }
  append(outerGfx, gfx);
  var visual = create("g");
  classes(visual).add("djs-visual");
  append(gfx, visual);
  return gfx;
};
GraphicsFactory.prototype.create = function(type, element, parentIndex) {
  var childrenGfx = this._getChildrenContainer(element.parent);
  return this._createContainer(type, childrenGfx, parentIndex, isFrameElement2(element));
};
GraphicsFactory.prototype.updateContainments = function(elements) {
  var self2 = this, elementRegistry = this._elementRegistry, parents;
  parents = (0, import_min_dash26.reduce)(elements, function(map14, e7) {
    if (e7.parent) {
      map14[e7.parent.id] = e7.parent;
    }
    return map14;
  }, {});
  (0, import_min_dash26.forEach)(parents, function(parent) {
    var children = parent.children;
    if (!children) {
      return;
    }
    var childrenGfx = self2._getChildrenContainer(parent);
    (0, import_min_dash26.forEach)(children.slice().reverse(), function(child) {
      var childGfx = elementRegistry.getGraphics(child);
      prependTo(childGfx.parentNode, childrenGfx);
    });
  });
};
GraphicsFactory.prototype.drawShape = function(visual, element) {
  var eventBus = this._eventBus;
  return eventBus.fire("render.shape", { gfx: visual, element });
};
GraphicsFactory.prototype.getShapePath = function(element) {
  var eventBus = this._eventBus;
  return eventBus.fire("render.getShapePath", element);
};
GraphicsFactory.prototype.drawConnection = function(visual, element) {
  var eventBus = this._eventBus;
  return eventBus.fire("render.connection", { gfx: visual, element });
};
GraphicsFactory.prototype.getConnectionPath = function(waypoints) {
  var eventBus = this._eventBus;
  return eventBus.fire("render.getConnectionPath", waypoints);
};
GraphicsFactory.prototype.update = function(type, element, gfx) {
  if (!element.parent) {
    return;
  }
  var visual = this._clear(gfx);
  if (type === "shape") {
    this.drawShape(visual, element);
    translate(gfx, element.x, element.y);
  } else if (type === "connection") {
    this.drawConnection(visual, element);
  } else {
    throw new Error("unknown type: " + type);
  }
  if (element.hidden) {
    attr(gfx, "display", "none");
  } else {
    attr(gfx, "display", "block");
  }
};
GraphicsFactory.prototype.remove = function(element) {
  var gfx = this._elementRegistry.getGraphics(element);
  remove(gfx.parentNode);
};
function prependTo(newNode, parentNode, siblingNode) {
  var node2 = siblingNode || parentNode.firstChild;
  if (newNode === node2) {
    return;
  }
  parentNode.insertBefore(newNode, node2);
}

// node_modules/diagram-js/lib/core/index.js
var core_default2 = {
  __depends__: [draw_default2],
  __init__: ["canvas"],
  canvas: ["type", Canvas],
  elementRegistry: ["type", ElementRegistry],
  elementFactory: ["type", ElementFactory],
  eventBus: ["type", EventBus],
  graphicsFactory: ["type", GraphicsFactory]
};

// node_modules/diagram-js/lib/Diagram.js
function bootstrap(modules) {
  var injector = new Injector(modules);
  injector.init();
  return injector;
}
function createInjector(options2) {
  options2 = options2 || {};
  var configModule = {
    "config": ["value", options2]
  };
  var modules = [configModule, core_default2].concat(options2.modules || []);
  return bootstrap(modules);
}
function Diagram(options2, injector) {
  this.injector = injector = injector || createInjector(options2);
  this.get = injector.get;
  this.invoke = injector.invoke;
  this.get("eventBus").fire("diagram.init");
}
Diagram.prototype.destroy = function() {
  this.get("eventBus").fire("diagram.destroy");
};
Diagram.prototype.clear = function() {
  this.get("eventBus").fire("diagram.clear");
};

// node_modules/bpmn-moddle/dist/index.esm.js
var import_min_dash29 = __toESM(require_dist(), 1);

// node_modules/moddle/dist/index.esm.js
var import_min_dash27 = __toESM(require_dist(), 1);
function Base2() {
}
Base2.prototype.get = function(name3) {
  return this.$model.properties.get(this, name3);
};
Base2.prototype.set = function(name3, value) {
  this.$model.properties.set(this, name3, value);
};
function Factory(model, properties) {
  this.model = model;
  this.properties = properties;
}
Factory.prototype.createType = function(descriptor) {
  var model = this.model;
  var props = this.properties, prototype = Object.create(Base2.prototype);
  (0, import_min_dash27.forEach)(descriptor.properties, function(p6) {
    if (!p6.isMany && p6.default !== void 0) {
      prototype[p6.name] = p6.default;
    }
  });
  props.defineModel(prototype, model);
  props.defineDescriptor(prototype, descriptor);
  var name3 = descriptor.ns.name;
  function ModdleElement(attrs) {
    props.define(this, "$type", { value: name3, enumerable: true });
    props.define(this, "$attrs", { value: {} });
    props.define(this, "$parent", { writable: true });
    (0, import_min_dash27.forEach)(attrs, (0, import_min_dash27.bind)(function(val, key) {
      this.set(key, val);
    }, this));
  }
  ModdleElement.prototype = prototype;
  ModdleElement.hasType = prototype.$instanceOf = this.model.hasType;
  props.defineModel(ModdleElement, model);
  props.defineDescriptor(ModdleElement, descriptor);
  return ModdleElement;
};
var BUILTINS = {
  String: true,
  Boolean: true,
  Integer: true,
  Real: true,
  Element: true
};
var TYPE_CONVERTERS = {
  String: function(s5) {
    return s5;
  },
  Boolean: function(s5) {
    return s5 === "true";
  },
  Integer: function(s5) {
    return parseInt(s5, 10);
  },
  Real: function(s5) {
    return parseFloat(s5);
  }
};
function coerceType(type, value) {
  var converter = TYPE_CONVERTERS[type];
  if (converter) {
    return converter(value);
  } else {
    return value;
  }
}
function isBuiltIn(type) {
  return !!BUILTINS[type];
}
function isSimple(type) {
  return !!TYPE_CONVERTERS[type];
}
function parseName(name3, defaultPrefix) {
  var parts = name3.split(/:/), localName, prefix3;
  if (parts.length === 1) {
    localName = name3;
    prefix3 = defaultPrefix;
  } else if (parts.length === 2) {
    localName = parts[1];
    prefix3 = parts[0];
  } else {
    throw new Error("expected <prefix:localName> or <localName>, got " + name3);
  }
  name3 = (prefix3 ? prefix3 + ":" : "") + localName;
  return {
    name: name3,
    prefix: prefix3,
    localName
  };
}
function DescriptorBuilder(nameNs) {
  this.ns = nameNs;
  this.name = nameNs.name;
  this.allTypes = [];
  this.allTypesByName = {};
  this.properties = [];
  this.propertiesByName = {};
}
DescriptorBuilder.prototype.build = function() {
  return (0, import_min_dash27.pick)(this, [
    "ns",
    "name",
    "allTypes",
    "allTypesByName",
    "properties",
    "propertiesByName",
    "bodyProperty",
    "idProperty"
  ]);
};
DescriptorBuilder.prototype.addProperty = function(p6, idx, validate3) {
  if (typeof idx === "boolean") {
    validate3 = idx;
    idx = void 0;
  }
  this.addNamedProperty(p6, validate3 !== false);
  var properties = this.properties;
  if (idx !== void 0) {
    properties.splice(idx, 0, p6);
  } else {
    properties.push(p6);
  }
};
DescriptorBuilder.prototype.replaceProperty = function(oldProperty, newProperty, replace) {
  var oldNameNs = oldProperty.ns;
  var props = this.properties, propertiesByName = this.propertiesByName, rename = oldProperty.name !== newProperty.name;
  if (oldProperty.isId) {
    if (!newProperty.isId) {
      throw new Error("property <" + newProperty.ns.name + "> must be id property to refine <" + oldProperty.ns.name + ">");
    }
    this.setIdProperty(newProperty, false);
  }
  if (oldProperty.isBody) {
    if (!newProperty.isBody) {
      throw new Error("property <" + newProperty.ns.name + "> must be body property to refine <" + oldProperty.ns.name + ">");
    }
    this.setBodyProperty(newProperty, false);
  }
  var idx = props.indexOf(oldProperty);
  if (idx === -1) {
    throw new Error("property <" + oldNameNs.name + "> not found in property list");
  }
  props.splice(idx, 1);
  this.addProperty(newProperty, replace ? void 0 : idx, rename);
  propertiesByName[oldNameNs.name] = propertiesByName[oldNameNs.localName] = newProperty;
};
DescriptorBuilder.prototype.redefineProperty = function(p6, targetPropertyName, replace) {
  var nsPrefix = p6.ns.prefix;
  var parts = targetPropertyName.split("#");
  var name3 = parseName(parts[0], nsPrefix);
  var attrName = parseName(parts[1], name3.prefix).name;
  var redefinedProperty = this.propertiesByName[attrName];
  if (!redefinedProperty) {
    throw new Error("refined property <" + attrName + "> not found");
  } else {
    this.replaceProperty(redefinedProperty, p6, replace);
  }
  delete p6.redefines;
};
DescriptorBuilder.prototype.addNamedProperty = function(p6, validate3) {
  var ns2 = p6.ns, propsByName = this.propertiesByName;
  if (validate3) {
    this.assertNotDefined(p6, ns2.name);
    this.assertNotDefined(p6, ns2.localName);
  }
  propsByName[ns2.name] = propsByName[ns2.localName] = p6;
};
DescriptorBuilder.prototype.removeNamedProperty = function(p6) {
  var ns2 = p6.ns, propsByName = this.propertiesByName;
  delete propsByName[ns2.name];
  delete propsByName[ns2.localName];
};
DescriptorBuilder.prototype.setBodyProperty = function(p6, validate3) {
  if (validate3 && this.bodyProperty) {
    throw new Error("body property defined multiple times (<" + this.bodyProperty.ns.name + ">, <" + p6.ns.name + ">)");
  }
  this.bodyProperty = p6;
};
DescriptorBuilder.prototype.setIdProperty = function(p6, validate3) {
  if (validate3 && this.idProperty) {
    throw new Error("id property defined multiple times (<" + this.idProperty.ns.name + ">, <" + p6.ns.name + ">)");
  }
  this.idProperty = p6;
};
DescriptorBuilder.prototype.assertNotDefined = function(p6, name3) {
  var propertyName = p6.name, definedProperty = this.propertiesByName[propertyName];
  if (definedProperty) {
    throw new Error("property <" + propertyName + "> already defined; override of <" + definedProperty.definedBy.ns.name + "#" + definedProperty.ns.name + "> by <" + p6.definedBy.ns.name + "#" + p6.ns.name + "> not allowed without redefines");
  }
};
DescriptorBuilder.prototype.hasProperty = function(name3) {
  return this.propertiesByName[name3];
};
DescriptorBuilder.prototype.addTrait = function(t6, inherited) {
  var typesByName = this.allTypesByName, types3 = this.allTypes;
  var typeName = t6.name;
  if (typeName in typesByName) {
    return;
  }
  (0, import_min_dash27.forEach)(t6.properties, (0, import_min_dash27.bind)(function(p6) {
    p6 = (0, import_min_dash27.assign)({}, p6, {
      name: p6.ns.localName,
      inherited
    });
    Object.defineProperty(p6, "definedBy", {
      value: t6
    });
    var replaces = p6.replaces, redefines = p6.redefines;
    if (replaces || redefines) {
      this.redefineProperty(p6, replaces || redefines, replaces);
    } else {
      if (p6.isBody) {
        this.setBodyProperty(p6);
      }
      if (p6.isId) {
        this.setIdProperty(p6);
      }
      this.addProperty(p6);
    }
  }, this));
  types3.push(t6);
  typesByName[typeName] = t6;
};
function Registry(packages2, properties) {
  this.packageMap = {};
  this.typeMap = {};
  this.packages = [];
  this.properties = properties;
  (0, import_min_dash27.forEach)(packages2, (0, import_min_dash27.bind)(this.registerPackage, this));
}
Registry.prototype.getPackage = function(uriOrPrefix) {
  return this.packageMap[uriOrPrefix];
};
Registry.prototype.getPackages = function() {
  return this.packages;
};
Registry.prototype.registerPackage = function(pkg) {
  pkg = (0, import_min_dash27.assign)({}, pkg);
  var pkgMap = this.packageMap;
  ensureAvailable(pkgMap, pkg, "prefix");
  ensureAvailable(pkgMap, pkg, "uri");
  (0, import_min_dash27.forEach)(pkg.types, (0, import_min_dash27.bind)(function(descriptor) {
    this.registerType(descriptor, pkg);
  }, this));
  pkgMap[pkg.uri] = pkgMap[pkg.prefix] = pkg;
  this.packages.push(pkg);
};
Registry.prototype.registerType = function(type, pkg) {
  type = (0, import_min_dash27.assign)({}, type, {
    superClass: (type.superClass || []).slice(),
    extends: (type.extends || []).slice(),
    properties: (type.properties || []).slice(),
    meta: (0, import_min_dash27.assign)(type.meta || {})
  });
  var ns2 = parseName(type.name, pkg.prefix), name3 = ns2.name, propertiesByName = {};
  (0, import_min_dash27.forEach)(type.properties, (0, import_min_dash27.bind)(function(p6) {
    var propertyNs = parseName(p6.name, ns2.prefix), propertyName = propertyNs.name;
    if (!isBuiltIn(p6.type)) {
      p6.type = parseName(p6.type, propertyNs.prefix).name;
    }
    (0, import_min_dash27.assign)(p6, {
      ns: propertyNs,
      name: propertyName
    });
    propertiesByName[propertyName] = p6;
  }, this));
  (0, import_min_dash27.assign)(type, {
    ns: ns2,
    name: name3,
    propertiesByName
  });
  (0, import_min_dash27.forEach)(type.extends, (0, import_min_dash27.bind)(function(extendsName) {
    var extended = this.typeMap[extendsName];
    extended.traits = extended.traits || [];
    extended.traits.push(name3);
  }, this));
  this.definePackage(type, pkg);
  this.typeMap[name3] = type;
};
Registry.prototype.mapTypes = function(nsName2, iterator, trait) {
  var type = isBuiltIn(nsName2.name) ? { name: nsName2.name } : this.typeMap[nsName2.name];
  var self2 = this;
  function traverseTrait(cls) {
    return traverseSuper(cls, true);
  }
  function traverseSuper(cls, trait2) {
    var parentNs = parseName(cls, isBuiltIn(cls) ? "" : nsName2.prefix);
    self2.mapTypes(parentNs, iterator, trait2);
  }
  if (!type) {
    throw new Error("unknown type <" + nsName2.name + ">");
  }
  (0, import_min_dash27.forEach)(type.superClass, trait ? traverseTrait : traverseSuper);
  iterator(type, !trait);
  (0, import_min_dash27.forEach)(type.traits, traverseTrait);
};
Registry.prototype.getEffectiveDescriptor = function(name3) {
  var nsName2 = parseName(name3);
  var builder = new DescriptorBuilder(nsName2);
  this.mapTypes(nsName2, function(type, inherited) {
    builder.addTrait(type, inherited);
  });
  var descriptor = builder.build();
  this.definePackage(descriptor, descriptor.allTypes[descriptor.allTypes.length - 1].$pkg);
  return descriptor;
};
Registry.prototype.definePackage = function(target, pkg) {
  this.properties.define(target, "$pkg", { value: pkg });
};
function ensureAvailable(packageMap, pkg, identifierKey) {
  var value = pkg[identifierKey];
  if (value in packageMap) {
    throw new Error("package with " + identifierKey + " <" + value + "> already defined");
  }
}
function Properties(model) {
  this.model = model;
}
Properties.prototype.set = function(target, name3, value) {
  if (!(0, import_min_dash27.isString)(name3) || !name3.length) {
    throw new TypeError("property name must be a non-empty string");
  }
  var property = this.model.getPropertyDescriptor(target, name3);
  var propertyName = property && property.name;
  if (isUndefined3(value)) {
    if (property) {
      delete target[propertyName];
    } else {
      delete target.$attrs[name3];
    }
  } else {
    if (property) {
      if (propertyName in target) {
        target[propertyName] = value;
      } else {
        defineProperty(target, property, value);
      }
    } else {
      target.$attrs[name3] = value;
    }
  }
};
Properties.prototype.get = function(target, name3) {
  var property = this.model.getPropertyDescriptor(target, name3);
  if (!property) {
    return target.$attrs[name3];
  }
  var propertyName = property.name;
  if (!target[propertyName] && property.isMany) {
    defineProperty(target, property, []);
  }
  return target[propertyName];
};
Properties.prototype.define = function(target, name3, options2) {
  if (!options2.writable) {
    var value = options2.value;
    options2 = (0, import_min_dash27.assign)({}, options2, {
      get: function() {
        return value;
      }
    });
    delete options2.value;
  }
  Object.defineProperty(target, name3, options2);
};
Properties.prototype.defineDescriptor = function(target, descriptor) {
  this.define(target, "$descriptor", { value: descriptor });
};
Properties.prototype.defineModel = function(target, model) {
  this.define(target, "$model", { value: model });
};
function isUndefined3(val) {
  return typeof val === "undefined";
}
function defineProperty(target, property, value) {
  Object.defineProperty(target, property.name, {
    enumerable: !property.isReference,
    writable: true,
    value,
    configurable: true
  });
}
function Moddle(packages2) {
  this.properties = new Properties(this);
  this.factory = new Factory(this, this.properties);
  this.registry = new Registry(packages2, this.properties);
  this.typeCache = {};
}
Moddle.prototype.create = function(descriptor, attrs) {
  var Type2 = this.getType(descriptor);
  if (!Type2) {
    throw new Error("unknown type <" + descriptor + ">");
  }
  return new Type2(attrs);
};
Moddle.prototype.getType = function(descriptor) {
  var cache = this.typeCache;
  var name3 = (0, import_min_dash27.isString)(descriptor) ? descriptor : descriptor.ns.name;
  var type = cache[name3];
  if (!type) {
    descriptor = this.registry.getEffectiveDescriptor(name3);
    type = cache[name3] = this.factory.createType(descriptor);
  }
  return type;
};
Moddle.prototype.createAny = function(name3, nsUri, properties) {
  var nameNs = parseName(name3);
  var element = {
    $type: name3,
    $instanceOf: function(type) {
      return type === this.$type;
    }
  };
  var descriptor = {
    name: name3,
    isGeneric: true,
    ns: {
      prefix: nameNs.prefix,
      localName: nameNs.localName,
      uri: nsUri
    }
  };
  this.properties.defineDescriptor(element, descriptor);
  this.properties.defineModel(element, this);
  this.properties.define(element, "$parent", { enumerable: false, writable: true });
  this.properties.define(element, "$instanceOf", { enumerable: false, writable: true });
  (0, import_min_dash27.forEach)(properties, function(a6, key) {
    if ((0, import_min_dash27.isObject)(a6) && a6.value !== void 0) {
      element[a6.name] = a6.value;
    } else {
      element[key] = a6;
    }
  });
  return element;
};
Moddle.prototype.getPackage = function(uriOrPrefix) {
  return this.registry.getPackage(uriOrPrefix);
};
Moddle.prototype.getPackages = function() {
  return this.registry.getPackages();
};
Moddle.prototype.getElementDescriptor = function(element) {
  return element.$descriptor;
};
Moddle.prototype.hasType = function(element, type) {
  if (type === void 0) {
    type = element;
    element = this;
  }
  var descriptor = element.$model.getElementDescriptor(element);
  return type in descriptor.allTypesByName;
};
Moddle.prototype.getPropertyDescriptor = function(element, property) {
  return this.getElementDescriptor(element).propertiesByName[property];
};
Moddle.prototype.getTypeDescriptor = function(type) {
  return this.registry.typeMap[type];
};

// node_modules/moddle-xml/dist/index.esm.js
var import_min_dash28 = __toESM(require_dist(), 1);

// node_modules/saxen/dist/index.esm.js
var fromCharCode = String.fromCharCode;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var ENTITY_PATTERN = /&#(\d+);|&#x([0-9a-f]+);|&(\w+);/ig;
var ENTITY_MAPPING = {
  "amp": "&",
  "apos": "'",
  "gt": ">",
  "lt": "<",
  "quot": '"'
};
Object.keys(ENTITY_MAPPING).forEach(function(k6) {
  ENTITY_MAPPING[k6.toUpperCase()] = ENTITY_MAPPING[k6];
});
function replaceEntities(_5, d5, x4, z5) {
  if (z5) {
    if (hasOwnProperty.call(ENTITY_MAPPING, z5)) {
      return ENTITY_MAPPING[z5];
    } else {
      return "&" + z5 + ";";
    }
  }
  if (d5) {
    return fromCharCode(d5);
  }
  return fromCharCode(parseInt(x4, 16));
}
function decodeEntities(s5) {
  if (s5.length > 3 && s5.indexOf("&") !== -1) {
    return s5.replace(ENTITY_PATTERN, replaceEntities);
  }
  return s5;
}
var XSI_URI = "http://www.w3.org/2001/XMLSchema-instance";
var XSI_PREFIX = "xsi";
var XSI_TYPE = "xsi:type";
var NON_WHITESPACE_OUTSIDE_ROOT_NODE = "non-whitespace outside of root node";
function error(msg) {
  return new Error(msg);
}
function missingNamespaceForPrefix(prefix3) {
  return "missing namespace for prefix <" + prefix3 + ">";
}
function getter(getFn) {
  return {
    "get": getFn,
    "enumerable": true
  };
}
function cloneNsMatrix(nsMatrix) {
  var clone2 = {}, key;
  for (key in nsMatrix) {
    clone2[key] = nsMatrix[key];
  }
  return clone2;
}
function uriPrefix(prefix3) {
  return prefix3 + "$uri";
}
function buildNsMatrix(nsUriToPrefix) {
  var nsMatrix = {}, uri2, prefix3;
  for (uri2 in nsUriToPrefix) {
    prefix3 = nsUriToPrefix[uri2];
    nsMatrix[prefix3] = prefix3;
    nsMatrix[uriPrefix(prefix3)] = uri2;
  }
  return nsMatrix;
}
function noopGetContext() {
  return { "line": 0, "column": 0 };
}
function throwFunc(err) {
  throw err;
}
function Parser(options2) {
  if (!this) {
    return new Parser(options2);
  }
  var proxy = options2 && options2["proxy"];
  var onText, onOpenTag, onCloseTag, onCDATA, onError = throwFunc, onWarning, onComment, onQuestion, onAttention;
  var getContext = noopGetContext;
  var maybeNS = false;
  var isNamespace = false;
  var returnError = null;
  var parseStop = false;
  var nsUriToPrefix;
  function handleError(err) {
    if (!(err instanceof Error)) {
      err = error(err);
    }
    returnError = err;
    onError(err, getContext);
  }
  function handleWarning(err) {
    if (!onWarning) {
      return;
    }
    if (!(err instanceof Error)) {
      err = error(err);
    }
    onWarning(err, getContext);
  }
  this["on"] = function(name3, cb) {
    if (typeof cb !== "function") {
      throw error("required args <name, cb>");
    }
    switch (name3) {
      case "openTag":
        onOpenTag = cb;
        break;
      case "text":
        onText = cb;
        break;
      case "closeTag":
        onCloseTag = cb;
        break;
      case "error":
        onError = cb;
        break;
      case "warn":
        onWarning = cb;
        break;
      case "cdata":
        onCDATA = cb;
        break;
      case "attention":
        onAttention = cb;
        break;
      case "question":
        onQuestion = cb;
        break;
      case "comment":
        onComment = cb;
        break;
      default:
        throw error("unsupported event: " + name3);
    }
    return this;
  };
  this["ns"] = function(nsMap) {
    if (typeof nsMap === "undefined") {
      nsMap = {};
    }
    if (typeof nsMap !== "object") {
      throw error("required args <nsMap={}>");
    }
    var _nsUriToPrefix = {}, k6;
    for (k6 in nsMap) {
      _nsUriToPrefix[k6] = nsMap[k6];
    }
    _nsUriToPrefix[XSI_URI] = XSI_PREFIX;
    isNamespace = true;
    nsUriToPrefix = _nsUriToPrefix;
    return this;
  };
  this["parse"] = function(xml2) {
    if (typeof xml2 !== "string") {
      throw error("required args <xml=string>");
    }
    returnError = null;
    parse3(xml2);
    getContext = noopGetContext;
    parseStop = false;
    return returnError;
  };
  this["stop"] = function() {
    parseStop = true;
  };
  function parse3(xml2) {
    var nsMatrixStack = isNamespace ? [] : null, nsMatrix = isNamespace ? buildNsMatrix(nsUriToPrefix) : null, _nsMatrix, nodeStack = [], anonymousNsCount = 0, tagStart = false, tagEnd = false, i6 = 0, j6 = 0, x4, y4, q3, w6, v5, xmlns, elementName, _elementName, elementProxy;
    var attrsString = "", attrsStart = 0, cachedAttrs;
    function getAttrs() {
      if (cachedAttrs !== null) {
        return cachedAttrs;
      }
      var nsUri, nsUriPrefix, nsName2, defaultAlias = isNamespace && nsMatrix["xmlns"], attrList = isNamespace && maybeNS ? [] : null, i7 = attrsStart, s5 = attrsString, l6 = s5.length, hasNewMatrix, newalias, value, alias, name3, attrs = {}, seenAttrs = {}, skipAttr, w7, j7;
      parseAttr:
        for (; i7 < l6; i7++) {
          skipAttr = false;
          w7 = s5.charCodeAt(i7);
          if (w7 === 32 || w7 < 14 && w7 > 8) {
            continue;
          }
          if (w7 < 65 || w7 > 122 || w7 > 90 && w7 < 97) {
            if (w7 !== 95 && w7 !== 58) {
              handleWarning("illegal first char attribute name");
              skipAttr = true;
            }
          }
          for (j7 = i7 + 1; j7 < l6; j7++) {
            w7 = s5.charCodeAt(j7);
            if (w7 > 96 && w7 < 123 || w7 > 64 && w7 < 91 || w7 > 47 && w7 < 59 || w7 === 46 || w7 === 45 || w7 === 95) {
              continue;
            }
            if (w7 === 32 || w7 < 14 && w7 > 8) {
              handleWarning("missing attribute value");
              i7 = j7;
              continue parseAttr;
            }
            if (w7 === 61) {
              break;
            }
            handleWarning("illegal attribute name char");
            skipAttr = true;
          }
          name3 = s5.substring(i7, j7);
          if (name3 === "xmlns:xmlns") {
            handleWarning("illegal declaration of xmlns");
            skipAttr = true;
          }
          w7 = s5.charCodeAt(j7 + 1);
          if (w7 === 34) {
            j7 = s5.indexOf('"', i7 = j7 + 2);
            if (j7 === -1) {
              j7 = s5.indexOf("'", i7);
              if (j7 !== -1) {
                handleWarning("attribute value quote missmatch");
                skipAttr = true;
              }
            }
          } else if (w7 === 39) {
            j7 = s5.indexOf("'", i7 = j7 + 2);
            if (j7 === -1) {
              j7 = s5.indexOf('"', i7);
              if (j7 !== -1) {
                handleWarning("attribute value quote missmatch");
                skipAttr = true;
              }
            }
          } else {
            handleWarning("missing attribute value quotes");
            skipAttr = true;
            for (j7 = j7 + 1; j7 < l6; j7++) {
              w7 = s5.charCodeAt(j7 + 1);
              if (w7 === 32 || w7 < 14 && w7 > 8) {
                break;
              }
            }
          }
          if (j7 === -1) {
            handleWarning("missing closing quotes");
            j7 = l6;
            skipAttr = true;
          }
          if (!skipAttr) {
            value = s5.substring(i7, j7);
          }
          i7 = j7;
          for (; j7 + 1 < l6; j7++) {
            w7 = s5.charCodeAt(j7 + 1);
            if (w7 === 32 || w7 < 14 && w7 > 8) {
              break;
            }
            if (i7 === j7) {
              handleWarning("illegal character after attribute end");
              skipAttr = true;
            }
          }
          i7 = j7 + 1;
          if (skipAttr) {
            continue parseAttr;
          }
          if (name3 in seenAttrs) {
            handleWarning("attribute <" + name3 + "> already defined");
            continue;
          }
          seenAttrs[name3] = true;
          if (!isNamespace) {
            attrs[name3] = value;
            continue;
          }
          if (maybeNS) {
            newalias = name3 === "xmlns" ? "xmlns" : name3.charCodeAt(0) === 120 && name3.substr(0, 6) === "xmlns:" ? name3.substr(6) : null;
            if (newalias !== null) {
              nsUri = decodeEntities(value);
              nsUriPrefix = uriPrefix(newalias);
              alias = nsUriToPrefix[nsUri];
              if (!alias) {
                if (newalias === "xmlns" || nsUriPrefix in nsMatrix && nsMatrix[nsUriPrefix] !== nsUri) {
                  do {
                    alias = "ns" + anonymousNsCount++;
                  } while (typeof nsMatrix[alias] !== "undefined");
                } else {
                  alias = newalias;
                }
                nsUriToPrefix[nsUri] = alias;
              }
              if (nsMatrix[newalias] !== alias) {
                if (!hasNewMatrix) {
                  nsMatrix = cloneNsMatrix(nsMatrix);
                  hasNewMatrix = true;
                }
                nsMatrix[newalias] = alias;
                if (newalias === "xmlns") {
                  nsMatrix[uriPrefix(alias)] = nsUri;
                  defaultAlias = alias;
                }
                nsMatrix[nsUriPrefix] = nsUri;
              }
              attrs[name3] = value;
              continue;
            }
            attrList.push(name3, value);
            continue;
          }
          w7 = name3.indexOf(":");
          if (w7 === -1) {
            attrs[name3] = value;
            continue;
          }
          if (!(nsName2 = nsMatrix[name3.substring(0, w7)])) {
            handleWarning(missingNamespaceForPrefix(name3.substring(0, w7)));
            continue;
          }
          name3 = defaultAlias === nsName2 ? name3.substr(w7 + 1) : nsName2 + name3.substr(w7);
          if (name3 === XSI_TYPE) {
            w7 = value.indexOf(":");
            if (w7 !== -1) {
              nsName2 = value.substring(0, w7);
              nsName2 = nsMatrix[nsName2] || nsName2;
              value = nsName2 + value.substring(w7);
            } else {
              value = defaultAlias + ":" + value;
            }
          }
          attrs[name3] = value;
        }
      if (maybeNS) {
        for (i7 = 0, l6 = attrList.length; i7 < l6; i7++) {
          name3 = attrList[i7++];
          value = attrList[i7];
          w7 = name3.indexOf(":");
          if (w7 !== -1) {
            if (!(nsName2 = nsMatrix[name3.substring(0, w7)])) {
              handleWarning(missingNamespaceForPrefix(name3.substring(0, w7)));
              continue;
            }
            name3 = defaultAlias === nsName2 ? name3.substr(w7 + 1) : nsName2 + name3.substr(w7);
            if (name3 === XSI_TYPE) {
              w7 = value.indexOf(":");
              if (w7 !== -1) {
                nsName2 = value.substring(0, w7);
                nsName2 = nsMatrix[nsName2] || nsName2;
                value = nsName2 + value.substring(w7);
              } else {
                value = defaultAlias + ":" + value;
              }
            }
          }
          attrs[name3] = value;
        }
      }
      return cachedAttrs = attrs;
    }
    function getParseContext() {
      var splitsRe = /(\r\n|\r|\n)/g;
      var line = 0;
      var column = 0;
      var startOfLine = 0;
      var endOfLine = j6;
      var match;
      var data;
      while (i6 >= startOfLine) {
        match = splitsRe.exec(xml2);
        if (!match) {
          break;
        }
        endOfLine = match[0].length + match.index;
        if (endOfLine > i6) {
          break;
        }
        line += 1;
        startOfLine = endOfLine;
      }
      if (i6 == -1) {
        column = endOfLine;
        data = xml2.substring(j6);
      } else if (j6 === 0) {
        data = xml2.substring(j6, i6);
      } else {
        column = i6 - startOfLine;
        data = j6 == -1 ? xml2.substring(i6) : xml2.substring(i6, j6 + 1);
      }
      return {
        "data": data,
        "line": line,
        "column": column
      };
    }
    getContext = getParseContext;
    if (proxy) {
      elementProxy = Object.create({}, {
        "name": getter(function() {
          return elementName;
        }),
        "originalName": getter(function() {
          return _elementName;
        }),
        "attrs": getter(getAttrs),
        "ns": getter(function() {
          return nsMatrix;
        })
      });
    }
    while (j6 !== -1) {
      if (xml2.charCodeAt(j6) === 60) {
        i6 = j6;
      } else {
        i6 = xml2.indexOf("<", j6);
      }
      if (i6 === -1) {
        if (nodeStack.length) {
          return handleError("unexpected end of file");
        }
        if (j6 === 0) {
          return handleError("missing start tag");
        }
        if (j6 < xml2.length) {
          if (xml2.substring(j6).trim()) {
            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);
          }
        }
        return;
      }
      if (j6 !== i6) {
        if (nodeStack.length) {
          if (onText) {
            onText(xml2.substring(j6, i6), decodeEntities, getContext);
            if (parseStop) {
              return;
            }
          }
        } else {
          if (xml2.substring(j6, i6).trim()) {
            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);
            if (parseStop) {
              return;
            }
          }
        }
      }
      w6 = xml2.charCodeAt(i6 + 1);
      if (w6 === 33) {
        q3 = xml2.charCodeAt(i6 + 2);
        if (q3 === 91 && xml2.substr(i6 + 3, 6) === "CDATA[") {
          j6 = xml2.indexOf("]]>", i6);
          if (j6 === -1) {
            return handleError("unclosed cdata");
          }
          if (onCDATA) {
            onCDATA(xml2.substring(i6 + 9, j6), getContext);
            if (parseStop) {
              return;
            }
          }
          j6 += 3;
          continue;
        }
        if (q3 === 45 && xml2.charCodeAt(i6 + 3) === 45) {
          j6 = xml2.indexOf("-->", i6);
          if (j6 === -1) {
            return handleError("unclosed comment");
          }
          if (onComment) {
            onComment(xml2.substring(i6 + 4, j6), decodeEntities, getContext);
            if (parseStop) {
              return;
            }
          }
          j6 += 3;
          continue;
        }
      }
      if (w6 === 63) {
        j6 = xml2.indexOf("?>", i6);
        if (j6 === -1) {
          return handleError("unclosed question");
        }
        if (onQuestion) {
          onQuestion(xml2.substring(i6, j6 + 2), getContext);
          if (parseStop) {
            return;
          }
        }
        j6 += 2;
        continue;
      }
      for (x4 = i6 + 1; ; x4++) {
        v5 = xml2.charCodeAt(x4);
        if (isNaN(v5)) {
          j6 = -1;
          return handleError("unclosed tag");
        }
        if (v5 === 34) {
          q3 = xml2.indexOf('"', x4 + 1);
          x4 = q3 !== -1 ? q3 : x4;
        } else if (v5 === 39) {
          q3 = xml2.indexOf("'", x4 + 1);
          x4 = q3 !== -1 ? q3 : x4;
        } else if (v5 === 62) {
          j6 = x4;
          break;
        }
      }
      if (w6 === 33) {
        if (onAttention) {
          onAttention(xml2.substring(i6, j6 + 1), decodeEntities, getContext);
          if (parseStop) {
            return;
          }
        }
        j6 += 1;
        continue;
      }
      cachedAttrs = {};
      if (w6 === 47) {
        tagStart = false;
        tagEnd = true;
        if (!nodeStack.length) {
          return handleError("missing open tag");
        }
        x4 = elementName = nodeStack.pop();
        q3 = i6 + 2 + x4.length;
        if (xml2.substring(i6 + 2, q3) !== x4) {
          return handleError("closing tag mismatch");
        }
        for (; q3 < j6; q3++) {
          w6 = xml2.charCodeAt(q3);
          if (w6 === 32 || w6 > 8 && w6 < 14) {
            continue;
          }
          return handleError("close tag");
        }
      } else {
        if (xml2.charCodeAt(j6 - 1) === 47) {
          x4 = elementName = xml2.substring(i6 + 1, j6 - 1);
          tagStart = true;
          tagEnd = true;
        } else {
          x4 = elementName = xml2.substring(i6 + 1, j6);
          tagStart = true;
          tagEnd = false;
        }
        if (!(w6 > 96 && w6 < 123 || w6 > 64 && w6 < 91 || w6 === 95 || w6 === 58)) {
          return handleError("illegal first char nodeName");
        }
        for (q3 = 1, y4 = x4.length; q3 < y4; q3++) {
          w6 = x4.charCodeAt(q3);
          if (w6 > 96 && w6 < 123 || w6 > 64 && w6 < 91 || w6 > 47 && w6 < 59 || w6 === 45 || w6 === 95 || w6 == 46) {
            continue;
          }
          if (w6 === 32 || w6 < 14 && w6 > 8) {
            elementName = x4.substring(0, q3);
            cachedAttrs = null;
            break;
          }
          return handleError("invalid nodeName");
        }
        if (!tagEnd) {
          nodeStack.push(elementName);
        }
      }
      if (isNamespace) {
        _nsMatrix = nsMatrix;
        if (tagStart) {
          if (!tagEnd) {
            nsMatrixStack.push(_nsMatrix);
          }
          if (cachedAttrs === null) {
            if (maybeNS = x4.indexOf("xmlns", q3) !== -1) {
              attrsStart = q3;
              attrsString = x4;
              getAttrs();
              maybeNS = false;
            }
          }
        }
        _elementName = elementName;
        w6 = elementName.indexOf(":");
        if (w6 !== -1) {
          xmlns = nsMatrix[elementName.substring(0, w6)];
          if (!xmlns) {
            return handleError("missing namespace on <" + _elementName + ">");
          }
          elementName = elementName.substr(w6 + 1);
        } else {
          xmlns = nsMatrix["xmlns"];
        }
        if (xmlns) {
          elementName = xmlns + ":" + elementName;
        }
      }
      if (tagStart) {
        attrsStart = q3;
        attrsString = x4;
        if (onOpenTag) {
          if (proxy) {
            onOpenTag(elementProxy, decodeEntities, tagEnd, getContext);
          } else {
            onOpenTag(elementName, getAttrs, decodeEntities, tagEnd, getContext);
          }
          if (parseStop) {
            return;
          }
        }
      }
      if (tagEnd) {
        if (onCloseTag) {
          onCloseTag(proxy ? elementProxy : elementName, decodeEntities, tagStart, getContext);
          if (parseStop) {
            return;
          }
        }
        if (isNamespace) {
          if (!tagStart) {
            nsMatrix = nsMatrixStack.pop();
          } else {
            nsMatrix = _nsMatrix;
          }
        }
      }
      j6 += 1;
    }
  }
}

// node_modules/moddle-xml/dist/index.esm.js
function hasLowerCaseAlias(pkg) {
  return pkg.xml && pkg.xml.tagAlias === "lowerCase";
}
var DEFAULT_NS_MAP = {
  "xsi": "http://www.w3.org/2001/XMLSchema-instance",
  "xml": "http://www.w3.org/XML/1998/namespace"
};
var XSI_TYPE2 = "xsi:type";
function serializeFormat(element) {
  return element.xml && element.xml.serialize;
}
function serializeAsType(element) {
  return serializeFormat(element) === XSI_TYPE2;
}
function serializeAsProperty(element) {
  return serializeFormat(element) === "property";
}
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function aliasToName(aliasNs, pkg) {
  if (!hasLowerCaseAlias(pkg)) {
    return aliasNs.name;
  }
  return aliasNs.prefix + ":" + capitalize(aliasNs.localName);
}
function prefixedToName(nameNs, pkg) {
  var name3 = nameNs.name, localName = nameNs.localName;
  var typePrefix = pkg.xml && pkg.xml.typePrefix;
  if (typePrefix && localName.indexOf(typePrefix) === 0) {
    return nameNs.prefix + ":" + localName.slice(typePrefix.length);
  } else {
    return name3;
  }
}
function normalizeXsiTypeName(name3, model) {
  var nameNs = parseName(name3);
  var pkg = model.getPackage(nameNs.prefix);
  return prefixedToName(nameNs, pkg);
}
function error2(message) {
  return new Error(message);
}
function getModdleDescriptor(element) {
  return element.$descriptor;
}
function Context(options2) {
  (0, import_min_dash28.assign)(this, options2);
  this.elementsById = {};
  this.references = [];
  this.warnings = [];
  this.addReference = function(reference) {
    this.references.push(reference);
  };
  this.addElement = function(element) {
    if (!element) {
      throw error2("expected element");
    }
    var elementsById = this.elementsById;
    var descriptor = getModdleDescriptor(element);
    var idProperty = descriptor.idProperty, id;
    if (idProperty) {
      id = element.get(idProperty.name);
      if (id) {
        if (!/^([a-z][\w-.]*:)?[a-z_][\w-.]*$/i.test(id)) {
          throw new Error("illegal ID <" + id + ">");
        }
        if (elementsById[id]) {
          throw error2("duplicate ID <" + id + ">");
        }
        elementsById[id] = element;
      }
    }
  };
  this.addWarning = function(warning) {
    this.warnings.push(warning);
  };
}
function BaseHandler() {
}
BaseHandler.prototype.handleEnd = function() {
};
BaseHandler.prototype.handleText = function() {
};
BaseHandler.prototype.handleNode = function() {
};
function NoopHandler() {
}
NoopHandler.prototype = Object.create(BaseHandler.prototype);
NoopHandler.prototype.handleNode = function() {
  return this;
};
function BodyHandler() {
}
BodyHandler.prototype = Object.create(BaseHandler.prototype);
BodyHandler.prototype.handleText = function(text) {
  this.body = (this.body || "") + text;
};
function ReferenceHandler(property, context) {
  this.property = property;
  this.context = context;
}
ReferenceHandler.prototype = Object.create(BodyHandler.prototype);
ReferenceHandler.prototype.handleNode = function(node2) {
  if (this.element) {
    throw error2("expected no sub nodes");
  } else {
    this.element = this.createReference(node2);
  }
  return this;
};
ReferenceHandler.prototype.handleEnd = function() {
  this.element.id = this.body;
};
ReferenceHandler.prototype.createReference = function(node2) {
  return {
    property: this.property.ns.name,
    id: ""
  };
};
function ValueHandler(propertyDesc, element) {
  this.element = element;
  this.propertyDesc = propertyDesc;
}
ValueHandler.prototype = Object.create(BodyHandler.prototype);
ValueHandler.prototype.handleEnd = function() {
  var value = this.body || "", element = this.element, propertyDesc = this.propertyDesc;
  value = coerceType(propertyDesc.type, value);
  if (propertyDesc.isMany) {
    element.get(propertyDesc.name).push(value);
  } else {
    element.set(propertyDesc.name, value);
  }
};
function BaseElementHandler() {
}
BaseElementHandler.prototype = Object.create(BodyHandler.prototype);
BaseElementHandler.prototype.handleNode = function(node2) {
  var parser2 = this, element = this.element;
  if (!element) {
    element = this.element = this.createElement(node2);
    this.context.addElement(element);
  } else {
    parser2 = this.handleChild(node2);
  }
  return parser2;
};
function ElementHandler(model, typeName, context) {
  this.model = model;
  this.type = model.getType(typeName);
  this.context = context;
}
ElementHandler.prototype = Object.create(BaseElementHandler.prototype);
ElementHandler.prototype.addReference = function(reference) {
  this.context.addReference(reference);
};
ElementHandler.prototype.handleText = function(text) {
  var element = this.element, descriptor = getModdleDescriptor(element), bodyProperty = descriptor.bodyProperty;
  if (!bodyProperty) {
    throw error2("unexpected body text <" + text + ">");
  }
  BodyHandler.prototype.handleText.call(this, text);
};
ElementHandler.prototype.handleEnd = function() {
  var value = this.body, element = this.element, descriptor = getModdleDescriptor(element), bodyProperty = descriptor.bodyProperty;
  if (bodyProperty && value !== void 0) {
    value = coerceType(bodyProperty.type, value);
    element.set(bodyProperty.name, value);
  }
};
ElementHandler.prototype.createElement = function(node2) {
  var attributes = node2.attributes, Type2 = this.type, descriptor = getModdleDescriptor(Type2), context = this.context, instance = new Type2({}), model = this.model, propNameNs;
  (0, import_min_dash28.forEach)(attributes, function(value, name3) {
    var prop = descriptor.propertiesByName[name3], values5;
    if (prop && prop.isReference) {
      if (!prop.isMany) {
        context.addReference({
          element: instance,
          property: prop.ns.name,
          id: value
        });
      } else {
        values5 = value.split(" ");
        (0, import_min_dash28.forEach)(values5, function(v5) {
          context.addReference({
            element: instance,
            property: prop.ns.name,
            id: v5
          });
        });
      }
    } else {
      if (prop) {
        value = coerceType(prop.type, value);
      } else if (name3 !== "xmlns") {
        propNameNs = parseName(name3, descriptor.ns.prefix);
        if (model.getPackage(propNameNs.prefix)) {
          context.addWarning({
            message: "unknown attribute <" + name3 + ">",
            element: instance,
            property: name3,
            value
          });
        }
      }
      instance.set(name3, value);
    }
  });
  return instance;
};
ElementHandler.prototype.getPropertyForNode = function(node2) {
  var name3 = node2.name;
  var nameNs = parseName(name3);
  var type = this.type, model = this.model, descriptor = getModdleDescriptor(type);
  var propertyName = nameNs.name, property = descriptor.propertiesByName[propertyName], elementTypeName, elementType;
  if (property && !property.isAttr) {
    if (serializeAsType(property)) {
      elementTypeName = node2.attributes[XSI_TYPE2];
      if (elementTypeName) {
        elementTypeName = normalizeXsiTypeName(elementTypeName, model);
        elementType = model.getType(elementTypeName);
        return (0, import_min_dash28.assign)({}, property, {
          effectiveType: getModdleDescriptor(elementType).name
        });
      }
    }
    return property;
  }
  var pkg = model.getPackage(nameNs.prefix);
  if (pkg) {
    elementTypeName = aliasToName(nameNs, pkg);
    elementType = model.getType(elementTypeName);
    property = (0, import_min_dash28.find)(descriptor.properties, function(p6) {
      return !p6.isVirtual && !p6.isReference && !p6.isAttribute && elementType.hasType(p6.type);
    });
    if (property) {
      return (0, import_min_dash28.assign)({}, property, {
        effectiveType: getModdleDescriptor(elementType).name
      });
    }
  } else {
    property = (0, import_min_dash28.find)(descriptor.properties, function(p6) {
      return !p6.isReference && !p6.isAttribute && p6.type === "Element";
    });
    if (property) {
      return property;
    }
  }
  throw error2("unrecognized element <" + nameNs.name + ">");
};
ElementHandler.prototype.toString = function() {
  return "ElementDescriptor[" + getModdleDescriptor(this.type).name + "]";
};
ElementHandler.prototype.valueHandler = function(propertyDesc, element) {
  return new ValueHandler(propertyDesc, element);
};
ElementHandler.prototype.referenceHandler = function(propertyDesc) {
  return new ReferenceHandler(propertyDesc, this.context);
};
ElementHandler.prototype.handler = function(type) {
  if (type === "Element") {
    return new GenericElementHandler(this.model, type, this.context);
  } else {
    return new ElementHandler(this.model, type, this.context);
  }
};
ElementHandler.prototype.handleChild = function(node2) {
  var propertyDesc, type, element, childHandler;
  propertyDesc = this.getPropertyForNode(node2);
  element = this.element;
  type = propertyDesc.effectiveType || propertyDesc.type;
  if (isSimple(type)) {
    return this.valueHandler(propertyDesc, element);
  }
  if (propertyDesc.isReference) {
    childHandler = this.referenceHandler(propertyDesc).handleNode(node2);
  } else {
    childHandler = this.handler(type).handleNode(node2);
  }
  var newElement = childHandler.element;
  if (newElement !== void 0) {
    if (propertyDesc.isMany) {
      element.get(propertyDesc.name).push(newElement);
    } else {
      element.set(propertyDesc.name, newElement);
    }
    if (propertyDesc.isReference) {
      (0, import_min_dash28.assign)(newElement, {
        element
      });
      this.context.addReference(newElement);
    } else {
      newElement.$parent = element;
    }
  }
  return childHandler;
};
function RootElementHandler(model, typeName, context) {
  ElementHandler.call(this, model, typeName, context);
}
RootElementHandler.prototype = Object.create(ElementHandler.prototype);
RootElementHandler.prototype.createElement = function(node2) {
  var name3 = node2.name, nameNs = parseName(name3), model = this.model, type = this.type, pkg = model.getPackage(nameNs.prefix), typeName = pkg && aliasToName(nameNs, pkg) || name3;
  if (!type.hasType(typeName)) {
    throw error2("unexpected element <" + node2.originalName + ">");
  }
  return ElementHandler.prototype.createElement.call(this, node2);
};
function GenericElementHandler(model, typeName, context) {
  this.model = model;
  this.context = context;
}
GenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);
GenericElementHandler.prototype.createElement = function(node2) {
  var name3 = node2.name, ns2 = parseName(name3), prefix3 = ns2.prefix, uri2 = node2.ns[prefix3 + "$uri"], attributes = node2.attributes;
  return this.model.createAny(name3, uri2, attributes);
};
GenericElementHandler.prototype.handleChild = function(node2) {
  var handler = new GenericElementHandler(this.model, "Element", this.context).handleNode(node2), element = this.element;
  var newElement = handler.element, children;
  if (newElement !== void 0) {
    children = element.$children = element.$children || [];
    children.push(newElement);
    newElement.$parent = element;
  }
  return handler;
};
GenericElementHandler.prototype.handleEnd = function() {
  if (this.body) {
    this.element.$body = this.body;
  }
};
function Reader(options2) {
  if (options2 instanceof Moddle) {
    options2 = {
      model: options2
    };
  }
  (0, import_min_dash28.assign)(this, { lax: false }, options2);
}
Reader.prototype.fromXML = function(xml2, options2, done) {
  var rootHandler = options2.rootHandler;
  if (options2 instanceof ElementHandler) {
    rootHandler = options2;
    options2 = {};
  } else {
    if (typeof options2 === "string") {
      rootHandler = this.handler(options2);
      options2 = {};
    } else if (typeof rootHandler === "string") {
      rootHandler = this.handler(rootHandler);
    }
  }
  var model = this.model, lax = this.lax;
  var context = new Context((0, import_min_dash28.assign)({}, options2, { rootHandler })), parser2 = new Parser({ proxy: true }), stack = createStack();
  rootHandler.context = context;
  stack.push(rootHandler);
  function handleError(err, getContext, lax2) {
    var ctx = getContext();
    var line = ctx.line, column = ctx.column, data = ctx.data;
    if (data.charAt(0) === "<" && data.indexOf(" ") !== -1) {
      data = data.slice(0, data.indexOf(" ")) + ">";
    }
    var message = "unparsable content " + (data ? data + " " : "") + "detected\n	line: " + line + "\n	column: " + column + "\n	nested error: " + err.message;
    if (lax2) {
      context.addWarning({
        message,
        error: err
      });
      return true;
    } else {
      throw error2(message);
    }
  }
  function handleWarning(err, getContext) {
    return handleError(err, getContext, true);
  }
  function resolveReferences() {
    var elementsById = context.elementsById;
    var references = context.references;
    var i6, r6;
    for (i6 = 0; r6 = references[i6]; i6++) {
      var element = r6.element;
      var reference = elementsById[r6.id];
      var property = getModdleDescriptor(element).propertiesByName[r6.property];
      if (!reference) {
        context.addWarning({
          message: "unresolved reference <" + r6.id + ">",
          element: r6.element,
          property: r6.property,
          value: r6.id
        });
      }
      if (property.isMany) {
        var collection = element.get(property.name), idx = collection.indexOf(r6);
        if (idx === -1) {
          idx = collection.length;
        }
        if (!reference) {
          collection.splice(idx, 1);
        } else {
          collection[idx] = reference;
        }
      } else {
        element.set(property.name, reference);
      }
    }
  }
  function handleClose() {
    stack.pop().handleEnd();
  }
  var PREAMBLE_START_PATTERN = /^<\?xml /i;
  var ENCODING_PATTERN = / encoding="([^"]+)"/i;
  var UTF_8_PATTERN = /^utf-8$/i;
  function handleQuestion(question) {
    if (!PREAMBLE_START_PATTERN.test(question)) {
      return;
    }
    var match = ENCODING_PATTERN.exec(question);
    var encoding = match && match[1];
    if (!encoding || UTF_8_PATTERN.test(encoding)) {
      return;
    }
    context.addWarning({
      message: "unsupported document encoding <" + encoding + ">, falling back to UTF-8"
    });
  }
  function handleOpen(node2, getContext) {
    var handler = stack.peek();
    try {
      stack.push(handler.handleNode(node2));
    } catch (err) {
      if (handleError(err, getContext, lax)) {
        stack.push(new NoopHandler());
      }
    }
  }
  function handleCData(text, getContext) {
    try {
      stack.peek().handleText(text);
    } catch (err) {
      handleWarning(err, getContext);
    }
  }
  function handleText(text, getContext) {
    if (!text.trim()) {
      return;
    }
    handleCData(text, getContext);
  }
  var uriMap = model.getPackages().reduce(function(uriMap2, p6) {
    uriMap2[p6.uri] = p6.prefix;
    return uriMap2;
  }, {
    "http://www.w3.org/XML/1998/namespace": "xml"
  });
  parser2.ns(uriMap).on("openTag", function(obj, decodeStr, selfClosing, getContext) {
    var attrs = obj.attrs || {};
    var decodedAttrs = Object.keys(attrs).reduce(function(d5, key) {
      var value = decodeStr(attrs[key]);
      d5[key] = value;
      return d5;
    }, {});
    var node2 = {
      name: obj.name,
      originalName: obj.originalName,
      attributes: decodedAttrs,
      ns: obj.ns
    };
    handleOpen(node2, getContext);
  }).on("question", handleQuestion).on("closeTag", handleClose).on("cdata", handleCData).on("text", function(text, decodeEntities2, getContext) {
    handleText(decodeEntities2(text), getContext);
  }).on("error", handleError).on("warn", handleWarning);
  return new Promise(function(resolve, reject) {
    var err;
    try {
      parser2.parse(xml2);
      resolveReferences();
    } catch (e7) {
      err = e7;
    }
    var rootElement = rootHandler.element;
    if (!err && !rootElement) {
      err = error2("failed to parse document as <" + rootHandler.type.$descriptor.name + ">");
    }
    var warnings = context.warnings;
    var references = context.references;
    var elementsById = context.elementsById;
    if (err) {
      err.warnings = warnings;
      return reject(err);
    } else {
      return resolve({
        rootElement,
        elementsById,
        references,
        warnings
      });
    }
  });
};
Reader.prototype.handler = function(name3) {
  return new RootElementHandler(this.model, name3);
};
function createStack() {
  var stack = [];
  Object.defineProperty(stack, "peek", {
    value: function() {
      return this[this.length - 1];
    }
  });
  return stack;
}
var XML_PREAMBLE = '<?xml version="1.0" encoding="UTF-8"?>\n';
var ESCAPE_ATTR_CHARS = /<|>|'|"|&|\n\r|\n/g;
var ESCAPE_CHARS = /<|>|&/g;
function Namespaces(parent) {
  var prefixMap = {};
  var uriMap = {};
  var used = {};
  var wellknown = [];
  var custom = [];
  this.byUri = function(uri2) {
    return uriMap[uri2] || parent && parent.byUri(uri2);
  };
  this.add = function(ns2, isWellknown) {
    uriMap[ns2.uri] = ns2;
    if (isWellknown) {
      wellknown.push(ns2);
    } else {
      custom.push(ns2);
    }
    this.mapPrefix(ns2.prefix, ns2.uri);
  };
  this.uriByPrefix = function(prefix3) {
    return prefixMap[prefix3 || "xmlns"];
  };
  this.mapPrefix = function(prefix3, uri2) {
    prefixMap[prefix3 || "xmlns"] = uri2;
  };
  this.getNSKey = function(ns2) {
    return ns2.prefix !== void 0 ? ns2.uri + "|" + ns2.prefix : ns2.uri;
  };
  this.logUsed = function(ns2) {
    var uri2 = ns2.uri;
    var nsKey = this.getNSKey(ns2);
    used[nsKey] = this.byUri(uri2);
    if (parent) {
      parent.logUsed(ns2);
    }
  };
  this.getUsed = function(ns2) {
    function isUsed(ns3) {
      var nsKey = self2.getNSKey(ns3);
      return used[nsKey];
    }
    var self2 = this;
    var allNs = [].concat(wellknown, custom);
    return allNs.filter(isUsed);
  };
}
function lower(string) {
  return string.charAt(0).toLowerCase() + string.slice(1);
}
function nameToAlias(name3, pkg) {
  if (hasLowerCaseAlias(pkg)) {
    return lower(name3);
  } else {
    return name3;
  }
}
function inherits(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
}
function nsName(ns2) {
  if ((0, import_min_dash28.isString)(ns2)) {
    return ns2;
  } else {
    return (ns2.prefix ? ns2.prefix + ":" : "") + ns2.localName;
  }
}
function getNsAttrs(namespaces) {
  return namespaces.getUsed().filter(function(ns2) {
    return ns2.prefix !== "xml";
  }).map(function(ns2) {
    var name3 = "xmlns" + (ns2.prefix ? ":" + ns2.prefix : "");
    return { name: name3, value: ns2.uri };
  });
}
function getElementNs(ns2, descriptor) {
  if (descriptor.isGeneric) {
    return (0, import_min_dash28.assign)({ localName: descriptor.ns.localName }, ns2);
  } else {
    return (0, import_min_dash28.assign)({ localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg) }, ns2);
  }
}
function getPropertyNs(ns2, descriptor) {
  return (0, import_min_dash28.assign)({ localName: descriptor.ns.localName }, ns2);
}
function getSerializableProperties(element) {
  var descriptor = element.$descriptor;
  return (0, import_min_dash28.filter)(descriptor.properties, function(p6) {
    var name3 = p6.name;
    if (p6.isVirtual) {
      return false;
    }
    if (!(0, import_min_dash28.has)(element, name3)) {
      return false;
    }
    var value = element[name3];
    if (value === p6.default) {
      return false;
    }
    if (value === null) {
      return false;
    }
    return p6.isMany ? value.length : true;
  });
}
var ESCAPE_ATTR_MAP = {
  "\n": "#10",
  "\n\r": "#10",
  '"': "#34",
  "'": "#39",
  "<": "#60",
  ">": "#62",
  "&": "#38"
};
var ESCAPE_MAP = {
  "<": "lt",
  ">": "gt",
  "&": "amp"
};
function escape2(str, charPattern, replaceMap) {
  str = (0, import_min_dash28.isString)(str) ? str : "" + str;
  return str.replace(charPattern, function(s5) {
    return "&" + replaceMap[s5] + ";";
  });
}
function escapeAttr(str) {
  return escape2(str, ESCAPE_ATTR_CHARS, ESCAPE_ATTR_MAP);
}
function escapeBody(str) {
  return escape2(str, ESCAPE_CHARS, ESCAPE_MAP);
}
function filterAttributes(props) {
  return (0, import_min_dash28.filter)(props, function(p6) {
    return p6.isAttr;
  });
}
function filterContained(props) {
  return (0, import_min_dash28.filter)(props, function(p6) {
    return !p6.isAttr;
  });
}
function ReferenceSerializer(tagName) {
  this.tagName = tagName;
}
ReferenceSerializer.prototype.build = function(element) {
  this.element = element;
  return this;
};
ReferenceSerializer.prototype.serializeTo = function(writer) {
  writer.appendIndent().append("<" + this.tagName + ">" + this.element.id + "</" + this.tagName + ">").appendNewLine();
};
function BodySerializer() {
}
BodySerializer.prototype.serializeValue = BodySerializer.prototype.serializeTo = function(writer) {
  writer.append(this.escape ? escapeBody(this.value) : this.value);
};
BodySerializer.prototype.build = function(prop, value) {
  this.value = value;
  if (prop.type === "String" && value.search(ESCAPE_CHARS) !== -1) {
    this.escape = true;
  }
  return this;
};
function ValueSerializer(tagName) {
  this.tagName = tagName;
}
inherits(ValueSerializer, BodySerializer);
ValueSerializer.prototype.serializeTo = function(writer) {
  writer.appendIndent().append("<" + this.tagName + ">");
  this.serializeValue(writer);
  writer.append("</" + this.tagName + ">").appendNewLine();
};
function ElementSerializer(parent, propertyDescriptor) {
  this.body = [];
  this.attrs = [];
  this.parent = parent;
  this.propertyDescriptor = propertyDescriptor;
}
ElementSerializer.prototype.build = function(element) {
  this.element = element;
  var elementDescriptor = element.$descriptor, propertyDescriptor = this.propertyDescriptor;
  var otherAttrs, properties;
  var isGeneric = elementDescriptor.isGeneric;
  if (isGeneric) {
    otherAttrs = this.parseGeneric(element);
  } else {
    otherAttrs = this.parseNsAttributes(element);
  }
  if (propertyDescriptor) {
    this.ns = this.nsPropertyTagName(propertyDescriptor);
  } else {
    this.ns = this.nsTagName(elementDescriptor);
  }
  this.tagName = this.addTagName(this.ns);
  if (!isGeneric) {
    properties = getSerializableProperties(element);
    this.parseAttributes(filterAttributes(properties));
    this.parseContainments(filterContained(properties));
  }
  this.parseGenericAttributes(element, otherAttrs);
  return this;
};
ElementSerializer.prototype.nsTagName = function(descriptor) {
  var effectiveNs = this.logNamespaceUsed(descriptor.ns);
  return getElementNs(effectiveNs, descriptor);
};
ElementSerializer.prototype.nsPropertyTagName = function(descriptor) {
  var effectiveNs = this.logNamespaceUsed(descriptor.ns);
  return getPropertyNs(effectiveNs, descriptor);
};
ElementSerializer.prototype.isLocalNs = function(ns2) {
  return ns2.uri === this.ns.uri;
};
ElementSerializer.prototype.nsAttributeName = function(element) {
  var ns2;
  if ((0, import_min_dash28.isString)(element)) {
    ns2 = parseName(element);
  } else {
    ns2 = element.ns;
  }
  if (element.inherited) {
    return { localName: ns2.localName };
  }
  var effectiveNs = this.logNamespaceUsed(ns2);
  this.getNamespaces().logUsed(effectiveNs);
  if (this.isLocalNs(effectiveNs)) {
    return { localName: ns2.localName };
  } else {
    return (0, import_min_dash28.assign)({ localName: ns2.localName }, effectiveNs);
  }
};
ElementSerializer.prototype.parseGeneric = function(element) {
  var self2 = this, body = this.body;
  var attributes = [];
  (0, import_min_dash28.forEach)(element, function(val, key) {
    var nonNsAttr;
    if (key === "$body") {
      body.push(new BodySerializer().build({ type: "String" }, val));
    } else if (key === "$children") {
      (0, import_min_dash28.forEach)(val, function(child) {
        body.push(new ElementSerializer(self2).build(child));
      });
    } else if (key.indexOf("$") !== 0) {
      nonNsAttr = self2.parseNsAttribute(element, key, val);
      if (nonNsAttr) {
        attributes.push({ name: key, value: val });
      }
    }
  });
  return attributes;
};
ElementSerializer.prototype.parseNsAttribute = function(element, name3, value) {
  var model = element.$model;
  var nameNs = parseName(name3);
  var ns2;
  if (nameNs.prefix === "xmlns") {
    ns2 = { prefix: nameNs.localName, uri: value };
  }
  if (!nameNs.prefix && nameNs.localName === "xmlns") {
    ns2 = { uri: value };
  }
  if (!ns2) {
    return {
      name: name3,
      value
    };
  }
  if (model && model.getPackage(value)) {
    this.logNamespace(ns2, true, true);
  } else {
    var actualNs = this.logNamespaceUsed(ns2, true);
    this.getNamespaces().logUsed(actualNs);
  }
};
ElementSerializer.prototype.parseNsAttributes = function(element, attrs) {
  var self2 = this;
  var genericAttrs = element.$attrs;
  var attributes = [];
  (0, import_min_dash28.forEach)(genericAttrs, function(value, name3) {
    var nonNsAttr = self2.parseNsAttribute(element, name3, value);
    if (nonNsAttr) {
      attributes.push(nonNsAttr);
    }
  });
  return attributes;
};
ElementSerializer.prototype.parseGenericAttributes = function(element, attributes) {
  var self2 = this;
  (0, import_min_dash28.forEach)(attributes, function(attr3) {
    if (attr3.name === XSI_TYPE2) {
      return;
    }
    try {
      self2.addAttribute(self2.nsAttributeName(attr3.name), attr3.value);
    } catch (e7) {
      console.warn("missing namespace information for ", attr3.name, "=", attr3.value, "on", element, e7);
    }
  });
};
ElementSerializer.prototype.parseContainments = function(properties) {
  var self2 = this, body = this.body, element = this.element;
  (0, import_min_dash28.forEach)(properties, function(p6) {
    var value = element.get(p6.name), isReference = p6.isReference, isMany = p6.isMany;
    if (!isMany) {
      value = [value];
    }
    if (p6.isBody) {
      body.push(new BodySerializer().build(p6, value[0]));
    } else if (isSimple(p6.type)) {
      (0, import_min_dash28.forEach)(value, function(v5) {
        body.push(new ValueSerializer(self2.addTagName(self2.nsPropertyTagName(p6))).build(p6, v5));
      });
    } else if (isReference) {
      (0, import_min_dash28.forEach)(value, function(v5) {
        body.push(new ReferenceSerializer(self2.addTagName(self2.nsPropertyTagName(p6))).build(v5));
      });
    } else {
      var asType = serializeAsType(p6), asProperty = serializeAsProperty(p6);
      (0, import_min_dash28.forEach)(value, function(v5) {
        var serializer;
        if (asType) {
          serializer = new TypeSerializer(self2, p6);
        } else if (asProperty) {
          serializer = new ElementSerializer(self2, p6);
        } else {
          serializer = new ElementSerializer(self2);
        }
        body.push(serializer.build(v5));
      });
    }
  });
};
ElementSerializer.prototype.getNamespaces = function(local) {
  var namespaces = this.namespaces, parent = this.parent, parentNamespaces;
  if (!namespaces) {
    parentNamespaces = parent && parent.getNamespaces();
    if (local || !parentNamespaces) {
      this.namespaces = namespaces = new Namespaces(parentNamespaces);
    } else {
      namespaces = parentNamespaces;
    }
  }
  return namespaces;
};
ElementSerializer.prototype.logNamespace = function(ns2, wellknown, local) {
  var namespaces = this.getNamespaces(local);
  var nsUri = ns2.uri, nsPrefix = ns2.prefix;
  var existing = namespaces.byUri(nsUri);
  if (!existing || local) {
    namespaces.add(ns2, wellknown);
  }
  namespaces.mapPrefix(nsPrefix, nsUri);
  return ns2;
};
ElementSerializer.prototype.logNamespaceUsed = function(ns2, local) {
  var element = this.element, model = element.$model, namespaces = this.getNamespaces(local);
  var prefix3 = ns2.prefix, uri2 = ns2.uri, newPrefix, idx, wellknownUri;
  if (!prefix3 && !uri2) {
    return { localName: ns2.localName };
  }
  wellknownUri = DEFAULT_NS_MAP[prefix3] || model && (model.getPackage(prefix3) || {}).uri;
  uri2 = uri2 || wellknownUri || namespaces.uriByPrefix(prefix3);
  if (!uri2) {
    throw new Error("no namespace uri given for prefix <" + prefix3 + ">");
  }
  ns2 = namespaces.byUri(uri2);
  if (!ns2) {
    newPrefix = prefix3;
    idx = 1;
    while (namespaces.uriByPrefix(newPrefix)) {
      newPrefix = prefix3 + "_" + idx++;
    }
    ns2 = this.logNamespace({ prefix: newPrefix, uri: uri2 }, wellknownUri === uri2);
  }
  if (prefix3) {
    namespaces.mapPrefix(prefix3, uri2);
  }
  return ns2;
};
ElementSerializer.prototype.parseAttributes = function(properties) {
  var self2 = this, element = this.element;
  (0, import_min_dash28.forEach)(properties, function(p6) {
    var value = element.get(p6.name);
    if (p6.isReference) {
      if (!p6.isMany) {
        value = value.id;
      } else {
        var values5 = [];
        (0, import_min_dash28.forEach)(value, function(v5) {
          values5.push(v5.id);
        });
        value = values5.join(" ");
      }
    }
    self2.addAttribute(self2.nsAttributeName(p6), value);
  });
};
ElementSerializer.prototype.addTagName = function(nsTagName) {
  var actualNs = this.logNamespaceUsed(nsTagName);
  this.getNamespaces().logUsed(actualNs);
  return nsName(nsTagName);
};
ElementSerializer.prototype.addAttribute = function(name3, value) {
  var attrs = this.attrs;
  if ((0, import_min_dash28.isString)(value)) {
    value = escapeAttr(value);
  }
  var idx = (0, import_min_dash28.findIndex)(attrs, function(element) {
    return element.name.localName === name3.localName && element.name.uri === name3.uri && element.name.prefix === name3.prefix;
  });
  var attr3 = { name: name3, value };
  if (idx !== -1) {
    attrs.splice(idx, 1, attr3);
  } else {
    attrs.push(attr3);
  }
};
ElementSerializer.prototype.serializeAttributes = function(writer) {
  var attrs = this.attrs, namespaces = this.namespaces;
  if (namespaces) {
    attrs = getNsAttrs(namespaces).concat(attrs);
  }
  (0, import_min_dash28.forEach)(attrs, function(a6) {
    writer.append(" ").append(nsName(a6.name)).append('="').append(a6.value).append('"');
  });
};
ElementSerializer.prototype.serializeTo = function(writer) {
  var firstBody = this.body[0], indent2 = firstBody && firstBody.constructor !== BodySerializer;
  writer.appendIndent().append("<" + this.tagName);
  this.serializeAttributes(writer);
  writer.append(firstBody ? ">" : " />");
  if (firstBody) {
    if (indent2) {
      writer.appendNewLine().indent();
    }
    (0, import_min_dash28.forEach)(this.body, function(b5) {
      b5.serializeTo(writer);
    });
    if (indent2) {
      writer.unindent().appendIndent();
    }
    writer.append("</" + this.tagName + ">");
  }
  writer.appendNewLine();
};
function TypeSerializer(parent, propertyDescriptor) {
  ElementSerializer.call(this, parent, propertyDescriptor);
}
inherits(TypeSerializer, ElementSerializer);
TypeSerializer.prototype.parseNsAttributes = function(element) {
  var attributes = ElementSerializer.prototype.parseNsAttributes.call(this, element);
  var descriptor = element.$descriptor;
  if (descriptor.name === this.propertyDescriptor.type) {
    return attributes;
  }
  var typeNs = this.typeNs = this.nsTagName(descriptor);
  this.getNamespaces().logUsed(this.typeNs);
  var pkg = element.$model.getPackage(typeNs.uri), typePrefix = pkg.xml && pkg.xml.typePrefix || "";
  this.addAttribute(this.nsAttributeName(XSI_TYPE2), (typeNs.prefix ? typeNs.prefix + ":" : "") + typePrefix + descriptor.ns.localName);
  return attributes;
};
TypeSerializer.prototype.isLocalNs = function(ns2) {
  return ns2.uri === (this.typeNs || this.ns).uri;
};
function SavingWriter() {
  this.value = "";
  this.write = function(str) {
    this.value += str;
  };
}
function FormatingWriter(out, format2) {
  var indent2 = [""];
  this.append = function(str) {
    out.write(str);
    return this;
  };
  this.appendNewLine = function() {
    if (format2) {
      out.write("\n");
    }
    return this;
  };
  this.appendIndent = function() {
    if (format2) {
      out.write(indent2.join("  "));
    }
    return this;
  };
  this.indent = function() {
    indent2.push("");
    return this;
  };
  this.unindent = function() {
    indent2.pop();
    return this;
  };
}
function Writer(options2) {
  options2 = (0, import_min_dash28.assign)({ format: false, preamble: true }, options2 || {});
  function toXML(tree, writer) {
    var internalWriter = writer || new SavingWriter();
    var formatingWriter = new FormatingWriter(internalWriter, options2.format);
    if (options2.preamble) {
      formatingWriter.append(XML_PREAMBLE);
    }
    new ElementSerializer().build(tree).serializeTo(formatingWriter);
    if (!writer) {
      return internalWriter.value;
    }
  }
  return {
    toXML
  };
}

// node_modules/bpmn-moddle/dist/index.esm.js
function BpmnModdle(packages2, options2) {
  Moddle.call(this, packages2, options2);
}
BpmnModdle.prototype = Object.create(Moddle.prototype);
BpmnModdle.prototype.fromXML = function(xmlStr, typeName, options2) {
  if (!(0, import_min_dash29.isString)(typeName)) {
    options2 = typeName;
    typeName = "bpmn:Definitions";
  }
  var reader = new Reader((0, import_min_dash29.assign)({ model: this, lax: true }, options2));
  var rootHandler = reader.handler(typeName);
  return reader.fromXML(xmlStr, rootHandler);
};
BpmnModdle.prototype.toXML = function(element, options2) {
  var writer = new Writer(options2);
  return new Promise(function(resolve, reject) {
    try {
      var result = writer.toXML(element);
      return resolve({
        xml: result
      });
    } catch (err) {
      return reject(err);
    }
  });
};
var name$5 = "BPMN20";
var uri$5 = "http://www.omg.org/spec/BPMN/20100524/MODEL";
var prefix$5 = "bpmn";
var associations$5 = [];
var types$5 = [
  {
    name: "Interface",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "operations",
        type: "Operation",
        isMany: true
      },
      {
        name: "implementationRef",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Operation",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "inMessageRef",
        type: "Message",
        isReference: true
      },
      {
        name: "outMessageRef",
        type: "Message",
        isReference: true
      },
      {
        name: "errorRef",
        type: "Error",
        isMany: true,
        isReference: true
      },
      {
        name: "implementationRef",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "EndPoint",
    superClass: [
      "RootElement"
    ]
  },
  {
    name: "Auditing",
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "GlobalTask",
    superClass: [
      "CallableElement"
    ],
    properties: [
      {
        name: "resources",
        type: "ResourceRole",
        isMany: true
      }
    ]
  },
  {
    name: "Monitoring",
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "Performer",
    superClass: [
      "ResourceRole"
    ]
  },
  {
    name: "Process",
    superClass: [
      "FlowElementsContainer",
      "CallableElement"
    ],
    properties: [
      {
        name: "processType",
        type: "ProcessType",
        isAttr: true
      },
      {
        name: "isClosed",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "auditing",
        type: "Auditing"
      },
      {
        name: "monitoring",
        type: "Monitoring"
      },
      {
        name: "properties",
        type: "Property",
        isMany: true
      },
      {
        name: "laneSets",
        isMany: true,
        replaces: "FlowElementsContainer#laneSets",
        type: "LaneSet"
      },
      {
        name: "flowElements",
        isMany: true,
        replaces: "FlowElementsContainer#flowElements",
        type: "FlowElement"
      },
      {
        name: "artifacts",
        type: "Artifact",
        isMany: true
      },
      {
        name: "resources",
        type: "ResourceRole",
        isMany: true
      },
      {
        name: "correlationSubscriptions",
        type: "CorrelationSubscription",
        isMany: true
      },
      {
        name: "supports",
        type: "Process",
        isMany: true,
        isReference: true
      },
      {
        name: "definitionalCollaborationRef",
        type: "Collaboration",
        isAttr: true,
        isReference: true
      },
      {
        name: "isExecutable",
        isAttr: true,
        type: "Boolean"
      }
    ]
  },
  {
    name: "LaneSet",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "lanes",
        type: "Lane",
        isMany: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Lane",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "partitionElementRef",
        type: "BaseElement",
        isAttr: true,
        isReference: true
      },
      {
        name: "partitionElement",
        type: "BaseElement"
      },
      {
        name: "flowNodeRef",
        type: "FlowNode",
        isMany: true,
        isReference: true
      },
      {
        name: "childLaneSet",
        type: "LaneSet",
        xml: {
          serialize: "xsi:type"
        }
      }
    ]
  },
  {
    name: "GlobalManualTask",
    superClass: [
      "GlobalTask"
    ]
  },
  {
    name: "ManualTask",
    superClass: [
      "Task"
    ]
  },
  {
    name: "UserTask",
    superClass: [
      "Task"
    ],
    properties: [
      {
        name: "renderings",
        type: "Rendering",
        isMany: true
      },
      {
        name: "implementation",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Rendering",
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "HumanPerformer",
    superClass: [
      "Performer"
    ]
  },
  {
    name: "PotentialOwner",
    superClass: [
      "HumanPerformer"
    ]
  },
  {
    name: "GlobalUserTask",
    superClass: [
      "GlobalTask"
    ],
    properties: [
      {
        name: "implementation",
        isAttr: true,
        type: "String"
      },
      {
        name: "renderings",
        type: "Rendering",
        isMany: true
      }
    ]
  },
  {
    name: "Gateway",
    isAbstract: true,
    superClass: [
      "FlowNode"
    ],
    properties: [
      {
        name: "gatewayDirection",
        type: "GatewayDirection",
        "default": "Unspecified",
        isAttr: true
      }
    ]
  },
  {
    name: "EventBasedGateway",
    superClass: [
      "Gateway"
    ],
    properties: [
      {
        name: "instantiate",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "eventGatewayType",
        type: "EventBasedGatewayType",
        isAttr: true,
        "default": "Exclusive"
      }
    ]
  },
  {
    name: "ComplexGateway",
    superClass: [
      "Gateway"
    ],
    properties: [
      {
        name: "activationCondition",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "default",
        type: "SequenceFlow",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ExclusiveGateway",
    superClass: [
      "Gateway"
    ],
    properties: [
      {
        name: "default",
        type: "SequenceFlow",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "InclusiveGateway",
    superClass: [
      "Gateway"
    ],
    properties: [
      {
        name: "default",
        type: "SequenceFlow",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ParallelGateway",
    superClass: [
      "Gateway"
    ]
  },
  {
    name: "RootElement",
    isAbstract: true,
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "Relationship",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "type",
        isAttr: true,
        type: "String"
      },
      {
        name: "direction",
        type: "RelationshipDirection",
        isAttr: true
      },
      {
        name: "source",
        isMany: true,
        isReference: true,
        type: "Element"
      },
      {
        name: "target",
        isMany: true,
        isReference: true,
        type: "Element"
      }
    ]
  },
  {
    name: "BaseElement",
    isAbstract: true,
    properties: [
      {
        name: "id",
        isAttr: true,
        type: "String",
        isId: true
      },
      {
        name: "documentation",
        type: "Documentation",
        isMany: true
      },
      {
        name: "extensionDefinitions",
        type: "ExtensionDefinition",
        isMany: true,
        isReference: true
      },
      {
        name: "extensionElements",
        type: "ExtensionElements"
      }
    ]
  },
  {
    name: "Extension",
    properties: [
      {
        name: "mustUnderstand",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "definition",
        type: "ExtensionDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ExtensionDefinition",
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "extensionAttributeDefinitions",
        type: "ExtensionAttributeDefinition",
        isMany: true
      }
    ]
  },
  {
    name: "ExtensionAttributeDefinition",
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "type",
        isAttr: true,
        type: "String"
      },
      {
        name: "isReference",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "extensionDefinition",
        type: "ExtensionDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ExtensionElements",
    properties: [
      {
        name: "valueRef",
        isAttr: true,
        isReference: true,
        type: "Element"
      },
      {
        name: "values",
        type: "Element",
        isMany: true
      },
      {
        name: "extensionAttributeDefinition",
        type: "ExtensionAttributeDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Documentation",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "text",
        type: "String",
        isBody: true
      },
      {
        name: "textFormat",
        "default": "text/plain",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Event",
    isAbstract: true,
    superClass: [
      "FlowNode",
      "InteractionNode"
    ],
    properties: [
      {
        name: "properties",
        type: "Property",
        isMany: true
      }
    ]
  },
  {
    name: "IntermediateCatchEvent",
    superClass: [
      "CatchEvent"
    ]
  },
  {
    name: "IntermediateThrowEvent",
    superClass: [
      "ThrowEvent"
    ]
  },
  {
    name: "EndEvent",
    superClass: [
      "ThrowEvent"
    ]
  },
  {
    name: "StartEvent",
    superClass: [
      "CatchEvent"
    ],
    properties: [
      {
        name: "isInterrupting",
        "default": true,
        isAttr: true,
        type: "Boolean"
      }
    ]
  },
  {
    name: "ThrowEvent",
    isAbstract: true,
    superClass: [
      "Event"
    ],
    properties: [
      {
        name: "dataInputs",
        type: "DataInput",
        isMany: true
      },
      {
        name: "dataInputAssociations",
        type: "DataInputAssociation",
        isMany: true
      },
      {
        name: "inputSet",
        type: "InputSet"
      },
      {
        name: "eventDefinitions",
        type: "EventDefinition",
        isMany: true
      },
      {
        name: "eventDefinitionRef",
        type: "EventDefinition",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "CatchEvent",
    isAbstract: true,
    superClass: [
      "Event"
    ],
    properties: [
      {
        name: "parallelMultiple",
        isAttr: true,
        type: "Boolean",
        "default": false
      },
      {
        name: "dataOutputs",
        type: "DataOutput",
        isMany: true
      },
      {
        name: "dataOutputAssociations",
        type: "DataOutputAssociation",
        isMany: true
      },
      {
        name: "outputSet",
        type: "OutputSet"
      },
      {
        name: "eventDefinitions",
        type: "EventDefinition",
        isMany: true
      },
      {
        name: "eventDefinitionRef",
        type: "EventDefinition",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "BoundaryEvent",
    superClass: [
      "CatchEvent"
    ],
    properties: [
      {
        name: "cancelActivity",
        "default": true,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "attachedToRef",
        type: "Activity",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "EventDefinition",
    isAbstract: true,
    superClass: [
      "RootElement"
    ]
  },
  {
    name: "CancelEventDefinition",
    superClass: [
      "EventDefinition"
    ]
  },
  {
    name: "ErrorEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "errorRef",
        type: "Error",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "TerminateEventDefinition",
    superClass: [
      "EventDefinition"
    ]
  },
  {
    name: "EscalationEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "escalationRef",
        type: "Escalation",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Escalation",
    properties: [
      {
        name: "structureRef",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "escalationCode",
        isAttr: true,
        type: "String"
      }
    ],
    superClass: [
      "RootElement"
    ]
  },
  {
    name: "CompensateEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "waitForCompletion",
        isAttr: true,
        type: "Boolean",
        "default": true
      },
      {
        name: "activityRef",
        type: "Activity",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "TimerEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "timeDate",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "timeCycle",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "timeDuration",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      }
    ]
  },
  {
    name: "LinkEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "target",
        type: "LinkEventDefinition",
        isAttr: true,
        isReference: true
      },
      {
        name: "source",
        type: "LinkEventDefinition",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "MessageEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "messageRef",
        type: "Message",
        isAttr: true,
        isReference: true
      },
      {
        name: "operationRef",
        type: "Operation",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ConditionalEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "condition",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      }
    ]
  },
  {
    name: "SignalEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "signalRef",
        type: "Signal",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Signal",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "structureRef",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ImplicitThrowEvent",
    superClass: [
      "ThrowEvent"
    ]
  },
  {
    name: "DataState",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ItemAwareElement",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "itemSubjectRef",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      },
      {
        name: "dataState",
        type: "DataState"
      }
    ]
  },
  {
    name: "DataAssociation",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "sourceRef",
        type: "ItemAwareElement",
        isMany: true,
        isReference: true
      },
      {
        name: "targetRef",
        type: "ItemAwareElement",
        isReference: true
      },
      {
        name: "transformation",
        type: "FormalExpression",
        xml: {
          serialize: "property"
        }
      },
      {
        name: "assignment",
        type: "Assignment",
        isMany: true
      }
    ]
  },
  {
    name: "DataInput",
    superClass: [
      "ItemAwareElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "isCollection",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "inputSetRef",
        type: "InputSet",
        isMany: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "inputSetWithOptional",
        type: "InputSet",
        isMany: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "inputSetWithWhileExecuting",
        type: "InputSet",
        isMany: true,
        isVirtual: true,
        isReference: true
      }
    ]
  },
  {
    name: "DataOutput",
    superClass: [
      "ItemAwareElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "isCollection",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "outputSetRef",
        type: "OutputSet",
        isMany: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "outputSetWithOptional",
        type: "OutputSet",
        isMany: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "outputSetWithWhileExecuting",
        type: "OutputSet",
        isMany: true,
        isVirtual: true,
        isReference: true
      }
    ]
  },
  {
    name: "InputSet",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "dataInputRefs",
        type: "DataInput",
        isMany: true,
        isReference: true
      },
      {
        name: "optionalInputRefs",
        type: "DataInput",
        isMany: true,
        isReference: true
      },
      {
        name: "whileExecutingInputRefs",
        type: "DataInput",
        isMany: true,
        isReference: true
      },
      {
        name: "outputSetRefs",
        type: "OutputSet",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "OutputSet",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "dataOutputRefs",
        type: "DataOutput",
        isMany: true,
        isReference: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "inputSetRefs",
        type: "InputSet",
        isMany: true,
        isReference: true
      },
      {
        name: "optionalOutputRefs",
        type: "DataOutput",
        isMany: true,
        isReference: true
      },
      {
        name: "whileExecutingOutputRefs",
        type: "DataOutput",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "Property",
    superClass: [
      "ItemAwareElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "DataInputAssociation",
    superClass: [
      "DataAssociation"
    ]
  },
  {
    name: "DataOutputAssociation",
    superClass: [
      "DataAssociation"
    ]
  },
  {
    name: "InputOutputSpecification",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "dataInputs",
        type: "DataInput",
        isMany: true
      },
      {
        name: "dataOutputs",
        type: "DataOutput",
        isMany: true
      },
      {
        name: "inputSets",
        type: "InputSet",
        isMany: true
      },
      {
        name: "outputSets",
        type: "OutputSet",
        isMany: true
      }
    ]
  },
  {
    name: "DataObject",
    superClass: [
      "FlowElement",
      "ItemAwareElement"
    ],
    properties: [
      {
        name: "isCollection",
        "default": false,
        isAttr: true,
        type: "Boolean"
      }
    ]
  },
  {
    name: "InputOutputBinding",
    properties: [
      {
        name: "inputDataRef",
        type: "InputSet",
        isAttr: true,
        isReference: true
      },
      {
        name: "outputDataRef",
        type: "OutputSet",
        isAttr: true,
        isReference: true
      },
      {
        name: "operationRef",
        type: "Operation",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Assignment",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "from",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "to",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      }
    ]
  },
  {
    name: "DataStore",
    superClass: [
      "RootElement",
      "ItemAwareElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "capacity",
        isAttr: true,
        type: "Integer"
      },
      {
        name: "isUnlimited",
        "default": true,
        isAttr: true,
        type: "Boolean"
      }
    ]
  },
  {
    name: "DataStoreReference",
    superClass: [
      "ItemAwareElement",
      "FlowElement"
    ],
    properties: [
      {
        name: "dataStoreRef",
        type: "DataStore",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "DataObjectReference",
    superClass: [
      "ItemAwareElement",
      "FlowElement"
    ],
    properties: [
      {
        name: "dataObjectRef",
        type: "DataObject",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ConversationLink",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "sourceRef",
        type: "InteractionNode",
        isAttr: true,
        isReference: true
      },
      {
        name: "targetRef",
        type: "InteractionNode",
        isAttr: true,
        isReference: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ConversationAssociation",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "innerConversationNodeRef",
        type: "ConversationNode",
        isAttr: true,
        isReference: true
      },
      {
        name: "outerConversationNodeRef",
        type: "ConversationNode",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "CallConversation",
    superClass: [
      "ConversationNode"
    ],
    properties: [
      {
        name: "calledCollaborationRef",
        type: "Collaboration",
        isAttr: true,
        isReference: true
      },
      {
        name: "participantAssociations",
        type: "ParticipantAssociation",
        isMany: true
      }
    ]
  },
  {
    name: "Conversation",
    superClass: [
      "ConversationNode"
    ]
  },
  {
    name: "SubConversation",
    superClass: [
      "ConversationNode"
    ],
    properties: [
      {
        name: "conversationNodes",
        type: "ConversationNode",
        isMany: true
      }
    ]
  },
  {
    name: "ConversationNode",
    isAbstract: true,
    superClass: [
      "InteractionNode",
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "participantRef",
        type: "Participant",
        isMany: true,
        isReference: true
      },
      {
        name: "messageFlowRefs",
        type: "MessageFlow",
        isMany: true,
        isReference: true
      },
      {
        name: "correlationKeys",
        type: "CorrelationKey",
        isMany: true
      }
    ]
  },
  {
    name: "GlobalConversation",
    superClass: [
      "Collaboration"
    ]
  },
  {
    name: "PartnerEntity",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "participantRef",
        type: "Participant",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "PartnerRole",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "participantRef",
        type: "Participant",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "CorrelationProperty",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "correlationPropertyRetrievalExpression",
        type: "CorrelationPropertyRetrievalExpression",
        isMany: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "type",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Error",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "structureRef",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "errorCode",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "CorrelationKey",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "correlationPropertyRef",
        type: "CorrelationProperty",
        isMany: true,
        isReference: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Expression",
    superClass: [
      "BaseElement"
    ],
    isAbstract: false,
    properties: [
      {
        name: "body",
        isBody: true,
        type: "String"
      }
    ]
  },
  {
    name: "FormalExpression",
    superClass: [
      "Expression"
    ],
    properties: [
      {
        name: "language",
        isAttr: true,
        type: "String"
      },
      {
        name: "evaluatesToTypeRef",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Message",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "itemRef",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ItemDefinition",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "itemKind",
        type: "ItemKind",
        isAttr: true
      },
      {
        name: "structureRef",
        isAttr: true,
        type: "String"
      },
      {
        name: "isCollection",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "import",
        type: "Import",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "FlowElement",
    isAbstract: true,
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "auditing",
        type: "Auditing"
      },
      {
        name: "monitoring",
        type: "Monitoring"
      },
      {
        name: "categoryValueRef",
        type: "CategoryValue",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "SequenceFlow",
    superClass: [
      "FlowElement"
    ],
    properties: [
      {
        name: "isImmediate",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "conditionExpression",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "sourceRef",
        type: "FlowNode",
        isAttr: true,
        isReference: true
      },
      {
        name: "targetRef",
        type: "FlowNode",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "FlowElementsContainer",
    isAbstract: true,
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "laneSets",
        type: "LaneSet",
        isMany: true
      },
      {
        name: "flowElements",
        type: "FlowElement",
        isMany: true
      }
    ]
  },
  {
    name: "CallableElement",
    isAbstract: true,
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "ioSpecification",
        type: "InputOutputSpecification",
        xml: {
          serialize: "property"
        }
      },
      {
        name: "supportedInterfaceRef",
        type: "Interface",
        isMany: true,
        isReference: true
      },
      {
        name: "ioBinding",
        type: "InputOutputBinding",
        isMany: true,
        xml: {
          serialize: "property"
        }
      }
    ]
  },
  {
    name: "FlowNode",
    isAbstract: true,
    superClass: [
      "FlowElement"
    ],
    properties: [
      {
        name: "incoming",
        type: "SequenceFlow",
        isMany: true,
        isReference: true
      },
      {
        name: "outgoing",
        type: "SequenceFlow",
        isMany: true,
        isReference: true
      },
      {
        name: "lanes",
        type: "Lane",
        isMany: true,
        isVirtual: true,
        isReference: true
      }
    ]
  },
  {
    name: "CorrelationPropertyRetrievalExpression",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "messagePath",
        type: "FormalExpression"
      },
      {
        name: "messageRef",
        type: "Message",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "CorrelationPropertyBinding",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "dataPath",
        type: "FormalExpression"
      },
      {
        name: "correlationPropertyRef",
        type: "CorrelationProperty",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Resource",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "resourceParameters",
        type: "ResourceParameter",
        isMany: true
      }
    ]
  },
  {
    name: "ResourceParameter",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "isRequired",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "type",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "CorrelationSubscription",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "correlationKeyRef",
        type: "CorrelationKey",
        isAttr: true,
        isReference: true
      },
      {
        name: "correlationPropertyBinding",
        type: "CorrelationPropertyBinding",
        isMany: true
      }
    ]
  },
  {
    name: "MessageFlow",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "sourceRef",
        type: "InteractionNode",
        isAttr: true,
        isReference: true
      },
      {
        name: "targetRef",
        type: "InteractionNode",
        isAttr: true,
        isReference: true
      },
      {
        name: "messageRef",
        type: "Message",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "MessageFlowAssociation",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "innerMessageFlowRef",
        type: "MessageFlow",
        isAttr: true,
        isReference: true
      },
      {
        name: "outerMessageFlowRef",
        type: "MessageFlow",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "InteractionNode",
    isAbstract: true,
    properties: [
      {
        name: "incomingConversationLinks",
        type: "ConversationLink",
        isMany: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "outgoingConversationLinks",
        type: "ConversationLink",
        isMany: true,
        isVirtual: true,
        isReference: true
      }
    ]
  },
  {
    name: "Participant",
    superClass: [
      "InteractionNode",
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "interfaceRef",
        type: "Interface",
        isMany: true,
        isReference: true
      },
      {
        name: "participantMultiplicity",
        type: "ParticipantMultiplicity"
      },
      {
        name: "endPointRefs",
        type: "EndPoint",
        isMany: true,
        isReference: true
      },
      {
        name: "processRef",
        type: "Process",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ParticipantAssociation",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "innerParticipantRef",
        type: "Participant",
        isAttr: true,
        isReference: true
      },
      {
        name: "outerParticipantRef",
        type: "Participant",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ParticipantMultiplicity",
    properties: [
      {
        name: "minimum",
        "default": 0,
        isAttr: true,
        type: "Integer"
      },
      {
        name: "maximum",
        "default": 1,
        isAttr: true,
        type: "Integer"
      }
    ],
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "Collaboration",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "isClosed",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "participants",
        type: "Participant",
        isMany: true
      },
      {
        name: "messageFlows",
        type: "MessageFlow",
        isMany: true
      },
      {
        name: "artifacts",
        type: "Artifact",
        isMany: true
      },
      {
        name: "conversations",
        type: "ConversationNode",
        isMany: true
      },
      {
        name: "conversationAssociations",
        type: "ConversationAssociation"
      },
      {
        name: "participantAssociations",
        type: "ParticipantAssociation",
        isMany: true
      },
      {
        name: "messageFlowAssociations",
        type: "MessageFlowAssociation",
        isMany: true
      },
      {
        name: "correlationKeys",
        type: "CorrelationKey",
        isMany: true
      },
      {
        name: "choreographyRef",
        type: "Choreography",
        isMany: true,
        isReference: true
      },
      {
        name: "conversationLinks",
        type: "ConversationLink",
        isMany: true
      }
    ]
  },
  {
    name: "ChoreographyActivity",
    isAbstract: true,
    superClass: [
      "FlowNode"
    ],
    properties: [
      {
        name: "participantRef",
        type: "Participant",
        isMany: true,
        isReference: true
      },
      {
        name: "initiatingParticipantRef",
        type: "Participant",
        isAttr: true,
        isReference: true
      },
      {
        name: "correlationKeys",
        type: "CorrelationKey",
        isMany: true
      },
      {
        name: "loopType",
        type: "ChoreographyLoopType",
        "default": "None",
        isAttr: true
      }
    ]
  },
  {
    name: "CallChoreography",
    superClass: [
      "ChoreographyActivity"
    ],
    properties: [
      {
        name: "calledChoreographyRef",
        type: "Choreography",
        isAttr: true,
        isReference: true
      },
      {
        name: "participantAssociations",
        type: "ParticipantAssociation",
        isMany: true
      }
    ]
  },
  {
    name: "SubChoreography",
    superClass: [
      "ChoreographyActivity",
      "FlowElementsContainer"
    ],
    properties: [
      {
        name: "artifacts",
        type: "Artifact",
        isMany: true
      }
    ]
  },
  {
    name: "ChoreographyTask",
    superClass: [
      "ChoreographyActivity"
    ],
    properties: [
      {
        name: "messageFlowRef",
        type: "MessageFlow",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "Choreography",
    superClass: [
      "Collaboration",
      "FlowElementsContainer"
    ]
  },
  {
    name: "GlobalChoreographyTask",
    superClass: [
      "Choreography"
    ],
    properties: [
      {
        name: "initiatingParticipantRef",
        type: "Participant",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "TextAnnotation",
    superClass: [
      "Artifact"
    ],
    properties: [
      {
        name: "text",
        type: "String"
      },
      {
        name: "textFormat",
        "default": "text/plain",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Group",
    superClass: [
      "Artifact"
    ],
    properties: [
      {
        name: "categoryValueRef",
        type: "CategoryValue",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Association",
    superClass: [
      "Artifact"
    ],
    properties: [
      {
        name: "associationDirection",
        type: "AssociationDirection",
        isAttr: true
      },
      {
        name: "sourceRef",
        type: "BaseElement",
        isAttr: true,
        isReference: true
      },
      {
        name: "targetRef",
        type: "BaseElement",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Category",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "categoryValue",
        type: "CategoryValue",
        isMany: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Artifact",
    isAbstract: true,
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "CategoryValue",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "categorizedFlowElements",
        type: "FlowElement",
        isMany: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "value",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Activity",
    isAbstract: true,
    superClass: [
      "FlowNode"
    ],
    properties: [
      {
        name: "isForCompensation",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "default",
        type: "SequenceFlow",
        isAttr: true,
        isReference: true
      },
      {
        name: "ioSpecification",
        type: "InputOutputSpecification",
        xml: {
          serialize: "property"
        }
      },
      {
        name: "boundaryEventRefs",
        type: "BoundaryEvent",
        isMany: true,
        isReference: true
      },
      {
        name: "properties",
        type: "Property",
        isMany: true
      },
      {
        name: "dataInputAssociations",
        type: "DataInputAssociation",
        isMany: true
      },
      {
        name: "dataOutputAssociations",
        type: "DataOutputAssociation",
        isMany: true
      },
      {
        name: "startQuantity",
        "default": 1,
        isAttr: true,
        type: "Integer"
      },
      {
        name: "resources",
        type: "ResourceRole",
        isMany: true
      },
      {
        name: "completionQuantity",
        "default": 1,
        isAttr: true,
        type: "Integer"
      },
      {
        name: "loopCharacteristics",
        type: "LoopCharacteristics"
      }
    ]
  },
  {
    name: "ServiceTask",
    superClass: [
      "Task"
    ],
    properties: [
      {
        name: "implementation",
        isAttr: true,
        type: "String"
      },
      {
        name: "operationRef",
        type: "Operation",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "SubProcess",
    superClass: [
      "Activity",
      "FlowElementsContainer",
      "InteractionNode"
    ],
    properties: [
      {
        name: "triggeredByEvent",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "artifacts",
        type: "Artifact",
        isMany: true
      }
    ]
  },
  {
    name: "LoopCharacteristics",
    isAbstract: true,
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "MultiInstanceLoopCharacteristics",
    superClass: [
      "LoopCharacteristics"
    ],
    properties: [
      {
        name: "isSequential",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "behavior",
        type: "MultiInstanceBehavior",
        "default": "All",
        isAttr: true
      },
      {
        name: "loopCardinality",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "loopDataInputRef",
        type: "ItemAwareElement",
        isReference: true
      },
      {
        name: "loopDataOutputRef",
        type: "ItemAwareElement",
        isReference: true
      },
      {
        name: "inputDataItem",
        type: "DataInput",
        xml: {
          serialize: "property"
        }
      },
      {
        name: "outputDataItem",
        type: "DataOutput",
        xml: {
          serialize: "property"
        }
      },
      {
        name: "complexBehaviorDefinition",
        type: "ComplexBehaviorDefinition",
        isMany: true
      },
      {
        name: "completionCondition",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "oneBehaviorEventRef",
        type: "EventDefinition",
        isAttr: true,
        isReference: true
      },
      {
        name: "noneBehaviorEventRef",
        type: "EventDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "StandardLoopCharacteristics",
    superClass: [
      "LoopCharacteristics"
    ],
    properties: [
      {
        name: "testBefore",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "loopCondition",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "loopMaximum",
        type: "Integer",
        isAttr: true
      }
    ]
  },
  {
    name: "CallActivity",
    superClass: [
      "Activity",
      "InteractionNode"
    ],
    properties: [
      {
        name: "calledElement",
        type: "String",
        isAttr: true
      }
    ]
  },
  {
    name: "Task",
    superClass: [
      "Activity",
      "InteractionNode"
    ]
  },
  {
    name: "SendTask",
    superClass: [
      "Task"
    ],
    properties: [
      {
        name: "implementation",
        isAttr: true,
        type: "String"
      },
      {
        name: "operationRef",
        type: "Operation",
        isAttr: true,
        isReference: true
      },
      {
        name: "messageRef",
        type: "Message",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ReceiveTask",
    superClass: [
      "Task"
    ],
    properties: [
      {
        name: "implementation",
        isAttr: true,
        type: "String"
      },
      {
        name: "instantiate",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "operationRef",
        type: "Operation",
        isAttr: true,
        isReference: true
      },
      {
        name: "messageRef",
        type: "Message",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ScriptTask",
    superClass: [
      "Task"
    ],
    properties: [
      {
        name: "scriptFormat",
        isAttr: true,
        type: "String"
      },
      {
        name: "script",
        type: "String"
      }
    ]
  },
  {
    name: "BusinessRuleTask",
    superClass: [
      "Task"
    ],
    properties: [
      {
        name: "implementation",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "AdHocSubProcess",
    superClass: [
      "SubProcess"
    ],
    properties: [
      {
        name: "completionCondition",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "ordering",
        type: "AdHocOrdering",
        isAttr: true
      },
      {
        name: "cancelRemainingInstances",
        "default": true,
        isAttr: true,
        type: "Boolean"
      }
    ]
  },
  {
    name: "Transaction",
    superClass: [
      "SubProcess"
    ],
    properties: [
      {
        name: "protocol",
        isAttr: true,
        type: "String"
      },
      {
        name: "method",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "GlobalScriptTask",
    superClass: [
      "GlobalTask"
    ],
    properties: [
      {
        name: "scriptLanguage",
        isAttr: true,
        type: "String"
      },
      {
        name: "script",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "GlobalBusinessRuleTask",
    superClass: [
      "GlobalTask"
    ],
    properties: [
      {
        name: "implementation",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ComplexBehaviorDefinition",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "condition",
        type: "FormalExpression"
      },
      {
        name: "event",
        type: "ImplicitThrowEvent"
      }
    ]
  },
  {
    name: "ResourceRole",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "resourceRef",
        type: "Resource",
        isReference: true
      },
      {
        name: "resourceParameterBindings",
        type: "ResourceParameterBinding",
        isMany: true
      },
      {
        name: "resourceAssignmentExpression",
        type: "ResourceAssignmentExpression"
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ResourceParameterBinding",
    properties: [
      {
        name: "expression",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "parameterRef",
        type: "ResourceParameter",
        isAttr: true,
        isReference: true
      }
    ],
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "ResourceAssignmentExpression",
    properties: [
      {
        name: "expression",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      }
    ],
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "Import",
    properties: [
      {
        name: "importType",
        isAttr: true,
        type: "String"
      },
      {
        name: "location",
        isAttr: true,
        type: "String"
      },
      {
        name: "namespace",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Definitions",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "targetNamespace",
        isAttr: true,
        type: "String"
      },
      {
        name: "expressionLanguage",
        "default": "http://www.w3.org/1999/XPath",
        isAttr: true,
        type: "String"
      },
      {
        name: "typeLanguage",
        "default": "http://www.w3.org/2001/XMLSchema",
        isAttr: true,
        type: "String"
      },
      {
        name: "imports",
        type: "Import",
        isMany: true
      },
      {
        name: "extensions",
        type: "Extension",
        isMany: true
      },
      {
        name: "rootElements",
        type: "RootElement",
        isMany: true
      },
      {
        name: "diagrams",
        isMany: true,
        type: "bpmndi:BPMNDiagram"
      },
      {
        name: "exporter",
        isAttr: true,
        type: "String"
      },
      {
        name: "relationships",
        type: "Relationship",
        isMany: true
      },
      {
        name: "exporterVersion",
        isAttr: true,
        type: "String"
      }
    ]
  }
];
var enumerations$3 = [
  {
    name: "ProcessType",
    literalValues: [
      {
        name: "None"
      },
      {
        name: "Public"
      },
      {
        name: "Private"
      }
    ]
  },
  {
    name: "GatewayDirection",
    literalValues: [
      {
        name: "Unspecified"
      },
      {
        name: "Converging"
      },
      {
        name: "Diverging"
      },
      {
        name: "Mixed"
      }
    ]
  },
  {
    name: "EventBasedGatewayType",
    literalValues: [
      {
        name: "Parallel"
      },
      {
        name: "Exclusive"
      }
    ]
  },
  {
    name: "RelationshipDirection",
    literalValues: [
      {
        name: "None"
      },
      {
        name: "Forward"
      },
      {
        name: "Backward"
      },
      {
        name: "Both"
      }
    ]
  },
  {
    name: "ItemKind",
    literalValues: [
      {
        name: "Physical"
      },
      {
        name: "Information"
      }
    ]
  },
  {
    name: "ChoreographyLoopType",
    literalValues: [
      {
        name: "None"
      },
      {
        name: "Standard"
      },
      {
        name: "MultiInstanceSequential"
      },
      {
        name: "MultiInstanceParallel"
      }
    ]
  },
  {
    name: "AssociationDirection",
    literalValues: [
      {
        name: "None"
      },
      {
        name: "One"
      },
      {
        name: "Both"
      }
    ]
  },
  {
    name: "MultiInstanceBehavior",
    literalValues: [
      {
        name: "None"
      },
      {
        name: "One"
      },
      {
        name: "All"
      },
      {
        name: "Complex"
      }
    ]
  },
  {
    name: "AdHocOrdering",
    literalValues: [
      {
        name: "Parallel"
      },
      {
        name: "Sequential"
      }
    ]
  }
];
var xml$1 = {
  tagAlias: "lowerCase",
  typePrefix: "t"
};
var BpmnPackage = {
  name: name$5,
  uri: uri$5,
  prefix: prefix$5,
  associations: associations$5,
  types: types$5,
  enumerations: enumerations$3,
  xml: xml$1
};
var name$4 = "BPMNDI";
var uri$4 = "http://www.omg.org/spec/BPMN/20100524/DI";
var prefix$4 = "bpmndi";
var types$4 = [
  {
    name: "BPMNDiagram",
    properties: [
      {
        name: "plane",
        type: "BPMNPlane",
        redefines: "di:Diagram#rootElement"
      },
      {
        name: "labelStyle",
        type: "BPMNLabelStyle",
        isMany: true
      }
    ],
    superClass: [
      "di:Diagram"
    ]
  },
  {
    name: "BPMNPlane",
    properties: [
      {
        name: "bpmnElement",
        isAttr: true,
        isReference: true,
        type: "bpmn:BaseElement",
        redefines: "di:DiagramElement#modelElement"
      }
    ],
    superClass: [
      "di:Plane"
    ]
  },
  {
    name: "BPMNShape",
    properties: [
      {
        name: "bpmnElement",
        isAttr: true,
        isReference: true,
        type: "bpmn:BaseElement",
        redefines: "di:DiagramElement#modelElement"
      },
      {
        name: "isHorizontal",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "isExpanded",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "isMarkerVisible",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "label",
        type: "BPMNLabel"
      },
      {
        name: "isMessageVisible",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "participantBandKind",
        type: "ParticipantBandKind",
        isAttr: true
      },
      {
        name: "choreographyActivityShape",
        type: "BPMNShape",
        isAttr: true,
        isReference: true
      }
    ],
    superClass: [
      "di:LabeledShape"
    ]
  },
  {
    name: "BPMNEdge",
    properties: [
      {
        name: "label",
        type: "BPMNLabel"
      },
      {
        name: "bpmnElement",
        isAttr: true,
        isReference: true,
        type: "bpmn:BaseElement",
        redefines: "di:DiagramElement#modelElement"
      },
      {
        name: "sourceElement",
        isAttr: true,
        isReference: true,
        type: "di:DiagramElement",
        redefines: "di:Edge#source"
      },
      {
        name: "targetElement",
        isAttr: true,
        isReference: true,
        type: "di:DiagramElement",
        redefines: "di:Edge#target"
      },
      {
        name: "messageVisibleKind",
        type: "MessageVisibleKind",
        isAttr: true,
        "default": "initiating"
      }
    ],
    superClass: [
      "di:LabeledEdge"
    ]
  },
  {
    name: "BPMNLabel",
    properties: [
      {
        name: "labelStyle",
        type: "BPMNLabelStyle",
        isAttr: true,
        isReference: true,
        redefines: "di:DiagramElement#style"
      }
    ],
    superClass: [
      "di:Label"
    ]
  },
  {
    name: "BPMNLabelStyle",
    properties: [
      {
        name: "font",
        type: "dc:Font"
      }
    ],
    superClass: [
      "di:Style"
    ]
  }
];
var enumerations$2 = [
  {
    name: "ParticipantBandKind",
    literalValues: [
      {
        name: "top_initiating"
      },
      {
        name: "middle_initiating"
      },
      {
        name: "bottom_initiating"
      },
      {
        name: "top_non_initiating"
      },
      {
        name: "middle_non_initiating"
      },
      {
        name: "bottom_non_initiating"
      }
    ]
  },
  {
    name: "MessageVisibleKind",
    literalValues: [
      {
        name: "initiating"
      },
      {
        name: "non_initiating"
      }
    ]
  }
];
var associations$4 = [];
var BpmnDiPackage = {
  name: name$4,
  uri: uri$4,
  prefix: prefix$4,
  types: types$4,
  enumerations: enumerations$2,
  associations: associations$4
};
var name$3 = "DC";
var uri$3 = "http://www.omg.org/spec/DD/20100524/DC";
var prefix$3 = "dc";
var types$3 = [
  {
    name: "Boolean"
  },
  {
    name: "Integer"
  },
  {
    name: "Real"
  },
  {
    name: "String"
  },
  {
    name: "Font",
    properties: [
      {
        name: "name",
        type: "String",
        isAttr: true
      },
      {
        name: "size",
        type: "Real",
        isAttr: true
      },
      {
        name: "isBold",
        type: "Boolean",
        isAttr: true
      },
      {
        name: "isItalic",
        type: "Boolean",
        isAttr: true
      },
      {
        name: "isUnderline",
        type: "Boolean",
        isAttr: true
      },
      {
        name: "isStrikeThrough",
        type: "Boolean",
        isAttr: true
      }
    ]
  },
  {
    name: "Point",
    properties: [
      {
        name: "x",
        type: "Real",
        "default": "0",
        isAttr: true
      },
      {
        name: "y",
        type: "Real",
        "default": "0",
        isAttr: true
      }
    ]
  },
  {
    name: "Bounds",
    properties: [
      {
        name: "x",
        type: "Real",
        "default": "0",
        isAttr: true
      },
      {
        name: "y",
        type: "Real",
        "default": "0",
        isAttr: true
      },
      {
        name: "width",
        type: "Real",
        isAttr: true
      },
      {
        name: "height",
        type: "Real",
        isAttr: true
      }
    ]
  }
];
var associations$3 = [];
var DcPackage = {
  name: name$3,
  uri: uri$3,
  prefix: prefix$3,
  types: types$3,
  associations: associations$3
};
var name$2 = "DI";
var uri$2 = "http://www.omg.org/spec/DD/20100524/DI";
var prefix$2 = "di";
var types$2 = [
  {
    name: "DiagramElement",
    isAbstract: true,
    properties: [
      {
        name: "id",
        isAttr: true,
        isId: true,
        type: "String"
      },
      {
        name: "extension",
        type: "Extension"
      },
      {
        name: "owningDiagram",
        type: "Diagram",
        isReadOnly: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "owningElement",
        type: "DiagramElement",
        isReadOnly: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "modelElement",
        isReadOnly: true,
        isVirtual: true,
        isReference: true,
        type: "Element"
      },
      {
        name: "style",
        type: "Style",
        isReadOnly: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "ownedElement",
        type: "DiagramElement",
        isReadOnly: true,
        isMany: true,
        isVirtual: true
      }
    ]
  },
  {
    name: "Node",
    isAbstract: true,
    superClass: [
      "DiagramElement"
    ]
  },
  {
    name: "Edge",
    isAbstract: true,
    superClass: [
      "DiagramElement"
    ],
    properties: [
      {
        name: "source",
        type: "DiagramElement",
        isReadOnly: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "target",
        type: "DiagramElement",
        isReadOnly: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "waypoint",
        isUnique: false,
        isMany: true,
        type: "dc:Point",
        xml: {
          serialize: "xsi:type"
        }
      }
    ]
  },
  {
    name: "Diagram",
    isAbstract: true,
    properties: [
      {
        name: "id",
        isAttr: true,
        isId: true,
        type: "String"
      },
      {
        name: "rootElement",
        type: "DiagramElement",
        isReadOnly: true,
        isVirtual: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "documentation",
        isAttr: true,
        type: "String"
      },
      {
        name: "resolution",
        isAttr: true,
        type: "Real"
      },
      {
        name: "ownedStyle",
        type: "Style",
        isReadOnly: true,
        isMany: true,
        isVirtual: true
      }
    ]
  },
  {
    name: "Shape",
    isAbstract: true,
    superClass: [
      "Node"
    ],
    properties: [
      {
        name: "bounds",
        type: "dc:Bounds"
      }
    ]
  },
  {
    name: "Plane",
    isAbstract: true,
    superClass: [
      "Node"
    ],
    properties: [
      {
        name: "planeElement",
        type: "DiagramElement",
        subsettedProperty: "DiagramElement-ownedElement",
        isMany: true
      }
    ]
  },
  {
    name: "LabeledEdge",
    isAbstract: true,
    superClass: [
      "Edge"
    ],
    properties: [
      {
        name: "ownedLabel",
        type: "Label",
        isReadOnly: true,
        subsettedProperty: "DiagramElement-ownedElement",
        isMany: true,
        isVirtual: true
      }
    ]
  },
  {
    name: "LabeledShape",
    isAbstract: true,
    superClass: [
      "Shape"
    ],
    properties: [
      {
        name: "ownedLabel",
        type: "Label",
        isReadOnly: true,
        subsettedProperty: "DiagramElement-ownedElement",
        isMany: true,
        isVirtual: true
      }
    ]
  },
  {
    name: "Label",
    isAbstract: true,
    superClass: [
      "Node"
    ],
    properties: [
      {
        name: "bounds",
        type: "dc:Bounds"
      }
    ]
  },
  {
    name: "Style",
    isAbstract: true,
    properties: [
      {
        name: "id",
        isAttr: true,
        isId: true,
        type: "String"
      }
    ]
  },
  {
    name: "Extension",
    properties: [
      {
        name: "values",
        isMany: true,
        type: "Element"
      }
    ]
  }
];
var associations$2 = [];
var xml = {
  tagAlias: "lowerCase"
};
var DiPackage = {
  name: name$2,
  uri: uri$2,
  prefix: prefix$2,
  types: types$2,
  associations: associations$2,
  xml
};
var name$1 = "bpmn.io colors for BPMN";
var uri$1 = "http://bpmn.io/schema/bpmn/biocolor/1.0";
var prefix$1 = "bioc";
var types$1 = [
  {
    name: "ColoredShape",
    "extends": [
      "bpmndi:BPMNShape"
    ],
    properties: [
      {
        name: "stroke",
        isAttr: true,
        type: "String"
      },
      {
        name: "fill",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ColoredEdge",
    "extends": [
      "bpmndi:BPMNEdge"
    ],
    properties: [
      {
        name: "stroke",
        isAttr: true,
        type: "String"
      },
      {
        name: "fill",
        isAttr: true,
        type: "String"
      }
    ]
  }
];
var enumerations$1 = [];
var associations$1 = [];
var BiocPackage = {
  name: name$1,
  uri: uri$1,
  prefix: prefix$1,
  types: types$1,
  enumerations: enumerations$1,
  associations: associations$1
};
var name = "BPMN in Color";
var uri = "http://www.omg.org/spec/BPMN/non-normative/color/1.0";
var prefix2 = "color";
var types2 = [
  {
    name: "ColoredLabel",
    "extends": [
      "bpmndi:BPMNLabel"
    ],
    properties: [
      {
        name: "color",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ColoredShape",
    "extends": [
      "bpmndi:BPMNShape"
    ],
    properties: [
      {
        name: "background-color",
        isAttr: true,
        type: "String"
      },
      {
        name: "border-color",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ColoredEdge",
    "extends": [
      "bpmndi:BPMNEdge"
    ],
    properties: [
      {
        name: "border-color",
        isAttr: true,
        type: "String"
      }
    ]
  }
];
var enumerations = [];
var associations = [];
var BpmnInColorPackage = {
  name,
  uri,
  prefix: prefix2,
  types: types2,
  enumerations,
  associations
};
var packages = {
  bpmn: BpmnPackage,
  bpmndi: BpmnDiPackage,
  dc: DcPackage,
  di: DiPackage,
  bioc: BiocPackage,
  color: BpmnInColorPackage
};
function simple(additionalPackages, options2) {
  var pks = (0, import_min_dash29.assign)({}, packages, additionalPackages);
  return new BpmnModdle(pks, options2);
}

// node_modules/bpmn-js/lib/import/Importer.js
var import_min_dash32 = __toESM(require_dist());

// node_modules/bpmn-js/lib/import/BpmnTreeWalker.js
var import_min_dash31 = __toESM(require_dist());

// node_modules/bpmn-js/lib/util/CompatibilityUtil.js
var import_min_dash30 = __toESM(require_dist());
function wrapForCompatibility(api) {
  return function() {
    if (!window.Promise) {
      throw new Error("Promises is not supported in this environment. Please polyfill Promise.");
    }
    var argLen = arguments.length;
    if (argLen >= 1 && (0, import_min_dash30.isFunction)(arguments[argLen - 1])) {
      var callback = arguments[argLen - 1];
      console.warn(new Error("Passing callbacks to " + api.name + " is deprecated and will be removed in a future major release. Please switch to promises: https://bpmn.io/l/moving-to-promises.html"));
      var argsWithoutCallback = Array.prototype.slice.call(arguments, 0, -1);
      api.apply(this, argsWithoutCallback).then(function(result) {
        var firstKey = Object.keys(result)[0];
        return callback(null, result[firstKey]);
      }, function(err) {
        return callback(err, err.warnings);
      });
    } else {
      return api.apply(this, arguments);
    }
  };
}
var DI_ERROR_MESSAGE = "Tried to access di from the businessObject. The di is available through the diagram element only. For more information, see https://github.com/bpmn-io/bpmn-js/issues/1472";
function ensureCompatDiRef(businessObject) {
  if (!(0, import_min_dash30.has)(businessObject, "di")) {
    Object.defineProperty(businessObject, "di", {
      enumerable: false,
      get: function() {
        throw new Error(DI_ERROR_MESSAGE);
      }
    });
  }
}

// node_modules/bpmn-js/lib/import/BpmnTreeWalker.js
function is2(element, type) {
  return element.$instanceOf(type);
}
function findDisplayCandidate(definitions) {
  return (0, import_min_dash31.find)(definitions.rootElements, function(e7) {
    return is2(e7, "bpmn:Process") || is2(e7, "bpmn:Collaboration");
  });
}
function BpmnTreeWalker(handler, translate3) {
  var handledElements = {};
  var deferred = [];
  var diMap = {};
  function contextual(fn2, ctx) {
    return function(e7) {
      fn2(e7, ctx);
    };
  }
  function handled(element) {
    handledElements[element.id] = element;
  }
  function isHandled(element) {
    return handledElements[element.id];
  }
  function visit(element, ctx) {
    var gfx = element.gfx;
    if (gfx) {
      throw new Error(translate3("already rendered {element}", { element: elementToString(element) }));
    }
    return handler.element(element, diMap[element.id], ctx);
  }
  function visitRoot(element, diagram) {
    return handler.root(element, diMap[element.id], diagram);
  }
  function visitIfDi(element, ctx) {
    try {
      var gfx = diMap[element.id] && visit(element, ctx);
      handled(element);
      return gfx;
    } catch (e7) {
      logError(e7.message, { element, error: e7 });
      console.error(translate3("failed to import {element}", { element: elementToString(element) }));
      console.error(e7);
    }
  }
  function logError(message, context) {
    handler.error(message, context);
  }
  function registerDi(di) {
    var bpmnElement = di.bpmnElement;
    if (bpmnElement) {
      if (diMap[bpmnElement.id]) {
        logError(translate3("multiple DI elements defined for {element}", {
          element: elementToString(bpmnElement)
        }), { element: bpmnElement });
      } else {
        diMap[bpmnElement.id] = di;
        ensureCompatDiRef(bpmnElement);
      }
    } else {
      logError(translate3("no bpmnElement referenced in {element}", {
        element: elementToString(di)
      }), { element: di });
    }
  }
  function handleDiagram(diagram) {
    handlePlane(diagram.plane);
  }
  function handlePlane(plane) {
    registerDi(plane);
    (0, import_min_dash31.forEach)(plane.planeElement, handlePlaneElement);
  }
  function handlePlaneElement(planeElement) {
    registerDi(planeElement);
  }
  function handleDefinitions(definitions, diagram) {
    var diagrams = definitions.diagrams;
    if (diagram && diagrams.indexOf(diagram) === -1) {
      throw new Error(translate3("diagram not part of bpmn:Definitions"));
    }
    if (!diagram && diagrams && diagrams.length) {
      diagram = diagrams[0];
    }
    if (!diagram) {
      throw new Error(translate3("no diagram to display"));
    }
    diMap = {};
    handleDiagram(diagram);
    var plane = diagram.plane;
    if (!plane) {
      throw new Error(translate3("no plane for {element}", { element: elementToString(diagram) }));
    }
    var rootElement = plane.bpmnElement;
    if (!rootElement) {
      rootElement = findDisplayCandidate(definitions);
      if (!rootElement) {
        throw new Error(translate3("no process or collaboration to display"));
      } else {
        logError(translate3("correcting missing bpmnElement on {plane} to {rootElement}", {
          plane: elementToString(plane),
          rootElement: elementToString(rootElement)
        }));
        plane.bpmnElement = rootElement;
        registerDi(plane);
      }
    }
    var ctx = visitRoot(rootElement, plane);
    if (is2(rootElement, "bpmn:Process") || is2(rootElement, "bpmn:SubProcess")) {
      handleProcess(rootElement, ctx);
    } else if (is2(rootElement, "bpmn:Collaboration")) {
      handleCollaboration(rootElement, ctx);
      handleUnhandledProcesses(definitions.rootElements, ctx);
    } else {
      throw new Error(translate3("unsupported bpmnElement for {plane}: {rootElement}", {
        plane: elementToString(plane),
        rootElement: elementToString(rootElement)
      }));
    }
    handleDeferred(deferred);
  }
  function handleDeferred() {
    var fn2;
    while (deferred.length) {
      fn2 = deferred.shift();
      fn2();
    }
  }
  function handleProcess(process2, context) {
    handleFlowElementsContainer(process2, context);
    handleIoSpecification(process2.ioSpecification, context);
    handleArtifacts(process2.artifacts, context);
    handled(process2);
  }
  function handleUnhandledProcesses(rootElements, ctx) {
    var processes = (0, import_min_dash31.filter)(rootElements, function(e7) {
      return !isHandled(e7) && is2(e7, "bpmn:Process") && e7.laneSets;
    });
    processes.forEach(contextual(handleProcess, ctx));
  }
  function handleMessageFlow(messageFlow, context) {
    visitIfDi(messageFlow, context);
  }
  function handleMessageFlows(messageFlows, context) {
    (0, import_min_dash31.forEach)(messageFlows, contextual(handleMessageFlow, context));
  }
  function handleDataAssociation(association, context) {
    visitIfDi(association, context);
  }
  function handleDataInput(dataInput, context) {
    visitIfDi(dataInput, context);
  }
  function handleDataOutput(dataOutput, context) {
    visitIfDi(dataOutput, context);
  }
  function handleArtifact(artifact, context) {
    visitIfDi(artifact, context);
  }
  function handleArtifacts(artifacts, context) {
    (0, import_min_dash31.forEach)(artifacts, function(e7) {
      if (is2(e7, "bpmn:Association")) {
        deferred.push(function() {
          handleArtifact(e7, context);
        });
      } else {
        handleArtifact(e7, context);
      }
    });
  }
  function handleIoSpecification(ioSpecification, context) {
    if (!ioSpecification) {
      return;
    }
    (0, import_min_dash31.forEach)(ioSpecification.dataInputs, contextual(handleDataInput, context));
    (0, import_min_dash31.forEach)(ioSpecification.dataOutputs, contextual(handleDataOutput, context));
  }
  function handleSubProcess(subProcess, context) {
    handleFlowElementsContainer(subProcess, context);
    handleArtifacts(subProcess.artifacts, context);
  }
  function handleFlowNode(flowNode, context) {
    var childCtx = visitIfDi(flowNode, context);
    if (is2(flowNode, "bpmn:SubProcess")) {
      handleSubProcess(flowNode, childCtx || context);
    }
    if (is2(flowNode, "bpmn:Activity")) {
      handleIoSpecification(flowNode.ioSpecification, context);
    }
    deferred.push(function() {
      (0, import_min_dash31.forEach)(flowNode.dataInputAssociations, contextual(handleDataAssociation, context));
      (0, import_min_dash31.forEach)(flowNode.dataOutputAssociations, contextual(handleDataAssociation, context));
    });
  }
  function handleSequenceFlow(sequenceFlow, context) {
    visitIfDi(sequenceFlow, context);
  }
  function handleDataElement(dataObject, context) {
    visitIfDi(dataObject, context);
  }
  function handleLane(lane, context) {
    deferred.push(function() {
      var newContext = visitIfDi(lane, context);
      if (lane.childLaneSet) {
        handleLaneSet(lane.childLaneSet, newContext || context);
      }
      wireFlowNodeRefs(lane);
    });
  }
  function handleLaneSet(laneSet, context) {
    (0, import_min_dash31.forEach)(laneSet.lanes, contextual(handleLane, context));
  }
  function handleLaneSets(laneSets, context) {
    (0, import_min_dash31.forEach)(laneSets, contextual(handleLaneSet, context));
  }
  function handleFlowElementsContainer(container, context) {
    handleFlowElements(container.flowElements, context);
    if (container.laneSets) {
      handleLaneSets(container.laneSets, context);
    }
  }
  function handleFlowElements(flowElements, context) {
    (0, import_min_dash31.forEach)(flowElements, function(e7) {
      if (is2(e7, "bpmn:SequenceFlow")) {
        deferred.push(function() {
          handleSequenceFlow(e7, context);
        });
      } else if (is2(e7, "bpmn:BoundaryEvent")) {
        deferred.unshift(function() {
          handleFlowNode(e7, context);
        });
      } else if (is2(e7, "bpmn:FlowNode")) {
        handleFlowNode(e7, context);
      } else if (is2(e7, "bpmn:DataObject")) {
      } else if (is2(e7, "bpmn:DataStoreReference")) {
        handleDataElement(e7, context);
      } else if (is2(e7, "bpmn:DataObjectReference")) {
        handleDataElement(e7, context);
      } else {
        logError(translate3("unrecognized flowElement {element} in context {context}", {
          element: elementToString(e7),
          context: context ? elementToString(context.businessObject) : "null"
        }), { element: e7, context });
      }
    });
  }
  function handleParticipant(participant, context) {
    var newCtx = visitIfDi(participant, context);
    var process2 = participant.processRef;
    if (process2) {
      handleProcess(process2, newCtx || context);
    }
  }
  function handleCollaboration(collaboration, context) {
    (0, import_min_dash31.forEach)(collaboration.participants, contextual(handleParticipant, context));
    handleArtifacts(collaboration.artifacts, context);
    deferred.push(function() {
      handleMessageFlows(collaboration.messageFlows, context);
    });
  }
  function wireFlowNodeRefs(lane) {
    (0, import_min_dash31.forEach)(lane.flowNodeRef, function(flowNode) {
      var lanes = flowNode.get("lanes");
      if (lanes) {
        lanes.push(lane);
      }
    });
  }
  return {
    handleDeferred,
    handleDefinitions,
    handleSubProcess,
    registerDi
  };
}

// node_modules/bpmn-js/lib/import/Importer.js
function importBpmnDiagram(diagram, definitions, bpmnDiagram) {
  var importer, eventBus, translate3, canvas;
  var error4, warnings = [];
  function render(definitions2, bpmnDiagram2) {
    var visitor = {
      root: function(element, di) {
        return importer.add(element, di);
      },
      element: function(element, di, parentShape) {
        return importer.add(element, di, parentShape);
      },
      error: function(message, context) {
        warnings.push({ message, context });
      }
    };
    var walker = new BpmnTreeWalker(visitor, translate3);
    bpmnDiagram2 = bpmnDiagram2 || definitions2.diagrams && definitions2.diagrams[0];
    var diagramsToImport = getDiagramsToImport(definitions2, bpmnDiagram2);
    if (!diagramsToImport) {
      throw new Error(translate3("no diagram to display"));
    }
    (0, import_min_dash32.forEach)(diagramsToImport, function(diagram2) {
      walker.handleDefinitions(definitions2, diagram2);
    });
    var rootId = bpmnDiagram2.plane.bpmnElement.id;
    canvas.setRootElement(canvas.findRoot(rootId + "_plane") || canvas.findRoot(rootId));
  }
  return new Promise(function(resolve, reject) {
    try {
      importer = diagram.get("bpmnImporter");
      eventBus = diagram.get("eventBus");
      translate3 = diagram.get("translate");
      canvas = diagram.get("canvas");
      eventBus.fire("import.render.start", { definitions });
      render(definitions, bpmnDiagram);
      eventBus.fire("import.render.complete", {
        error: error4,
        warnings
      });
      return resolve({ warnings });
    } catch (e7) {
      e7.warnings = warnings;
      return reject(e7);
    }
  });
}
function getDiagramsToImport(definitions, bpmnDiagram) {
  if (!bpmnDiagram) {
    return;
  }
  var bpmnElement = bpmnDiagram.plane.bpmnElement, rootElement = bpmnElement;
  if (!is(bpmnElement, "bpmn:Process") && !is(bpmnElement, "bpmn:Collaboration")) {
    rootElement = findRootProcess(bpmnElement);
  }
  var collaboration;
  if (is(rootElement, "bpmn:Collaboration")) {
    collaboration = rootElement;
  } else {
    collaboration = (0, import_min_dash32.find)(definitions.rootElements, function(element) {
      if (!is(element, "bpmn:Collaboration")) {
        return;
      }
      return (0, import_min_dash32.find)(element.participants, function(participant) {
        return participant.processRef === rootElement;
      });
    });
  }
  var rootElements = [rootElement];
  if (collaboration) {
    rootElements = (0, import_min_dash32.map)(collaboration.participants, function(participant) {
      return participant.processRef;
    });
    rootElements.push(collaboration);
  }
  var allChildren = selfAndAllFlowElements(rootElements);
  var diagramsToImport = [bpmnDiagram];
  var handledElements = [bpmnElement];
  (0, import_min_dash32.forEach)(definitions.diagrams, function(diagram) {
    var businessObject = diagram.plane.bpmnElement;
    if (allChildren.indexOf(businessObject) !== -1 && handledElements.indexOf(businessObject) === -1) {
      diagramsToImport.push(diagram);
      handledElements.push(businessObject);
    }
  });
  return diagramsToImport;
}
function selfAndAllFlowElements(elements) {
  var result = [];
  (0, import_min_dash32.forEach)(elements, function(element) {
    if (!element) {
      return;
    }
    result.push(element);
    result = result.concat(selfAndAllFlowElements(element.flowElements));
  });
  return result;
}
function findRootProcess(element) {
  var parent = element;
  while (parent) {
    if (is(parent, "bpmn:Process")) {
      return parent;
    }
    parent = parent.$parent;
  }
}

// node_modules/bpmn-js/lib/util/PoweredByUtil.js
var BPMNIO_LOGO_SVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14.02 5.57" width="53" height="21"><path fill="currentColor" d="M1.88.92v.14c0 .41-.13.68-.4.8.33.14.46.44.46.86v.33c0 .61-.33.95-.95.95H0V0h.95c.65 0 .93.3.93.92zM.63.57v1.06h.24c.24 0 .38-.1.38-.43V.98c0-.28-.1-.4-.32-.4zm0 1.63v1.22h.36c.2 0 .32-.1.32-.39v-.35c0-.37-.12-.48-.4-.48H.63zM4.18.99v.52c0 .64-.31.98-.94.98h-.3V4h-.62V0h.92c.63 0 .94.35.94.99zM2.94.57v1.35h.3c.2 0 .3-.09.3-.37v-.6c0-.29-.1-.38-.3-.38h-.3zm2.89 2.27L6.25 0h.88v4h-.6V1.12L6.1 3.99h-.6l-.46-2.82v2.82h-.55V0h.87zM8.14 1.1V4h-.56V0h.79L9 2.4V0h.56v4h-.64zm2.49 2.29v.6h-.6v-.6zM12.12 1c0-.63.33-1 .95-1 .61 0 .95.37.95 1v2.04c0 .64-.34 1-.95 1-.62 0-.95-.37-.95-1zm.62 2.08c0 .28.13.39.33.39s.32-.1.32-.4V.98c0-.29-.12-.4-.32-.4s-.33.11-.33.4z"/><path fill="currentColor" d="M0 4.53h14.02v1.04H0zM11.08 0h.63v.62h-.63zm.63 4V1h-.63v2.98z"/></svg>';
var BPMNIO_IMG = BPMNIO_LOGO_SVG;
var LOGO_STYLES = {
  verticalAlign: "middle"
};
var LINK_STYLES = {
  "color": "#404040"
};
var LIGHTBOX_STYLES = {
  "zIndex": "1001",
  "position": "fixed",
  "top": "0",
  "left": "0",
  "right": "0",
  "bottom": "0"
};
var BACKDROP_STYLES = {
  "width": "100%",
  "height": "100%",
  "background": "rgba(40,40,40,0.2)"
};
var NOTICE_STYLES = {
  "position": "absolute",
  "left": "50%",
  "top": "40%",
  "transform": "translate(-50%)",
  "width": "260px",
  "padding": "10px",
  "background": "white",
  "boxShadow": "0 1px 4px rgba(0,0,0,0.3)",
  "fontFamily": "Helvetica, Arial, sans-serif",
  "fontSize": "14px",
  "display": "flex",
  "lineHeight": "1.3"
};
var LIGHTBOX_MARKUP = '<div class="bjs-powered-by-lightbox"><div class="backdrop"></div><div class="notice"><a href="https://bpmn.io" target="_blank" rel="noopener" class="link">' + BPMNIO_IMG + '</a><span>Web-based tooling for BPMN, DMN and CMMN diagrams powered by <a href="https://bpmn.io" target="_blank" rel="noopener">bpmn.io</a>.</span></div></div>';
var lightbox;
function createLightbox() {
  lightbox = domify$1(LIGHTBOX_MARKUP);
  assign(lightbox, LIGHTBOX_STYLES);
  assign(query("svg", lightbox), LOGO_STYLES);
  assign(query(".backdrop", lightbox), BACKDROP_STYLES);
  assign(query(".notice", lightbox), NOTICE_STYLES);
  assign(query(".link", lightbox), LINK_STYLES, {
    "margin": "15px 20px 15px 10px",
    "alignSelf": "center"
  });
}
function open() {
  if (!lightbox) {
    createLightbox();
    delegate.bind(lightbox, ".backdrop", "click", function(event2) {
      document.body.removeChild(lightbox);
    });
  }
  document.body.appendChild(lightbox);
}

// node_modules/bpmn-js/lib/BaseViewer.js
function BaseViewer(options2) {
  options2 = (0, import_min_dash33.assign)({}, DEFAULT_OPTIONS, options2);
  this._moddle = this._createModdle(options2);
  this._container = this._createContainer(options2);
  addProjectLogo(this._container);
  this._init(this._container, this._moddle, options2);
}
e(BaseViewer, Diagram);
BaseViewer.prototype.importXML = wrapForCompatibility(async function importXML(xml2, bpmnDiagram) {
  const self2 = this;
  function ParseCompleteEvent(data) {
    const event2 = self2.get("eventBus").createEvent(data);
    Object.defineProperty(event2, "context", {
      enumerable: true,
      get: function() {
        console.warn(new Error("import.parse.complete <context> is deprecated and will be removed in future library versions"));
        return {
          warnings: data.warnings,
          references: data.references,
          elementsById: data.elementsById
        };
      }
    });
    return event2;
  }
  let aggregatedWarnings = [];
  try {
    xml2 = this._emit("import.parse.start", { xml: xml2 }) || xml2;
    let parseResult;
    try {
      parseResult = await this._moddle.fromXML(xml2, "bpmn:Definitions");
    } catch (error4) {
      this._emit("import.parse.complete", {
        error: error4
      });
      throw error4;
    }
    let definitions = parseResult.rootElement;
    const references = parseResult.references;
    const parseWarnings = parseResult.warnings;
    const elementsById = parseResult.elementsById;
    aggregatedWarnings = aggregatedWarnings.concat(parseWarnings);
    definitions = this._emit("import.parse.complete", ParseCompleteEvent({
      error: null,
      definitions,
      elementsById,
      references,
      warnings: aggregatedWarnings
    })) || definitions;
    const importResult = await this.importDefinitions(definitions, bpmnDiagram);
    aggregatedWarnings = aggregatedWarnings.concat(importResult.warnings);
    this._emit("import.done", { error: null, warnings: aggregatedWarnings });
    return { warnings: aggregatedWarnings };
  } catch (err) {
    let error4 = err;
    aggregatedWarnings = aggregatedWarnings.concat(error4.warnings || []);
    addWarningsToError(error4, aggregatedWarnings);
    error4 = checkValidationError(error4);
    this._emit("import.done", { error: error4, warnings: error4.warnings });
    throw error4;
  }
});
BaseViewer.prototype.importDefinitions = wrapForCompatibility(async function importDefinitions(definitions, bpmnDiagram) {
  this._setDefinitions(definitions);
  const result = await this.open(bpmnDiagram);
  return { warnings: result.warnings };
});
BaseViewer.prototype.open = wrapForCompatibility(async function open2(bpmnDiagramOrId) {
  const definitions = this._definitions;
  let bpmnDiagram = bpmnDiagramOrId;
  if (!definitions) {
    const error4 = new Error("no XML imported");
    addWarningsToError(error4, []);
    throw error4;
  }
  if (typeof bpmnDiagramOrId === "string") {
    bpmnDiagram = findBPMNDiagram(definitions, bpmnDiagramOrId);
    if (!bpmnDiagram) {
      const error4 = new Error("BPMNDiagram <" + bpmnDiagramOrId + "> not found");
      addWarningsToError(error4, []);
      throw error4;
    }
  }
  try {
    this.clear();
  } catch (error4) {
    addWarningsToError(error4, []);
    throw error4;
  }
  const { warnings } = await importBpmnDiagram(this, definitions, bpmnDiagram);
  return { warnings };
});
BaseViewer.prototype.saveXML = wrapForCompatibility(async function saveXML(options2) {
  options2 = options2 || {};
  let definitions = this._definitions, error4, xml2;
  try {
    if (!definitions) {
      throw new Error("no definitions loaded");
    }
    definitions = this._emit("saveXML.start", {
      definitions
    }) || definitions;
    const result2 = await this._moddle.toXML(definitions, options2);
    xml2 = result2.xml;
    xml2 = this._emit("saveXML.serialized", {
      xml: xml2
    }) || xml2;
  } catch (err) {
    error4 = err;
  }
  const result = error4 ? { error: error4 } : { xml: xml2 };
  this._emit("saveXML.done", result);
  if (error4) {
    throw error4;
  }
  return result;
});
BaseViewer.prototype.saveSVG = wrapForCompatibility(async function saveSVG(options2 = {}) {
  this._emit("saveSVG.start");
  let svg, err;
  try {
    const canvas = this.get("canvas");
    const contentNode = canvas.getActiveLayer(), defsNode = query("defs", canvas._svg);
    const contents = innerSVG(contentNode), defs = defsNode ? "<defs>" + innerSVG(defsNode) + "</defs>" : "";
    const bbox = contentNode.getBBox();
    svg = '<?xml version="1.0" encoding="utf-8"?>\n<!-- created with bpmn-js / http://bpmn.io -->\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="' + bbox.width + '" height="' + bbox.height + '" viewBox="' + bbox.x + " " + bbox.y + " " + bbox.width + " " + bbox.height + '" version="1.1">' + defs + contents + "</svg>";
  } catch (e7) {
    err = e7;
  }
  this._emit("saveSVG.done", {
    error: err,
    svg
  });
  if (err) {
    throw err;
  }
  return { svg };
});
BaseViewer.prototype._setDefinitions = function(definitions) {
  this._definitions = definitions;
};
BaseViewer.prototype.getModules = function() {
  return this._modules;
};
BaseViewer.prototype.clear = function() {
  if (!this.getDefinitions()) {
    return;
  }
  Diagram.prototype.clear.call(this);
};
BaseViewer.prototype.destroy = function() {
  Diagram.prototype.destroy.call(this);
  remove2(this._container);
};
BaseViewer.prototype.on = function(event2, priority, callback, target) {
  return this.get("eventBus").on(event2, priority, callback, target);
};
BaseViewer.prototype.off = function(event2, callback) {
  this.get("eventBus").off(event2, callback);
};
BaseViewer.prototype.attachTo = function(parentNode) {
  if (!parentNode) {
    throw new Error("parentNode required");
  }
  this.detach();
  if (parentNode.get && parentNode.constructor.prototype.jquery) {
    parentNode = parentNode.get(0);
  }
  if (typeof parentNode === "string") {
    parentNode = query(parentNode);
  }
  parentNode.appendChild(this._container);
  this._emit("attach", {});
  this.get("canvas").resized();
};
BaseViewer.prototype.getDefinitions = function() {
  return this._definitions;
};
BaseViewer.prototype.detach = function() {
  const container = this._container, parentNode = container.parentNode;
  if (!parentNode) {
    return;
  }
  this._emit("detach", {});
  parentNode.removeChild(container);
};
BaseViewer.prototype._init = function(container, moddle, options2) {
  const baseModules = options2.modules || this.getModules(), additionalModules = options2.additionalModules || [], staticModules = [
    {
      bpmnjs: ["value", this],
      moddle: ["value", moddle]
    }
  ];
  const diagramModules = [].concat(staticModules, baseModules, additionalModules);
  const diagramOptions = (0, import_min_dash33.assign)((0, import_min_dash33.omit)(options2, ["additionalModules"]), {
    canvas: (0, import_min_dash33.assign)({}, options2.canvas, { container }),
    modules: diagramModules
  });
  Diagram.call(this, diagramOptions);
  if (options2 && options2.container) {
    this.attachTo(options2.container);
  }
};
BaseViewer.prototype._emit = function(type, event2) {
  return this.get("eventBus").fire(type, event2);
};
BaseViewer.prototype._createContainer = function(options2) {
  const container = domify$1('<div class="bjs-container"></div>');
  assign(container, {
    width: ensureUnit(options2.width),
    height: ensureUnit(options2.height),
    position: options2.position
  });
  return container;
};
BaseViewer.prototype._createModdle = function(options2) {
  const moddleOptions = (0, import_min_dash33.assign)({}, this._moddleExtensions, options2.moddleExtensions);
  return new simple(moddleOptions);
};
BaseViewer.prototype._modules = [];
function addWarningsToError(err, warningsAry) {
  err.warnings = warningsAry;
  return err;
}
function checkValidationError(err) {
  const pattern = /unparsable content <([^>]+)> detected([\s\S]*)$/;
  const match = pattern.exec(err.message);
  if (match) {
    err.message = "unparsable content <" + match[1] + "> detected; this may indicate an invalid BPMN 2.0 diagram file" + match[2];
  }
  return err;
}
var DEFAULT_OPTIONS = {
  width: "100%",
  height: "100%",
  position: "relative"
};
function ensureUnit(val) {
  return val + ((0, import_min_dash33.isNumber)(val) ? "px" : "");
}
function findBPMNDiagram(definitions, diagramId) {
  if (!diagramId) {
    return null;
  }
  return (0, import_min_dash33.find)(definitions.diagrams, function(element) {
    return element.id === diagramId;
  }) || null;
}
function addProjectLogo(container) {
  const img = BPMNIO_IMG;
  const linkMarkup = '<a href="http://bpmn.io" target="_blank" class="bjs-powered-by" title="Powered by bpmn.io" >' + img + "</a>";
  const linkElement = domify$1(linkMarkup);
  assign(query("svg", linkElement), LOGO_STYLES);
  assign(linkElement, LINK_STYLES, {
    position: "absolute",
    bottom: "15px",
    right: "15px",
    zIndex: "100"
  });
  container.appendChild(linkElement);
  event.bind(linkElement, "click", function(event2) {
    open();
    event2.preventDefault();
  });
}

// node_modules/bpmn-js/lib/Viewer.js
function Viewer(options2) {
  BaseViewer.call(this, options2);
}
e(Viewer, BaseViewer);
Viewer.prototype._modules = [
  core_default,
  translate_default,
  selection_default,
  overlays_default,
  drilldown_default
];
Viewer.prototype._moddleExtensions = {};

// node_modules/diagram-js/lib/features/keyboard/Keyboard.js
var import_min_dash35 = __toESM(require_dist());

// node_modules/diagram-js/lib/features/keyboard/KeyboardUtil.js
var import_min_dash34 = __toESM(require_dist());
var KEYS_COPY = ["c", "C", "KeyC"];
var KEYS_PASTE = ["v", "V", "KeyV"];
var KEYS_REDO = ["y", "Y", "KeyY"];
var KEYS_UNDO = ["z", "Z", "KeyZ"];
function hasModifier(event2) {
  return event2.ctrlKey || event2.metaKey || event2.shiftKey || event2.altKey;
}
function isCmd(event2) {
  if (event2.altKey) {
    return false;
  }
  return event2.ctrlKey || event2.metaKey;
}
function isKey(keys4, event2) {
  keys4 = (0, import_min_dash34.isArray)(keys4) ? keys4 : [keys4];
  return keys4.indexOf(event2.key) !== -1 || keys4.indexOf(event2.code) !== -1;
}
function isShift(event2) {
  return event2.shiftKey;
}
function isCopy(event2) {
  return isCmd(event2) && isKey(KEYS_COPY, event2);
}
function isPaste(event2) {
  return isCmd(event2) && isKey(KEYS_PASTE, event2);
}
function isUndo(event2) {
  return isCmd(event2) && !isShift(event2) && isKey(KEYS_UNDO, event2);
}
function isRedo(event2) {
  return isCmd(event2) && (isKey(KEYS_REDO, event2) || isKey(KEYS_UNDO, event2) && isShift(event2));
}

// node_modules/diagram-js/lib/features/keyboard/Keyboard.js
var KEYDOWN_EVENT = "keyboard.keydown";
var KEYUP_EVENT = "keyboard.keyup";
var HANDLE_MODIFIER_ATTRIBUTE = "input-handle-modified-keys";
var DEFAULT_PRIORITY3 = 1e3;
function Keyboard(config, eventBus) {
  var self2 = this;
  this._config = config || {};
  this._eventBus = eventBus;
  this._keydownHandler = this._keydownHandler.bind(this);
  this._keyupHandler = this._keyupHandler.bind(this);
  eventBus.on("diagram.destroy", function() {
    self2._fire("destroy");
    self2.unbind();
  });
  eventBus.on("diagram.init", function() {
    self2._fire("init");
  });
  eventBus.on("attach", function() {
    if (config && config.bindTo) {
      self2.bind(config.bindTo);
    }
  });
  eventBus.on("detach", function() {
    self2.unbind();
  });
}
Keyboard.$inject = [
  "config.keyboard",
  "eventBus"
];
Keyboard.prototype._keydownHandler = function(event2) {
  this._keyHandler(event2, KEYDOWN_EVENT);
};
Keyboard.prototype._keyupHandler = function(event2) {
  this._keyHandler(event2, KEYUP_EVENT);
};
Keyboard.prototype._keyHandler = function(event2, type) {
  var eventBusResult;
  if (this._isEventIgnored(event2)) {
    return;
  }
  var context = {
    keyEvent: event2
  };
  eventBusResult = this._eventBus.fire(type || KEYDOWN_EVENT, context);
  if (eventBusResult) {
    event2.preventDefault();
  }
};
Keyboard.prototype._isEventIgnored = function(event2) {
  if (event2.defaultPrevented) {
    return true;
  }
  return isInput(event2.target) && this._isModifiedKeyIgnored(event2);
};
Keyboard.prototype._isModifiedKeyIgnored = function(event2) {
  if (!isCmd(event2)) {
    return true;
  }
  var allowedModifiers = this._getAllowedModifiers(event2.target);
  return allowedModifiers.indexOf(event2.key) === -1;
};
Keyboard.prototype._getAllowedModifiers = function(element) {
  var modifierContainer = closest(element, "[" + HANDLE_MODIFIER_ATTRIBUTE + "]", true);
  if (!modifierContainer || this._node && !this._node.contains(modifierContainer)) {
    return [];
  }
  return modifierContainer.getAttribute(HANDLE_MODIFIER_ATTRIBUTE).split(",");
};
Keyboard.prototype.bind = function(node2) {
  this.unbind();
  this._node = node2;
  event.bind(node2, "keydown", this._keydownHandler);
  event.bind(node2, "keyup", this._keyupHandler);
  this._fire("bind");
};
Keyboard.prototype.getBinding = function() {
  return this._node;
};
Keyboard.prototype.unbind = function() {
  var node2 = this._node;
  if (node2) {
    this._fire("unbind");
    event.unbind(node2, "keydown", this._keydownHandler);
    event.unbind(node2, "keyup", this._keyupHandler);
  }
  this._node = null;
};
Keyboard.prototype._fire = function(event2) {
  this._eventBus.fire("keyboard." + event2, { node: this._node });
};
Keyboard.prototype.addListener = function(priority, listener, type) {
  if ((0, import_min_dash35.isFunction)(priority)) {
    type = listener;
    listener = priority;
    priority = DEFAULT_PRIORITY3;
  }
  this._eventBus.on(type || KEYDOWN_EVENT, priority, listener);
};
Keyboard.prototype.removeListener = function(listener, type) {
  this._eventBus.off(type || KEYDOWN_EVENT, listener);
};
Keyboard.prototype.hasModifier = hasModifier;
Keyboard.prototype.isCmd = isCmd;
Keyboard.prototype.isShift = isShift;
Keyboard.prototype.isKey = isKey;
function isInput(target) {
  return target && (matches(target, "input, textarea") || target.contentEditable === "true");
}

// node_modules/diagram-js/lib/features/keyboard/KeyboardBindings.js
var LOW_PRIORITY5 = 500;
function KeyboardBindings(eventBus, keyboard) {
  var self2 = this;
  eventBus.on("editorActions.init", LOW_PRIORITY5, function(event2) {
    var editorActions = event2.editorActions;
    self2.registerBindings(keyboard, editorActions);
  });
}
KeyboardBindings.$inject = [
  "eventBus",
  "keyboard"
];
KeyboardBindings.prototype.registerBindings = function(keyboard, editorActions) {
  function addListener(action, fn2) {
    if (editorActions.isRegistered(action)) {
      keyboard.addListener(fn2);
    }
  }
  addListener("undo", function(context) {
    var event2 = context.keyEvent;
    if (isUndo(event2)) {
      editorActions.trigger("undo");
      return true;
    }
  });
  addListener("redo", function(context) {
    var event2 = context.keyEvent;
    if (isRedo(event2)) {
      editorActions.trigger("redo");
      return true;
    }
  });
  addListener("copy", function(context) {
    var event2 = context.keyEvent;
    if (isCopy(event2)) {
      editorActions.trigger("copy");
      return true;
    }
  });
  addListener("paste", function(context) {
    var event2 = context.keyEvent;
    if (isPaste(event2)) {
      editorActions.trigger("paste");
      return true;
    }
  });
  addListener("stepZoom", function(context) {
    var event2 = context.keyEvent;
    if (isKey(["+", "Add", "="], event2) && isCmd(event2)) {
      editorActions.trigger("stepZoom", { value: 1 });
      return true;
    }
  });
  addListener("stepZoom", function(context) {
    var event2 = context.keyEvent;
    if (isKey(["-", "Subtract"], event2) && isCmd(event2)) {
      editorActions.trigger("stepZoom", { value: -1 });
      return true;
    }
  });
  addListener("zoom", function(context) {
    var event2 = context.keyEvent;
    if (isKey("0", event2) && isCmd(event2)) {
      editorActions.trigger("zoom", { value: 1 });
      return true;
    }
  });
  addListener("removeSelection", function(context) {
    var event2 = context.keyEvent;
    if (isKey(["Backspace", "Delete", "Del"], event2)) {
      editorActions.trigger("removeSelection");
      return true;
    }
  });
};

// node_modules/diagram-js/lib/features/keyboard/index.js
var keyboard_default = {
  __init__: ["keyboard", "keyboardBindings"],
  keyboard: ["type", Keyboard],
  keyboardBindings: ["type", KeyboardBindings]
};

// node_modules/diagram-js/lib/navigation/keyboard-move/KeyboardMove.js
var import_min_dash36 = __toESM(require_dist());
var DEFAULT_CONFIG = {
  moveSpeed: 50,
  moveSpeedAccelerated: 200
};
function KeyboardMove(config, keyboard, canvas) {
  var self2 = this;
  this._config = (0, import_min_dash36.assign)({}, DEFAULT_CONFIG, config || {});
  keyboard.addListener(arrowsListener);
  function arrowsListener(context) {
    var event2 = context.keyEvent, config2 = self2._config;
    if (!keyboard.isCmd(event2)) {
      return;
    }
    if (keyboard.isKey([
      "ArrowLeft",
      "Left",
      "ArrowUp",
      "Up",
      "ArrowDown",
      "Down",
      "ArrowRight",
      "Right"
    ], event2)) {
      var speed = keyboard.isShift(event2) ? config2.moveSpeedAccelerated : config2.moveSpeed;
      var direction;
      switch (event2.key) {
        case "ArrowLeft":
        case "Left":
          direction = "left";
          break;
        case "ArrowUp":
        case "Up":
          direction = "up";
          break;
        case "ArrowRight":
        case "Right":
          direction = "right";
          break;
        case "ArrowDown":
        case "Down":
          direction = "down";
          break;
      }
      self2.moveCanvas({
        speed,
        direction
      });
      return true;
    }
  }
  this.moveCanvas = function(opts) {
    var dx = 0, dy = 0, speed = opts.speed;
    var actualSpeed = speed / Math.min(Math.sqrt(canvas.viewbox().scale), 1);
    switch (opts.direction) {
      case "left":
        dx = actualSpeed;
        break;
      case "up":
        dy = actualSpeed;
        break;
      case "right":
        dx = -actualSpeed;
        break;
      case "down":
        dy = -actualSpeed;
        break;
    }
    canvas.scroll({
      dx,
      dy
    });
  };
}
KeyboardMove.$inject = [
  "config.keyboardMove",
  "keyboard",
  "canvas"
];

// node_modules/diagram-js/lib/navigation/keyboard-move/index.js
var keyboard_move_default = {
  __depends__: [
    keyboard_default
  ],
  __init__: ["keyboardMove"],
  keyboardMove: ["type", KeyboardMove]
};

// node_modules/diagram-js/lib/util/Cursor.js
var CURSOR_CLS_PATTERN = /^djs-cursor-.*$/;
function set2(mode) {
  var classes3 = classes2(document.body);
  classes3.removeMatching(CURSOR_CLS_PATTERN);
  if (mode) {
    classes3.add("djs-cursor-" + mode);
  }
}
function unset() {
  set2(null);
}

// node_modules/diagram-js/lib/util/ClickTrap.js
var TRAP_PRIORITY = 5e3;
function install(eventBus, eventName) {
  eventName = eventName || "element.click";
  function trap() {
    return false;
  }
  eventBus.once(eventName, TRAP_PRIORITY, trap);
  return function() {
    eventBus.off(eventName, trap);
  };
}

// node_modules/diagram-js/lib/util/PositionUtil.js
function center(bounds) {
  return {
    x: bounds.x + bounds.width / 2,
    y: bounds.y + bounds.height / 2
  };
}
function delta(a6, b5) {
  return {
    x: a6.x - b5.x,
    y: a6.y - b5.y
  };
}

// node_modules/diagram-js/lib/navigation/movecanvas/MoveCanvas.js
var THRESHOLD = 15;
function MoveCanvas(eventBus, canvas) {
  var context;
  eventBus.on("element.mousedown", 500, function(e7) {
    return handleStart(e7.originalEvent);
  });
  function handleMove(event2) {
    var start = context.start, button = context.button, position = toPoint(event2), delta2 = delta(position, start);
    if (!context.dragging && length(delta2) > THRESHOLD) {
      context.dragging = true;
      if (button === 0) {
        install(eventBus);
      }
      set2("grab");
    }
    if (context.dragging) {
      var lastPosition = context.last || context.start;
      delta2 = delta(position, lastPosition);
      canvas.scroll({
        dx: delta2.x,
        dy: delta2.y
      });
      context.last = position;
    }
    event2.preventDefault();
  }
  function handleEnd(event2) {
    event.unbind(document, "mousemove", handleMove);
    event.unbind(document, "mouseup", handleEnd);
    context = null;
    unset();
  }
  function handleStart(event2) {
    if (closest(event2.target, ".djs-draggable")) {
      return;
    }
    var button = event2.button;
    if (button >= 2 || event2.ctrlKey || event2.shiftKey || event2.altKey) {
      return;
    }
    context = {
      button,
      start: toPoint(event2)
    };
    event.bind(document, "mousemove", handleMove);
    event.bind(document, "mouseup", handleEnd);
    return true;
  }
  this.isActive = function() {
    return !!context;
  };
}
MoveCanvas.$inject = [
  "eventBus",
  "canvas"
];
function length(point) {
  return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
}

// node_modules/diagram-js/lib/navigation/movecanvas/index.js
var movecanvas_default = {
  __init__: ["moveCanvas"],
  moveCanvas: ["type", MoveCanvas]
};

// node_modules/diagram-js/lib/util/Math.js
function log10(x4) {
  return Math.log(x4) / Math.log(10);
}

// node_modules/diagram-js/lib/navigation/zoomscroll/ZoomUtil.js
function getStepSize(range, steps) {
  var minLinearRange = log10(range.min), maxLinearRange = log10(range.max);
  var absoluteLinearRange = Math.abs(minLinearRange) + Math.abs(maxLinearRange);
  return absoluteLinearRange / steps;
}
function cap(range, scale) {
  return Math.max(range.min, Math.min(range.max, scale));
}

// node_modules/diagram-js/lib/navigation/zoomscroll/ZoomScroll.js
var import_min_dash37 = __toESM(require_dist());
var sign = Math.sign || function(n5) {
  return n5 >= 0 ? 1 : -1;
};
var RANGE = { min: 0.2, max: 4 };
var NUM_STEPS = 10;
var DELTA_THRESHOLD = 0.1;
var DEFAULT_SCALE = 0.75;
function ZoomScroll(config, eventBus, canvas) {
  config = config || {};
  this._enabled = false;
  this._canvas = canvas;
  this._container = canvas._container;
  this._handleWheel = (0, import_min_dash37.bind)(this._handleWheel, this);
  this._totalDelta = 0;
  this._scale = config.scale || DEFAULT_SCALE;
  var self2 = this;
  eventBus.on("canvas.init", function(e7) {
    self2._init(config.enabled !== false);
  });
}
ZoomScroll.$inject = [
  "config.zoomScroll",
  "eventBus",
  "canvas"
];
ZoomScroll.prototype.scroll = function scroll(delta2) {
  this._canvas.scroll(delta2);
};
ZoomScroll.prototype.reset = function reset() {
  this._canvas.zoom("fit-viewport");
};
ZoomScroll.prototype.zoom = function zoom(delta2, position) {
  var stepSize = getStepSize(RANGE, NUM_STEPS * 2);
  this._totalDelta += delta2;
  if (Math.abs(this._totalDelta) > DELTA_THRESHOLD) {
    this._zoom(delta2, position, stepSize);
    this._totalDelta = 0;
  }
};
ZoomScroll.prototype._handleWheel = function handleWheel(event2) {
  if (closest(event2.target, ".djs-scrollable", true)) {
    return;
  }
  var element = this._container;
  event2.preventDefault();
  var isZoom = event2.ctrlKey;
  var isHorizontalScroll = event2.shiftKey;
  var factor = -1 * this._scale, delta2;
  if (isZoom) {
    factor *= event2.deltaMode === 0 ? 0.02 : 0.32;
  } else {
    factor *= event2.deltaMode === 0 ? 1 : 16;
  }
  if (isZoom) {
    var elementRect = element.getBoundingClientRect();
    var offset = {
      x: event2.clientX - elementRect.left,
      y: event2.clientY - elementRect.top
    };
    delta2 = Math.sqrt(Math.pow(event2.deltaY, 2) + Math.pow(event2.deltaX, 2)) * sign(event2.deltaY) * factor;
    this.zoom(delta2, offset);
  } else {
    if (isHorizontalScroll) {
      delta2 = {
        dx: factor * event2.deltaY,
        dy: 0
      };
    } else {
      delta2 = {
        dx: factor * event2.deltaX,
        dy: factor * event2.deltaY
      };
    }
    this.scroll(delta2);
  }
};
ZoomScroll.prototype.stepZoom = function stepZoom(delta2, position) {
  var stepSize = getStepSize(RANGE, NUM_STEPS);
  this._zoom(delta2, position, stepSize);
};
ZoomScroll.prototype._zoom = function(delta2, position, stepSize) {
  var canvas = this._canvas;
  var direction = delta2 > 0 ? 1 : -1;
  var currentLinearZoomLevel = log10(canvas.zoom());
  var newLinearZoomLevel = Math.round(currentLinearZoomLevel / stepSize) * stepSize;
  newLinearZoomLevel += stepSize * direction;
  var newLogZoomLevel = Math.pow(10, newLinearZoomLevel);
  canvas.zoom(cap(RANGE, newLogZoomLevel), position);
};
ZoomScroll.prototype.toggle = function toggle(newEnabled) {
  var element = this._container;
  var handleWheel2 = this._handleWheel;
  var oldEnabled = this._enabled;
  if (typeof newEnabled === "undefined") {
    newEnabled = !oldEnabled;
  }
  if (oldEnabled !== newEnabled) {
    event[newEnabled ? "bind" : "unbind"](element, "wheel", handleWheel2, false);
  }
  this._enabled = newEnabled;
  return newEnabled;
};
ZoomScroll.prototype._init = function(newEnabled) {
  this.toggle(newEnabled);
};

// node_modules/diagram-js/lib/navigation/zoomscroll/index.js
var zoomscroll_default = {
  __init__: ["zoomScroll"],
  zoomScroll: ["type", ZoomScroll]
};

// node_modules/bpmn-js/lib/NavigatedViewer.js
function NavigatedViewer(options2) {
  Viewer.call(this, options2);
}
e(NavigatedViewer, Viewer);
NavigatedViewer.prototype._navigationModules = [
  keyboard_move_default,
  movecanvas_default,
  zoomscroll_default
];
NavigatedViewer.prototype._modules = [].concat(Viewer.prototype._modules, NavigatedViewer.prototype._navigationModules);

// node_modules/bpmn-js/lib/BaseModeler.js
function BaseModeler(options2) {
  BaseViewer.call(this, options2);
  this.on("import.parse.complete", function(event2) {
    if (!event2.error) {
      this._collectIds(event2.definitions, event2.elementsById);
    }
  }, this);
  this.on("diagram.destroy", function() {
    this.get("moddle").ids.clear();
  }, this);
}
e(BaseModeler, BaseViewer);
BaseModeler.prototype._createModdle = function(options2) {
  var moddle = BaseViewer.prototype._createModdle.call(this, options2);
  moddle.ids = new index_esm_default([32, 36, 1]);
  return moddle;
};
BaseModeler.prototype._collectIds = function(definitions, elementsById) {
  var moddle = definitions.$model, ids3 = moddle.ids, id;
  ids3.clear();
  for (id in elementsById) {
    ids3.claim(id, elementsById[id]);
  }
};

// node_modules/diagram-js/lib/features/touch/TouchInteractionEvents.js
var import_min_dash38 = __toESM(require_dist());
var import_hammerjs = __toESM(require_hammer());
var MIN_ZOOM = 0.2;
var MAX_ZOOM = 4;
var mouseEvents = [
  "mousedown",
  "mouseup",
  "mouseover",
  "mouseout",
  "click",
  "dblclick"
];
function log() {
}
function get2(service, injector) {
  return injector.get(service, false);
}
function stopEvent(event2) {
  event2.preventDefault();
  if (typeof event2.stopPropagation === "function") {
    event2.stopPropagation();
  } else if (event2.srcEvent && typeof event2.srcEvent.stopPropagation === "function") {
    event2.srcEvent.stopPropagation();
  }
  if (typeof event2.stopImmediatePropagation === "function") {
    event2.stopImmediatePropagation();
  }
}
function createTouchRecognizer(node2) {
  function stopMouse(event2) {
    (0, import_min_dash38.forEach)(mouseEvents, function(e7) {
      event.bind(node2, e7, stopEvent, true);
    });
  }
  function allowMouse(event2) {
    setTimeout(function() {
      (0, import_min_dash38.forEach)(mouseEvents, function(e7) {
        event.unbind(node2, e7, stopEvent, true);
      });
    }, 500);
  }
  event.bind(node2, "touchstart", stopMouse, true);
  event.bind(node2, "touchend", allowMouse, true);
  event.bind(node2, "touchcancel", allowMouse, true);
  var recognizer = new import_hammerjs.default.Manager(node2, {
    inputClass: import_hammerjs.default.TouchInput,
    recognizers: [],
    domEvents: true
  });
  var tap = new import_hammerjs.default.Tap();
  var pan = new import_hammerjs.default.Pan({ threshold: 10 });
  var press = new import_hammerjs.default.Press();
  var pinch = new import_hammerjs.default.Pinch();
  var doubleTap = new import_hammerjs.default.Tap({ event: "doubletap", taps: 2 });
  pinch.requireFailure(pan);
  pinch.requireFailure(press);
  recognizer.add([pan, press, pinch, doubleTap, tap]);
  recognizer.reset = function(force) {
    var recognizers = this.recognizers, session = this.session;
    if (session.stopped) {
      return;
    }
    log("recognizer", "stop");
    recognizer.stop(force);
    setTimeout(function() {
      var i6, r6;
      log("recognizer", "reset");
      for (i6 = 0; r6 = recognizers[i6]; i6++) {
        r6.reset();
        r6.state = 8;
      }
      session.curRecognizer = null;
    }, 0);
  };
  recognizer.on("hammer.input", function(event2) {
    if (event2.srcEvent.defaultPrevented) {
      recognizer.reset(true);
    }
  });
  return recognizer;
}
function TouchInteractionEvents(injector, canvas, eventBus, elementRegistry, interactionEvents) {
  var dragging = get2("dragging", injector), move = get2("move", injector), contextPad = get2("contextPad", injector), palette = get2("palette", injector);
  var recognizer;
  function handler(type, buttonType) {
    return function(event2) {
      log("element", type, event2);
      var gfx = getGfx2(event2.target), element = gfx && elementRegistry.get(gfx);
      if (buttonType) {
        event2.srcEvent.button = buttonType;
      }
      return interactionEvents.fire(type, event2, element);
    };
  }
  function getGfx2(target) {
    var node2 = closest(target, "svg, .djs-element", true);
    return node2;
  }
  function initEvents(svg) {
    recognizer = createTouchRecognizer(svg);
    function startGrabCanvas(event2) {
      log("canvas", "grab start");
      var lx = 0, ly = 0;
      function update(e7) {
        var dx = e7.deltaX - lx, dy = e7.deltaY - ly;
        canvas.scroll({ dx, dy });
        lx = e7.deltaX;
        ly = e7.deltaY;
      }
      function end(e7) {
        recognizer.off("panmove", update);
        recognizer.off("panend", end);
        recognizer.off("pancancel", end);
        log("canvas", "grab end");
      }
      recognizer.on("panmove", update);
      recognizer.on("panend", end);
      recognizer.on("pancancel", end);
    }
    function startGrab(event2) {
      var gfx = getGfx2(event2.target), element = gfx && elementRegistry.get(gfx);
      if (move && canvas.getRootElement() !== element) {
        log("element", "move start", element, event2, true);
        return move.start(event2, element, true);
      } else {
        startGrabCanvas(event2);
      }
    }
    function startZoom(e7) {
      log("canvas", "zoom start");
      var zoom2 = canvas.zoom(), mid4 = e7.center;
      function update(e8) {
        var ratio = 1 - (1 - e8.scale) / 1.5, newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, ratio * zoom2));
        canvas.zoom(newZoom, mid4);
        stopEvent(e8);
      }
      function end(e8) {
        recognizer.off("pinchmove", update);
        recognizer.off("pinchend", end);
        recognizer.off("pinchcancel", end);
        recognizer.reset(true);
        log("canvas", "zoom end");
      }
      recognizer.on("pinchmove", update);
      recognizer.on("pinchend", end);
      recognizer.on("pinchcancel", end);
    }
    recognizer.on("tap", handler("element.click"));
    recognizer.on("doubletap", handler("element.dblclick", 1));
    recognizer.on("panstart", startGrab);
    recognizer.on("press", startGrab);
    recognizer.on("pinchstart", startZoom);
  }
  if (dragging) {
    eventBus.on("drag.move", function(event2) {
      var originalEvent = event2.originalEvent;
      if (!originalEvent || originalEvent instanceof MouseEvent) {
        return;
      }
      var position = toPoint(originalEvent);
      var node2 = document.elementFromPoint(position.x, position.y), gfx = getGfx2(node2), element = gfx && elementRegistry.get(gfx);
      if (element !== event2.hover) {
        if (event2.hover) {
          dragging.out(event2);
        }
        if (element) {
          dragging.hover({ element, gfx });
          event2.hover = element;
          event2.hoverGfx = gfx;
        }
      }
    });
  }
  if (contextPad) {
    eventBus.on("contextPad.create", function(event2) {
      var node2 = event2.pad.html;
      var padRecognizer = createTouchRecognizer(node2);
      padRecognizer.on("panstart", function(event3) {
        log("context-pad", "panstart", event3);
        contextPad.trigger("dragstart", event3, true);
      });
      padRecognizer.on("press", function(event3) {
        log("context-pad", "press", event3);
        contextPad.trigger("dragstart", event3, true);
      });
      padRecognizer.on("tap", function(event3) {
        log("context-pad", "tap", event3);
        contextPad.trigger("click", event3);
      });
    });
  }
  if (palette) {
    eventBus.on("palette.create", function(event2) {
      var node2 = event2.container;
      var padRecognizer = createTouchRecognizer(node2);
      padRecognizer.on("panstart", function(event3) {
        log("palette", "panstart", event3);
        palette.trigger("dragstart", event3, true);
      });
      padRecognizer.on("press", function(event3) {
        log("palette", "press", event3);
        palette.trigger("dragstart", event3, true);
      });
      padRecognizer.on("tap", function(event3) {
        log("palette", "tap", event3);
        palette.trigger("click", event3);
      });
    });
  }
  eventBus.on("canvas.init", function(event2) {
    initEvents(event2.svg);
  });
}
TouchInteractionEvents.$inject = [
  "injector",
  "canvas",
  "eventBus",
  "elementRegistry",
  "interactionEvents",
  "touchFix"
];

// node_modules/diagram-js/lib/features/touch/TouchFix.js
function TouchFix(canvas, eventBus) {
  var self2 = this;
  eventBus.on("canvas.init", function(e7) {
    self2.addBBoxMarker(e7.svg);
  });
}
TouchFix.$inject = ["canvas", "eventBus"];
TouchFix.prototype.addBBoxMarker = function(svg) {
  var markerStyle = {
    fill: "none",
    class: "outer-bound-marker"
  };
  var rect1 = create("rect");
  attr(rect1, {
    x: -1e4,
    y: 1e4,
    width: 10,
    height: 10
  });
  attr(rect1, markerStyle);
  append(svg, rect1);
  var rect2 = create("rect");
  attr(rect2, {
    x: 1e4,
    y: 1e4,
    width: 10,
    height: 10
  });
  attr(rect2, markerStyle);
  append(svg, rect2);
};

// node_modules/diagram-js/lib/features/touch/index.js
var touch_default = {
  __depends__: [interaction_events_default],
  __init__: ["touchInteractionEvents"],
  touchInteractionEvents: ["type", TouchInteractionEvents],
  touchFix: ["type", TouchFix]
};

// node_modules/diagram-js/lib/navigation/touch/index.js
var touch_default2 = {
  __depends__: [
    touch_default
  ]
};

// node_modules/diagram-js/lib/features/align-elements/AlignElements.js
var import_min_dash39 = __toESM(require_dist());
function last(arr) {
  return arr && arr[arr.length - 1];
}
function sortTopOrMiddle(element) {
  return element.y;
}
function sortLeftOrCenter(element) {
  return element.x;
}
var ALIGNMENT_SORTING = {
  left: sortLeftOrCenter,
  center: sortLeftOrCenter,
  right: function(element) {
    return element.x + element.width;
  },
  top: sortTopOrMiddle,
  middle: sortTopOrMiddle,
  bottom: function(element) {
    return element.y + element.height;
  }
};
function AlignElements(modeling, rules) {
  this._modeling = modeling;
  this._rules = rules;
}
AlignElements.$inject = ["modeling", "rules"];
AlignElements.prototype._getOrientationDetails = function(type) {
  var vertical = ["top", "bottom", "middle"], axis = "x", dimension = "width";
  if (vertical.indexOf(type) !== -1) {
    axis = "y";
    dimension = "height";
  }
  return {
    axis,
    dimension
  };
};
AlignElements.prototype._isType = function(type, types3) {
  return types3.indexOf(type) !== -1;
};
AlignElements.prototype._alignmentPosition = function(type, sortedElements) {
  var orientation = this._getOrientationDetails(type), axis = orientation.axis, dimension = orientation.dimension, alignment = {}, centers = {}, hasSharedCenters = false, centeredElements, firstElement, lastElement;
  function getMiddleOrTop(first, last2) {
    return Math.round((first[axis] + last2[axis] + last2[dimension]) / 2);
  }
  if (this._isType(type, ["left", "top"])) {
    alignment[type] = sortedElements[0][axis];
  } else if (this._isType(type, ["right", "bottom"])) {
    lastElement = last(sortedElements);
    alignment[type] = lastElement[axis] + lastElement[dimension];
  } else if (this._isType(type, ["center", "middle"])) {
    (0, import_min_dash39.forEach)(sortedElements, function(element) {
      var center2 = element[axis] + Math.round(element[dimension] / 2);
      if (centers[center2]) {
        centers[center2].elements.push(element);
      } else {
        centers[center2] = {
          elements: [element],
          center: center2
        };
      }
    });
    centeredElements = (0, import_min_dash39.sortBy)(centers, function(center2) {
      if (center2.elements.length > 1) {
        hasSharedCenters = true;
      }
      return center2.elements.length;
    });
    if (hasSharedCenters) {
      alignment[type] = last(centeredElements).center;
      return alignment;
    }
    firstElement = sortedElements[0];
    sortedElements = (0, import_min_dash39.sortBy)(sortedElements, function(element) {
      return element[axis] + element[dimension];
    });
    lastElement = last(sortedElements);
    alignment[type] = getMiddleOrTop(firstElement, lastElement);
  }
  return alignment;
};
AlignElements.prototype.trigger = function(elements, type) {
  var modeling = this._modeling, allowed;
  var filteredElements = (0, import_min_dash39.filter)(elements, function(element) {
    return !(element.waypoints || element.host || element.labelTarget);
  });
  allowed = this._rules.allowed("elements.align", { elements: filteredElements });
  if ((0, import_min_dash39.isArray)(allowed)) {
    filteredElements = allowed;
  }
  if (filteredElements.length < 2 || !allowed) {
    return;
  }
  var sortFn = ALIGNMENT_SORTING[type];
  var sortedElements = (0, import_min_dash39.sortBy)(filteredElements, sortFn);
  var alignment = this._alignmentPosition(type, sortedElements);
  modeling.alignElements(sortedElements, alignment);
};

// node_modules/diagram-js/lib/features/align-elements/index.js
var align_elements_default = {
  __init__: ["alignElements"],
  alignElements: ["type", AlignElements]
};

// node_modules/diagram-js/lib/features/context-pad/ContextPad.js
var import_min_dash40 = __toESM(require_dist());
var entrySelector = ".entry";
var DEFAULT_PRIORITY4 = 1e3;
var CONTEXT_PAD_PADDING = 12;
function ContextPad(canvas, config, eventBus, overlays) {
  this._canvas = canvas;
  this._eventBus = eventBus;
  this._overlays = overlays;
  var scale = (0, import_min_dash40.isDefined)(config && config.scale) ? config.scale : {
    min: 1,
    max: 1.5
  };
  this._overlaysConfig = {
    scale
  };
  this._current = null;
  this._init();
}
ContextPad.$inject = [
  "canvas",
  "config.contextPad",
  "eventBus",
  "overlays"
];
ContextPad.prototype._init = function() {
  var self2 = this;
  this._eventBus.on("selection.changed", function(event2) {
    var selection = event2.newSelection;
    var target = selection.length ? selection.length === 1 ? selection[0] : selection : null;
    if (target) {
      self2.open(target, true);
    } else {
      self2.close();
    }
  });
  this._eventBus.on("elements.changed", function(event2) {
    var elements = event2.elements, current = self2._current;
    if (!current) {
      return;
    }
    var currentTarget = current.target;
    var currentChanged = (0, import_min_dash40.some)((0, import_min_dash40.isArray)(currentTarget) ? currentTarget : [currentTarget], function(element) {
      return includes(elements, element);
    });
    if (currentChanged) {
      self2.open(currentTarget, true);
    }
  });
};
ContextPad.prototype.registerProvider = function(priority, provider) {
  if (!provider) {
    provider = priority;
    priority = DEFAULT_PRIORITY4;
  }
  this._eventBus.on("contextPad.getProviders", priority, function(event2) {
    event2.providers.push(provider);
  });
};
ContextPad.prototype.getEntries = function(target) {
  var providers = this._getProviders();
  var provideFn = (0, import_min_dash40.isArray)(target) ? "getMultiElementContextPadEntries" : "getContextPadEntries";
  var entries = {};
  (0, import_min_dash40.forEach)(providers, function(provider) {
    if (!(0, import_min_dash40.isFunction)(provider[provideFn])) {
      return;
    }
    var entriesOrUpdater = provider[provideFn](target);
    if ((0, import_min_dash40.isFunction)(entriesOrUpdater)) {
      entries = entriesOrUpdater(entries);
    } else {
      (0, import_min_dash40.forEach)(entriesOrUpdater, function(entry, id) {
        entries[id] = entry;
      });
    }
  });
  return entries;
};
ContextPad.prototype.trigger = function(action, event2, autoActivate) {
  var entry, originalEvent, button = event2.delegateTarget || event2.target;
  if (!button) {
    return event2.preventDefault();
  }
  entry = attr2(button, "data-action");
  originalEvent = event2.originalEvent || event2;
  return this.triggerEntry(entry, action, originalEvent, autoActivate);
};
ContextPad.prototype.triggerEntry = function(entryId, action, event2, autoActivate) {
  if (!this.isShown()) {
    return;
  }
  var target = this._current.target, entries = this._current.entries;
  var entry = entries[entryId];
  if (!entry) {
    return;
  }
  var handler = entry.action;
  if ((0, import_min_dash40.isFunction)(handler)) {
    if (action === "click") {
      return handler(event2, target, autoActivate);
    }
  } else {
    if (handler[action]) {
      return handler[action](event2, target, autoActivate);
    }
  }
  event2.preventDefault();
};
ContextPad.prototype.open = function(target, force) {
  if (!force && this.isOpen(target)) {
    return;
  }
  this.close();
  this._updateAndOpen(target);
};
ContextPad.prototype._getProviders = function() {
  var event2 = this._eventBus.createEvent({
    type: "contextPad.getProviders",
    providers: []
  });
  this._eventBus.fire(event2);
  return event2.providers;
};
ContextPad.prototype._updateAndOpen = function(target) {
  var entries = this.getEntries(target), pad = this.getPad(target), html = pad.html, image;
  (0, import_min_dash40.forEach)(entries, function(entry, id) {
    var grouping = entry.group || "default", control = domify$1(entry.html || '<div class="entry" draggable="true"></div>'), container;
    attr2(control, "data-action", id);
    container = query("[data-group=" + (0, import_css.default)(grouping) + "]", html);
    if (!container) {
      container = domify$1('<div class="group"></div>');
      attr2(container, "data-group", grouping);
      html.appendChild(container);
    }
    container.appendChild(control);
    if (entry.className) {
      addClasses(control, entry.className);
    }
    if (entry.title) {
      attr2(control, "title", entry.title);
    }
    if (entry.imageUrl) {
      image = domify$1("<img>");
      attr2(image, "src", entry.imageUrl);
      image.style.width = "100%";
      image.style.height = "100%";
      control.appendChild(image);
    }
  });
  classes2(html).add("open");
  this._current = {
    target,
    entries,
    pad
  };
  this._eventBus.fire("contextPad.open", { current: this._current });
};
ContextPad.prototype.getPad = function(target) {
  if (this.isOpen()) {
    return this._current.pad;
  }
  var self2 = this;
  var overlays = this._overlays;
  var html = domify$1('<div class="djs-context-pad"></div>');
  var position = this._getPosition(target);
  var overlaysConfig = (0, import_min_dash40.assign)({
    html
  }, this._overlaysConfig, position);
  delegate.bind(html, entrySelector, "click", function(event2) {
    self2.trigger("click", event2);
  });
  delegate.bind(html, entrySelector, "dragstart", function(event2) {
    self2.trigger("dragstart", event2);
  });
  event.bind(html, "mousedown", function(event2) {
    event2.stopPropagation();
  });
  var activeRootElement = this._canvas.getRootElement();
  this._overlayId = overlays.add(activeRootElement, "context-pad", overlaysConfig);
  var pad = overlays.get(this._overlayId);
  this._eventBus.fire("contextPad.create", {
    target,
    pad
  });
  return pad;
};
ContextPad.prototype.close = function() {
  if (!this.isOpen()) {
    return;
  }
  this._overlays.remove(this._overlayId);
  this._overlayId = null;
  this._eventBus.fire("contextPad.close", { current: this._current });
  this._current = null;
};
ContextPad.prototype.isOpen = function(target) {
  var current = this._current;
  if (!current) {
    return false;
  }
  if (!target) {
    return true;
  }
  var currentTarget = current.target;
  if ((0, import_min_dash40.isArray)(target) !== (0, import_min_dash40.isArray)(currentTarget)) {
    return false;
  }
  if ((0, import_min_dash40.isArray)(target)) {
    return target.length === currentTarget.length && (0, import_min_dash40.every)(target, function(element) {
      return includes(currentTarget, element);
    });
  } else {
    return currentTarget === target;
  }
};
ContextPad.prototype.isShown = function() {
  return this.isOpen() && this._overlays.isShown();
};
ContextPad.prototype._getPosition = function(target) {
  var elements = (0, import_min_dash40.isArray)(target) ? target : [target];
  var bBox = getBBox(elements);
  return {
    position: {
      left: bBox.x + bBox.width + CONTEXT_PAD_PADDING,
      top: bBox.y - CONTEXT_PAD_PADDING / 2
    }
  };
};
function addClasses(element, classNames) {
  var classes3 = classes2(element);
  classNames = (0, import_min_dash40.isArray)(classNames) ? classNames : classNames.split(/\s+/g);
  classNames.forEach(function(cls) {
    classes3.add(cls);
  });
}
function includes(array, item) {
  return array.indexOf(item) !== -1;
}

// node_modules/diagram-js/lib/features/context-pad/index.js
var context_pad_default = {
  __depends__: [
    interaction_events_default,
    overlays_default
  ],
  contextPad: ["type", ContextPad]
};

// node_modules/preact/dist/preact.module.js
var n;
var l;
var u;
var i;
var t;
var o;
var r;
var f = {};
var e2 = [];
var c = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
function s(n5, l6) {
  for (var u5 in l6)
    n5[u5] = l6[u5];
  return n5;
}
function a(n5) {
  var l6 = n5.parentNode;
  l6 && l6.removeChild(n5);
}
function h(l6, u5, i6) {
  var t6, o7, r6, f5 = {};
  for (r6 in u5)
    r6 == "key" ? t6 = u5[r6] : r6 == "ref" ? o7 = u5[r6] : f5[r6] = u5[r6];
  if (arguments.length > 2 && (f5.children = arguments.length > 3 ? n.call(arguments, 2) : i6), typeof l6 == "function" && l6.defaultProps != null)
    for (r6 in l6.defaultProps)
      f5[r6] === void 0 && (f5[r6] = l6.defaultProps[r6]);
  return v(l6, f5, t6, o7, null);
}
function v(n5, i6, t6, o7, r6) {
  var f5 = { type: n5, props: i6, key: t6, ref: o7, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: r6 == null ? ++u : r6 };
  return r6 == null && l.vnode != null && l.vnode(f5), f5;
}
function p(n5) {
  return n5.children;
}
function d(n5, l6) {
  this.props = n5, this.context = l6;
}
function _(n5, l6) {
  if (l6 == null)
    return n5.__ ? _(n5.__, n5.__.__k.indexOf(n5) + 1) : null;
  for (var u5; l6 < n5.__k.length; l6++)
    if ((u5 = n5.__k[l6]) != null && u5.__e != null)
      return u5.__e;
  return typeof n5.type == "function" ? _(n5) : null;
}
function k(n5) {
  var l6, u5;
  if ((n5 = n5.__) != null && n5.__c != null) {
    for (n5.__e = n5.__c.base = null, l6 = 0; l6 < n5.__k.length; l6++)
      if ((u5 = n5.__k[l6]) != null && u5.__e != null) {
        n5.__e = n5.__c.base = u5.__e;
        break;
      }
    return k(n5);
  }
}
function b(n5) {
  (!n5.__d && (n5.__d = true) && t.push(n5) && !g.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || setTimeout)(g);
}
function g() {
  for (var n5; g.__r = t.length; )
    n5 = t.sort(function(n6, l6) {
      return n6.__v.__b - l6.__v.__b;
    }), t = [], n5.some(function(n6) {
      var l6, u5, i6, t6, o7, r6;
      n6.__d && (o7 = (t6 = (l6 = n6).__v).__e, (r6 = l6.__P) && (u5 = [], (i6 = s({}, t6)).__v = t6.__v + 1, j(r6, t6, i6, l6.__n, r6.ownerSVGElement !== void 0, t6.__h != null ? [o7] : null, u5, o7 == null ? _(t6) : o7, t6.__h), z(u5, t6), t6.__e != o7 && k(t6)));
    });
}
function w(n5, l6, u5, i6, t6, o7, r6, c5, s5, a6) {
  var h5, y4, d5, k6, b5, g6, w6, x4 = i6 && i6.__k || e2, C4 = x4.length;
  for (u5.__k = [], h5 = 0; h5 < l6.length; h5++)
    if ((k6 = u5.__k[h5] = (k6 = l6[h5]) == null || typeof k6 == "boolean" ? null : typeof k6 == "string" || typeof k6 == "number" || typeof k6 == "bigint" ? v(null, k6, null, null, k6) : Array.isArray(k6) ? v(p, { children: k6 }, null, null, null) : k6.__b > 0 ? v(k6.type, k6.props, k6.key, k6.ref ? k6.ref : null, k6.__v) : k6) != null) {
      if (k6.__ = u5, k6.__b = u5.__b + 1, (d5 = x4[h5]) === null || d5 && k6.key == d5.key && k6.type === d5.type)
        x4[h5] = void 0;
      else
        for (y4 = 0; y4 < C4; y4++) {
          if ((d5 = x4[y4]) && k6.key == d5.key && k6.type === d5.type) {
            x4[y4] = void 0;
            break;
          }
          d5 = null;
        }
      j(n5, k6, d5 = d5 || f, t6, o7, r6, c5, s5, a6), b5 = k6.__e, (y4 = k6.ref) && d5.ref != y4 && (w6 || (w6 = []), d5.ref && w6.push(d5.ref, null, k6), w6.push(y4, k6.__c || b5, k6)), b5 != null ? (g6 == null && (g6 = b5), typeof k6.type == "function" && k6.__k === d5.__k ? k6.__d = s5 = m(k6, s5, n5) : s5 = A(n5, k6, d5, x4, b5, s5), typeof u5.type == "function" && (u5.__d = s5)) : s5 && d5.__e == s5 && s5.parentNode != n5 && (s5 = _(d5));
    }
  for (u5.__e = g6, h5 = C4; h5--; )
    x4[h5] != null && N(x4[h5], x4[h5]);
  if (w6)
    for (h5 = 0; h5 < w6.length; h5++)
      M(w6[h5], w6[++h5], w6[++h5]);
}
function m(n5, l6, u5) {
  for (var i6, t6 = n5.__k, o7 = 0; t6 && o7 < t6.length; o7++)
    (i6 = t6[o7]) && (i6.__ = n5, l6 = typeof i6.type == "function" ? m(i6, l6, u5) : A(u5, i6, i6, t6, i6.__e, l6));
  return l6;
}
function A(n5, l6, u5, i6, t6, o7) {
  var r6, f5, e7;
  if (l6.__d !== void 0)
    r6 = l6.__d, l6.__d = void 0;
  else if (u5 == null || t6 != o7 || t6.parentNode == null)
    n:
      if (o7 == null || o7.parentNode !== n5)
        n5.appendChild(t6), r6 = null;
      else {
        for (f5 = o7, e7 = 0; (f5 = f5.nextSibling) && e7 < i6.length; e7 += 1)
          if (f5 == t6)
            break n;
        n5.insertBefore(t6, o7), r6 = o7;
      }
  return r6 !== void 0 ? r6 : t6.nextSibling;
}
function C(n5, l6, u5, i6, t6) {
  var o7;
  for (o7 in u5)
    o7 === "children" || o7 === "key" || o7 in l6 || H(n5, o7, null, u5[o7], i6);
  for (o7 in l6)
    t6 && typeof l6[o7] != "function" || o7 === "children" || o7 === "key" || o7 === "value" || o7 === "checked" || u5[o7] === l6[o7] || H(n5, o7, l6[o7], u5[o7], i6);
}
function $(n5, l6, u5) {
  l6[0] === "-" ? n5.setProperty(l6, u5) : n5[l6] = u5 == null ? "" : typeof u5 != "number" || c.test(l6) ? u5 : u5 + "px";
}
function H(n5, l6, u5, i6, t6) {
  var o7;
  n:
    if (l6 === "style")
      if (typeof u5 == "string")
        n5.style.cssText = u5;
      else {
        if (typeof i6 == "string" && (n5.style.cssText = i6 = ""), i6)
          for (l6 in i6)
            u5 && l6 in u5 || $(n5.style, l6, "");
        if (u5)
          for (l6 in u5)
            i6 && u5[l6] === i6[l6] || $(n5.style, l6, u5[l6]);
      }
    else if (l6[0] === "o" && l6[1] === "n")
      o7 = l6 !== (l6 = l6.replace(/Capture$/, "")), l6 = l6.toLowerCase() in n5 ? l6.toLowerCase().slice(2) : l6.slice(2), n5.l || (n5.l = {}), n5.l[l6 + o7] = u5, u5 ? i6 || n5.addEventListener(l6, o7 ? T : I, o7) : n5.removeEventListener(l6, o7 ? T : I, o7);
    else if (l6 !== "dangerouslySetInnerHTML") {
      if (t6)
        l6 = l6.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if (l6 !== "href" && l6 !== "list" && l6 !== "form" && l6 !== "tabIndex" && l6 !== "download" && l6 in n5)
        try {
          n5[l6] = u5 == null ? "" : u5;
          break n;
        } catch (n6) {
        }
      typeof u5 == "function" || (u5 == null || u5 === false && l6.indexOf("-") == -1 ? n5.removeAttribute(l6) : n5.setAttribute(l6, u5));
    }
}
function I(n5) {
  this.l[n5.type + false](l.event ? l.event(n5) : n5);
}
function T(n5) {
  this.l[n5.type + true](l.event ? l.event(n5) : n5);
}
function j(n5, u5, i6, t6, o7, r6, f5, e7, c5) {
  var a6, h5, v5, y4, _5, k6, b5, g6, m6, x4, A5, C4, $4, H4, I4, T6 = u5.type;
  if (u5.constructor !== void 0)
    return null;
  i6.__h != null && (c5 = i6.__h, e7 = u5.__e = i6.__e, u5.__h = null, r6 = [e7]), (a6 = l.__b) && a6(u5);
  try {
    n:
      if (typeof T6 == "function") {
        if (g6 = u5.props, m6 = (a6 = T6.contextType) && t6[a6.__c], x4 = a6 ? m6 ? m6.props.value : a6.__ : t6, i6.__c ? b5 = (h5 = u5.__c = i6.__c).__ = h5.__E : ("prototype" in T6 && T6.prototype.render ? u5.__c = h5 = new T6(g6, x4) : (u5.__c = h5 = new d(g6, x4), h5.constructor = T6, h5.render = O), m6 && m6.sub(h5), h5.props = g6, h5.state || (h5.state = {}), h5.context = x4, h5.__n = t6, v5 = h5.__d = true, h5.__h = [], h5._sb = []), h5.__s == null && (h5.__s = h5.state), T6.getDerivedStateFromProps != null && (h5.__s == h5.state && (h5.__s = s({}, h5.__s)), s(h5.__s, T6.getDerivedStateFromProps(g6, h5.__s))), y4 = h5.props, _5 = h5.state, v5)
          T6.getDerivedStateFromProps == null && h5.componentWillMount != null && h5.componentWillMount(), h5.componentDidMount != null && h5.__h.push(h5.componentDidMount);
        else {
          if (T6.getDerivedStateFromProps == null && g6 !== y4 && h5.componentWillReceiveProps != null && h5.componentWillReceiveProps(g6, x4), !h5.__e && h5.shouldComponentUpdate != null && h5.shouldComponentUpdate(g6, h5.__s, x4) === false || u5.__v === i6.__v) {
            for (h5.props = g6, h5.state = h5.__s, u5.__v !== i6.__v && (h5.__d = false), h5.__v = u5, u5.__e = i6.__e, u5.__k = i6.__k, u5.__k.forEach(function(n6) {
              n6 && (n6.__ = u5);
            }), A5 = 0; A5 < h5._sb.length; A5++)
              h5.__h.push(h5._sb[A5]);
            h5._sb = [], h5.__h.length && f5.push(h5);
            break n;
          }
          h5.componentWillUpdate != null && h5.componentWillUpdate(g6, h5.__s, x4), h5.componentDidUpdate != null && h5.__h.push(function() {
            h5.componentDidUpdate(y4, _5, k6);
          });
        }
        if (h5.context = x4, h5.props = g6, h5.__v = u5, h5.__P = n5, C4 = l.__r, $4 = 0, "prototype" in T6 && T6.prototype.render) {
          for (h5.state = h5.__s, h5.__d = false, C4 && C4(u5), a6 = h5.render(h5.props, h5.state, h5.context), H4 = 0; H4 < h5._sb.length; H4++)
            h5.__h.push(h5._sb[H4]);
          h5._sb = [];
        } else
          do {
            h5.__d = false, C4 && C4(u5), a6 = h5.render(h5.props, h5.state, h5.context), h5.state = h5.__s;
          } while (h5.__d && ++$4 < 25);
        h5.state = h5.__s, h5.getChildContext != null && (t6 = s(s({}, t6), h5.getChildContext())), v5 || h5.getSnapshotBeforeUpdate == null || (k6 = h5.getSnapshotBeforeUpdate(y4, _5)), I4 = a6 != null && a6.type === p && a6.key == null ? a6.props.children : a6, w(n5, Array.isArray(I4) ? I4 : [I4], u5, i6, t6, o7, r6, f5, e7, c5), h5.base = u5.__e, u5.__h = null, h5.__h.length && f5.push(h5), b5 && (h5.__E = h5.__ = null), h5.__e = false;
      } else
        r6 == null && u5.__v === i6.__v ? (u5.__k = i6.__k, u5.__e = i6.__e) : u5.__e = L(i6.__e, u5, i6, t6, o7, r6, f5, c5);
    (a6 = l.diffed) && a6(u5);
  } catch (n6) {
    u5.__v = null, (c5 || r6 != null) && (u5.__e = e7, u5.__h = !!c5, r6[r6.indexOf(e7)] = null), l.__e(n6, u5, i6);
  }
}
function z(n5, u5) {
  l.__c && l.__c(u5, n5), n5.some(function(u6) {
    try {
      n5 = u6.__h, u6.__h = [], n5.some(function(n6) {
        n6.call(u6);
      });
    } catch (n6) {
      l.__e(n6, u6.__v);
    }
  });
}
function L(l6, u5, i6, t6, o7, r6, e7, c5) {
  var s5, h5, v5, y4 = i6.props, p6 = u5.props, d5 = u5.type, k6 = 0;
  if (d5 === "svg" && (o7 = true), r6 != null) {
    for (; k6 < r6.length; k6++)
      if ((s5 = r6[k6]) && "setAttribute" in s5 == !!d5 && (d5 ? s5.localName === d5 : s5.nodeType === 3)) {
        l6 = s5, r6[k6] = null;
        break;
      }
  }
  if (l6 == null) {
    if (d5 === null)
      return document.createTextNode(p6);
    l6 = o7 ? document.createElementNS("http://www.w3.org/2000/svg", d5) : document.createElement(d5, p6.is && p6), r6 = null, c5 = false;
  }
  if (d5 === null)
    y4 === p6 || c5 && l6.data === p6 || (l6.data = p6);
  else {
    if (r6 = r6 && n.call(l6.childNodes), h5 = (y4 = i6.props || f).dangerouslySetInnerHTML, v5 = p6.dangerouslySetInnerHTML, !c5) {
      if (r6 != null)
        for (y4 = {}, k6 = 0; k6 < l6.attributes.length; k6++)
          y4[l6.attributes[k6].name] = l6.attributes[k6].value;
      (v5 || h5) && (v5 && (h5 && v5.__html == h5.__html || v5.__html === l6.innerHTML) || (l6.innerHTML = v5 && v5.__html || ""));
    }
    if (C(l6, p6, y4, o7, c5), v5)
      u5.__k = [];
    else if (k6 = u5.props.children, w(l6, Array.isArray(k6) ? k6 : [k6], u5, i6, t6, o7 && d5 !== "foreignObject", r6, e7, r6 ? r6[0] : i6.__k && _(i6, 0), c5), r6 != null)
      for (k6 = r6.length; k6--; )
        r6[k6] != null && a(r6[k6]);
    c5 || ("value" in p6 && (k6 = p6.value) !== void 0 && (k6 !== l6.value || d5 === "progress" && !k6 || d5 === "option" && k6 !== y4.value) && H(l6, "value", k6, y4.value, false), "checked" in p6 && (k6 = p6.checked) !== void 0 && k6 !== l6.checked && H(l6, "checked", k6, y4.checked, false));
  }
  return l6;
}
function M(n5, u5, i6) {
  try {
    typeof n5 == "function" ? n5(u5) : n5.current = u5;
  } catch (n6) {
    l.__e(n6, i6);
  }
}
function N(n5, u5, i6) {
  var t6, o7;
  if (l.unmount && l.unmount(n5), (t6 = n5.ref) && (t6.current && t6.current !== n5.__e || M(t6, null, u5)), (t6 = n5.__c) != null) {
    if (t6.componentWillUnmount)
      try {
        t6.componentWillUnmount();
      } catch (n6) {
        l.__e(n6, u5);
      }
    t6.base = t6.__P = null, n5.__c = void 0;
  }
  if (t6 = n5.__k)
    for (o7 = 0; o7 < t6.length; o7++)
      t6[o7] && N(t6[o7], u5, i6 || typeof n5.type != "function");
  i6 || n5.__e == null || a(n5.__e), n5.__ = n5.__e = n5.__d = void 0;
}
function O(n5, l6, u5) {
  return this.constructor(n5, u5);
}
function P(u5, i6, t6) {
  var o7, r6, e7;
  l.__ && l.__(u5, i6), r6 = (o7 = typeof t6 == "function") ? null : t6 && t6.__k || i6.__k, e7 = [], j(i6, u5 = (!o7 && t6 || i6).__k = h(p, null, [u5]), r6 || f, f, i6.ownerSVGElement !== void 0, !o7 && t6 ? [t6] : r6 ? null : i6.firstChild ? n.call(i6.childNodes) : null, e7, !o7 && t6 ? t6 : r6 ? r6.__e : i6.firstChild, o7), z(e7, u5);
}
n = e2.slice, l = { __e: function(n5, l6, u5, i6) {
  for (var t6, o7, r6; l6 = l6.__; )
    if ((t6 = l6.__c) && !t6.__)
      try {
        if ((o7 = t6.constructor) && o7.getDerivedStateFromError != null && (t6.setState(o7.getDerivedStateFromError(n5)), r6 = t6.__d), t6.componentDidCatch != null && (t6.componentDidCatch(n5, i6 || {}), r6 = t6.__d), r6)
          return t6.__E = t6;
      } catch (l7) {
        n5 = l7;
      }
  throw n5;
} }, u = 0, i = function(n5) {
  return n5 != null && n5.constructor === void 0;
}, d.prototype.setState = function(n5, l6) {
  var u5;
  u5 = this.__s != null && this.__s !== this.state ? this.__s : this.__s = s({}, this.state), typeof n5 == "function" && (n5 = n5(s({}, u5), this.props)), n5 && s(u5, n5), n5 != null && this.__v && (l6 && this._sb.push(l6), b(this));
}, d.prototype.forceUpdate = function(n5) {
  this.__v && (this.__e = true, n5 && this.__h.push(n5), b(this));
}, d.prototype.render = p, t = [], g.__r = 0, r = 0;

// node_modules/htm/dist/htm.module.js
var n2 = function(t6, s5, r6, e7) {
  var u5;
  s5[0] = 0;
  for (var h5 = 1; h5 < s5.length; h5++) {
    var p6 = s5[h5++], a6 = s5[h5] ? (s5[0] |= p6 ? 1 : 2, r6[s5[h5++]]) : s5[++h5];
    p6 === 3 ? e7[0] = a6 : p6 === 4 ? e7[1] = Object.assign(e7[1] || {}, a6) : p6 === 5 ? (e7[1] = e7[1] || {})[s5[++h5]] = a6 : p6 === 6 ? e7[1][s5[++h5]] += a6 + "" : p6 ? (u5 = t6.apply(a6, n2(t6, a6, r6, ["", null])), e7.push(u5), a6[0] ? s5[0] |= 2 : (s5[h5 - 2] = 0, s5[h5] = u5)) : e7.push(a6);
  }
  return e7;
};
var t2 = /* @__PURE__ */ new Map();
function htm_module_default(s5) {
  var r6 = t2.get(this);
  return r6 || (r6 = /* @__PURE__ */ new Map(), t2.set(this, r6)), (r6 = n2(this, r6.get(s5) || (r6.set(s5, r6 = function(n5) {
    for (var t6, s6, r7 = 1, e7 = "", u5 = "", h5 = [0], p6 = function(n6) {
      r7 === 1 && (n6 || (e7 = e7.replace(/^\s*\n\s*|\s*\n\s*$/g, ""))) ? h5.push(0, n6, e7) : r7 === 3 && (n6 || e7) ? (h5.push(3, n6, e7), r7 = 2) : r7 === 2 && e7 === "..." && n6 ? h5.push(4, n6, 0) : r7 === 2 && e7 && !n6 ? h5.push(5, 0, true, e7) : r7 >= 5 && ((e7 || !n6 && r7 === 5) && (h5.push(r7, 0, e7, s6), r7 = 6), n6 && (h5.push(r7, n6, 0, s6), r7 = 6)), e7 = "";
    }, a6 = 0; a6 < n5.length; a6++) {
      a6 && (r7 === 1 && p6(), p6(a6));
      for (var l6 = 0; l6 < n5[a6].length; l6++)
        t6 = n5[a6][l6], r7 === 1 ? t6 === "<" ? (p6(), h5 = [h5], r7 = 3) : e7 += t6 : r7 === 4 ? e7 === "--" && t6 === ">" ? (r7 = 1, e7 = "") : e7 = t6 + e7[0] : u5 ? t6 === u5 ? u5 = "" : e7 += t6 : t6 === '"' || t6 === "'" ? u5 = t6 : t6 === ">" ? (p6(), r7 = 1) : r7 && (t6 === "=" ? (r7 = 5, s6 = e7, e7 = "") : t6 === "/" && (r7 < 5 || n5[a6][l6 + 1] === ">") ? (p6(), r7 === 3 && (h5 = h5[0]), r7 = h5, (h5 = h5[0]).push(2, 0, r7), r7 = 0) : t6 === " " || t6 === "	" || t6 === "\n" || t6 === "\r" ? (p6(), r7 = 2) : e7 += t6), r7 === 3 && e7 === "!--" && (r7 = 4, h5 = h5[0]);
    }
    return p6(), h5;
  }(s5)), r6), arguments, [])).length > 1 ? r6 : r6[0];
}

// node_modules/htm/preact/index.module.js
var m2 = htm_module_default.bind(h);

// node_modules/preact/hooks/dist/hooks.module.js
var t3;
var r2;
var u2;
var i2;
var o2 = 0;
var f2 = [];
var c2 = [];
var e3 = l.__b;
var a2 = l.__r;
var v2 = l.diffed;
var l2 = l.__c;
var m3 = l.unmount;
function d2(t6, u5) {
  l.__h && l.__h(r2, t6, o2 || u5), o2 = 0;
  var i6 = r2.__H || (r2.__H = { __: [], __h: [] });
  return t6 >= i6.__.length && i6.__.push({ __V: c2 }), i6.__[t6];
}
function p2(n5) {
  return o2 = 1, y(B, n5);
}
function y(n5, u5, i6) {
  var o7 = d2(t3++, 2);
  if (o7.t = n5, !o7.__c && (o7.__ = [i6 ? i6(u5) : B(void 0, u5), function(n6) {
    var t6 = o7.__N ? o7.__N[0] : o7.__[0], r6 = o7.t(t6, n6);
    t6 !== r6 && (o7.__N = [r6, o7.__[1]], o7.__c.setState({}));
  }], o7.__c = r2, !r2.u)) {
    r2.u = true;
    var f5 = r2.shouldComponentUpdate;
    r2.shouldComponentUpdate = function(n6, t6, r6) {
      if (!o7.__c.__H)
        return true;
      var u6 = o7.__c.__H.__.filter(function(n7) {
        return n7.__c;
      });
      if (u6.every(function(n7) {
        return !n7.__N;
      }))
        return !f5 || f5.call(this, n6, t6, r6);
      var i7 = false;
      return u6.forEach(function(n7) {
        if (n7.__N) {
          var t7 = n7.__[0];
          n7.__ = n7.__N, n7.__N = void 0, t7 !== n7.__[0] && (i7 = true);
        }
      }), !(!i7 && o7.__c.props === n6) && (!f5 || f5.call(this, n6, t6, r6));
    };
  }
  return o7.__N || o7.__;
}
function h2(u5, i6) {
  var o7 = d2(t3++, 3);
  !l.__s && z2(o7.__H, i6) && (o7.__ = u5, o7.i = i6, r2.__H.__h.push(o7));
}
function s2(u5, i6) {
  var o7 = d2(t3++, 4);
  !l.__s && z2(o7.__H, i6) && (o7.__ = u5, o7.i = i6, r2.__h.push(o7));
}
function _2(n5) {
  return o2 = 5, F(function() {
    return { current: n5 };
  }, []);
}
function F(n5, r6) {
  var u5 = d2(t3++, 7);
  return z2(u5.__H, r6) ? (u5.__V = n5(), u5.i = r6, u5.__h = n5, u5.__V) : u5.__;
}
function T2(n5, t6) {
  return o2 = 8, F(function() {
    return n5;
  }, t6);
}
function b2() {
  for (var t6; t6 = f2.shift(); )
    if (t6.__P && t6.__H)
      try {
        t6.__H.__h.forEach(k2), t6.__H.__h.forEach(w2), t6.__H.__h = [];
      } catch (r6) {
        t6.__H.__h = [], l.__e(r6, t6.__v);
      }
}
l.__b = function(n5) {
  r2 = null, e3 && e3(n5);
}, l.__r = function(n5) {
  a2 && a2(n5), t3 = 0;
  var i6 = (r2 = n5.__c).__H;
  i6 && (u2 === r2 ? (i6.__h = [], r2.__h = [], i6.__.forEach(function(n6) {
    n6.__N && (n6.__ = n6.__N), n6.__V = c2, n6.__N = n6.i = void 0;
  })) : (i6.__h.forEach(k2), i6.__h.forEach(w2), i6.__h = [])), u2 = r2;
}, l.diffed = function(t6) {
  v2 && v2(t6);
  var o7 = t6.__c;
  o7 && o7.__H && (o7.__H.__h.length && (f2.push(o7) !== 1 && i2 === l.requestAnimationFrame || ((i2 = l.requestAnimationFrame) || j2)(b2)), o7.__H.__.forEach(function(n5) {
    n5.i && (n5.__H = n5.i), n5.__V !== c2 && (n5.__ = n5.__V), n5.i = void 0, n5.__V = c2;
  })), u2 = r2 = null;
}, l.__c = function(t6, r6) {
  r6.some(function(t7) {
    try {
      t7.__h.forEach(k2), t7.__h = t7.__h.filter(function(n5) {
        return !n5.__ || w2(n5);
      });
    } catch (u5) {
      r6.some(function(n5) {
        n5.__h && (n5.__h = []);
      }), r6 = [], l.__e(u5, t7.__v);
    }
  }), l2 && l2(t6, r6);
}, l.unmount = function(t6) {
  m3 && m3(t6);
  var r6, u5 = t6.__c;
  u5 && u5.__H && (u5.__H.__.forEach(function(n5) {
    try {
      k2(n5);
    } catch (n6) {
      r6 = n6;
    }
  }), u5.__H = void 0, r6 && l.__e(r6, u5.__v));
};
var g2 = typeof requestAnimationFrame == "function";
function j2(n5) {
  var t6, r6 = function() {
    clearTimeout(u5), g2 && cancelAnimationFrame(t6), setTimeout(n5);
  }, u5 = setTimeout(r6, 100);
  g2 && (t6 = requestAnimationFrame(r6));
}
function k2(n5) {
  var t6 = r2, u5 = n5.__c;
  typeof u5 == "function" && (n5.__c = void 0, u5()), r2 = t6;
}
function w2(n5) {
  var t6 = r2;
  n5.__c = n5.__(), r2 = t6;
}
function z2(n5, t6) {
  return !n5 || n5.length !== t6.length || t6.some(function(t7, r6) {
    return t7 !== n5[r6];
  });
}
function B(n5, t6) {
  return typeof t6 == "function" ? t6(n5) : t6;
}

// node_modules/diagram-js/lib/features/popup-menu/PopupMenu.js
var import_min_dash42 = __toESM(require_dist());

// node_modules/clsx/dist/clsx.m.js
function r3(e7) {
  var t6, f5, n5 = "";
  if (typeof e7 == "string" || typeof e7 == "number")
    n5 += e7;
  else if (typeof e7 == "object")
    if (Array.isArray(e7))
      for (t6 = 0; t6 < e7.length; t6++)
        e7[t6] && (f5 = r3(e7[t6])) && (n5 && (n5 += " "), n5 += f5);
    else
      for (t6 in e7)
        e7[t6] && (n5 && (n5 += " "), n5 += t6);
  return n5;
}
function clsx() {
  for (var e7, t6, f5 = 0, n5 = ""; f5 < arguments.length; )
    (e7 = arguments[f5++]) && (t6 = r3(e7)) && (n5 && (n5 += " "), n5 += t6);
  return n5;
}
var clsx_m_default = clsx;

// node_modules/diagram-js/lib/features/popup-menu/PopupMenuItem.js
function PopupMenuItem(props) {
  const {
    entry,
    selected,
    onMouseEnter,
    onMouseLeave,
    onClick
  } = props;
  return m2`
    <li
      class=${clsx_m_default("entry", { selected })}
      data-id=${entry.id}
      title=${entry.title || entry.label}
      onClick=${onClick}
      onMouseEnter=${onMouseEnter}
      onMouseLeave=${onMouseLeave}
    >
      <div class="djs-popup-entry-content">
        <span
          class=${clsx_m_default("djs-popup-entry-name", entry.className)}
        >
          ${entry.imageUrl ? m2`
            <img class="djs-popup-entry-icon" src=${entry.imageUrl} />
          ` : null}

          ${entry.label ? m2`
            <span class="djs-popup-label">
              ${entry.label}
            </span>
          ` : null}
        </span>
        ${entry.description && m2`
          <span
            class="djs-popup-entry-description"
            title=${entry.description}
          >
            ${entry.description}
          </span>
        `}
      </div>
      ${entry.documentationRef && m2`
        <div class="djs-popup-entry-docs">
          <a
            href="${entry.documentationRef}"
            onClick=${(event2) => event2.stopPropagation()}
            title="Open element documentation"
            target="_blank"
            rel="noopener"
          >
            <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path fill-rule="evenodd" clip-rule="evenodd" d="M10.6368 10.6375V5.91761H11.9995V10.6382C11.9995 10.9973 11.8623 11.3141 11.5878 11.5885C11.3134 11.863 10.9966 12.0002 10.6375 12.0002H1.36266C0.982345 12.0002 0.660159 11.8681 0.396102 11.6041C0.132044 11.34 1.52588e-05 11.0178 1.52588e-05 10.6375V1.36267C1.52588e-05 0.98236 0.132044 0.660173 0.396102 0.396116C0.660159 0.132058 0.982345 2.95639e-05 1.36266 2.95639e-05H5.91624V1.36267H1.36266V10.6375H10.6368ZM12 0H7.2794L7.27873 1.36197H9.68701L3.06507 7.98391L4.01541 8.93425L10.6373 2.31231V4.72059H12V0Z" fill="#818798"/>
            </svg>
          </a>
        </div>
      `}
    </li>
  `;
}

// node_modules/diagram-js/lib/features/popup-menu/PopupMenuList.js
function PopupMenuList(props) {
  const {
    selectedEntry,
    setSelectedEntry,
    onClick,
    entries
  } = props;
  const resultsRef = _2();
  const groups = F(() => groupEntries(entries), [entries]);
  s2(() => {
    const containerEl = resultsRef.current;
    if (!containerEl)
      return;
    const selectedEl = containerEl.querySelector(".selected");
    if (selectedEl) {
      scrollIntoView(selectedEl);
    }
  }, [selectedEntry]);
  return m2`
    <div class="djs-popup-results" ref=${resultsRef}>
      ${groups.map((group) => m2`
        ${group.name && m2`
          <div key=${group.id} class="entry-header" title=${group.name}>
            ${group.name}
          </div>
        `}
        <ul class="djs-popup-group" data-group=${group.id}>
          ${group.entries.map((entry) => m2`
            <${PopupMenuItem}
              key=${entry.id}
              entry=${entry}
              selected=${entry === selectedEntry}
              onMouseEnter=${() => setSelectedEntry(entry)}
              onMouseLeave=${() => setSelectedEntry(null)}
              onClick=${onClick}
            />
          `)}
        </ul>
      `)}
    </div>
  `;
}
function groupEntries(entries) {
  const groups = [];
  const getGroup = (group) => groups.find((elem) => group.id === elem.id);
  const containsGroup = (group) => !!getGroup(group);
  const formatGroup = (group) => typeof group === "string" ? { id: group } : group;
  entries.forEach((entry) => {
    const group = entry.group ? formatGroup(entry.group) : { id: "default" };
    if (!containsGroup(group)) {
      groups.push({ ...group, entries: [entry] });
    } else {
      getGroup(group).entries.push(entry);
    }
  });
  return groups;
}
function scrollIntoView(el) {
  if (typeof el.scrollIntoViewIfNeeded === "function") {
    el.scrollIntoViewIfNeeded();
  } else {
    el.scrollIntoView({
      scrollMode: "if-needed",
      block: "nearest"
    });
  }
}

// node_modules/diagram-js/lib/features/popup-menu/PopupMenuComponent.js
var import_min_dash41 = __toESM(require_dist());
function PopupMenuComponent(props) {
  const {
    onClose,
    onSelect,
    className,
    headerEntries,
    position,
    title,
    width,
    scale,
    search,
    entries: originalEntries,
    onOpened,
    onClosed
  } = props;
  const searchable = F(() => {
    if (!(0, import_min_dash41.isDefined)(search)) {
      return false;
    }
    return originalEntries.length > 5;
  }, [search, originalEntries]);
  const inputRef = _2();
  const [value, setValue] = p2("");
  const [entries, setEntries] = p2(originalEntries);
  const [selectedEntry, setSelectedEntry] = p2(entries[0]);
  h2(() => {
    onOpened();
    return () => {
      onClosed();
    };
  }, []);
  const updateEntries = T2((newEntries) => {
    if (!selectedEntry || !newEntries.includes(selectedEntry)) {
      setSelectedEntry(newEntries[0]);
    }
    setEntries(newEntries);
  }, [selectedEntry, setEntries, setSelectedEntry]);
  h2(() => {
    if (!searchable) {
      return;
    }
    const filter28 = (entry) => {
      if (!value) {
        return true;
      }
      const search2 = [
        entry.description || "",
        entry.label || ""
      ].join("---").toLowerCase();
      return value.toLowerCase().split(/\s/g).every((term) => search2.includes(term));
    };
    const entries2 = originalEntries.filter(filter28);
    updateEntries(entries2);
  }, [value, originalEntries, searchable]);
  h2(() => {
    const handleKeyDown2 = (event2) => {
      if (event2.key === "Escape") {
        event2.preventDefault();
        return onClose();
      }
    };
    document.documentElement.addEventListener("keydown", handleKeyDown2);
    return () => {
      document.documentElement.removeEventListener("keydown", handleKeyDown2);
    };
  }, []);
  s2(() => {
    inputRef.current && inputRef.current.focus();
  }, []);
  const keyboardSelect = T2((direction) => {
    const idx = entries.indexOf(selectedEntry);
    let nextIdx = idx + direction;
    if (nextIdx < 0) {
      nextIdx = entries.length - 1;
    }
    if (nextIdx >= entries.length) {
      nextIdx = 0;
    }
    setSelectedEntry(entries[nextIdx]);
  }, [entries, selectedEntry, setSelectedEntry]);
  const handleKeyDown = T2((event2) => {
    if (event2.key === "Enter" && selectedEntry) {
      return onSelect(event2, selectedEntry);
    }
    if (event2.key === "Escape") {
      return onClose();
    }
    if (event2.key === "ArrowUp" || event2.key === "Tab" && event2.shiftKey) {
      keyboardSelect(-1);
      return event2.preventDefault();
    }
    if (event2.key === "ArrowDown" || event2.key === "Tab") {
      keyboardSelect(1);
      return event2.preventDefault();
    }
  }, [onSelect, onClose, selectedEntry, keyboardSelect]);
  const handleKey = T2((event2) => {
    if (matches(event2.target, "input")) {
      setValue(() => event2.target.value);
    }
  }, [setValue]);
  const displayHeader = F(() => title || headerEntries.length > 0, [title, headerEntries]);
  return m2`
    <${PopupMenuWrapper}
      onClose=${onClose}
      onKeyup=${handleKey}
      onKeydown=${handleKeyDown}
      className=${className}
      position=${position}
      width=${width}
      scale=${scale}
    >
      ${displayHeader && m2`
        <div class="djs-popup-header">
          <h3 class="djs-popup-title" title=${title}>${title}</h3>
          ${headerEntries.map((entry) => m2`
            <span
              class=${getHeaderClasses(entry, entry === selectedEntry)}
              onClick=${(event2) => onSelect(event2, entry)}
              title=${entry.title || entry.label}
              data-id=${entry.id}
              onMouseEnter=${() => setSelectedEntry(entry)}
              onMouseLeave=${() => setSelectedEntry(null)}
            >
              ${entry.imageUrl ? m2`
                <img class="djs-popup-entry-icon" src=${entry.imageUrl} />
              ` : null}

              ${entry.label ? m2`
                <span class="djs-popup-label">${entry.label}</span>
              ` : null}
            </span>
          `)}
        </div>
      `}
      ${originalEntries.length > 0 && m2`
        <div class="djs-popup-body">

          ${searchable && m2`
          <div class="djs-popup-search">
            <svg class="djs-popup-search-icon" width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path fill-rule="evenodd" clip-rule="evenodd" d="M9.0325 8.5H9.625L13.3675 12.25L12.25 13.3675L8.5 9.625V9.0325L8.2975 8.8225C7.4425 9.5575 6.3325 10 5.125 10C2.4325 10 0.25 7.8175 0.25 5.125C0.25 2.4325 2.4325 0.25 5.125 0.25C7.8175 0.25 10 2.4325 10 5.125C10 6.3325 9.5575 7.4425 8.8225 8.2975L9.0325 8.5ZM1.75 5.125C1.75 6.9925 3.2575 8.5 5.125 8.5C6.9925 8.5 8.5 6.9925 8.5 5.125C8.5 3.2575 6.9925 1.75 5.125 1.75C3.2575 1.75 1.75 3.2575 1.75 5.125Z" fill="#22242A"/>
            </svg>
            <input
                ref=${inputRef}
                type="text"
              />
          </div>
          `}

          <${PopupMenuList}
            entries=${entries}
            selectedEntry=${selectedEntry}
            setSelectedEntry=${setSelectedEntry}
            onClick=${onSelect}
          />
        </div>
        ${entries.length === 0 && m2`
          <div class="djs-popup-no-results">No matching entries found.</div>
        `}
      `}
    </${PopupMenuWrapper}>
  `;
}
function PopupMenuWrapper(props) {
  const {
    onClose,
    onKeydown,
    onKeyup,
    className,
    children,
    position: positionGetter
  } = props;
  const popupRef = _2();
  const checkClose = T2((event2) => {
    const popup = closest(event2.target, ".djs-popup", true);
    if (popup) {
      return;
    }
    onClose();
  }, [onClose]);
  s2(() => {
    if (typeof positionGetter !== "function") {
      return;
    }
    const popupEl = popupRef.current;
    const position = positionGetter(popupEl);
    popupEl.style.left = `${position.x}px`;
    popupEl.style.top = `${position.y}px`;
  }, [popupRef.current, positionGetter]);
  s2(() => {
    popupRef.current && popupRef.current.focus();
  }, []);
  return m2`
    <div
      class="djs-popup-backdrop"
      onClick=${checkClose}
    >
      <div
        class=${clsx_m_default("djs-popup", className)}
        style=${getPopupStyle(props)}
        onKeydown=${onKeydown}
        onKeyup=${onKeyup}
        ref=${popupRef}
        tabIndex="-1"
      >
        ${children}
      </div>
    </div>
  `;
}
function getPopupStyle(props) {
  return {
    transform: `scale(${props.scale})`,
    width: `${props.width}px`
  };
}
function getHeaderClasses(entry, selected) {
  return clsx_m_default("entry", entry.className, entry.active ? "active" : "", entry.disabled ? "disabled" : "", selected ? "selected" : "");
}

// node_modules/diagram-js/lib/features/popup-menu/PopupMenu.js
var DATA_REF = "data-id";
var CLOSE_EVENTS = [
  "contextPad.close",
  "canvas.viewbox.changing",
  "commandStack.changed"
];
var DEFAULT_PRIORITY5 = 1e3;
function PopupMenu(config, eventBus, canvas) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  this._current = null;
  var scale = (0, import_min_dash42.isDefined)(config && config.scale) ? config.scale : {
    min: 1,
    max: 1.5
  };
  this._config = {
    scale
  };
  eventBus.on("diagram.destroy", () => {
    this.close();
  });
  eventBus.on("element.changed", (event2) => {
    const element = this.isOpen() && this._current.element;
    if (event2.element === element) {
      this._render();
    }
  });
}
PopupMenu.$inject = [
  "config.popupMenu",
  "eventBus",
  "canvas"
];
PopupMenu.prototype._render = function() {
  const {
    position: _position,
    className,
    entries,
    headerEntries,
    options: options2
  } = this._current;
  const entriesArray = [
    ...Object.entries(entries).map(([key, value]) => ({ id: key, ...value }))
  ];
  const headerEntriesArray = [
    ...Object.entries(headerEntries).map(([key, value]) => ({ id: key, ...value }))
  ];
  const position = _position && ((container) => this._ensureVisible(container, _position));
  const scale = this._updateScale(this._current.container);
  const onClose = (result) => this.close(result);
  const onSelect = (event2, entry) => this.trigger(event2, entry);
  P(m2`
      <${PopupMenuComponent}
        onClose=${onClose}
        onSelect=${onSelect}
        position=${position}
        className=${className}
        entries=${entriesArray}
        headerEntries=${headerEntriesArray}
        scale=${scale}
        onOpened=${this._onOpened.bind(this)}
        onClosed=${this._onClosed.bind(this)}
        ...${{ ...options2 }}
      />
    `, this._current.container);
};
PopupMenu.prototype.open = function(element, providerId, position, options2) {
  if (!element) {
    throw new Error("Element is missing");
  }
  if (!providerId) {
    throw new Error("No registered providers for: " + providerId);
  }
  if (!position) {
    throw new Error("the position argument is missing");
  }
  if (this.isOpen()) {
    this.close();
  }
  const {
    entries,
    headerEntries
  } = this._getContext(element, providerId);
  this._current = {
    position,
    className: providerId,
    element,
    entries,
    headerEntries,
    container: this._createContainer({ provider: providerId }),
    options: options2
  };
  this._emit("open");
  this._bindAutoClose();
  this._render();
};
PopupMenu.prototype._getContext = function(element, provider) {
  const providers = this._getProviders(provider);
  if (!providers || !providers.length) {
    throw new Error("No registered providers for: " + provider);
  }
  const entries = this._getEntries(element, providers);
  const headerEntries = this._getHeaderEntries(element, providers);
  return {
    entries,
    headerEntries,
    empty: !(Object.keys(entries).length || Object.keys(headerEntries).length)
  };
};
PopupMenu.prototype.close = function() {
  if (!this.isOpen()) {
    return;
  }
  this._emit("close");
  this.reset();
  this._current = null;
};
PopupMenu.prototype.reset = function() {
  const container = this._current.container;
  P(null, container);
  remove2(container);
};
PopupMenu.prototype._emit = function(event2, payload) {
  this._eventBus.fire(`popupMenu.${event2}`, payload);
};
PopupMenu.prototype._onOpened = function() {
  this._emit("opened");
};
PopupMenu.prototype._onClosed = function() {
  this._emit("closed");
};
PopupMenu.prototype._createContainer = function(config) {
  let parent = config && config.parent || "body";
  if (typeof parent === "string") {
    parent = document.querySelector(parent);
  }
  const container = domify$1(`<div class="djs-popup-parent djs-parent" data-popup=${config.provider}></div>`);
  parent.appendChild(container);
  return container;
};
PopupMenu.prototype._bindAutoClose = function() {
  this._eventBus.once(CLOSE_EVENTS, this.close, this);
};
PopupMenu.prototype._unbindAutoClose = function() {
  this._eventBus.off(CLOSE_EVENTS, this.close, this);
};
PopupMenu.prototype._updateScale = function(container) {
  var zoom2 = this._canvas.zoom();
  var scaleConfig = this._config.scale, minScale, maxScale, scale = zoom2;
  if (scaleConfig !== true) {
    if (scaleConfig === false) {
      minScale = 1;
      maxScale = 1;
    } else {
      minScale = scaleConfig.min;
      maxScale = scaleConfig.max;
    }
    if ((0, import_min_dash42.isDefined)(minScale) && zoom2 < minScale) {
      scale = minScale;
    }
    if ((0, import_min_dash42.isDefined)(maxScale) && zoom2 > maxScale) {
      scale = maxScale;
    }
  }
  return scale;
};
PopupMenu.prototype._ensureVisible = function(container, position) {
  var documentBounds = document.documentElement.getBoundingClientRect();
  var containerBounds = container.getBoundingClientRect();
  var overAxis = {}, left = position.x, top = position.y;
  if (position.x + containerBounds.width > documentBounds.width) {
    overAxis.x = true;
  }
  if (position.y + containerBounds.height > documentBounds.height) {
    overAxis.y = true;
  }
  if (overAxis.x && overAxis.y) {
    left = position.x - containerBounds.width;
    top = position.y - containerBounds.height;
  } else if (overAxis.x) {
    left = position.x - containerBounds.width;
    top = position.y;
  } else if (overAxis.y && position.y < containerBounds.height) {
    left = position.x;
    top = 10;
  } else if (overAxis.y) {
    left = position.x;
    top = position.y - containerBounds.height;
  }
  return {
    x: left,
    y: top
  };
};
PopupMenu.prototype.isEmpty = function(element, providerId) {
  if (!element) {
    throw new Error("element parameter is missing");
  }
  if (!providerId) {
    throw new Error("providerId parameter is missing");
  }
  const providers = this._getProviders(providerId);
  if (!providers || !providers.length) {
    return true;
  }
  return this._getContext(element, providerId).empty;
};
PopupMenu.prototype.registerProvider = function(id, priority, provider) {
  if (!provider) {
    provider = priority;
    priority = DEFAULT_PRIORITY5;
  }
  this._eventBus.on("popupMenu.getProviders." + id, priority, function(event2) {
    event2.providers.push(provider);
  });
};
PopupMenu.prototype._getProviders = function(id) {
  var event2 = this._eventBus.createEvent({
    type: "popupMenu.getProviders." + id,
    providers: []
  });
  this._eventBus.fire(event2);
  return event2.providers;
};
PopupMenu.prototype._getEntries = function(element, providers) {
  var entries = {};
  (0, import_min_dash42.forEach)(providers, function(provider) {
    if (!provider.getPopupMenuEntries) {
      (0, import_min_dash42.forEach)(provider.getEntries(element), function(entry) {
        var id = entry.id;
        if (!id) {
          throw new Error("every entry must have the id property set");
        }
        entries[id] = (0, import_min_dash42.omit)(entry, ["id"]);
      });
      return;
    }
    var entriesOrUpdater = provider.getPopupMenuEntries(element);
    if ((0, import_min_dash42.isFunction)(entriesOrUpdater)) {
      entries = entriesOrUpdater(entries);
    } else {
      (0, import_min_dash42.forEach)(entriesOrUpdater, function(entry, id) {
        entries[id] = entry;
      });
    }
  });
  return entries;
};
PopupMenu.prototype._getHeaderEntries = function(element, providers) {
  var entries = {};
  (0, import_min_dash42.forEach)(providers, function(provider) {
    if (!provider.getPopupMenuHeaderEntries) {
      if (!provider.getHeaderEntries) {
        return;
      }
      (0, import_min_dash42.forEach)(provider.getHeaderEntries(element), function(entry) {
        var id = entry.id;
        if (!id) {
          throw new Error("every entry must have the id property set");
        }
        entries[id] = (0, import_min_dash42.omit)(entry, ["id"]);
      });
      return;
    }
    var entriesOrUpdater = provider.getPopupMenuHeaderEntries(element);
    if ((0, import_min_dash42.isFunction)(entriesOrUpdater)) {
      entries = entriesOrUpdater(entries);
    } else {
      (0, import_min_dash42.forEach)(entriesOrUpdater, function(entry, id) {
        entries[id] = entry;
      });
    }
  });
  return entries;
};
PopupMenu.prototype.isOpen = function() {
  return !!this._current;
};
PopupMenu.prototype.trigger = function(event2, entry) {
  event2.preventDefault();
  if (!entry) {
    let element = closest(event2.delegateTarget || event2.target, ".entry", true);
    let entryId = attr2(element, DATA_REF);
    entry = this._getEntry(entryId);
  }
  if (entry.action) {
    return entry.action.call(null, event2, entry);
  }
};
PopupMenu.prototype._getEntry = function(entryId) {
  var entry = this._current.entries[entryId] || this._current.headerEntries[entryId];
  if (!entry) {
    throw new Error("entry not found");
  }
  return entry;
};

// node_modules/diagram-js/lib/features/popup-menu/index.js
var popup_menu_default = {
  __init__: ["popupMenu"],
  popupMenu: ["type", PopupMenu]
};

// node_modules/bpmn-js/lib/features/align-elements/AlignElementsContextPadProvider.js
var import_min_dash43 = __toESM(require_dist());

// node_modules/bpmn-js/lib/features/align-elements/AlignElementsIcons.js
var icons = {
  align: "data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%202000%202000%22%3E%3Cpath%20style%3D%22stroke%3AcurrentColor%3Bstroke-width%3A100%3Bstroke-linecap%3Around%22%20d%3D%22M200%20150v1700%22%2F%3E%3Crect%20x%3D%22500%22%20y%3D%22150%22%20width%3D%221300%22%20height%3D%22700%22%20rx%3D%221%22%20style%3D%22fill%3Anone%3Bstroke%3AcurrentColor%3Bstroke-width%3A100%22%2F%3E%3Crect%20x%3D%22500%22%20y%3D%221150%22%20width%3D%22700%22%20height%3D%22700%22%20rx%3D%221%22%20style%3D%22fill%3AcurrentColor%3Bstroke%3AcurrentColor%3Bstroke-width%3A100%3Bopacity%3A.5%22%2F%3E%3C%2Fsvg%3E",
  bottom: "data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%201800%201800%22%3E%3Cpath%20style%3D%22stroke%3AcurrentColor%3Bstroke-width%3A100%3Bstroke-linecap%3Around%22%20d%3D%22M150%201650h1500%22%2F%3E%3Crect%20x%3D%22150%22%20y%3D%22350%22%20width%3D%22600%22%20height%3D%221300%22%20rx%3D%221%22%20style%3D%22fill%3Anone%3Bstroke%3AcurrentColor%3Bstroke-width%3A100%22%2F%3E%3Crect%20x%3D%221050%22%20y%3D%22850%22%20width%3D%22600%22%20height%3D%22800%22%20rx%3D%221%22%20style%3D%22fill%3AcurrentColor%3Bstroke%3AcurrentColor%3Bstroke-width%3A100%3Bopacity%3A.5%22%2F%3E%3C%2Fsvg%3E",
  center: "data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%201800%201800%22%3E%3Cpath%20style%3D%22stroke%3AcurrentColor%3Bstroke-width%3A100%3Bstroke-linecap%3Around%22%20d%3D%22M900%20150v1500%22%2F%3E%3Crect%20x%3D%22250%22%20y%3D%22150%22%20width%3D%221300%22%20height%3D%22600%22%20rx%3D%221%22%20style%3D%22fill%3Anone%3Bstroke%3AcurrentColor%3Bstroke-width%3A100%22%2F%3E%3Crect%20x%3D%22500%22%20y%3D%221050%22%20width%3D%22800%22%20height%3D%22600%22%20rx%3D%221%22%20style%3D%22fill%3AcurrentColor%3Bstroke%3AcurrentColor%3Bstroke-width%3A100%3Bopacity%3A.5%22%2F%3E%3C%2Fsvg%3E",
  left: "data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%201800%201800%22%3E%3Cpath%20style%3D%22stroke%3AcurrentColor%3Bstroke-width%3A100%3Bstroke-linecap%3Around%22%20d%3D%22M100%20150v1500%22%2F%3E%3Crect%20x%3D%22100%22%20y%3D%22150%22%20width%3D%221300%22%20height%3D%22600%22%20rx%3D%221%22%20style%3D%22fill%3Anone%3Bstroke%3AcurrentColor%3Bstroke-width%3A100%22%2F%3E%3Crect%20x%3D%22100%22%20y%3D%221050%22%20width%3D%22800%22%20height%3D%22600%22%20rx%3D%221%22%20style%3D%22fill%3AcurrentColor%3Bstroke%3AcurrentColor%3Bstroke-width%3A100%3Bopacity%3A.5%22%2F%3E%3C%2Fsvg%3E",
  right: "data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%201800%201800%22%3E%3Cpath%20style%3D%22stroke%3AcurrentColor%3Bstroke-width%3A100%3Bstroke-linecap%3Around%22%20d%3D%22M1650%20150v1500%22%2F%3E%3Crect%20x%3D%22350%22%20y%3D%22150%22%20width%3D%221300%22%20height%3D%22600%22%20rx%3D%221%22%20style%3D%22fill%3Anone%3Bstroke%3AcurrentColor%3Bstroke-width%3A100%22%2F%3E%3Crect%20x%3D%22850%22%20y%3D%221050%22%20width%3D%22800%22%20height%3D%22600%22%20rx%3D%221%22%20style%3D%22fill%3AcurrentColor%3Bstroke%3AcurrentColor%3Bstroke-width%3A100%3Bopacity%3A.5%22%2F%3E%3C%2Fsvg%3E",
  top: "data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%201800%201800%22%3E%3Cpath%20style%3D%22stroke%3AcurrentColor%3Bstroke-width%3A100%3Bstroke-linecap%3Around%22%20d%3D%22M150%20150h1500%22%2F%3E%3Crect%20x%3D%22150%22%20y%3D%22150%22%20width%3D%22600%22%20height%3D%221300%22%20rx%3D%221%22%20style%3D%22fill%3Anone%3Bstroke%3AcurrentColor%3Bstroke-width%3A100%22%2F%3E%3Crect%20x%3D%221050%22%20y%3D%22150%22%20width%3D%22600%22%20height%3D%22800%22%20rx%3D%221%22%20style%3D%22fill%3AcurrentColor%3Bstroke%3AcurrentColor%3Bstroke-width%3A100%3Bopacity%3A.5%22%2F%3E%3C%2Fsvg%3E",
  middle: "data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%201800%201800%22%3E%3Cpath%20style%3D%22stroke%3AcurrentColor%3Bstroke-width%3A100%3Bstroke-linecap%3Around%22%20d%3D%22M150%20900h1500%22%2F%3E%3Crect%20x%3D%22150%22%20y%3D%22250%22%20width%3D%22600%22%20height%3D%221300%22%20rx%3D%221%22%20style%3D%22fill%3Anone%3Bstroke%3AcurrentColor%3Bstroke-width%3A100%22%2F%3E%3Crect%20x%3D%221050%22%20y%3D%22500%22%20width%3D%22600%22%20height%3D%22800%22%20rx%3D%221%22%20style%3D%22fill%3AcurrentColor%3Bstroke%3AcurrentColor%3Bstroke-width%3A100%3Bopacity%3A.5%22%2F%3E%3C%2Fsvg%3E"
};
var AlignElementsIcons_default = icons;

// node_modules/bpmn-js/lib/features/align-elements/AlignElementsContextPadProvider.js
var LOW_PRIORITY6 = 900;
function AlignElementsContextPadProvider(contextPad, popupMenu, translate3, canvas) {
  contextPad.registerProvider(LOW_PRIORITY6, this);
  this._contextPad = contextPad;
  this._popupMenu = popupMenu;
  this._translate = translate3;
  this._canvas = canvas;
}
AlignElementsContextPadProvider.$inject = [
  "contextPad",
  "popupMenu",
  "translate",
  "canvas"
];
AlignElementsContextPadProvider.prototype.getMultiElementContextPadEntries = function(elements) {
  var actions = {};
  if (this._isAllowed(elements)) {
    (0, import_min_dash43.assign)(actions, this._getEntries(elements));
  }
  return actions;
};
AlignElementsContextPadProvider.prototype._isAllowed = function(elements) {
  return !this._popupMenu.isEmpty(elements, "align-elements");
};
AlignElementsContextPadProvider.prototype._getEntries = function(elements) {
  var self2 = this;
  return {
    "align-elements": {
      group: "align-elements",
      title: self2._translate("Align elements"),
      imageUrl: AlignElementsIcons_default["align"],
      action: {
        click: function(event2, elements2) {
          var position = self2._getMenuPosition(elements2);
          (0, import_min_dash43.assign)(position, {
            cursor: {
              x: event2.x,
              y: event2.y
            }
          });
          self2._popupMenu.open(elements2, "align-elements", position);
        }
      }
    }
  };
};
AlignElementsContextPadProvider.prototype._getMenuPosition = function(elements) {
  var Y_OFFSET = 5;
  var pad = this._contextPad.getPad(elements).html;
  var padRect = pad.getBoundingClientRect();
  var pos = {
    x: padRect.left,
    y: padRect.bottom + Y_OFFSET
  };
  return pos;
};

// node_modules/bpmn-js/lib/features/align-elements/AlignElementsMenuProvider.js
var import_min_dash44 = __toESM(require_dist());
var ALIGNMENT_OPTIONS = [
  "left",
  "center",
  "right",
  "top",
  "middle",
  "bottom"
];
function AlignElementsMenuProvider(popupMenu, alignElements, translate3, rules) {
  this._alignElements = alignElements;
  this._translate = translate3;
  this._popupMenu = popupMenu;
  this._rules = rules;
  popupMenu.registerProvider("align-elements", this);
}
AlignElementsMenuProvider.$inject = [
  "popupMenu",
  "alignElements",
  "translate",
  "rules"
];
AlignElementsMenuProvider.prototype.getPopupMenuEntries = function(elements) {
  var entries = {};
  if (this._isAllowed(elements)) {
    (0, import_min_dash44.assign)(entries, this._getEntries(elements));
  }
  return entries;
};
AlignElementsMenuProvider.prototype._isAllowed = function(elements) {
  return this._rules.allowed("elements.align", { elements });
};
AlignElementsMenuProvider.prototype._getEntries = function(elements) {
  var alignElements = this._alignElements, translate3 = this._translate, popupMenu = this._popupMenu;
  var entries = {};
  (0, import_min_dash44.forEach)(ALIGNMENT_OPTIONS, function(alignment) {
    entries["align-elements-" + alignment] = {
      group: "align",
      title: translate3("Align elements " + alignment),
      className: "bjs-align-elements-menu-entry",
      imageUrl: AlignElementsIcons_default[alignment],
      action: function(event2, entry) {
        alignElements.trigger(elements, alignment);
        popupMenu.close();
      }
    };
  });
  return entries;
};

// node_modules/diagram-js/lib/features/rules/RuleProvider.js
function RuleProvider(eventBus) {
  CommandInterceptor.call(this, eventBus);
  this.init();
}
RuleProvider.$inject = ["eventBus"];
e(RuleProvider, CommandInterceptor);
RuleProvider.prototype.addRule = function(actions, priority, fn2) {
  var self2 = this;
  if (typeof actions === "string") {
    actions = [actions];
  }
  actions.forEach(function(action) {
    self2.canExecute(action, priority, function(context, action2, event2) {
      return fn2(context);
    }, true);
  });
};
RuleProvider.prototype.init = function() {
};

// node_modules/bpmn-js/lib/features/align-elements/BpmnAlignElements.js
var import_min_dash45 = __toESM(require_dist());
function BpmnAlignElements(eventBus) {
  RuleProvider.call(this, eventBus);
}
BpmnAlignElements.$inject = ["eventBus"];
e(BpmnAlignElements, RuleProvider);
BpmnAlignElements.prototype.init = function() {
  this.addRule("elements.align", function(context) {
    var elements = context.elements;
    var filteredElements = (0, import_min_dash45.filter)(elements, function(element) {
      return !(element.waypoints || element.host || element.labelTarget);
    });
    filteredElements = getParents(filteredElements);
    if (filteredElements.length < 2) {
      return false;
    }
    return filteredElements;
  });
};

// node_modules/bpmn-js/lib/features/align-elements/index.js
var align_elements_default2 = {
  __depends__: [
    align_elements_default,
    context_pad_default,
    popup_menu_default
  ],
  __init__: [
    "alignElementsContextPadProvider",
    "alignElementsMenuProvider",
    "bpmnAlignElements"
  ],
  alignElementsContextPadProvider: ["type", AlignElementsContextPadProvider],
  alignElementsMenuProvider: ["type", AlignElementsMenuProvider],
  bpmnAlignElements: ["type", BpmnAlignElements]
};

// node_modules/diagram-js/lib/features/auto-place/AutoPlaceUtil.js
var import_min_dash46 = __toESM(require_dist());
var PLACEMENT_DETECTION_PAD = 10;
var DEFAULT_DISTANCE = 50;
var DEFAULT_MAX_DISTANCE = 250;
function findFreePosition(source, element, position, getNextPosition) {
  var connectedAtPosition;
  while (connectedAtPosition = getConnectedAtPosition(source, position, element)) {
    position = getNextPosition(element, position, connectedAtPosition);
  }
  return position;
}
function generateGetNextPosition(nextPositionDirection) {
  return function(element, previousPosition, connectedAtPosition) {
    var nextPosition = {
      x: previousPosition.x,
      y: previousPosition.y
    };
    ["x", "y"].forEach(function(axis) {
      var nextPositionDirectionForAxis = nextPositionDirection[axis];
      if (!nextPositionDirectionForAxis) {
        return;
      }
      var dimension = axis === "x" ? "width" : "height";
      var margin = nextPositionDirectionForAxis.margin, minDistance = nextPositionDirectionForAxis.minDistance;
      if (margin < 0) {
        nextPosition[axis] = Math.min(connectedAtPosition[axis] + margin - element[dimension] / 2, previousPosition[axis] - minDistance + margin);
      } else {
        nextPosition[axis] = Math.max(connectedAtPosition[axis] + connectedAtPosition[dimension] + margin + element[dimension] / 2, previousPosition[axis] + minDistance + margin);
      }
    });
    return nextPosition;
  };
}
function getConnectedAtPosition(source, position, element) {
  var bounds = {
    x: position.x - element.width / 2,
    y: position.y - element.height / 2,
    width: element.width,
    height: element.height
  };
  var closure = getAutoPlaceClosure(source, element);
  return (0, import_min_dash46.find)(closure, function(target) {
    if (target === element) {
      return false;
    }
    var orientation = getOrientation(target, bounds, PLACEMENT_DETECTION_PAD);
    return orientation === "intersect";
  });
}
function getConnectedDistance(source, hints) {
  if (!hints) {
    hints = {};
  }
  function getDefaultWeight(connection) {
    return connection.source === source ? 1 : -1;
  }
  var defaultDistance = hints.defaultDistance || DEFAULT_DISTANCE, direction = hints.direction || "e", filter28 = hints.filter, getWeight = hints.getWeight || getDefaultWeight, maxDistance = hints.maxDistance || DEFAULT_MAX_DISTANCE, reference = hints.reference || "start";
  if (!filter28) {
    filter28 = noneFilter;
  }
  function getDistance3(a6, b5) {
    if (direction === "n") {
      if (reference === "start") {
        return asTRBL(a6).top - asTRBL(b5).bottom;
      } else if (reference === "center") {
        return asTRBL(a6).top - getMid(b5).y;
      } else {
        return asTRBL(a6).top - asTRBL(b5).top;
      }
    } else if (direction === "w") {
      if (reference === "start") {
        return asTRBL(a6).left - asTRBL(b5).right;
      } else if (reference === "center") {
        return asTRBL(a6).left - getMid(b5).x;
      } else {
        return asTRBL(a6).left - asTRBL(b5).left;
      }
    } else if (direction === "s") {
      if (reference === "start") {
        return asTRBL(b5).top - asTRBL(a6).bottom;
      } else if (reference === "center") {
        return getMid(b5).y - asTRBL(a6).bottom;
      } else {
        return asTRBL(b5).bottom - asTRBL(a6).bottom;
      }
    } else {
      if (reference === "start") {
        return asTRBL(b5).left - asTRBL(a6).right;
      } else if (reference === "center") {
        return getMid(b5).x - asTRBL(a6).right;
      } else {
        return asTRBL(b5).right - asTRBL(a6).right;
      }
    }
  }
  var sourcesDistances = source.incoming.filter(filter28).map(function(connection) {
    var weight = getWeight(connection);
    var distance2 = weight < 0 ? getDistance3(connection.source, source) : getDistance3(source, connection.source);
    return {
      id: connection.source.id,
      distance: distance2,
      weight
    };
  });
  var targetsDistances = source.outgoing.filter(filter28).map(function(connection) {
    var weight = getWeight(connection);
    var distance2 = weight > 0 ? getDistance3(source, connection.target) : getDistance3(connection.target, source);
    return {
      id: connection.target.id,
      distance: distance2,
      weight
    };
  });
  var distances = sourcesDistances.concat(targetsDistances).reduce(function(accumulator, currentValue) {
    accumulator[currentValue.id + "__weight_" + currentValue.weight] = currentValue;
    return accumulator;
  }, {});
  var distancesGrouped = (0, import_min_dash46.reduce)(distances, function(accumulator, currentValue) {
    var distance2 = currentValue.distance, weight = currentValue.weight;
    if (distance2 < 0 || distance2 > maxDistance) {
      return accumulator;
    }
    if (!accumulator[String(distance2)]) {
      accumulator[String(distance2)] = 0;
    }
    accumulator[String(distance2)] += 1 * weight;
    if (!accumulator.distance || accumulator[accumulator.distance] < accumulator[String(distance2)]) {
      accumulator.distance = distance2;
    }
    return accumulator;
  }, {});
  return distancesGrouped.distance || defaultDistance;
}
function getAutoPlaceClosure(source) {
  var allConnected = getConnected(source);
  if (source.host) {
    allConnected = allConnected.concat(getConnected(source.host));
  }
  if (source.attachers) {
    allConnected = allConnected.concat(source.attachers.reduce(function(shapes, attacher) {
      return shapes.concat(getConnected(attacher));
    }, []));
  }
  return allConnected;
}
function getConnected(element) {
  return getTargets(element).concat(getSources(element));
}
function getSources(shape) {
  return shape.incoming.map(function(connection) {
    return connection.source;
  });
}
function getTargets(shape) {
  return shape.outgoing.map(function(connection) {
    return connection.target;
  });
}
function noneFilter() {
  return true;
}

// node_modules/diagram-js/lib/features/auto-place/AutoPlace.js
var LOW_PRIORITY7 = 100;
function AutoPlace(eventBus, modeling, canvas) {
  eventBus.on("autoPlace", LOW_PRIORITY7, function(context) {
    var shape = context.shape, source = context.source;
    return getNewShapePosition(source, shape);
  });
  eventBus.on("autoPlace.end", function(event2) {
    canvas.scrollToElement(event2.shape);
  });
  this.append = function(source, shape, hints) {
    eventBus.fire("autoPlace.start", {
      source,
      shape
    });
    var position = eventBus.fire("autoPlace", {
      source,
      shape
    });
    var newShape = modeling.appendShape(source, shape, position, source.parent, hints);
    eventBus.fire("autoPlace.end", {
      source,
      shape: newShape
    });
    return newShape;
  };
}
AutoPlace.$inject = [
  "eventBus",
  "modeling",
  "canvas"
];
function getNewShapePosition(source, element, hints) {
  if (!hints) {
    hints = {};
  }
  var distance2 = hints.defaultDistance || DEFAULT_DISTANCE;
  var sourceMid = getMid(source), sourceTrbl = asTRBL(source);
  return {
    x: sourceTrbl.right + distance2 + element.width / 2,
    y: sourceMid.y
  };
}

// node_modules/diagram-js/lib/features/auto-place/AutoPlaceSelectionBehavior.js
function AutoPlaceSelectionBehavior(eventBus, selection) {
  eventBus.on("autoPlace.end", 500, function(e7) {
    selection.select(e7.shape);
  });
}
AutoPlaceSelectionBehavior.$inject = [
  "eventBus",
  "selection"
];

// node_modules/diagram-js/lib/features/auto-place/index.js
var auto_place_default = {
  __init__: ["autoPlaceSelectionBehavior"],
  autoPlace: ["type", AutoPlace],
  autoPlaceSelectionBehavior: ["type", AutoPlaceSelectionBehavior]
};

// node_modules/bpmn-js/lib/features/modeling/util/ModelingUtil.js
function getParent2(element, anyType) {
  if (typeof anyType === "string") {
    anyType = [anyType];
  }
  while (element = element.parent) {
    if (isAny(element, anyType)) {
      return element;
    }
  }
  return null;
}

// node_modules/bpmn-js/lib/features/auto-place/BpmnAutoPlaceUtil.js
function getNewShapePosition2(source, element) {
  if (is(element, "bpmn:TextAnnotation")) {
    return getTextAnnotationPosition(source, element);
  }
  if (isAny(element, ["bpmn:DataObjectReference", "bpmn:DataStoreReference"])) {
    return getDataElementPosition(source, element);
  }
  if (is(element, "bpmn:FlowNode")) {
    return getFlowNodePosition(source, element);
  }
}
function getFlowNodePosition(source, element) {
  var sourceTrbl = asTRBL(source);
  var sourceMid = getMid(source);
  var horizontalDistance = getConnectedDistance(source, {
    filter: function(connection) {
      return is(connection, "bpmn:SequenceFlow");
    }
  });
  var margin = 30, minDistance = 80, orientation = "left";
  if (is(source, "bpmn:BoundaryEvent")) {
    orientation = getOrientation(source, source.host, -25);
    if (orientation.indexOf("top") !== -1) {
      margin *= -1;
    }
  }
  var position = {
    x: sourceTrbl.right + horizontalDistance + element.width / 2,
    y: sourceMid.y + getVerticalDistance(orientation, minDistance)
  };
  var nextPositionDirection = {
    y: {
      margin,
      minDistance
    }
  };
  return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));
}
function getVerticalDistance(orientation, minDistance) {
  if (orientation.indexOf("top") != -1) {
    return -1 * minDistance;
  } else if (orientation.indexOf("bottom") != -1) {
    return minDistance;
  } else {
    return 0;
  }
}
function getTextAnnotationPosition(source, element) {
  var sourceTrbl = asTRBL(source);
  var position = {
    x: sourceTrbl.right + element.width / 2,
    y: sourceTrbl.top - 50 - element.height / 2
  };
  if (isConnection2(source)) {
    position = getMid(source);
    position.x += 100;
    position.y -= 50;
  }
  var nextPositionDirection = {
    y: {
      margin: -30,
      minDistance: 20
    }
  };
  return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));
}
function getDataElementPosition(source, element) {
  var sourceTrbl = asTRBL(source);
  var position = {
    x: sourceTrbl.right - 10 + element.width / 2,
    y: sourceTrbl.bottom + 40 + element.width / 2
  };
  var nextPositionDirection = {
    x: {
      margin: 30,
      minDistance: 30
    }
  };
  return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));
}
function isConnection2(element) {
  return !!element.waypoints;
}

// node_modules/bpmn-js/lib/features/auto-place/BpmnAutoPlace.js
function AutoPlace2(eventBus) {
  eventBus.on("autoPlace", function(context) {
    var shape = context.shape, source = context.source;
    return getNewShapePosition2(source, shape);
  });
}
AutoPlace2.$inject = ["eventBus"];

// node_modules/bpmn-js/lib/features/auto-place/index.js
var auto_place_default2 = {
  __depends__: [auto_place_default],
  __init__: ["bpmnAutoPlace"],
  bpmnAutoPlace: ["type", AutoPlace2]
};

// node_modules/diagram-js/lib/features/auto-resize/AutoResize.js
var import_min_dash47 = __toESM(require_dist());
function AutoResize(eventBus, elementRegistry, modeling, rules) {
  CommandInterceptor.call(this, eventBus);
  this._elementRegistry = elementRegistry;
  this._modeling = modeling;
  this._rules = rules;
  var self2 = this;
  this.postExecuted(["shape.create"], function(event2) {
    var context = event2.context, hints = context.hints || {}, shape = context.shape, parent = context.parent || context.newParent;
    if (hints.autoResize === false) {
      return;
    }
    self2._expand([shape], parent);
  });
  this.postExecuted(["elements.move"], function(event2) {
    var context = event2.context, elements = (0, import_min_dash47.flatten)((0, import_min_dash47.values)(context.closure.topLevel)), hints = context.hints;
    var autoResize = hints ? hints.autoResize : true;
    if (autoResize === false) {
      return;
    }
    var expandings = (0, import_min_dash47.groupBy)(elements, function(element) {
      return element.parent.id;
    });
    (0, import_min_dash47.forEach)(expandings, function(elements2, parentId) {
      if ((0, import_min_dash47.isArray)(autoResize)) {
        elements2 = elements2.filter(function(element) {
          return (0, import_min_dash47.find)(autoResize, (0, import_min_dash47.matchPattern)({ id: element.id }));
        });
      }
      self2._expand(elements2, parentId);
    });
  });
  this.postExecuted(["shape.toggleCollapse"], function(event2) {
    var context = event2.context, hints = context.hints, shape = context.shape;
    if (hints && hints.autoResize === false) {
      return;
    }
    if (shape.collapsed) {
      return;
    }
    self2._expand(shape.children || [], shape);
  });
  this.postExecuted(["shape.resize"], function(event2) {
    var context = event2.context, hints = context.hints, shape = context.shape, parent = shape.parent;
    if (hints && hints.autoResize === false) {
      return;
    }
    if (parent) {
      self2._expand([shape], parent);
    }
  });
}
AutoResize.$inject = [
  "eventBus",
  "elementRegistry",
  "modeling",
  "rules"
];
e(AutoResize, CommandInterceptor);
AutoResize.prototype._getOptimalBounds = function(elements, target) {
  var offset = this.getOffset(target), padding = this.getPadding(target);
  var elementsTrbl = asTRBL(getBBox(elements)), targetTrbl = asTRBL(target);
  var newTrbl = {};
  if (elementsTrbl.top - targetTrbl.top < padding.top) {
    newTrbl.top = elementsTrbl.top - offset.top;
  }
  if (elementsTrbl.left - targetTrbl.left < padding.left) {
    newTrbl.left = elementsTrbl.left - offset.left;
  }
  if (targetTrbl.right - elementsTrbl.right < padding.right) {
    newTrbl.right = elementsTrbl.right + offset.right;
  }
  if (targetTrbl.bottom - elementsTrbl.bottom < padding.bottom) {
    newTrbl.bottom = elementsTrbl.bottom + offset.bottom;
  }
  return asBounds((0, import_min_dash47.assign)({}, targetTrbl, newTrbl));
};
AutoResize.prototype._expand = function(elements, target) {
  if (typeof target === "string") {
    target = this._elementRegistry.get(target);
  }
  var allowed = this._rules.allowed("element.autoResize", {
    elements,
    target
  });
  if (!allowed) {
    return;
  }
  var newBounds = this._getOptimalBounds(elements, target);
  if (!boundsChanged(newBounds, target)) {
    return;
  }
  var resizeDirections = getResizeDirections((0, import_min_dash47.pick)(target, ["x", "y", "width", "height"]), newBounds);
  this.resize(target, newBounds, {
    autoResize: resizeDirections
  });
  var parent = target.parent;
  if (parent) {
    this._expand([target], parent);
  }
};
AutoResize.prototype.getOffset = function(shape) {
  return { top: 60, bottom: 60, left: 100, right: 100 };
};
AutoResize.prototype.getPadding = function(shape) {
  return { top: 2, bottom: 2, left: 15, right: 15 };
};
AutoResize.prototype.resize = function(shape, newBounds, hints) {
  this._modeling.resizeShape(shape, newBounds, null, hints);
};
function boundsChanged(newBounds, oldBounds) {
  return newBounds.x !== oldBounds.x || newBounds.y !== oldBounds.y || newBounds.width !== oldBounds.width || newBounds.height !== oldBounds.height;
}
function getResizeDirections(oldBounds, newBounds) {
  var directions2 = "";
  oldBounds = asTRBL(oldBounds);
  newBounds = asTRBL(newBounds);
  if (oldBounds.top > newBounds.top) {
    directions2 = directions2.concat("n");
  }
  if (oldBounds.right < newBounds.right) {
    directions2 = directions2.concat("w");
  }
  if (oldBounds.bottom < newBounds.bottom) {
    directions2 = directions2.concat("s");
  }
  if (oldBounds.left > newBounds.left) {
    directions2 = directions2.concat("e");
  }
  return directions2;
}

// node_modules/bpmn-js/lib/features/auto-resize/BpmnAutoResize.js
function BpmnAutoResize(injector) {
  injector.invoke(AutoResize, this);
}
BpmnAutoResize.$inject = [
  "injector"
];
e(BpmnAutoResize, AutoResize);
BpmnAutoResize.prototype.resize = function(target, newBounds, hints) {
  if (is(target, "bpmn:Participant")) {
    this._modeling.resizeLane(target, newBounds, null, hints);
  } else {
    this._modeling.resizeShape(target, newBounds, null, hints);
  }
};

// node_modules/bpmn-js/lib/features/auto-resize/BpmnAutoResizeProvider.js
var import_min_dash48 = __toESM(require_dist());

// node_modules/diagram-js/lib/features/auto-resize/AutoResizeProvider.js
function AutoResizeProvider(eventBus) {
  RuleProvider.call(this, eventBus);
  var self2 = this;
  this.addRule("element.autoResize", function(context) {
    return self2.canResize(context.elements, context.target);
  });
}
AutoResizeProvider.$inject = ["eventBus"];
e(AutoResizeProvider, RuleProvider);
AutoResizeProvider.prototype.canResize = function(elements, target) {
  return false;
};

// node_modules/bpmn-js/lib/features/auto-resize/BpmnAutoResizeProvider.js
function BpmnAutoResizeProvider(eventBus, modeling) {
  AutoResizeProvider.call(this, eventBus);
  this._modeling = modeling;
}
e(BpmnAutoResizeProvider, AutoResizeProvider);
BpmnAutoResizeProvider.$inject = [
  "eventBus",
  "modeling"
];
BpmnAutoResizeProvider.prototype.canResize = function(elements, target) {
  if (is(target.di, "bpmndi:BPMNPlane")) {
    return false;
  }
  if (!is(target, "bpmn:Participant") && !is(target, "bpmn:Lane") && !is(target, "bpmn:SubProcess")) {
    return false;
  }
  var canResize2 = true;
  (0, import_min_dash48.forEach)(elements, function(element) {
    if (is(element, "bpmn:Lane") || element.labelTarget) {
      canResize2 = false;
      return;
    }
  });
  return canResize2;
};

// node_modules/bpmn-js/lib/features/auto-resize/index.js
var auto_resize_default = {
  __init__: [
    "bpmnAutoResize",
    "bpmnAutoResizeProvider"
  ],
  bpmnAutoResize: ["type", BpmnAutoResize],
  bpmnAutoResizeProvider: ["type", BpmnAutoResizeProvider]
};

// node_modules/diagram-js/lib/features/hover-fix/HoverFix.js
var HIGH_PRIORITY = 1500;
function HoverFix(elementRegistry, eventBus, injector) {
  var self2 = this;
  var dragging = injector.get("dragging", false);
  function ensureHover(event2) {
    if (event2.hover) {
      return;
    }
    var originalEvent = event2.originalEvent;
    var gfx = self2._findTargetGfx(originalEvent);
    var element = gfx && elementRegistry.get(gfx);
    if (gfx && element) {
      event2.stopPropagation();
      dragging.hover({ element, gfx });
      dragging.move(originalEvent);
    }
  }
  if (dragging) {
    eventBus.on("drag.start", function(event2) {
      eventBus.once("drag.move", HIGH_PRIORITY, function(event3) {
        ensureHover(event3);
      });
    });
  }
  (function() {
    var hoverGfx;
    var hover;
    eventBus.on("element.hover", function(event2) {
      hoverGfx = event2.gfx;
      hover = event2.element;
    });
    eventBus.on("element.hover", HIGH_PRIORITY, function(event2) {
      if (hover) {
        eventBus.fire("element.out", {
          element: hover,
          gfx: hoverGfx
        });
      }
    });
    eventBus.on("element.out", function() {
      hoverGfx = null;
      hover = null;
    });
  })();
  this._findTargetGfx = function(event2) {
    var position, target;
    if (!(event2 instanceof MouseEvent)) {
      return;
    }
    position = toPoint(event2);
    target = document.elementFromPoint(position.x, position.y);
    return getGfx(target);
  };
}
HoverFix.$inject = [
  "elementRegistry",
  "eventBus",
  "injector"
];
function getGfx(target) {
  return closest(target, "svg, .djs-element", true);
}

// node_modules/diagram-js/lib/features/hover-fix/index.js
var hover_fix_default = {
  __init__: [
    "hoverFix"
  ],
  hoverFix: ["type", HoverFix]
};

// node_modules/diagram-js/lib/features/dragging/Dragging.js
var import_min_dash49 = __toESM(require_dist());
var round2 = Math.round;
var DRAG_ACTIVE_CLS = "djs-drag-active";
function preventDefault(event2) {
  event2.preventDefault();
}
function isTouchEvent(event2) {
  return typeof TouchEvent !== "undefined" && event2 instanceof TouchEvent;
}
function getLength(point) {
  return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
}
function Dragging(eventBus, canvas, selection, elementRegistry) {
  var defaultOptions = {
    threshold: 5,
    trapClick: true
  };
  var context;
  function toLocalPoint(globalPosition) {
    var viewbox = canvas.viewbox();
    var clientRect = canvas._container.getBoundingClientRect();
    return {
      x: viewbox.x + (globalPosition.x - clientRect.left) / viewbox.scale,
      y: viewbox.y + (globalPosition.y - clientRect.top) / viewbox.scale
    };
  }
  function fire(type, dragContext) {
    dragContext = dragContext || context;
    var event2 = eventBus.createEvent((0, import_min_dash49.assign)({}, dragContext.payload, dragContext.data, { isTouch: dragContext.isTouch }));
    if (eventBus.fire("drag." + type, event2) === false) {
      return false;
    }
    return eventBus.fire(dragContext.prefix + "." + type, event2);
  }
  function restoreSelection(previousSelection) {
    var existingSelection = previousSelection.filter(function(element) {
      return elementRegistry.get(element.id);
    });
    existingSelection.length && selection.select(existingSelection);
  }
  function move(event2, activate) {
    var payload = context.payload, displacement = context.displacement;
    var globalStart = context.globalStart, globalCurrent = toPoint(event2), globalDelta = delta(globalCurrent, globalStart);
    var localStart = context.localStart, localCurrent = toLocalPoint(globalCurrent), localDelta = delta(localCurrent, localStart);
    if (!context.active && (activate || getLength(globalDelta) > context.threshold)) {
      (0, import_min_dash49.assign)(payload, {
        x: round2(localStart.x + displacement.x),
        y: round2(localStart.y + displacement.y),
        dx: 0,
        dy: 0
      }, { originalEvent: event2 });
      if (fire("start") === false) {
        return cancel();
      }
      context.active = true;
      if (!context.keepSelection) {
        payload.previousSelection = selection.get();
        selection.select(null);
      }
      if (context.cursor) {
        set2(context.cursor);
      }
      canvas.addMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);
    }
    stopPropagation(event2);
    if (context.active) {
      (0, import_min_dash49.assign)(payload, {
        x: round2(localCurrent.x + displacement.x),
        y: round2(localCurrent.y + displacement.y),
        dx: round2(localDelta.x),
        dy: round2(localDelta.y)
      }, { originalEvent: event2 });
      fire("move");
    }
  }
  function end(event2) {
    var previousContext, returnValue = true;
    if (context.active) {
      if (event2) {
        context.payload.originalEvent = event2;
        stopPropagation(event2);
      }
      returnValue = fire("end");
    }
    if (returnValue === false) {
      fire("rejected");
    }
    previousContext = cleanup(returnValue !== true);
    fire("ended", previousContext);
  }
  function checkCancel(event2) {
    if (isKey("Escape", event2)) {
      preventDefault(event2);
      cancel();
    }
  }
  function trapClickAndEnd(event2) {
    var untrap;
    if (context.active) {
      untrap = install(eventBus);
      setTimeout(untrap, 400);
      preventDefault(event2);
    }
    end(event2);
  }
  function trapTouch(event2) {
    move(event2);
  }
  function hover(event2) {
    var payload = context.payload;
    payload.hoverGfx = event2.gfx;
    payload.hover = event2.element;
    fire("hover");
  }
  function out(event2) {
    fire("out");
    var payload = context.payload;
    payload.hoverGfx = null;
    payload.hover = null;
  }
  function cancel(restore) {
    var previousContext;
    if (!context) {
      return;
    }
    var wasActive = context.active;
    if (wasActive) {
      fire("cancel");
    }
    previousContext = cleanup(restore);
    if (wasActive) {
      fire("canceled", previousContext);
    }
  }
  function cleanup(restore) {
    var previousContext, endDrag;
    fire("cleanup");
    unset();
    if (context.trapClick) {
      endDrag = trapClickAndEnd;
    } else {
      endDrag = end;
    }
    event.unbind(document, "mousemove", move);
    event.unbind(document, "dragstart", preventDefault);
    event.unbind(document, "selectstart", preventDefault);
    event.unbind(document, "mousedown", endDrag, true);
    event.unbind(document, "mouseup", endDrag, true);
    event.unbind(document, "keyup", checkCancel);
    event.unbind(document, "touchstart", trapTouch, true);
    event.unbind(document, "touchcancel", cancel, true);
    event.unbind(document, "touchmove", move, true);
    event.unbind(document, "touchend", end, true);
    eventBus.off("element.hover", hover);
    eventBus.off("element.out", out);
    canvas.removeMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);
    var previousSelection = context.payload.previousSelection;
    if (restore !== false && previousSelection && !selection.get().length) {
      restoreSelection(previousSelection);
    }
    previousContext = context;
    context = null;
    return previousContext;
  }
  function init(event2, relativeTo, prefix3, options2) {
    if (context) {
      cancel(false);
    }
    if (typeof relativeTo === "string") {
      options2 = prefix3;
      prefix3 = relativeTo;
      relativeTo = null;
    }
    options2 = (0, import_min_dash49.assign)({}, defaultOptions, options2 || {});
    var data = options2.data || {}, originalEvent, globalStart, localStart, endDrag, isTouch;
    if (options2.trapClick) {
      endDrag = trapClickAndEnd;
    } else {
      endDrag = end;
    }
    if (event2) {
      originalEvent = getOriginal(event2) || event2;
      globalStart = toPoint(event2);
      stopPropagation(event2);
      if (originalEvent.type === "dragstart") {
        preventDefault(originalEvent);
      }
    } else {
      originalEvent = null;
      globalStart = { x: 0, y: 0 };
    }
    localStart = toLocalPoint(globalStart);
    if (!relativeTo) {
      relativeTo = localStart;
    }
    isTouch = isTouchEvent(originalEvent);
    context = (0, import_min_dash49.assign)({
      prefix: prefix3,
      data,
      payload: {},
      globalStart,
      displacement: delta(relativeTo, localStart),
      localStart,
      isTouch
    }, options2);
    if (!options2.manual) {
      if (isTouch) {
        event.bind(document, "touchstart", trapTouch, true);
        event.bind(document, "touchcancel", cancel, true);
        event.bind(document, "touchmove", move, true);
        event.bind(document, "touchend", end, true);
      } else {
        event.bind(document, "mousemove", move);
        event.bind(document, "dragstart", preventDefault);
        event.bind(document, "selectstart", preventDefault);
        event.bind(document, "mousedown", endDrag, true);
        event.bind(document, "mouseup", endDrag, true);
      }
      event.bind(document, "keyup", checkCancel);
      eventBus.on("element.hover", hover);
      eventBus.on("element.out", out);
    }
    fire("init");
    if (options2.autoActivate) {
      move(event2, true);
    }
  }
  eventBus.on("diagram.destroy", cancel);
  this.init = init;
  this.move = move;
  this.hover = hover;
  this.out = out;
  this.end = end;
  this.cancel = cancel;
  this.context = function() {
    return context;
  };
  this.setOptions = function(options2) {
    (0, import_min_dash49.assign)(defaultOptions, options2);
  };
}
Dragging.$inject = [
  "eventBus",
  "canvas",
  "selection",
  "elementRegistry"
];

// node_modules/diagram-js/lib/features/dragging/index.js
var dragging_default = {
  __depends__: [
    hover_fix_default,
    selection_default
  ],
  dragging: ["type", Dragging]
};

// node_modules/diagram-js/lib/features/auto-scroll/AutoScroll.js
var import_min_dash50 = __toESM(require_dist());
function AutoScroll(config, eventBus, canvas) {
  this._canvas = canvas;
  this._opts = (0, import_min_dash50.assign)({
    scrollThresholdIn: [20, 20, 20, 20],
    scrollThresholdOut: [0, 0, 0, 0],
    scrollRepeatTimeout: 15,
    scrollStep: 10
  }, config);
  var self2 = this;
  eventBus.on("drag.move", function(e7) {
    var point = self2._toBorderPoint(e7);
    self2.startScroll(point);
  });
  eventBus.on(["drag.cleanup"], function() {
    self2.stopScroll();
  });
}
AutoScroll.$inject = [
  "config.autoScroll",
  "eventBus",
  "canvas"
];
AutoScroll.prototype.startScroll = function(point) {
  var canvas = this._canvas;
  var opts = this._opts;
  var self2 = this;
  var clientRect = canvas.getContainer().getBoundingClientRect();
  var diff = [
    point.x,
    point.y,
    clientRect.width - point.x,
    clientRect.height - point.y
  ];
  this.stopScroll();
  var dx = 0, dy = 0;
  for (var i6 = 0; i6 < 4; i6++) {
    if (between(diff[i6], opts.scrollThresholdOut[i6], opts.scrollThresholdIn[i6])) {
      if (i6 === 0) {
        dx = opts.scrollStep;
      } else if (i6 == 1) {
        dy = opts.scrollStep;
      } else if (i6 == 2) {
        dx = -opts.scrollStep;
      } else if (i6 == 3) {
        dy = -opts.scrollStep;
      }
    }
  }
  if (dx !== 0 || dy !== 0) {
    canvas.scroll({ dx, dy });
    this._scrolling = setTimeout(function() {
      self2.startScroll(point);
    }, opts.scrollRepeatTimeout);
  }
};
function between(val, start, end) {
  if (start < val && val < end) {
    return true;
  }
  return false;
}
AutoScroll.prototype.stopScroll = function() {
  clearTimeout(this._scrolling);
};
AutoScroll.prototype.setOptions = function(options2) {
  this._opts = (0, import_min_dash50.assign)({}, this._opts, options2);
};
AutoScroll.prototype._toBorderPoint = function(event2) {
  var clientRect = this._canvas._container.getBoundingClientRect();
  var globalPosition = toPoint(event2.originalEvent);
  return {
    x: globalPosition.x - clientRect.left,
    y: globalPosition.y - clientRect.top
  };
};

// node_modules/diagram-js/lib/features/auto-scroll/index.js
var auto_scroll_default = {
  __depends__: [
    dragging_default
  ],
  __init__: ["autoScroll"],
  autoScroll: ["type", AutoScroll]
};

// node_modules/diagram-js/lib/features/rules/Rules.js
function Rules(injector) {
  this._commandStack = injector.get("commandStack", false);
}
Rules.$inject = ["injector"];
Rules.prototype.allowed = function(action, context) {
  var allowed = true;
  var commandStack = this._commandStack;
  if (commandStack) {
    allowed = commandStack.canExecute(action, context);
  }
  return allowed === void 0 ? true : allowed;
};

// node_modules/diagram-js/lib/features/rules/index.js
var rules_default = {
  __init__: ["rules"],
  rules: ["type", Rules]
};

// node_modules/diagram-js/lib/features/bendpoints/Bendpoints.js
var import_min_dash51 = __toESM(require_dist());

// node_modules/diagram-js/lib/util/LineIntersection.js
var import_path_intersection2 = __toESM(require_intersect());
var round3 = Math.round;
var max = Math.max;
function circlePath(center2, r6) {
  var x4 = center2.x, y4 = center2.y;
  return [
    ["M", x4, y4],
    ["m", 0, -r6],
    ["a", r6, r6, 0, 1, 1, 0, 2 * r6],
    ["a", r6, r6, 0, 1, 1, 0, -2 * r6],
    ["z"]
  ];
}
function linePath(points) {
  var segments = [];
  points.forEach(function(p6, idx) {
    segments.push([idx === 0 ? "M" : "L", p6.x, p6.y]);
  });
  return segments;
}
var INTERSECTION_THRESHOLD = 10;
function getBendpointIntersection(waypoints, reference) {
  var i6, w6;
  for (i6 = 0; w6 = waypoints[i6]; i6++) {
    if (pointDistance(w6, reference) <= INTERSECTION_THRESHOLD) {
      return {
        point: waypoints[i6],
        bendpoint: true,
        index: i6
      };
    }
  }
  return null;
}
function getPathIntersection(waypoints, reference) {
  var intersections = (0, import_path_intersection2.default)(circlePath(reference, INTERSECTION_THRESHOLD), linePath(waypoints));
  var a6 = intersections[0], b5 = intersections[intersections.length - 1], idx;
  if (!a6) {
    return null;
  }
  if (a6 !== b5) {
    if (a6.segment2 !== b5.segment2) {
      idx = max(a6.segment2, b5.segment2) - 1;
      return {
        point: waypoints[idx],
        bendpoint: true,
        index: idx
      };
    }
    return {
      point: {
        x: round3(a6.x + b5.x) / 2,
        y: round3(a6.y + b5.y) / 2
      },
      index: a6.segment2
    };
  }
  return {
    point: {
      x: round3(a6.x),
      y: round3(a6.y)
    },
    index: a6.segment2
  };
}
function getApproxIntersection(waypoints, reference) {
  return getBendpointIntersection(waypoints, reference) || getPathIntersection(waypoints, reference);
}

// node_modules/diagram-js/lib/features/bendpoints/GeometricUtil.js
function vectorLength(v5) {
  return Math.sqrt(Math.pow(v5.x, 2) + Math.pow(v5.y, 2));
}
function getAngle(line) {
  return Math.atan((line[1].y - line[0].y) / (line[1].x - line[0].x));
}
function rotateVector(vector, angle) {
  return !angle ? vector : {
    x: Math.cos(angle) * vector.x - Math.sin(angle) * vector.y,
    y: Math.sin(angle) * vector.x + Math.cos(angle) * vector.y
  };
}
function solveLambaSystem(a6, b5, c5) {
  var system = [
    { n: a6[0] - c5[0], lambda: b5[0] },
    { n: a6[1] - c5[1], lambda: b5[1] }
  ];
  var n5 = system[0].n * b5[0] + system[1].n * b5[1], l6 = system[0].lambda * b5[0] + system[1].lambda * b5[1];
  return -n5 / l6;
}
function perpendicularFoot(point, line) {
  var a6 = line[0], b5 = line[1];
  var bd = { x: b5.x - a6.x, y: b5.y - a6.y };
  var r6 = solveLambaSystem([a6.x, a6.y], [bd.x, bd.y], [point.x, point.y]);
  return { x: a6.x + r6 * bd.x, y: a6.y + r6 * bd.y };
}
function getDistancePointLine(point, line) {
  var pfPoint = perpendicularFoot(point, line);
  var connectionVector = {
    x: pfPoint.x - point.x,
    y: pfPoint.y - point.y
  };
  return vectorLength(connectionVector);
}
function getDistancePointPoint(point1, point2) {
  return vectorLength({
    x: point1.x - point2.x,
    y: point1.y - point2.y
  });
}

// node_modules/diagram-js/lib/features/bendpoints/BendpointUtil.js
var BENDPOINT_CLS = "djs-bendpoint";
var SEGMENT_DRAGGER_CLS = "djs-segment-dragger";
function toCanvasCoordinates(canvas, event2) {
  var position = toPoint(event2), clientRect = canvas._container.getBoundingClientRect(), offset;
  offset = {
    x: clientRect.left,
    y: clientRect.top
  };
  var viewbox = canvas.viewbox();
  return {
    x: viewbox.x + (position.x - offset.x) / viewbox.scale,
    y: viewbox.y + (position.y - offset.y) / viewbox.scale
  };
}
function getConnectionIntersection(canvas, waypoints, event2) {
  var localPosition = toCanvasCoordinates(canvas, event2), intersection2 = getApproxIntersection(waypoints, localPosition);
  return intersection2;
}
function addBendpoint(parentGfx, cls) {
  var groupGfx = create("g");
  classes(groupGfx).add(BENDPOINT_CLS);
  append(parentGfx, groupGfx);
  var visual = create("circle");
  attr(visual, {
    cx: 0,
    cy: 0,
    r: 4
  });
  classes(visual).add("djs-visual");
  append(groupGfx, visual);
  var hit = create("circle");
  attr(hit, {
    cx: 0,
    cy: 0,
    r: 10
  });
  classes(hit).add("djs-hit");
  append(groupGfx, hit);
  if (cls) {
    classes(groupGfx).add(cls);
  }
  return groupGfx;
}
function createParallelDragger(parentGfx, segmentStart, segmentEnd, alignment) {
  var draggerGfx = create("g");
  append(parentGfx, draggerGfx);
  var width = 18, height = 6, padding = 11, hitWidth = calculateHitWidth(segmentStart, segmentEnd, alignment), hitHeight = height + padding;
  var visual = create("rect");
  attr(visual, {
    x: -width / 2,
    y: -height / 2,
    width,
    height
  });
  classes(visual).add("djs-visual");
  append(draggerGfx, visual);
  var hit = create("rect");
  attr(hit, {
    x: -hitWidth / 2,
    y: -hitHeight / 2,
    width: hitWidth,
    height: hitHeight
  });
  classes(hit).add("djs-hit");
  append(draggerGfx, hit);
  rotate(draggerGfx, alignment === "v" ? 90 : 0, 0, 0);
  return draggerGfx;
}
function addSegmentDragger(parentGfx, segmentStart, segmentEnd) {
  var groupGfx = create("g"), mid4 = getMidPoint(segmentStart, segmentEnd), alignment = pointsAligned(segmentStart, segmentEnd);
  append(parentGfx, groupGfx);
  createParallelDragger(groupGfx, segmentStart, segmentEnd, alignment);
  classes(groupGfx).add(SEGMENT_DRAGGER_CLS);
  classes(groupGfx).add(alignment === "h" ? "horizontal" : "vertical");
  translate(groupGfx, mid4.x, mid4.y);
  return groupGfx;
}
function calculateSegmentMoveRegion(segmentLength) {
  return Math.abs(Math.round(segmentLength * 2 / 3));
}
function getClosestPointOnConnection(position, connection) {
  var segment = getClosestSegment(position, connection);
  return perpendicularFoot(position, segment);
}
function calculateHitWidth(segmentStart, segmentEnd, alignment) {
  var segmentLengthXAxis = segmentEnd.x - segmentStart.x, segmentLengthYAxis = segmentEnd.y - segmentStart.y;
  return alignment === "h" ? calculateSegmentMoveRegion(segmentLengthXAxis) : calculateSegmentMoveRegion(segmentLengthYAxis);
}
function getClosestSegment(position, connection) {
  var waypoints = connection.waypoints;
  var minDistance = Infinity, segmentIndex;
  for (var i6 = 0; i6 < waypoints.length - 1; i6++) {
    var start = waypoints[i6], end = waypoints[i6 + 1], distance2 = getDistancePointLine(position, [start, end]);
    if (distance2 < minDistance) {
      minDistance = distance2;
      segmentIndex = i6;
    }
  }
  return [waypoints[segmentIndex], waypoints[segmentIndex + 1]];
}

// node_modules/diagram-js/lib/features/bendpoints/Bendpoints.js
function Bendpoints(eventBus, canvas, interactionEvents, bendpointMove, connectionSegmentMove) {
  function isIntersectionMiddle(intersection2, waypoints, treshold) {
    var idx = intersection2.index, p6 = intersection2.point, p0, p1, mid4, aligned, xDelta, yDelta;
    if (idx <= 0 || intersection2.bendpoint) {
      return false;
    }
    p0 = waypoints[idx - 1];
    p1 = waypoints[idx];
    mid4 = getMidPoint(p0, p1), aligned = pointsAligned(p0, p1);
    xDelta = Math.abs(p6.x - mid4.x);
    yDelta = Math.abs(p6.y - mid4.y);
    return aligned && xDelta <= treshold && yDelta <= treshold;
  }
  function calculateIntersectionThreshold(connection, intersection2) {
    var waypoints = connection.waypoints, relevantSegment, alignment, segmentLength, threshold;
    if (intersection2.index <= 0 || intersection2.bendpoint) {
      return null;
    }
    relevantSegment = {
      start: waypoints[intersection2.index - 1],
      end: waypoints[intersection2.index]
    };
    alignment = pointsAligned(relevantSegment.start, relevantSegment.end);
    if (!alignment) {
      return null;
    }
    if (alignment === "h") {
      segmentLength = relevantSegment.end.x - relevantSegment.start.x;
    } else {
      segmentLength = relevantSegment.end.y - relevantSegment.start.y;
    }
    threshold = calculateSegmentMoveRegion(segmentLength) / 2;
    return threshold;
  }
  function activateBendpointMove(event2, connection) {
    var waypoints = connection.waypoints, intersection2 = getConnectionIntersection(canvas, waypoints, event2), threshold;
    if (!intersection2) {
      return;
    }
    threshold = calculateIntersectionThreshold(connection, intersection2);
    if (isIntersectionMiddle(intersection2, waypoints, threshold)) {
      connectionSegmentMove.start(event2, connection, intersection2.index);
    } else {
      bendpointMove.start(event2, connection, intersection2.index, !intersection2.bendpoint);
    }
    return true;
  }
  function bindInteractionEvents(node2, eventName, element) {
    event.bind(node2, eventName, function(event2) {
      interactionEvents.triggerMouseEvent(eventName, event2, element);
      event2.stopPropagation();
    });
  }
  function getBendpointsContainer(element, create3) {
    var layer = canvas.getLayer("overlays"), gfx = query('.djs-bendpoints[data-element-id="' + (0, import_css.default)(element.id) + '"]', layer);
    if (!gfx && create3) {
      gfx = create("g");
      attr(gfx, { "data-element-id": element.id });
      classes(gfx).add("djs-bendpoints");
      append(layer, gfx);
      bindInteractionEvents(gfx, "mousedown", element);
      bindInteractionEvents(gfx, "click", element);
      bindInteractionEvents(gfx, "dblclick", element);
    }
    return gfx;
  }
  function getSegmentDragger(idx, parentGfx) {
    return query('.djs-segment-dragger[data-segment-idx="' + idx + '"]', parentGfx);
  }
  function createBendpoints(gfx, connection) {
    connection.waypoints.forEach(function(p6, idx) {
      var bendpoint = addBendpoint(gfx);
      append(gfx, bendpoint);
      translate(bendpoint, p6.x, p6.y);
    });
    addBendpoint(gfx, "floating");
  }
  function createSegmentDraggers(gfx, connection) {
    var waypoints = connection.waypoints;
    var segmentStart, segmentEnd, segmentDraggerGfx;
    for (var i6 = 1; i6 < waypoints.length; i6++) {
      segmentStart = waypoints[i6 - 1];
      segmentEnd = waypoints[i6];
      if (pointsAligned(segmentStart, segmentEnd)) {
        segmentDraggerGfx = addSegmentDragger(gfx, segmentStart, segmentEnd);
        attr(segmentDraggerGfx, { "data-segment-idx": i6 });
        bindInteractionEvents(segmentDraggerGfx, "mousemove", connection);
      }
    }
  }
  function clearBendpoints(gfx) {
    (0, import_min_dash51.forEach)(all("." + BENDPOINT_CLS, gfx), function(node2) {
      remove(node2);
    });
  }
  function clearSegmentDraggers(gfx) {
    (0, import_min_dash51.forEach)(all("." + SEGMENT_DRAGGER_CLS, gfx), function(node2) {
      remove(node2);
    });
  }
  function addHandles(connection) {
    var gfx = getBendpointsContainer(connection);
    if (!gfx) {
      gfx = getBendpointsContainer(connection, true);
      createBendpoints(gfx, connection);
      createSegmentDraggers(gfx, connection);
    }
    return gfx;
  }
  function updateHandles(connection) {
    var gfx = getBendpointsContainer(connection);
    if (gfx) {
      clearSegmentDraggers(gfx);
      clearBendpoints(gfx);
      createSegmentDraggers(gfx, connection);
      createBendpoints(gfx, connection);
    }
  }
  function updateFloatingBendpointPosition(parentGfx, intersection2) {
    var floating = query(".floating", parentGfx), point = intersection2.point;
    if (!floating) {
      return;
    }
    translate(floating, point.x, point.y);
  }
  function updateSegmentDraggerPosition(parentGfx, intersection2, waypoints) {
    var draggerGfx = getSegmentDragger(intersection2.index, parentGfx), segmentStart = waypoints[intersection2.index - 1], segmentEnd = waypoints[intersection2.index], point = intersection2.point, mid4 = getMidPoint(segmentStart, segmentEnd), alignment = pointsAligned(segmentStart, segmentEnd), draggerVisual, relativePosition;
    if (!draggerGfx) {
      return;
    }
    draggerVisual = getDraggerVisual(draggerGfx);
    relativePosition = {
      x: point.x - mid4.x,
      y: point.y - mid4.y
    };
    if (alignment === "v") {
      relativePosition = {
        x: relativePosition.y,
        y: relativePosition.x
      };
    }
    translate(draggerVisual, relativePosition.x, relativePosition.y);
  }
  eventBus.on("connection.changed", function(event2) {
    updateHandles(event2.element);
  });
  eventBus.on("connection.remove", function(event2) {
    var gfx = getBendpointsContainer(event2.element);
    if (gfx) {
      remove(gfx);
    }
  });
  eventBus.on("element.marker.update", function(event2) {
    var element = event2.element, bendpointsGfx;
    if (!element.waypoints) {
      return;
    }
    bendpointsGfx = addHandles(element);
    if (event2.add) {
      classes(bendpointsGfx).add(event2.marker);
    } else {
      classes(bendpointsGfx).remove(event2.marker);
    }
  });
  eventBus.on("element.mousemove", function(event2) {
    var element = event2.element, waypoints = element.waypoints, bendpointsGfx, intersection2;
    if (waypoints) {
      bendpointsGfx = getBendpointsContainer(element, true);
      intersection2 = getConnectionIntersection(canvas, waypoints, event2.originalEvent);
      if (!intersection2) {
        return;
      }
      updateFloatingBendpointPosition(bendpointsGfx, intersection2);
      if (!intersection2.bendpoint) {
        updateSegmentDraggerPosition(bendpointsGfx, intersection2, waypoints);
      }
    }
  });
  eventBus.on("element.mousedown", function(event2) {
    if (!isPrimaryButton(event2)) {
      return;
    }
    var originalEvent = event2.originalEvent, element = event2.element;
    if (!element.waypoints) {
      return;
    }
    return activateBendpointMove(originalEvent, element);
  });
  eventBus.on("selection.changed", function(event2) {
    var newSelection = event2.newSelection, primary = newSelection[0];
    if (primary && primary.waypoints) {
      addHandles(primary);
    }
  });
  eventBus.on("element.hover", function(event2) {
    var element = event2.element;
    if (element.waypoints) {
      addHandles(element);
      interactionEvents.registerEvent(event2.gfx, "mousemove", "element.mousemove");
    }
  });
  eventBus.on("element.out", function(event2) {
    interactionEvents.unregisterEvent(event2.gfx, "mousemove", "element.mousemove");
  });
  eventBus.on("element.updateId", function(context) {
    var element = context.element, newId = context.newId;
    if (element.waypoints) {
      var bendpointContainer = getBendpointsContainer(element);
      if (bendpointContainer) {
        attr(bendpointContainer, { "data-element-id": newId });
      }
    }
  });
  this.addHandles = addHandles;
  this.updateHandles = updateHandles;
  this.getBendpointsContainer = getBendpointsContainer;
  this.getSegmentDragger = getSegmentDragger;
}
Bendpoints.$inject = [
  "eventBus",
  "canvas",
  "interactionEvents",
  "bendpointMove",
  "connectionSegmentMove"
];
function getDraggerVisual(draggerGfx) {
  return query(".djs-visual", draggerGfx);
}

// node_modules/diagram-js/lib/features/bendpoints/BendpointMove.js
var round4 = Math.round;
var RECONNECT_START = "reconnectStart";
var RECONNECT_END = "reconnectEnd";
var UPDATE_WAYPOINTS = "updateWaypoints";
function BendpointMove(injector, eventBus, canvas, dragging, rules, modeling) {
  this._injector = injector;
  this.start = function(event2, connection, bendpointIndex, insert) {
    var gfx = canvas.getGraphics(connection), source = connection.source, target = connection.target, waypoints = connection.waypoints, type;
    if (!insert && bendpointIndex === 0) {
      type = RECONNECT_START;
    } else if (!insert && bendpointIndex === waypoints.length - 1) {
      type = RECONNECT_END;
    } else {
      type = UPDATE_WAYPOINTS;
    }
    var command = type === UPDATE_WAYPOINTS ? "connection.updateWaypoints" : "connection.reconnect";
    var allowed = rules.allowed(command, {
      connection,
      source,
      target
    });
    if (allowed === false) {
      allowed = rules.allowed(command, {
        connection,
        source: target,
        target: source
      });
    }
    if (allowed === false) {
      return;
    }
    dragging.init(event2, "bendpoint.move", {
      data: {
        connection,
        connectionGfx: gfx,
        context: {
          allowed,
          bendpointIndex,
          connection,
          source,
          target,
          insert,
          type
        }
      }
    });
  };
  eventBus.on("bendpoint.move.hover", function(event2) {
    var context = event2.context, connection = context.connection, source = connection.source, target = connection.target, hover = event2.hover, type = context.type;
    context.hover = hover;
    var allowed;
    if (!hover) {
      return;
    }
    var command = type === UPDATE_WAYPOINTS ? "connection.updateWaypoints" : "connection.reconnect";
    allowed = context.allowed = rules.allowed(command, {
      connection,
      source: type === RECONNECT_START ? hover : source,
      target: type === RECONNECT_END ? hover : target
    });
    if (allowed) {
      context.source = type === RECONNECT_START ? hover : source;
      context.target = type === RECONNECT_END ? hover : target;
      return;
    }
    if (allowed === false) {
      allowed = context.allowed = rules.allowed(command, {
        connection,
        source: type === RECONNECT_END ? hover : target,
        target: type === RECONNECT_START ? hover : source
      });
    }
    if (allowed) {
      context.source = type === RECONNECT_END ? hover : target;
      context.target = type === RECONNECT_START ? hover : source;
    }
  });
  eventBus.on(["bendpoint.move.out", "bendpoint.move.cleanup"], function(event2) {
    var context = event2.context, type = context.type;
    context.hover = null;
    context.source = null;
    context.target = null;
    if (type !== UPDATE_WAYPOINTS) {
      context.allowed = false;
    }
  });
  eventBus.on("bendpoint.move.end", function(event2) {
    var context = event2.context, allowed = context.allowed, bendpointIndex = context.bendpointIndex, connection = context.connection, insert = context.insert, newWaypoints = connection.waypoints.slice(), source = context.source, target = context.target, type = context.type, hints = context.hints || {};
    var docking = {
      x: round4(event2.x),
      y: round4(event2.y)
    };
    if (!allowed) {
      return false;
    }
    if (type === UPDATE_WAYPOINTS) {
      if (insert) {
        newWaypoints.splice(bendpointIndex, 0, docking);
      } else {
        newWaypoints[bendpointIndex] = docking;
      }
      hints.bendpointMove = {
        insert,
        bendpointIndex
      };
      newWaypoints = this.cropWaypoints(connection, newWaypoints);
      modeling.updateWaypoints(connection, filterRedundantWaypoints(newWaypoints), hints);
    } else {
      if (type === RECONNECT_START) {
        hints.docking = "source";
        if (isReverse(context)) {
          hints.docking = "target";
          hints.newWaypoints = newWaypoints.reverse();
        }
      } else if (type === RECONNECT_END) {
        hints.docking = "target";
        if (isReverse(context)) {
          hints.docking = "source";
          hints.newWaypoints = newWaypoints.reverse();
        }
      }
      modeling.reconnect(connection, source, target, docking, hints);
    }
  }, this);
}
BendpointMove.$inject = [
  "injector",
  "eventBus",
  "canvas",
  "dragging",
  "rules",
  "modeling"
];
BendpointMove.prototype.cropWaypoints = function(connection, newWaypoints) {
  var connectionDocking = this._injector.get("connectionDocking", false);
  if (!connectionDocking) {
    return newWaypoints;
  }
  var waypoints = connection.waypoints;
  connection.waypoints = newWaypoints;
  connection.waypoints = connectionDocking.getCroppedWaypoints(connection);
  newWaypoints = connection.waypoints;
  connection.waypoints = waypoints;
  return newWaypoints;
};
function isReverse(context) {
  var hover = context.hover, source = context.source, target = context.target, type = context.type;
  if (type === RECONNECT_START) {
    return hover && target && hover === target && source !== target;
  }
  if (type === RECONNECT_END) {
    return hover && source && hover === source && source !== target;
  }
}

// node_modules/diagram-js/lib/features/bendpoints/BendpointMovePreview.js
var RECONNECT_START2 = "reconnectStart";
var RECONNECT_END2 = "reconnectEnd";
var UPDATE_WAYPOINTS2 = "updateWaypoints";
var MARKER_OK = "connect-ok";
var MARKER_NOT_OK = "connect-not-ok";
var MARKER_CONNECT_HOVER = "connect-hover";
var MARKER_CONNECT_UPDATING = "djs-updating";
var MARKER_ELEMENT_HIDDEN = "djs-element-hidden";
var HIGH_PRIORITY2 = 1100;
function BendpointMovePreview(bendpointMove, injector, eventBus, canvas) {
  this._injector = injector;
  var connectionPreview = injector.get("connectionPreview", false);
  eventBus.on("bendpoint.move.start", function(event2) {
    var context = event2.context, bendpointIndex = context.bendpointIndex, connection = context.connection, insert = context.insert, waypoints = connection.waypoints, newWaypoints = waypoints.slice();
    context.waypoints = waypoints;
    if (insert) {
      newWaypoints.splice(bendpointIndex, 0, { x: event2.x, y: event2.y });
    }
    connection.waypoints = newWaypoints;
    var draggerGfx = context.draggerGfx = addBendpoint(canvas.getLayer("overlays"));
    classes(draggerGfx).add("djs-dragging");
    canvas.addMarker(connection, MARKER_ELEMENT_HIDDEN);
    canvas.addMarker(connection, MARKER_CONNECT_UPDATING);
  });
  eventBus.on("bendpoint.move.hover", function(event2) {
    var context = event2.context, allowed = context.allowed, hover = context.hover, type = context.type;
    if (hover) {
      canvas.addMarker(hover, MARKER_CONNECT_HOVER);
      if (type === UPDATE_WAYPOINTS2) {
        return;
      }
      if (allowed) {
        canvas.removeMarker(hover, MARKER_NOT_OK);
        canvas.addMarker(hover, MARKER_OK);
      } else if (allowed === false) {
        canvas.removeMarker(hover, MARKER_OK);
        canvas.addMarker(hover, MARKER_NOT_OK);
      }
    }
  });
  eventBus.on([
    "bendpoint.move.out",
    "bendpoint.move.cleanup"
  ], HIGH_PRIORITY2, function(event2) {
    var context = event2.context, hover = context.hover, target = context.target;
    if (hover) {
      canvas.removeMarker(hover, MARKER_CONNECT_HOVER);
      canvas.removeMarker(hover, target ? MARKER_OK : MARKER_NOT_OK);
    }
  });
  eventBus.on("bendpoint.move.move", function(event2) {
    var context = event2.context, allowed = context.allowed, bendpointIndex = context.bendpointIndex, draggerGfx = context.draggerGfx, hover = context.hover, type = context.type, connection = context.connection, source = connection.source, target = connection.target, newWaypoints = connection.waypoints.slice(), bendpoint = { x: event2.x, y: event2.y }, hints = context.hints || {}, drawPreviewHints = {};
    if (connectionPreview) {
      if (hints.connectionStart) {
        drawPreviewHints.connectionStart = hints.connectionStart;
      }
      if (hints.connectionEnd) {
        drawPreviewHints.connectionEnd = hints.connectionEnd;
      }
      if (type === RECONNECT_START2) {
        if (isReverse(context)) {
          drawPreviewHints.connectionEnd = drawPreviewHints.connectionEnd || bendpoint;
          drawPreviewHints.source = target;
          drawPreviewHints.target = hover || source;
          newWaypoints = newWaypoints.reverse();
        } else {
          drawPreviewHints.connectionStart = drawPreviewHints.connectionStart || bendpoint;
          drawPreviewHints.source = hover || source;
          drawPreviewHints.target = target;
        }
      } else if (type === RECONNECT_END2) {
        if (isReverse(context)) {
          drawPreviewHints.connectionStart = drawPreviewHints.connectionStart || bendpoint;
          drawPreviewHints.source = hover || target;
          drawPreviewHints.target = source;
          newWaypoints = newWaypoints.reverse();
        } else {
          drawPreviewHints.connectionEnd = drawPreviewHints.connectionEnd || bendpoint;
          drawPreviewHints.source = source;
          drawPreviewHints.target = hover || target;
        }
      } else {
        drawPreviewHints.noCropping = true;
        drawPreviewHints.noLayout = true;
        newWaypoints[bendpointIndex] = bendpoint;
      }
      if (type === UPDATE_WAYPOINTS2) {
        newWaypoints = bendpointMove.cropWaypoints(connection, newWaypoints);
      }
      drawPreviewHints.waypoints = newWaypoints;
      connectionPreview.drawPreview(context, allowed, drawPreviewHints);
    }
    translate(draggerGfx, event2.x, event2.y);
  }, this);
  eventBus.on([
    "bendpoint.move.end",
    "bendpoint.move.cancel"
  ], HIGH_PRIORITY2, function(event2) {
    var context = event2.context, connection = context.connection, draggerGfx = context.draggerGfx, hover = context.hover, target = context.target, waypoints = context.waypoints;
    connection.waypoints = waypoints;
    remove(draggerGfx);
    canvas.removeMarker(connection, MARKER_CONNECT_UPDATING);
    canvas.removeMarker(connection, MARKER_ELEMENT_HIDDEN);
    if (hover) {
      canvas.removeMarker(hover, MARKER_OK);
      canvas.removeMarker(hover, target ? MARKER_OK : MARKER_NOT_OK);
    }
    if (connectionPreview) {
      connectionPreview.cleanUp(context);
    }
  });
}
BendpointMovePreview.$inject = [
  "bendpointMove",
  "injector",
  "eventBus",
  "canvas"
];

// node_modules/diagram-js/lib/features/bendpoints/ConnectionSegmentMove.js
var MARKER_CONNECT_HOVER2 = "connect-hover";
var MARKER_CONNECT_UPDATING2 = "djs-updating";
function axisAdd(point, axis, delta2) {
  return axisSet(point, axis, point[axis] + delta2);
}
function axisSet(point, axis, value) {
  return {
    x: axis === "x" ? value : point.x,
    y: axis === "y" ? value : point.y
  };
}
function axisFenced(position, segmentStart, segmentEnd, axis) {
  var maxValue = Math.max(segmentStart[axis], segmentEnd[axis]), minValue = Math.min(segmentStart[axis], segmentEnd[axis]);
  var padding = 20;
  var fencedValue = Math.min(Math.max(minValue + padding, position[axis]), maxValue - padding);
  return axisSet(segmentStart, axis, fencedValue);
}
function flipAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getDocking(point, referenceElement, moveAxis) {
  var referenceMid, inverseAxis;
  if (point.original) {
    return point.original;
  } else {
    referenceMid = getMid(referenceElement);
    inverseAxis = flipAxis(moveAxis);
    return axisSet(point, inverseAxis, referenceMid[inverseAxis]);
  }
}
function ConnectionSegmentMove(injector, eventBus, canvas, dragging, graphicsFactory, modeling) {
  var connectionDocking = injector.get("connectionDocking", false);
  this.start = function(event2, connection, idx) {
    var context, gfx = canvas.getGraphics(connection), segmentStartIndex = idx - 1, segmentEndIndex = idx, waypoints = connection.waypoints, segmentStart = waypoints[segmentStartIndex], segmentEnd = waypoints[segmentEndIndex], intersection2 = getConnectionIntersection(canvas, waypoints, event2), direction, axis, dragPosition;
    direction = pointsAligned(segmentStart, segmentEnd);
    if (!direction) {
      return;
    }
    axis = direction === "v" ? "x" : "y";
    if (segmentStartIndex === 0) {
      segmentStart = getDocking(segmentStart, connection.source, axis);
    }
    if (segmentEndIndex === waypoints.length - 1) {
      segmentEnd = getDocking(segmentEnd, connection.target, axis);
    }
    if (intersection2) {
      dragPosition = intersection2.point;
    } else {
      dragPosition = {
        x: (segmentStart.x + segmentEnd.x) / 2,
        y: (segmentStart.y + segmentEnd.y) / 2
      };
    }
    context = {
      connection,
      segmentStartIndex,
      segmentEndIndex,
      segmentStart,
      segmentEnd,
      axis,
      dragPosition
    };
    dragging.init(event2, dragPosition, "connectionSegment.move", {
      cursor: axis === "x" ? "resize-ew" : "resize-ns",
      data: {
        connection,
        connectionGfx: gfx,
        context
      }
    });
  };
  function cropConnection(connection, newWaypoints) {
    if (!connectionDocking) {
      return newWaypoints;
    }
    var oldWaypoints = connection.waypoints, croppedWaypoints;
    connection.waypoints = newWaypoints;
    croppedWaypoints = connectionDocking.getCroppedWaypoints(connection);
    connection.waypoints = oldWaypoints;
    return croppedWaypoints;
  }
  function redrawConnection(data) {
    graphicsFactory.update("connection", data.connection, data.connectionGfx);
  }
  function updateDragger(context, segmentOffset, event2) {
    var newWaypoints = context.newWaypoints, segmentStartIndex = context.segmentStartIndex + segmentOffset, segmentStart = newWaypoints[segmentStartIndex], segmentEndIndex = context.segmentEndIndex + segmentOffset, segmentEnd = newWaypoints[segmentEndIndex], axis = flipAxis(context.axis);
    var draggerPosition = axisFenced(event2, segmentStart, segmentEnd, axis);
    translate(context.draggerGfx, draggerPosition.x, draggerPosition.y);
  }
  function filterRedundantWaypoints2(waypoints, segmentStartIndex) {
    var segmentOffset = 0;
    var filteredWaypoints = waypoints.filter(function(r6, idx) {
      if (pointsOnLine(waypoints[idx - 1], waypoints[idx + 1], r6)) {
        segmentOffset = idx <= segmentStartIndex ? segmentOffset - 1 : segmentOffset;
        return false;
      }
      return true;
    });
    return {
      waypoints: filteredWaypoints,
      segmentOffset
    };
  }
  eventBus.on("connectionSegment.move.start", function(event2) {
    var context = event2.context, connection = event2.connection, layer = canvas.getLayer("overlays");
    context.originalWaypoints = connection.waypoints.slice();
    context.draggerGfx = addSegmentDragger(layer, context.segmentStart, context.segmentEnd);
    classes(context.draggerGfx).add("djs-dragging");
    canvas.addMarker(connection, MARKER_CONNECT_UPDATING2);
  });
  eventBus.on("connectionSegment.move.move", function(event2) {
    var context = event2.context, connection = context.connection, segmentStartIndex = context.segmentStartIndex, segmentEndIndex = context.segmentEndIndex, segmentStart = context.segmentStart, segmentEnd = context.segmentEnd, axis = context.axis;
    var newWaypoints = context.originalWaypoints.slice(), newSegmentStart = axisAdd(segmentStart, axis, event2["d" + axis]), newSegmentEnd = axisAdd(segmentEnd, axis, event2["d" + axis]);
    var waypointCount = newWaypoints.length, segmentOffset = 0;
    newWaypoints[segmentStartIndex] = newSegmentStart;
    newWaypoints[segmentEndIndex] = newSegmentEnd;
    var sourceToSegmentOrientation, targetToSegmentOrientation;
    if (segmentStartIndex < 2) {
      sourceToSegmentOrientation = getOrientation(connection.source, newSegmentStart);
      if (segmentStartIndex === 1) {
        if (sourceToSegmentOrientation === "intersect") {
          newWaypoints.shift();
          newWaypoints[0] = newSegmentStart;
          segmentOffset--;
        }
      } else {
        if (sourceToSegmentOrientation !== "intersect") {
          newWaypoints.unshift(segmentStart);
          segmentOffset++;
        }
      }
    }
    if (segmentEndIndex > waypointCount - 3) {
      targetToSegmentOrientation = getOrientation(connection.target, newSegmentEnd);
      if (segmentEndIndex === waypointCount - 2) {
        if (targetToSegmentOrientation === "intersect") {
          newWaypoints.pop();
          newWaypoints[newWaypoints.length - 1] = newSegmentEnd;
        }
      } else {
        if (targetToSegmentOrientation !== "intersect") {
          newWaypoints.push(segmentEnd);
        }
      }
    }
    context.newWaypoints = connection.waypoints = cropConnection(connection, newWaypoints);
    updateDragger(context, segmentOffset, event2);
    context.newSegmentStartIndex = segmentStartIndex + segmentOffset;
    redrawConnection(event2);
  });
  eventBus.on("connectionSegment.move.hover", function(event2) {
    event2.context.hover = event2.hover;
    canvas.addMarker(event2.hover, MARKER_CONNECT_HOVER2);
  });
  eventBus.on([
    "connectionSegment.move.out",
    "connectionSegment.move.cleanup"
  ], function(event2) {
    var hover = event2.context.hover;
    if (hover) {
      canvas.removeMarker(hover, MARKER_CONNECT_HOVER2);
    }
  });
  eventBus.on("connectionSegment.move.cleanup", function(event2) {
    var context = event2.context, connection = context.connection;
    if (context.draggerGfx) {
      remove(context.draggerGfx);
    }
    canvas.removeMarker(connection, MARKER_CONNECT_UPDATING2);
  });
  eventBus.on([
    "connectionSegment.move.cancel",
    "connectionSegment.move.end"
  ], function(event2) {
    var context = event2.context, connection = context.connection;
    connection.waypoints = context.originalWaypoints;
    redrawConnection(event2);
  });
  eventBus.on("connectionSegment.move.end", function(event2) {
    var context = event2.context, connection = context.connection, newWaypoints = context.newWaypoints, newSegmentStartIndex = context.newSegmentStartIndex;
    newWaypoints = newWaypoints.map(function(p6) {
      return {
        original: p6.original,
        x: Math.round(p6.x),
        y: Math.round(p6.y)
      };
    });
    var filtered = filterRedundantWaypoints2(newWaypoints, newSegmentStartIndex);
    var filteredWaypoints = filtered.waypoints, croppedWaypoints = cropConnection(connection, filteredWaypoints), segmentOffset = filtered.segmentOffset;
    var hints = {
      segmentMove: {
        segmentStartIndex: context.segmentStartIndex,
        newSegmentStartIndex: newSegmentStartIndex + segmentOffset
      }
    };
    modeling.updateWaypoints(connection, croppedWaypoints, hints);
  });
}
ConnectionSegmentMove.$inject = [
  "injector",
  "eventBus",
  "canvas",
  "dragging",
  "graphicsFactory",
  "modeling"
];

// node_modules/diagram-js/lib/features/bendpoints/BendpointSnapping.js
var import_min_dash52 = __toESM(require_dist());

// node_modules/diagram-js/lib/features/snapping/SnapUtil.js
var abs = Math.abs;
var round5 = Math.round;
function snapTo(value, values5, tolerance) {
  tolerance = tolerance === void 0 ? 10 : tolerance;
  var idx, snapValue;
  for (idx = 0; idx < values5.length; idx++) {
    snapValue = values5[idx];
    if (abs(snapValue - value) <= tolerance) {
      return snapValue;
    }
  }
}
function topLeft(bounds) {
  return {
    x: bounds.x,
    y: bounds.y
  };
}
function bottomRight(bounds) {
  return {
    x: bounds.x + bounds.width,
    y: bounds.y + bounds.height
  };
}
function mid(bounds, defaultValue) {
  if (!bounds || isNaN(bounds.x) || isNaN(bounds.y)) {
    return defaultValue;
  }
  return {
    x: round5(bounds.x + bounds.width / 2),
    y: round5(bounds.y + bounds.height / 2)
  };
}
function isSnapped(event2, axis) {
  var snapped = event2.snapped;
  if (!snapped) {
    return false;
  }
  if (typeof axis === "string") {
    return snapped[axis];
  }
  return snapped.x && snapped.y;
}
function setSnapped(event2, axis, value) {
  if (typeof axis !== "string") {
    throw new Error("axis must be in [x, y]");
  }
  if (typeof value !== "number" && value !== false) {
    throw new Error("value must be Number or false");
  }
  var delta2, previousValue = event2[axis];
  var snapped = event2.snapped = event2.snapped || {};
  if (value === false) {
    snapped[axis] = false;
  } else {
    snapped[axis] = true;
    delta2 = value - previousValue;
    event2[axis] += delta2;
    event2["d" + axis] += delta2;
  }
  return previousValue;
}
function getChildren2(parent) {
  return parent.children || [];
}

// node_modules/diagram-js/lib/features/bendpoints/BendpointSnapping.js
var abs2 = Math.abs;
var round6 = Math.round;
var TOLERANCE = 10;
function BendpointSnapping(eventBus) {
  function snapTo2(values5, value) {
    if ((0, import_min_dash52.isArray)(values5)) {
      var i6 = values5.length;
      while (i6--)
        if (abs2(values5[i6] - value) <= TOLERANCE) {
          return values5[i6];
        }
    } else {
      values5 = +values5;
      var rem = value % values5;
      if (rem < TOLERANCE) {
        return value - rem;
      }
      if (rem > values5 - TOLERANCE) {
        return value - rem + values5;
      }
    }
    return value;
  }
  function getSnapPoint(element, event2) {
    if (element.waypoints) {
      return getClosestPointOnConnection(event2, element);
    }
    if (element.width) {
      return {
        x: round6(element.width / 2 + element.x),
        y: round6(element.height / 2 + element.y)
      };
    }
  }
  function getConnectionSegmentSnaps(event2) {
    var context = event2.context, snapPoints = context.snapPoints, connection = context.connection, waypoints = connection.waypoints, segmentStart = context.segmentStart, segmentStartIndex = context.segmentStartIndex, segmentEnd = context.segmentEnd, segmentEndIndex = context.segmentEndIndex, axis = context.axis;
    if (snapPoints) {
      return snapPoints;
    }
    var referenceWaypoints = [
      waypoints[segmentStartIndex - 1],
      segmentStart,
      segmentEnd,
      waypoints[segmentEndIndex + 1]
    ];
    if (segmentStartIndex < 2) {
      referenceWaypoints.unshift(getSnapPoint(connection.source, event2));
    }
    if (segmentEndIndex > waypoints.length - 3) {
      referenceWaypoints.unshift(getSnapPoint(connection.target, event2));
    }
    context.snapPoints = snapPoints = { horizontal: [], vertical: [] };
    (0, import_min_dash52.forEach)(referenceWaypoints, function(p6) {
      if (p6) {
        p6 = p6.original || p6;
        if (axis === "y") {
          snapPoints.horizontal.push(p6.y);
        }
        if (axis === "x") {
          snapPoints.vertical.push(p6.x);
        }
      }
    });
    return snapPoints;
  }
  eventBus.on("connectionSegment.move.move", 1500, function(event2) {
    var snapPoints = getConnectionSegmentSnaps(event2), x4 = event2.x, y4 = event2.y, sx, sy;
    if (!snapPoints) {
      return;
    }
    sx = snapTo2(snapPoints.vertical, x4);
    sy = snapTo2(snapPoints.horizontal, y4);
    var cx = x4 - sx, cy = y4 - sy;
    (0, import_min_dash52.assign)(event2, {
      dx: event2.dx - cx,
      dy: event2.dy - cy,
      x: sx,
      y: sy
    });
    if (cx || snapPoints.vertical.indexOf(x4) !== -1) {
      setSnapped(event2, "x", sx);
    }
    if (cy || snapPoints.horizontal.indexOf(y4) !== -1) {
      setSnapped(event2, "y", sy);
    }
  });
  function getBendpointSnaps(context) {
    var snapPoints = context.snapPoints, waypoints = context.connection.waypoints, bendpointIndex = context.bendpointIndex;
    if (snapPoints) {
      return snapPoints;
    }
    var referenceWaypoints = [waypoints[bendpointIndex - 1], waypoints[bendpointIndex + 1]];
    context.snapPoints = snapPoints = { horizontal: [], vertical: [] };
    (0, import_min_dash52.forEach)(referenceWaypoints, function(p6) {
      if (p6) {
        p6 = p6.original || p6;
        snapPoints.horizontal.push(p6.y);
        snapPoints.vertical.push(p6.x);
      }
    });
    return snapPoints;
  }
  eventBus.on([
    "connect.hover",
    "connect.move",
    "connect.end"
  ], 1500, function(event2) {
    var context = event2.context, hover = context.hover, hoverMid = hover && getSnapPoint(hover, event2);
    if (!isConnection3(hover) || !hoverMid || !hoverMid.x || !hoverMid.y) {
      return;
    }
    setSnapped(event2, "x", hoverMid.x);
    setSnapped(event2, "y", hoverMid.y);
  });
  eventBus.on(["bendpoint.move.move", "bendpoint.move.end"], 1500, function(event2) {
    var context = event2.context, snapPoints = getBendpointSnaps(context), hover = context.hover, hoverMid = hover && getSnapPoint(hover, event2), x4 = event2.x, y4 = event2.y, sx, sy;
    if (!snapPoints) {
      return;
    }
    sx = snapTo2(hoverMid ? snapPoints.vertical.concat([hoverMid.x]) : snapPoints.vertical, x4);
    sy = snapTo2(hoverMid ? snapPoints.horizontal.concat([hoverMid.y]) : snapPoints.horizontal, y4);
    var cx = x4 - sx, cy = y4 - sy;
    (0, import_min_dash52.assign)(event2, {
      dx: event2.dx - cx,
      dy: event2.dy - cy,
      x: event2.x - cx,
      y: event2.y - cy
    });
    if (cx || snapPoints.vertical.indexOf(x4) !== -1) {
      setSnapped(event2, "x", sx);
    }
    if (cy || snapPoints.horizontal.indexOf(y4) !== -1) {
      setSnapped(event2, "y", sy);
    }
  });
}
BendpointSnapping.$inject = ["eventBus"];
function isConnection3(element) {
  return element && !!element.waypoints;
}

// node_modules/diagram-js/lib/features/bendpoints/index.js
var bendpoints_default = {
  __depends__: [
    dragging_default,
    rules_default
  ],
  __init__: ["bendpoints", "bendpointSnapping", "bendpointMovePreview"],
  bendpoints: ["type", Bendpoints],
  bendpointMove: ["type", BendpointMove],
  bendpointMovePreview: ["type", BendpointMovePreview],
  connectionSegmentMove: ["type", ConnectionSegmentMove],
  bendpointSnapping: ["type", BendpointSnapping]
};

// node_modules/diagram-js/lib/features/connect/Connect.js
var import_min_dash53 = __toESM(require_dist());
function Connect(eventBus, dragging, modeling, rules) {
  function canConnect2(source, target) {
    return rules.allowed("connection.create", {
      source,
      target
    });
  }
  function canConnectReverse(source, target) {
    return canConnect2(target, source);
  }
  eventBus.on("connect.hover", function(event2) {
    var context = event2.context, start = context.start, hover = event2.hover, canExecute;
    context.hover = hover;
    canExecute = context.canExecute = canConnect2(start, hover);
    if ((0, import_min_dash53.isNil)(canExecute)) {
      return;
    }
    if (canExecute !== false) {
      context.source = start;
      context.target = hover;
      return;
    }
    canExecute = context.canExecute = canConnectReverse(start, hover);
    if ((0, import_min_dash53.isNil)(canExecute)) {
      return;
    }
    if (canExecute !== false) {
      context.source = hover;
      context.target = start;
    }
  });
  eventBus.on(["connect.out", "connect.cleanup"], function(event2) {
    var context = event2.context;
    context.hover = null;
    context.source = null;
    context.target = null;
    context.canExecute = false;
  });
  eventBus.on("connect.end", function(event2) {
    var context = event2.context, canExecute = context.canExecute, connectionStart = context.connectionStart, connectionEnd = {
      x: event2.x,
      y: event2.y
    }, source = context.source, target = context.target;
    if (!canExecute) {
      return false;
    }
    var attrs = null, hints = {
      connectionStart: isReverse2(context) ? connectionEnd : connectionStart,
      connectionEnd: isReverse2(context) ? connectionStart : connectionEnd
    };
    if ((0, import_min_dash53.isObject)(canExecute)) {
      attrs = canExecute;
    }
    context.connection = modeling.connect(source, target, attrs, hints);
  });
  this.start = function(event2, start, connectionStart, autoActivate) {
    if (!(0, import_min_dash53.isObject)(connectionStart)) {
      autoActivate = connectionStart;
      connectionStart = getMid(start);
    }
    dragging.init(event2, "connect", {
      autoActivate,
      data: {
        shape: start,
        context: {
          start,
          connectionStart
        }
      }
    });
  };
}
Connect.$inject = [
  "eventBus",
  "dragging",
  "modeling",
  "rules"
];
function isReverse2(context) {
  var hover = context.hover, source = context.source, target = context.target;
  return hover && source && hover === source && source !== target;
}

// node_modules/diagram-js/lib/features/connect/ConnectPreview.js
var HIGH_PRIORITY3 = 1100;
var LOW_PRIORITY8 = 900;
var MARKER_OK2 = "connect-ok";
var MARKER_NOT_OK2 = "connect-not-ok";
function ConnectPreview(injector, eventBus, canvas) {
  var connectionPreview = injector.get("connectionPreview", false);
  connectionPreview && eventBus.on("connect.move", function(event2) {
    var context = event2.context, canConnect2 = context.canExecute, hover = context.hover, source = context.source, start = context.start, startPosition = context.startPosition, target = context.target, connectionStart = context.connectionStart || startPosition, connectionEnd = context.connectionEnd || {
      x: event2.x,
      y: event2.y
    }, previewStart = connectionStart, previewEnd = connectionEnd;
    if (isReverse2(context)) {
      previewStart = connectionEnd;
      previewEnd = connectionStart;
    }
    connectionPreview.drawPreview(context, canConnect2, {
      source: source || start,
      target: target || hover,
      connectionStart: previewStart,
      connectionEnd: previewEnd
    });
  });
  eventBus.on("connect.hover", LOW_PRIORITY8, function(event2) {
    var context = event2.context, hover = event2.hover, canExecute = context.canExecute;
    if (canExecute === null) {
      return;
    }
    canvas.addMarker(hover, canExecute ? MARKER_OK2 : MARKER_NOT_OK2);
  });
  eventBus.on([
    "connect.out",
    "connect.cleanup"
  ], HIGH_PRIORITY3, function(event2) {
    var hover = event2.hover;
    if (hover) {
      canvas.removeMarker(hover, MARKER_OK2);
      canvas.removeMarker(hover, MARKER_NOT_OK2);
    }
  });
  connectionPreview && eventBus.on("connect.cleanup", function(event2) {
    connectionPreview.cleanUp(event2.context);
  });
}
ConnectPreview.$inject = [
  "injector",
  "eventBus",
  "canvas"
];

// node_modules/diagram-js/lib/features/connect/index.js
var connect_default = {
  __depends__: [
    selection_default,
    rules_default,
    dragging_default
  ],
  __init__: [
    "connectPreview"
  ],
  connect: ["type", Connect],
  connectPreview: ["type", ConnectPreview]
};

// node_modules/diagram-js/lib/features/connection-preview/ConnectionPreview.js
var import_min_dash54 = __toESM(require_dist());
var MARKER_CONNECTION_PREVIEW = "djs-connection-preview";
function ConnectionPreview(injector, canvas, graphicsFactory, elementFactory) {
  this._canvas = canvas;
  this._graphicsFactory = graphicsFactory;
  this._elementFactory = elementFactory;
  this._connectionDocking = injector.get("connectionDocking", false);
  this._layouter = injector.get("layouter", false);
}
ConnectionPreview.$inject = [
  "injector",
  "canvas",
  "graphicsFactory",
  "elementFactory"
];
ConnectionPreview.prototype.drawPreview = function(context, canConnect2, hints) {
  hints = hints || {};
  var connectionPreviewGfx = context.connectionPreviewGfx, getConnection = context.getConnection, source = hints.source, target = hints.target, waypoints = hints.waypoints, connectionStart = hints.connectionStart, connectionEnd = hints.connectionEnd, noLayout = hints.noLayout, noCropping = hints.noCropping, noNoop = hints.noNoop, connection;
  var self2 = this;
  if (!connectionPreviewGfx) {
    connectionPreviewGfx = context.connectionPreviewGfx = this.createConnectionPreviewGfx();
  }
  clear(connectionPreviewGfx);
  if (!getConnection) {
    getConnection = context.getConnection = cacheReturnValues(function(canConnect3, source2, target2) {
      return self2.getConnection(canConnect3, source2, target2);
    });
  }
  if (canConnect2) {
    connection = getConnection(canConnect2, source, target);
  }
  if (!connection) {
    !noNoop && this.drawNoopPreview(connectionPreviewGfx, hints);
    return;
  }
  connection.waypoints = waypoints || [];
  if (this._layouter && !noLayout) {
    connection.waypoints = this._layouter.layoutConnection(connection, {
      source,
      target,
      connectionStart,
      connectionEnd,
      waypoints: hints.waypoints || connection.waypoints
    });
  }
  if (!connection.waypoints || !connection.waypoints.length) {
    connection.waypoints = [
      source ? getMid(source) : connectionStart,
      target ? getMid(target) : connectionEnd
    ];
  }
  if (this._connectionDocking && (source || target) && !noCropping) {
    connection.waypoints = this._connectionDocking.getCroppedWaypoints(connection, source, target);
  }
  this._graphicsFactory.drawConnection(connectionPreviewGfx, connection);
};
ConnectionPreview.prototype.drawNoopPreview = function(connectionPreviewGfx, hints) {
  var source = hints.source, target = hints.target, start = hints.connectionStart || getMid(source), end = hints.connectionEnd || getMid(target);
  var waypoints = this.cropWaypoints(start, end, source, target);
  var connection = this.createNoopConnection(waypoints[0], waypoints[1]);
  append(connectionPreviewGfx, connection);
};
ConnectionPreview.prototype.cropWaypoints = function(start, end, source, target) {
  var graphicsFactory = this._graphicsFactory, sourcePath = source && graphicsFactory.getShapePath(source), targetPath = target && graphicsFactory.getShapePath(target), connectionPath = graphicsFactory.getConnectionPath({ waypoints: [start, end] });
  start = source && getElementLineIntersection(sourcePath, connectionPath, true) || start;
  end = target && getElementLineIntersection(targetPath, connectionPath, false) || end;
  return [start, end];
};
ConnectionPreview.prototype.cleanUp = function(context) {
  if (context && context.connectionPreviewGfx) {
    remove(context.connectionPreviewGfx);
  }
};
ConnectionPreview.prototype.getConnection = function(canConnect2) {
  var attrs = ensureConnectionAttrs(canConnect2);
  return this._elementFactory.createConnection(attrs);
};
ConnectionPreview.prototype.createConnectionPreviewGfx = function() {
  var gfx = create("g");
  attr(gfx, {
    pointerEvents: "none"
  });
  classes(gfx).add(MARKER_CONNECTION_PREVIEW);
  append(this._canvas.getActiveLayer(), gfx);
  return gfx;
};
ConnectionPreview.prototype.createNoopConnection = function(start, end) {
  var connection = create("polyline");
  attr(connection, {
    "stroke": "#333",
    "strokeDasharray": [1],
    "strokeWidth": 2,
    "pointer-events": "none"
  });
  attr(connection, { "points": [start.x, start.y, end.x, end.y] });
  return connection;
};
function cacheReturnValues(fn2) {
  var returnValues = {};
  return function(firstArgument) {
    var key = JSON.stringify(firstArgument);
    var returnValue = returnValues[key];
    if (!returnValue) {
      returnValue = returnValues[key] = fn2.apply(null, arguments);
    }
    return returnValue;
  };
}
function ensureConnectionAttrs(canConnect2) {
  if ((0, import_min_dash54.isObject)(canConnect2)) {
    return canConnect2;
  } else {
    return {};
  }
}

// node_modules/diagram-js/lib/features/connection-preview/index.js
var connection_preview_default = {
  __init__: ["connectionPreview"],
  connectionPreview: ["type", ConnectionPreview]
};

// node_modules/diagram-js-direct-editing/lib/DirectEditing.js
var import_min_dash56 = __toESM(require_dist());

// node_modules/diagram-js-direct-editing/lib/TextBox.js
var import_min_dash55 = __toESM(require_dist());
var min = Math.min;
var max2 = Math.max;
function preventDefault2(e7) {
  e7.preventDefault();
}
function stopPropagation2(e7) {
  e7.stopPropagation();
}
function isTextNode(node2) {
  return node2.nodeType === Node.TEXT_NODE;
}
function toArray(nodeList) {
  return [].slice.call(nodeList);
}
function TextBox(options2) {
  this.container = options2.container;
  this.parent = domify$1('<div class="djs-direct-editing-parent"><div class="djs-direct-editing-content" contenteditable="true"></div></div>');
  this.content = query("[contenteditable]", this.parent);
  this.keyHandler = options2.keyHandler || function() {
  };
  this.resizeHandler = options2.resizeHandler || function() {
  };
  this.autoResize = (0, import_min_dash55.bind)(this.autoResize, this);
  this.handlePaste = (0, import_min_dash55.bind)(this.handlePaste, this);
}
TextBox.prototype.create = function(bounds, style, value, options2) {
  var self2 = this;
  var parent = this.parent, content = this.content, container = this.container;
  options2 = this.options = options2 || {};
  style = this.style = style || {};
  var parentStyle = (0, import_min_dash55.pick)(style, [
    "width",
    "height",
    "maxWidth",
    "maxHeight",
    "minWidth",
    "minHeight",
    "left",
    "top",
    "backgroundColor",
    "position",
    "overflow",
    "border",
    "wordWrap",
    "textAlign",
    "outline",
    "transform"
  ]);
  (0, import_min_dash55.assign)(parent.style, {
    width: bounds.width + "px",
    height: bounds.height + "px",
    maxWidth: bounds.maxWidth + "px",
    maxHeight: bounds.maxHeight + "px",
    minWidth: bounds.minWidth + "px",
    minHeight: bounds.minHeight + "px",
    left: bounds.x + "px",
    top: bounds.y + "px",
    backgroundColor: "#ffffff",
    position: "absolute",
    overflow: "visible",
    border: "1px solid #ccc",
    boxSizing: "border-box",
    wordWrap: "normal",
    textAlign: "center",
    outline: "none"
  }, parentStyle);
  var contentStyle = (0, import_min_dash55.pick)(style, [
    "fontFamily",
    "fontSize",
    "fontWeight",
    "lineHeight",
    "padding",
    "paddingTop",
    "paddingRight",
    "paddingBottom",
    "paddingLeft"
  ]);
  (0, import_min_dash55.assign)(content.style, {
    boxSizing: "border-box",
    width: "100%",
    outline: "none",
    wordWrap: "break-word"
  }, contentStyle);
  if (options2.centerVertically) {
    (0, import_min_dash55.assign)(content.style, {
      position: "absolute",
      top: "50%",
      transform: "translate(0, -50%)"
    }, contentStyle);
  }
  content.innerText = value;
  event.bind(content, "keydown", this.keyHandler);
  event.bind(content, "mousedown", stopPropagation2);
  event.bind(content, "paste", self2.handlePaste);
  if (options2.autoResize) {
    event.bind(content, "input", this.autoResize);
  }
  if (options2.resizable) {
    this.resizable(style);
  }
  container.appendChild(parent);
  this.setSelection(content.lastChild, content.lastChild && content.lastChild.length);
  return parent;
};
TextBox.prototype.handlePaste = function(e7) {
  var options2 = this.options, style = this.style;
  e7.preventDefault();
  var text;
  if (e7.clipboardData) {
    text = e7.clipboardData.getData("text/plain");
  } else {
    text = window.clipboardData.getData("Text");
  }
  this.insertText(text);
  if (options2.autoResize) {
    var hasResized = this.autoResize(style);
    if (hasResized) {
      this.resizeHandler(hasResized);
    }
  }
};
TextBox.prototype.insertText = function(text) {
  text = normalizeEndOfLineSequences(text);
  var success = document.execCommand("insertText", false, text);
  if (success) {
    return;
  }
  this._insertTextIE(text);
};
TextBox.prototype._insertTextIE = function(text) {
  var range = this.getSelection(), startContainer = range.startContainer, endContainer = range.endContainer, startOffset = range.startOffset, endOffset = range.endOffset, commonAncestorContainer = range.commonAncestorContainer;
  var childNodesArray = toArray(commonAncestorContainer.childNodes);
  var container, offset;
  if (isTextNode(commonAncestorContainer)) {
    var containerTextContent = startContainer.textContent;
    startContainer.textContent = containerTextContent.substring(0, startOffset) + text + containerTextContent.substring(endOffset);
    container = startContainer;
    offset = startOffset + text.length;
  } else if (startContainer === this.content && endContainer === this.content) {
    var textNode = document.createTextNode(text);
    this.content.insertBefore(textNode, childNodesArray[startOffset]);
    container = textNode;
    offset = textNode.textContent.length;
  } else {
    var startContainerChildIndex = childNodesArray.indexOf(startContainer), endContainerChildIndex = childNodesArray.indexOf(endContainer);
    childNodesArray.forEach(function(childNode, index2) {
      if (index2 === startContainerChildIndex) {
        childNode.textContent = startContainer.textContent.substring(0, startOffset) + text + endContainer.textContent.substring(endOffset);
      } else if (index2 > startContainerChildIndex && index2 <= endContainerChildIndex) {
        remove2(childNode);
      }
    });
    container = startContainer;
    offset = startOffset + text.length;
  }
  if (container && offset !== void 0) {
    setTimeout(function() {
      self.setSelection(container, offset);
    });
  }
};
TextBox.prototype.autoResize = function() {
  var parent = this.parent, content = this.content;
  var fontSize = parseInt(this.style.fontSize) || 12;
  if (content.scrollHeight > parent.offsetHeight || content.scrollHeight < parent.offsetHeight - fontSize) {
    var bounds = parent.getBoundingClientRect();
    var height = content.scrollHeight;
    parent.style.height = height + "px";
    this.resizeHandler({
      width: bounds.width,
      height: bounds.height,
      dx: 0,
      dy: height - bounds.height
    });
  }
};
TextBox.prototype.resizable = function() {
  var self2 = this;
  var parent = this.parent, resizeHandle = this.resizeHandle;
  var minWidth = parseInt(this.style.minWidth) || 0, minHeight = parseInt(this.style.minHeight) || 0, maxWidth = parseInt(this.style.maxWidth) || Infinity, maxHeight = parseInt(this.style.maxHeight) || Infinity;
  if (!resizeHandle) {
    resizeHandle = this.resizeHandle = domify$1('<div class="djs-direct-editing-resize-handle"></div>');
    var startX, startY, startWidth, startHeight;
    var onMouseDown = function(e7) {
      preventDefault2(e7);
      stopPropagation2(e7);
      startX = e7.clientX;
      startY = e7.clientY;
      var bounds = parent.getBoundingClientRect();
      startWidth = bounds.width;
      startHeight = bounds.height;
      event.bind(document, "mousemove", onMouseMove);
      event.bind(document, "mouseup", onMouseUp);
    };
    var onMouseMove = function(e7) {
      preventDefault2(e7);
      stopPropagation2(e7);
      var newWidth = min(max2(startWidth + e7.clientX - startX, minWidth), maxWidth);
      var newHeight = min(max2(startHeight + e7.clientY - startY, minHeight), maxHeight);
      parent.style.width = newWidth + "px";
      parent.style.height = newHeight + "px";
      self2.resizeHandler({
        width: startWidth,
        height: startHeight,
        dx: e7.clientX - startX,
        dy: e7.clientY - startY
      });
    };
    var onMouseUp = function(e7) {
      preventDefault2(e7);
      stopPropagation2(e7);
      event.unbind(document, "mousemove", onMouseMove, false);
      event.unbind(document, "mouseup", onMouseUp, false);
    };
    event.bind(resizeHandle, "mousedown", onMouseDown);
  }
  (0, import_min_dash55.assign)(resizeHandle.style, {
    position: "absolute",
    bottom: "0px",
    right: "0px",
    cursor: "nwse-resize",
    width: "0",
    height: "0",
    borderTop: (parseInt(this.style.fontSize) / 4 || 3) + "px solid transparent",
    borderRight: (parseInt(this.style.fontSize) / 4 || 3) + "px solid #ccc",
    borderBottom: (parseInt(this.style.fontSize) / 4 || 3) + "px solid #ccc",
    borderLeft: (parseInt(this.style.fontSize) / 4 || 3) + "px solid transparent"
  });
  parent.appendChild(resizeHandle);
};
TextBox.prototype.destroy = function() {
  var parent = this.parent, content = this.content, resizeHandle = this.resizeHandle;
  content.innerText = "";
  parent.removeAttribute("style");
  content.removeAttribute("style");
  event.unbind(content, "keydown", this.keyHandler);
  event.unbind(content, "mousedown", stopPropagation2);
  event.unbind(content, "input", this.autoResize);
  event.unbind(content, "paste", this.handlePaste);
  if (resizeHandle) {
    resizeHandle.removeAttribute("style");
    remove2(resizeHandle);
  }
  remove2(parent);
};
TextBox.prototype.getValue = function() {
  return this.content.innerText.trim();
};
TextBox.prototype.getSelection = function() {
  var selection = window.getSelection(), range = selection.getRangeAt(0);
  return range;
};
TextBox.prototype.setSelection = function(container, offset) {
  var range = document.createRange();
  if (container === null) {
    range.selectNodeContents(this.content);
  } else {
    range.setStart(container, offset);
    range.setEnd(container, offset);
  }
  var selection = window.getSelection();
  selection.removeAllRanges();
  selection.addRange(range);
};
function normalizeEndOfLineSequences(string) {
  return string.replace(/\r\n|\r|\n/g, "\n");
}

// node_modules/diagram-js-direct-editing/lib/DirectEditing.js
function DirectEditing(eventBus, canvas) {
  this._eventBus = eventBus;
  this._providers = [];
  this._textbox = new TextBox({
    container: canvas.getContainer(),
    keyHandler: (0, import_min_dash56.bind)(this._handleKey, this),
    resizeHandler: (0, import_min_dash56.bind)(this._handleResize, this)
  });
}
DirectEditing.$inject = ["eventBus", "canvas"];
DirectEditing.prototype.registerProvider = function(provider) {
  this._providers.push(provider);
};
DirectEditing.prototype.isActive = function(element) {
  return !!(this._active && (!element || this._active.element === element));
};
DirectEditing.prototype.cancel = function() {
  if (!this._active) {
    return;
  }
  this._fire("cancel");
  this.close();
};
DirectEditing.prototype._fire = function(event2, context) {
  this._eventBus.fire("directEditing." + event2, context || { active: this._active });
};
DirectEditing.prototype.close = function() {
  this._textbox.destroy();
  this._fire("deactivate");
  this._active = null;
  this.resizable = void 0;
};
DirectEditing.prototype.complete = function() {
  var active = this._active;
  if (!active) {
    return;
  }
  var containerBounds, previousBounds = active.context.bounds, newBounds = this.$textbox.getBoundingClientRect(), newText = this.getValue(), previousText = active.context.text;
  if (newText !== previousText || newBounds.height !== previousBounds.height || newBounds.width !== previousBounds.width) {
    containerBounds = this._textbox.container.getBoundingClientRect();
    active.provider.update(active.element, newText, active.context.text, {
      x: newBounds.left - containerBounds.left,
      y: newBounds.top - containerBounds.top,
      width: newBounds.width,
      height: newBounds.height
    });
  }
  this._fire("complete");
  this.close();
};
DirectEditing.prototype.getValue = function() {
  return this._textbox.getValue();
};
DirectEditing.prototype._handleKey = function(e7) {
  e7.stopPropagation();
  var key = e7.keyCode || e7.charCode;
  if (key === 27) {
    e7.preventDefault();
    return this.cancel();
  }
  if (key === 13 && !e7.shiftKey) {
    e7.preventDefault();
    return this.complete();
  }
};
DirectEditing.prototype._handleResize = function(event2) {
  this._fire("resize", event2);
};
DirectEditing.prototype.activate = function(element) {
  if (this.isActive()) {
    this.cancel();
  }
  var context;
  var provider = (0, import_min_dash56.find)(this._providers, function(p6) {
    return (context = p6.activate(element)) ? p6 : null;
  });
  if (context) {
    this.$textbox = this._textbox.create(context.bounds, context.style, context.text, context.options);
    this._active = {
      element,
      context,
      provider
    };
    if (context.options && context.options.resizable) {
      this.resizable = true;
    }
    this._fire("activate");
  }
  return !!context;
};

// node_modules/diagram-js-direct-editing/index.js
var diagram_js_direct_editing_default = {
  __depends__: [
    interaction_events_default
  ],
  __init__: ["directEditing"],
  directEditing: ["type", DirectEditing]
};

// node_modules/diagram-js/lib/features/preview-support/PreviewSupport.js
var import_min_dash57 = __toESM(require_dist());
var MARKER_TYPES = [
  "marker-start",
  "marker-mid",
  "marker-end"
];
var NODES_CAN_HAVE_MARKER = [
  "circle",
  "ellipse",
  "line",
  "path",
  "polygon",
  "polyline",
  "rect"
];
function PreviewSupport(elementRegistry, eventBus, canvas, styles) {
  this._elementRegistry = elementRegistry;
  this._canvas = canvas;
  this._styles = styles;
  this._clonedMarkers = {};
  var self2 = this;
  eventBus.on("drag.cleanup", function() {
    (0, import_min_dash57.forEach)(self2._clonedMarkers, function(clonedMarker) {
      remove(clonedMarker);
    });
    self2._clonedMarkers = {};
  });
}
PreviewSupport.$inject = [
  "elementRegistry",
  "eventBus",
  "canvas",
  "styles"
];
PreviewSupport.prototype.getGfx = function(element) {
  return this._elementRegistry.getGraphics(element);
};
PreviewSupport.prototype.addDragger = function(element, group, gfx) {
  gfx = gfx || this.getGfx(element);
  var dragger = clone(gfx);
  var bbox = gfx.getBoundingClientRect();
  this._cloneMarkers(getVisual(dragger));
  attr(dragger, this._styles.cls("djs-dragger", [], {
    x: bbox.top,
    y: bbox.left
  }));
  append(group, dragger);
  return dragger;
};
PreviewSupport.prototype.addFrame = function(shape, group) {
  var frame = create("rect", {
    class: "djs-resize-overlay",
    width: shape.width,
    height: shape.height,
    x: shape.x,
    y: shape.y
  });
  append(group, frame);
  return frame;
};
PreviewSupport.prototype._cloneMarkers = function(gfx) {
  var self2 = this;
  if (gfx.childNodes) {
    for (var i6 = 0; i6 < gfx.childNodes.length; i6++) {
      self2._cloneMarkers(gfx.childNodes[i6]);
    }
  }
  if (!canHaveMarker(gfx)) {
    return;
  }
  MARKER_TYPES.forEach(function(markerType) {
    if (attr(gfx, markerType)) {
      var marker = getMarker(gfx, markerType, self2._canvas.getContainer());
      self2._cloneMarker(gfx, marker, markerType);
    }
  });
};
PreviewSupport.prototype._cloneMarker = function(gfx, marker, markerType) {
  var markerId = marker.id;
  var clonedMarker = this._clonedMarkers[markerId];
  if (!clonedMarker) {
    clonedMarker = clone(marker);
    var clonedMarkerId = markerId + "-clone";
    clonedMarker.id = clonedMarkerId;
    classes(clonedMarker).add("djs-dragger").add("djs-dragger-marker");
    this._clonedMarkers[markerId] = clonedMarker;
    var defs = query("defs", this._canvas._svg);
    if (!defs) {
      defs = create("defs");
      append(this._canvas._svg, defs);
    }
    append(defs, clonedMarker);
  }
  var reference = idToReference(this._clonedMarkers[markerId].id);
  attr(gfx, markerType, reference);
};
function getMarker(node2, markerType, parentNode) {
  var id = referenceToId(attr(node2, markerType));
  return query("marker#" + id, parentNode || document);
}
function referenceToId(reference) {
  return reference.match(/url\(['"]?#([^'"]*)['"]?\)/)[1];
}
function idToReference(id) {
  return "url(#" + id + ")";
}
function canHaveMarker(node2) {
  return NODES_CAN_HAVE_MARKER.indexOf(node2.nodeName) !== -1;
}

// node_modules/diagram-js/lib/features/preview-support/index.js
var preview_support_default = {
  __init__: ["previewSupport"],
  previewSupport: ["type", PreviewSupport]
};

// node_modules/diagram-js/lib/features/create/Create.js
var import_min_dash58 = __toESM(require_dist());
var MARKER_OK3 = "drop-ok";
var MARKER_NOT_OK3 = "drop-not-ok";
var MARKER_ATTACH = "attach-ok";
var MARKER_NEW_PARENT = "new-parent";
var PREFIX = "create";
var HIGH_PRIORITY4 = 2e3;
function Create(canvas, dragging, eventBus, modeling, rules) {
  function canCreate2(elements, target, position, source, hints) {
    if (!target) {
      return false;
    }
    elements = (0, import_min_dash58.filter)(elements, function(element) {
      var labelTarget = element.labelTarget;
      return !element.parent && !(isLabel2(element) && elements.indexOf(labelTarget) !== -1);
    });
    var shape = (0, import_min_dash58.find)(elements, function(element) {
      return !isConnection4(element);
    });
    var attach = false, connect = false, create3 = false;
    if (isSingleShape(elements)) {
      attach = rules.allowed("shape.attach", {
        position,
        shape,
        target
      });
    }
    if (!attach) {
      if (isSingleShape(elements)) {
        create3 = rules.allowed("shape.create", {
          position,
          shape,
          source,
          target
        });
      } else {
        create3 = rules.allowed("elements.create", {
          elements,
          position,
          target
        });
      }
    }
    var connectionTarget = hints.connectionTarget;
    if (create3 || attach) {
      if (shape && source) {
        connect = rules.allowed("connection.create", {
          source: connectionTarget === source ? shape : source,
          target: connectionTarget === source ? source : shape,
          hints: {
            targetParent: target,
            targetAttach: attach
          }
        });
      }
      return {
        attach,
        connect
      };
    }
    if (create3 === null || attach === null) {
      return null;
    }
    return false;
  }
  function setMarker(element, marker) {
    [MARKER_ATTACH, MARKER_OK3, MARKER_NOT_OK3, MARKER_NEW_PARENT].forEach(function(m6) {
      if (m6 === marker) {
        canvas.addMarker(element, m6);
      } else {
        canvas.removeMarker(element, m6);
      }
    });
  }
  eventBus.on(["create.move", "create.hover"], function(event2) {
    var context = event2.context, elements = context.elements, hover = event2.hover, source = context.source, hints = context.hints || {};
    if (!hover) {
      context.canExecute = false;
      context.target = null;
      return;
    }
    ensureConstraints(event2);
    var position = {
      x: event2.x,
      y: event2.y
    };
    var canExecute = context.canExecute = hover && canCreate2(elements, hover, position, source, hints);
    if (hover && canExecute !== null) {
      context.target = hover;
      if (canExecute && canExecute.attach) {
        setMarker(hover, MARKER_ATTACH);
      } else {
        setMarker(hover, canExecute ? MARKER_NEW_PARENT : MARKER_NOT_OK3);
      }
    }
  });
  eventBus.on(["create.end", "create.out", "create.cleanup"], function(event2) {
    var hover = event2.hover;
    if (hover) {
      setMarker(hover, null);
    }
  });
  eventBus.on("create.end", function(event2) {
    var context = event2.context, source = context.source, shape = context.shape, elements = context.elements, target = context.target, canExecute = context.canExecute, attach = canExecute && canExecute.attach, connect = canExecute && canExecute.connect, hints = context.hints || {};
    if (canExecute === false || !target) {
      return false;
    }
    ensureConstraints(event2);
    var position = {
      x: event2.x,
      y: event2.y
    };
    if (connect) {
      shape = modeling.appendShape(source, shape, position, target, {
        attach,
        connection: connect === true ? {} : connect,
        connectionTarget: hints.connectionTarget
      });
    } else {
      elements = modeling.createElements(elements, position, target, (0, import_min_dash58.assign)({}, hints, {
        attach
      }));
      shape = (0, import_min_dash58.find)(elements, function(element) {
        return !isConnection4(element);
      });
    }
    (0, import_min_dash58.assign)(context, {
      elements,
      shape
    });
    (0, import_min_dash58.assign)(event2, {
      elements,
      shape
    });
  });
  function cancel() {
    var context = dragging.context();
    if (context && context.prefix === PREFIX) {
      dragging.cancel();
    }
  }
  eventBus.on("create.init", function() {
    eventBus.on("elements.changed", cancel);
    eventBus.once(["create.cancel", "create.end"], HIGH_PRIORITY4, function() {
      eventBus.off("elements.changed", cancel);
    });
  });
  this.start = function(event2, elements, context) {
    if (!(0, import_min_dash58.isArray)(elements)) {
      elements = [elements];
    }
    var shape = (0, import_min_dash58.find)(elements, function(element) {
      return !isConnection4(element);
    });
    if (!shape) {
      return;
    }
    context = (0, import_min_dash58.assign)({
      elements,
      hints: {},
      shape
    }, context || {});
    (0, import_min_dash58.forEach)(elements, function(element) {
      if (!(0, import_min_dash58.isNumber)(element.x)) {
        element.x = 0;
      }
      if (!(0, import_min_dash58.isNumber)(element.y)) {
        element.y = 0;
      }
    });
    var visibleElements = (0, import_min_dash58.filter)(elements, function(element) {
      return !element.hidden;
    });
    var bbox = getBBox(visibleElements);
    (0, import_min_dash58.forEach)(elements, function(element) {
      if (isConnection4(element)) {
        element.waypoints = (0, import_min_dash58.map)(element.waypoints, function(waypoint) {
          return {
            x: waypoint.x - bbox.x - bbox.width / 2,
            y: waypoint.y - bbox.y - bbox.height / 2
          };
        });
      }
      (0, import_min_dash58.assign)(element, {
        x: element.x - bbox.x - bbox.width / 2,
        y: element.y - bbox.y - bbox.height / 2
      });
    });
    dragging.init(event2, PREFIX, {
      cursor: "grabbing",
      autoActivate: true,
      data: {
        shape,
        elements,
        context
      }
    });
  };
}
Create.$inject = [
  "canvas",
  "dragging",
  "eventBus",
  "modeling",
  "rules"
];
function ensureConstraints(event2) {
  var context = event2.context, createConstraints = context.createConstraints;
  if (!createConstraints) {
    return;
  }
  if (createConstraints.left) {
    event2.x = Math.max(event2.x, createConstraints.left);
  }
  if (createConstraints.right) {
    event2.x = Math.min(event2.x, createConstraints.right);
  }
  if (createConstraints.top) {
    event2.y = Math.max(event2.y, createConstraints.top);
  }
  if (createConstraints.bottom) {
    event2.y = Math.min(event2.y, createConstraints.bottom);
  }
}
function isConnection4(element) {
  return !!element.waypoints;
}
function isSingleShape(elements) {
  return elements && elements.length === 1 && !isConnection4(elements[0]);
}
function isLabel2(element) {
  return !!element.labelTarget;
}

// node_modules/diagram-js/lib/features/create/CreatePreview.js
var LOW_PRIORITY9 = 750;
function CreatePreview(canvas, eventBus, graphicsFactory, previewSupport, styles) {
  function createDragGroup(elements) {
    var dragGroup = create("g");
    attr(dragGroup, styles.cls("djs-drag-group", ["no-events"]));
    var childrenGfx = create("g");
    elements.forEach(function(element) {
      var gfx;
      if (element.hidden) {
        return;
      }
      if (element.waypoints) {
        gfx = graphicsFactory._createContainer("connection", childrenGfx);
        graphicsFactory.drawConnection(getVisual(gfx), element);
      } else {
        gfx = graphicsFactory._createContainer("shape", childrenGfx);
        graphicsFactory.drawShape(getVisual(gfx), element);
        translate(gfx, element.x, element.y);
      }
      previewSupport.addDragger(element, dragGroup, gfx);
    });
    return dragGroup;
  }
  eventBus.on("create.move", LOW_PRIORITY9, function(event2) {
    var hover = event2.hover, context = event2.context, elements = context.elements, dragGroup = context.dragGroup;
    if (!dragGroup) {
      dragGroup = context.dragGroup = createDragGroup(elements);
    }
    var activeLayer;
    if (hover) {
      if (!dragGroup.parentNode) {
        activeLayer = canvas.getActiveLayer();
        append(activeLayer, dragGroup);
      }
      translate(dragGroup, event2.x, event2.y);
    } else {
      remove(dragGroup);
    }
  });
  eventBus.on("create.cleanup", function(event2) {
    var context = event2.context, dragGroup = context.dragGroup;
    if (dragGroup) {
      remove(dragGroup);
    }
  });
}
CreatePreview.$inject = [
  "canvas",
  "eventBus",
  "graphicsFactory",
  "previewSupport",
  "styles"
];

// node_modules/diagram-js/lib/features/create/index.js
var create_default = {
  __depends__: [
    dragging_default,
    preview_support_default,
    rules_default,
    selection_default
  ],
  __init__: [
    "create",
    "createPreview"
  ],
  create: ["type", Create],
  createPreview: ["type", CreatePreview]
};

// node_modules/diagram-js/lib/features/clipboard/Clipboard.js
function Clipboard() {
}
Clipboard.prototype.get = function() {
  return this._data;
};
Clipboard.prototype.set = function(data) {
  this._data = data;
};
Clipboard.prototype.clear = function() {
  var data = this._data;
  delete this._data;
  return data;
};
Clipboard.prototype.isEmpty = function() {
  return !this._data;
};

// node_modules/diagram-js/lib/features/clipboard/index.js
var clipboard_default = {
  clipboard: ["type", Clipboard]
};

// node_modules/diagram-js/lib/features/mouse/Mouse.js
function Mouse(eventBus) {
  var self2 = this;
  this._lastMoveEvent = null;
  function setLastMoveEvent(mousemoveEvent) {
    self2._lastMoveEvent = mousemoveEvent;
  }
  eventBus.on("canvas.init", function(context) {
    var svg = self2._svg = context.svg;
    svg.addEventListener("mousemove", setLastMoveEvent);
  });
  eventBus.on("canvas.destroy", function() {
    self2._lastMouseEvent = null;
    self2._svg.removeEventListener("mousemove", setLastMoveEvent);
  });
}
Mouse.$inject = ["eventBus"];
Mouse.prototype.getLastMoveEvent = function() {
  return this._lastMoveEvent || createMoveEvent(0, 0);
};
function createMoveEvent(x4, y4) {
  var event2 = document.createEvent("MouseEvent");
  var screenX = x4, screenY = y4, clientX = x4, clientY = y4;
  if (event2.initMouseEvent) {
    event2.initMouseEvent("mousemove", true, true, window, 0, screenX, screenY, clientX, clientY, false, false, false, false, 0, null);
  }
  return event2;
}

// node_modules/diagram-js/lib/features/mouse/index.js
var mouse_default = {
  __init__: ["mouse"],
  mouse: ["type", Mouse]
};

// node_modules/diagram-js/lib/features/copy-paste/CopyPaste.js
var import_min_dash59 = __toESM(require_dist());
function CopyPaste(canvas, create3, clipboard, elementFactory, eventBus, modeling, mouse, rules) {
  this._canvas = canvas;
  this._create = create3;
  this._clipboard = clipboard;
  this._elementFactory = elementFactory;
  this._eventBus = eventBus;
  this._modeling = modeling;
  this._mouse = mouse;
  this._rules = rules;
  eventBus.on("copyPaste.copyElement", function(context) {
    var descriptor = context.descriptor, element = context.element, elements = context.elements;
    descriptor.priority = 1;
    descriptor.id = element.id;
    var parentCopied = (0, import_min_dash59.find)(elements, function(e7) {
      return e7 === element.parent;
    });
    if (parentCopied) {
      descriptor.parent = element.parent.id;
    }
    if (isAttacher(element)) {
      descriptor.priority = 2;
      descriptor.host = element.host.id;
    }
    if (isConnection5(element)) {
      descriptor.priority = 3;
      descriptor.source = element.source.id;
      descriptor.target = element.target.id;
      descriptor.waypoints = copyWaypoints(element);
    }
    if (isLabel3(element)) {
      descriptor.priority = 4;
      descriptor.labelTarget = element.labelTarget.id;
    }
    (0, import_min_dash59.forEach)(["x", "y", "width", "height"], function(property) {
      if ((0, import_min_dash59.isNumber)(element[property])) {
        descriptor[property] = element[property];
      }
    });
    descriptor.hidden = element.hidden;
    descriptor.collapsed = element.collapsed;
  });
  eventBus.on("copyPaste.pasteElements", function(context) {
    var hints = context.hints;
    (0, import_min_dash59.assign)(hints, {
      createElementsBehavior: false
    });
  });
}
CopyPaste.$inject = [
  "canvas",
  "create",
  "clipboard",
  "elementFactory",
  "eventBus",
  "modeling",
  "mouse",
  "rules"
];
CopyPaste.prototype.copy = function(elements) {
  var allowed, tree;
  if (!(0, import_min_dash59.isArray)(elements)) {
    elements = elements ? [elements] : [];
  }
  allowed = this._eventBus.fire("copyPaste.canCopyElements", {
    elements
  });
  if (allowed === false) {
    tree = {};
  } else {
    tree = this.createTree((0, import_min_dash59.isArray)(allowed) ? allowed : elements);
  }
  this._clipboard.set(tree);
  this._eventBus.fire("copyPaste.elementsCopied", {
    elements,
    tree
  });
  return tree;
};
CopyPaste.prototype.paste = function(context) {
  var tree = this._clipboard.get();
  if (this._clipboard.isEmpty()) {
    return;
  }
  var hints = context && context.hints || {};
  this._eventBus.fire("copyPaste.pasteElements", {
    hints
  });
  var elements = this._createElements(tree);
  if (context && context.element && context.point) {
    return this._paste(elements, context.element, context.point, hints);
  }
  this._create.start(this._mouse.getLastMoveEvent(), elements, {
    hints: hints || {}
  });
};
CopyPaste.prototype._paste = function(elements, target, position, hints) {
  (0, import_min_dash59.forEach)(elements, function(element) {
    if (!(0, import_min_dash59.isNumber)(element.x)) {
      element.x = 0;
    }
    if (!(0, import_min_dash59.isNumber)(element.y)) {
      element.y = 0;
    }
  });
  var bbox = getBBox(elements);
  (0, import_min_dash59.forEach)(elements, function(element) {
    if (isConnection5(element)) {
      element.waypoints = (0, import_min_dash59.map)(element.waypoints, function(waypoint) {
        return {
          x: waypoint.x - bbox.x - bbox.width / 2,
          y: waypoint.y - bbox.y - bbox.height / 2
        };
      });
    }
    (0, import_min_dash59.assign)(element, {
      x: element.x - bbox.x - bbox.width / 2,
      y: element.y - bbox.y - bbox.height / 2
    });
  });
  return this._modeling.createElements(elements, position, target, (0, import_min_dash59.assign)({}, hints));
};
CopyPaste.prototype._createElements = function(tree) {
  var self2 = this;
  var eventBus = this._eventBus;
  var cache = {};
  var elements = [];
  (0, import_min_dash59.forEach)(tree, function(branch, depth) {
    depth = parseInt(depth, 10);
    branch = (0, import_min_dash59.sortBy)(branch, "priority");
    (0, import_min_dash59.forEach)(branch, function(descriptor) {
      var attrs = (0, import_min_dash59.assign)({}, (0, import_min_dash59.omit)(descriptor, ["priority"]));
      if (cache[descriptor.parent]) {
        attrs.parent = cache[descriptor.parent];
      } else {
        delete attrs.parent;
      }
      eventBus.fire("copyPaste.pasteElement", {
        cache,
        descriptor: attrs
      });
      var element;
      if (isConnection5(attrs)) {
        attrs.source = cache[descriptor.source];
        attrs.target = cache[descriptor.target];
        element = cache[descriptor.id] = self2.createConnection(attrs);
        elements.push(element);
        return;
      }
      if (isLabel3(attrs)) {
        attrs.labelTarget = cache[attrs.labelTarget];
        element = cache[descriptor.id] = self2.createLabel(attrs);
        elements.push(element);
        return;
      }
      if (attrs.host) {
        attrs.host = cache[attrs.host];
      }
      element = cache[descriptor.id] = self2.createShape(attrs);
      elements.push(element);
    });
  });
  return elements;
};
CopyPaste.prototype.createConnection = function(attrs) {
  var connection = this._elementFactory.createConnection((0, import_min_dash59.omit)(attrs, ["id"]));
  return connection;
};
CopyPaste.prototype.createLabel = function(attrs) {
  var label = this._elementFactory.createLabel((0, import_min_dash59.omit)(attrs, ["id"]));
  return label;
};
CopyPaste.prototype.createShape = function(attrs) {
  var shape = this._elementFactory.createShape((0, import_min_dash59.omit)(attrs, ["id"]));
  return shape;
};
CopyPaste.prototype.hasRelations = function(element, elements) {
  var labelTarget, source, target;
  if (isConnection5(element)) {
    source = (0, import_min_dash59.find)(elements, (0, import_min_dash59.matchPattern)({ id: element.source.id }));
    target = (0, import_min_dash59.find)(elements, (0, import_min_dash59.matchPattern)({ id: element.target.id }));
    if (!source || !target) {
      return false;
    }
  }
  if (isLabel3(element)) {
    labelTarget = (0, import_min_dash59.find)(elements, (0, import_min_dash59.matchPattern)({ id: element.labelTarget.id }));
    if (!labelTarget) {
      return false;
    }
  }
  return true;
};
CopyPaste.prototype.createTree = function(elements) {
  var rules = this._rules, self2 = this;
  var tree = {}, elementsData = [];
  var parents = getParents(elements);
  function canCopy2(element, elements2) {
    return rules.allowed("element.copy", {
      element,
      elements: elements2
    });
  }
  function addElementData(element, depth) {
    var foundElementData = (0, import_min_dash59.find)(elementsData, function(elementsData2) {
      return element === elementsData2.element;
    });
    if (!foundElementData) {
      elementsData.push({
        element,
        depth
      });
      return;
    }
    if (foundElementData.depth < depth) {
      elementsData = removeElementData(foundElementData, elementsData);
      elementsData.push({
        element: foundElementData.element,
        depth
      });
    }
  }
  function removeElementData(elementData2, elementsData2) {
    var index2 = elementsData2.indexOf(elementData2);
    if (index2 !== -1) {
      elementsData2.splice(index2, 1);
    }
    return elementsData2;
  }
  eachElement(parents, function(element, _index, depth) {
    if (isLabel3(element)) {
      return;
    }
    (0, import_min_dash59.forEach)(element.labels, function(label) {
      addElementData(label, depth);
    });
    function addRelatedElements(elements2) {
      elements2 && elements2.length && (0, import_min_dash59.forEach)(elements2, function(element2) {
        (0, import_min_dash59.forEach)(element2.labels, function(label) {
          addElementData(label, depth);
        });
        addElementData(element2, depth);
      });
    }
    (0, import_min_dash59.forEach)([element.attachers, element.incoming, element.outgoing], addRelatedElements);
    addElementData(element, depth);
    var children = [];
    if (element.children) {
      children = element.children.slice();
    }
    self2._eventBus.fire("copyPaste.createTree", {
      element,
      children
    });
    return children;
  });
  elements = (0, import_min_dash59.map)(elementsData, function(elementData2) {
    return elementData2.element;
  });
  elementsData = (0, import_min_dash59.map)(elementsData, function(elementData2) {
    elementData2.descriptor = {};
    self2._eventBus.fire("copyPaste.copyElement", {
      descriptor: elementData2.descriptor,
      element: elementData2.element,
      elements
    });
    return elementData2;
  });
  elementsData = (0, import_min_dash59.sortBy)(elementsData, function(elementData2) {
    return elementData2.descriptor.priority;
  });
  elements = (0, import_min_dash59.map)(elementsData, function(elementData2) {
    return elementData2.element;
  });
  (0, import_min_dash59.forEach)(elementsData, function(elementData2) {
    var depth = elementData2.depth;
    if (!self2.hasRelations(elementData2.element, elements)) {
      removeElement(elementData2.element, elements);
      return;
    }
    if (!canCopy2(elementData2.element, elements)) {
      removeElement(elementData2.element, elements);
      return;
    }
    if (!tree[depth]) {
      tree[depth] = [];
    }
    tree[depth].push(elementData2.descriptor);
  });
  return tree;
};
function isAttacher(element) {
  return !!element.host;
}
function isConnection5(element) {
  return !!element.waypoints;
}
function isLabel3(element) {
  return !!element.labelTarget;
}
function copyWaypoints(element) {
  return (0, import_min_dash59.map)(element.waypoints, function(waypoint) {
    waypoint = copyWaypoint(waypoint);
    if (waypoint.original) {
      waypoint.original = copyWaypoint(waypoint.original);
    }
    return waypoint;
  });
}
function copyWaypoint(waypoint) {
  return (0, import_min_dash59.assign)({}, waypoint);
}
function removeElement(element, elements) {
  var index2 = elements.indexOf(element);
  if (index2 === -1) {
    return elements;
  }
  return elements.splice(index2, 1);
}

// node_modules/diagram-js/lib/features/copy-paste/index.js
var copy_paste_default = {
  __depends__: [
    clipboard_default,
    create_default,
    mouse_default,
    rules_default
  ],
  __init__: ["copyPaste"],
  copyPaste: ["type", CopyPaste]
};

// node_modules/bpmn-js/lib/features/copy-paste/BpmnCopyPaste.js
var import_min_dash60 = __toESM(require_dist());
function copyProperties(source, target, properties) {
  if (!(0, import_min_dash60.isArray)(properties)) {
    properties = [properties];
  }
  (0, import_min_dash60.forEach)(properties, function(property) {
    if (!(0, import_min_dash60.isUndefined)(source[property])) {
      target[property] = source[property];
    }
  });
}
var LOW_PRIORITY10 = 750;
function BpmnCopyPaste(bpmnFactory, eventBus, moddleCopy) {
  function copy2(bo, clone2) {
    var targetBo = bpmnFactory.create(bo.$type);
    return moddleCopy.copyElement(bo, targetBo, null, clone2);
  }
  eventBus.on("copyPaste.copyElement", LOW_PRIORITY10, function(context) {
    var descriptor = context.descriptor, element = context.element, businessObject = getBusinessObject(element);
    if (isLabel4(element)) {
      return descriptor;
    }
    var businessObjectCopy = descriptor.businessObject = copy2(businessObject, true);
    var diCopy = descriptor.di = copy2(getDi(element), true);
    diCopy.bpmnElement = businessObjectCopy;
    copyProperties(businessObjectCopy, descriptor, "name");
    copyProperties(diCopy, descriptor, "isExpanded");
    if (businessObject.default) {
      descriptor.default = businessObject.default.id;
    }
  });
  var referencesKey = "-bpmn-js-refs";
  function getReferences(cache) {
    return cache[referencesKey] = cache[referencesKey] || {};
  }
  function setReferences(cache, references) {
    cache[referencesKey] = references;
  }
  function resolveReferences(descriptor, cache, references) {
    var businessObject = getBusinessObject(descriptor);
    if (descriptor.default) {
      references[descriptor.default] = {
        element: businessObject,
        property: "default"
      };
    }
    if (descriptor.host) {
      getBusinessObject(descriptor).attachedToRef = getBusinessObject(cache[descriptor.host]);
    }
    return (0, import_min_dash60.omit)(references, (0, import_min_dash60.reduce)(references, function(array, reference, key) {
      var element = reference.element, property = reference.property;
      if (key === descriptor.id) {
        element[property] = businessObject;
        array.push(descriptor.id);
      }
      return array;
    }, []));
  }
  eventBus.on("copyPaste.pasteElement", function(context) {
    var cache = context.cache, descriptor = context.descriptor, businessObject = descriptor.businessObject, di = descriptor.di;
    if (isLabel4(descriptor)) {
      descriptor.businessObject = getBusinessObject(cache[descriptor.labelTarget]);
      descriptor.di = getDi(cache[descriptor.labelTarget]);
      return;
    }
    businessObject = descriptor.businessObject = copy2(businessObject);
    di = descriptor.di = copy2(di);
    di.bpmnElement = businessObject;
    copyProperties(descriptor, businessObject, [
      "isExpanded",
      "name"
    ]);
    descriptor.type = businessObject.$type;
  });
  eventBus.on("copyPaste.copyElement", LOW_PRIORITY10, function(context) {
    var descriptor = context.descriptor, element = context.element;
    if (!is(element, "bpmn:Participant")) {
      return;
    }
    var participantBo = getBusinessObject(element);
    if (participantBo.processRef) {
      descriptor.processRef = copy2(participantBo.processRef, true);
    }
  });
  eventBus.on("copyPaste.pasteElement", function(context) {
    var descriptor = context.descriptor, processRef = descriptor.processRef;
    if (processRef) {
      descriptor.processRef = copy2(processRef);
    }
  });
  eventBus.on("copyPaste.pasteElement", LOW_PRIORITY10, function(context) {
    var cache = context.cache, descriptor = context.descriptor;
    setReferences(cache, resolveReferences(descriptor, cache, getReferences(cache)));
  });
}
BpmnCopyPaste.$inject = [
  "bpmnFactory",
  "eventBus",
  "moddleCopy"
];
function isLabel4(element) {
  return !!element.labelTarget;
}

// node_modules/bpmn-js/lib/features/copy-paste/ModdleCopy.js
var import_min_dash61 = __toESM(require_dist());
var DISALLOWED_PROPERTIES = [
  "artifacts",
  "dataInputAssociations",
  "dataOutputAssociations",
  "default",
  "flowElements",
  "lanes",
  "incoming",
  "outgoing",
  "categoryValue"
];
function ModdleCopy(eventBus, bpmnFactory, moddle) {
  this._bpmnFactory = bpmnFactory;
  this._eventBus = eventBus;
  this._moddle = moddle;
  eventBus.on("moddleCopy.canCopyProperties", function(context) {
    var propertyNames = context.propertyNames;
    if (!propertyNames || !propertyNames.length) {
      return;
    }
    return (0, import_min_dash61.sortBy)(propertyNames, function(propertyName) {
      return propertyName === "extensionElements";
    });
  });
  eventBus.on("moddleCopy.canCopyProperty", function(context) {
    var parent = context.parent, parentDescriptor = (0, import_min_dash61.isObject)(parent) && parent.$descriptor, propertyName = context.propertyName;
    if (propertyName && DISALLOWED_PROPERTIES.indexOf(propertyName) !== -1) {
      return false;
    }
    if (propertyName && parentDescriptor && !(0, import_min_dash61.find)(parentDescriptor.properties, (0, import_min_dash61.matchPattern)({ name: propertyName }))) {
      return false;
    }
  });
  eventBus.on("moddleCopy.canSetCopiedProperty", function(context) {
    var property = context.property;
    if (is3(property, "bpmn:ExtensionElements") && (!property.values || !property.values.length)) {
      return false;
    }
  });
}
ModdleCopy.$inject = [
  "eventBus",
  "bpmnFactory",
  "moddle"
];
ModdleCopy.prototype.copyElement = function(sourceElement, targetElement, propertyNames, clone2) {
  var self2 = this;
  if (propertyNames && !(0, import_min_dash61.isArray)(propertyNames)) {
    propertyNames = [propertyNames];
  }
  propertyNames = propertyNames || getPropertyNames(sourceElement.$descriptor);
  var canCopyProperties = this._eventBus.fire("moddleCopy.canCopyProperties", {
    propertyNames,
    sourceElement,
    targetElement,
    clone: clone2
  });
  if (canCopyProperties === false) {
    return targetElement;
  }
  if ((0, import_min_dash61.isArray)(canCopyProperties)) {
    propertyNames = canCopyProperties;
  }
  (0, import_min_dash61.forEach)(propertyNames, function(propertyName) {
    var sourceProperty;
    if ((0, import_min_dash61.has)(sourceElement, propertyName)) {
      sourceProperty = sourceElement.get(propertyName);
    }
    var copiedProperty = self2.copyProperty(sourceProperty, targetElement, propertyName, clone2);
    if (!(0, import_min_dash61.isDefined)(copiedProperty)) {
      return;
    }
    var canSetProperty = self2._eventBus.fire("moddleCopy.canSetCopiedProperty", {
      parent: targetElement,
      property: copiedProperty,
      propertyName
    });
    if (canSetProperty === false) {
      return;
    }
    targetElement.set(propertyName, copiedProperty);
  });
  return targetElement;
};
ModdleCopy.prototype.copyProperty = function(property, parent, propertyName, clone2) {
  var self2 = this;
  var copiedProperty = this._eventBus.fire("moddleCopy.canCopyProperty", {
    parent,
    property,
    propertyName,
    clone: clone2
  });
  if (copiedProperty === false) {
    return;
  }
  if (copiedProperty) {
    if ((0, import_min_dash61.isObject)(copiedProperty) && copiedProperty.$type && !copiedProperty.$parent) {
      copiedProperty.$parent = parent;
    }
    return copiedProperty;
  }
  var propertyDescriptor = this._moddle.getPropertyDescriptor(parent, propertyName);
  if (propertyDescriptor.isReference) {
    return;
  }
  if (propertyDescriptor.isId) {
    return property && this._copyId(property, parent, clone2);
  }
  if ((0, import_min_dash61.isArray)(property)) {
    return (0, import_min_dash61.reduce)(property, function(childProperties, childProperty) {
      copiedProperty = self2.copyProperty(childProperty, parent, propertyName, clone2);
      if (copiedProperty) {
        return childProperties.concat(copiedProperty);
      }
      return childProperties;
    }, []);
  }
  if ((0, import_min_dash61.isObject)(property) && property.$type) {
    if (this._moddle.getElementDescriptor(property).isGeneric) {
      return;
    }
    copiedProperty = self2._bpmnFactory.create(property.$type);
    copiedProperty.$parent = parent;
    copiedProperty = self2.copyElement(property, copiedProperty, null, clone2);
    return copiedProperty;
  }
  return property;
};
ModdleCopy.prototype._copyId = function(id, element, clone2) {
  if (clone2) {
    return id;
  }
  if (this._moddle.ids.assigned(id)) {
    return;
  } else {
    this._moddle.ids.claim(id, element);
    return id;
  }
};
function getPropertyNames(descriptor, keepDefaultProperties) {
  return (0, import_min_dash61.reduce)(descriptor.properties, function(properties, property) {
    if (keepDefaultProperties && property.default) {
      return properties;
    }
    return properties.concat(property.name);
  }, []);
}
function is3(element, type) {
  return element && typeof element.$instanceOf === "function" && element.$instanceOf(type);
}

// node_modules/bpmn-js/lib/features/copy-paste/index.js
var copy_paste_default2 = {
  __depends__: [
    copy_paste_default
  ],
  __init__: ["bpmnCopyPaste", "moddleCopy"],
  bpmnCopyPaste: ["type", BpmnCopyPaste],
  moddleCopy: ["type", ModdleCopy]
};

// node_modules/diagram-js/lib/features/replace/Replace.js
var import_min_dash62 = __toESM(require_dist());
var round7 = Math.round;
function Replace(modeling) {
  this._modeling = modeling;
}
Replace.$inject = ["modeling"];
Replace.prototype.replaceElement = function(oldElement, newElementData, options2) {
  if (oldElement.waypoints) {
    return null;
  }
  var modeling = this._modeling;
  var width = newElementData.width || oldElement.width, height = newElementData.height || oldElement.height, x4 = newElementData.x || oldElement.x, y4 = newElementData.y || oldElement.y, centerX = round7(x4 + width / 2), centerY = round7(y4 + height / 2);
  return modeling.replaceShape(oldElement, (0, import_min_dash62.assign)({}, newElementData, {
    x: centerX,
    y: centerY,
    width,
    height
  }), options2);
};

// node_modules/diagram-js/lib/features/replace/index.js
var replace_default = {
  __init__: ["replace"],
  replace: ["type", Replace]
};

// node_modules/bpmn-js/lib/features/replace/BpmnReplace.js
var import_min_dash63 = __toESM(require_dist());
function copyProperties2(source, target, properties) {
  if (!(0, import_min_dash63.isArray)(properties)) {
    properties = [properties];
  }
  (0, import_min_dash63.forEach)(properties, function(property) {
    if (!(0, import_min_dash63.isUndefined)(source[property])) {
      target[property] = source[property];
    }
  });
}
var CUSTOM_PROPERTIES = [
  "cancelActivity",
  "instantiate",
  "eventGatewayType",
  "triggeredByEvent",
  "isInterrupting"
];
function shouldToggleCollapsed(element, targetElement) {
  var oldCollapsed = element && (0, import_min_dash63.has)(element, "collapsed") ? element.collapsed : !isExpanded(element);
  var targetCollapsed;
  if (targetElement && ((0, import_min_dash63.has)(targetElement, "collapsed") || (0, import_min_dash63.has)(targetElement, "isExpanded"))) {
    targetCollapsed = (0, import_min_dash63.has)(targetElement, "collapsed") ? targetElement.collapsed : !targetElement.isExpanded;
  } else {
    targetCollapsed = oldCollapsed;
  }
  if (oldCollapsed !== targetCollapsed) {
    return true;
  }
  return false;
}
function BpmnReplace(bpmnFactory, elementFactory, moddleCopy, modeling, replace, rules, selection) {
  function replaceElement(element, target, hints) {
    hints = hints || {};
    var type = target.type, oldBusinessObject = element.businessObject;
    if (isSubProcess(oldBusinessObject) && type === "bpmn:SubProcess") {
      if (shouldToggleCollapsed(element, target)) {
        modeling.toggleCollapse(element);
        return element;
      }
    }
    var newBusinessObject = bpmnFactory.create(type);
    var newElement = {
      type,
      businessObject: newBusinessObject
    };
    newElement.di = {};
    copyProperties2(element.di, newElement.di, [
      "fill",
      "stroke",
      "background-color",
      "border-color",
      "color"
    ]);
    var elementProps = getPropertyNames(oldBusinessObject.$descriptor), newElementProps = getPropertyNames(newBusinessObject.$descriptor, true), copyProps = intersection(elementProps, newElementProps);
    (0, import_min_dash63.assign)(newBusinessObject, (0, import_min_dash63.pick)(target, CUSTOM_PROPERTIES));
    var properties = (0, import_min_dash63.filter)(copyProps, function(propertyName) {
      if (propertyName === "eventDefinitions") {
        return hasEventDefinition2(element, target.eventDefinitionType);
      }
      if (propertyName === "loopCharacteristics") {
        return !isEventSubProcess(newBusinessObject);
      }
      if ((0, import_min_dash63.has)(newBusinessObject, propertyName)) {
        return false;
      }
      if (propertyName === "processRef" && target.isExpanded === false) {
        return false;
      }
      if (propertyName === "triggeredByEvent") {
        return false;
      }
      return true;
    });
    newBusinessObject = moddleCopy.copyElement(oldBusinessObject, newBusinessObject, properties);
    if (target.eventDefinitionType) {
      if (!hasEventDefinition2(newBusinessObject, target.eventDefinitionType)) {
        newElement.eventDefinitionType = target.eventDefinitionType;
        newElement.eventDefinitionAttrs = target.eventDefinitionAttrs;
      }
    }
    if (is(oldBusinessObject, "bpmn:Activity")) {
      if (isSubProcess(oldBusinessObject)) {
        newElement.isExpanded = isExpanded(element);
      } else if (target && (0, import_min_dash63.has)(target, "isExpanded")) {
        newElement.isExpanded = target.isExpanded;
        var defaultSize = elementFactory.getDefaultSize(newBusinessObject, {
          isExpanded: newElement.isExpanded
        });
        newElement.width = defaultSize.width;
        newElement.height = defaultSize.height;
        newElement.x = element.x - (newElement.width - element.width) / 2;
        newElement.y = element.y - (newElement.height - element.height) / 2;
      }
      if (isExpanded(element) && !is(oldBusinessObject, "bpmn:Task") && newElement.isExpanded) {
        newElement.width = element.width;
        newElement.height = element.height;
      }
    }
    if (isSubProcess(oldBusinessObject) && !isSubProcess(newBusinessObject)) {
      hints.moveChildren = false;
    }
    if (is(oldBusinessObject, "bpmn:Participant")) {
      if (target.isExpanded === true) {
        newBusinessObject.processRef = bpmnFactory.create("bpmn:Process");
      } else {
        hints.moveChildren = false;
      }
      newElement.width = element.width;
      newElement.height = elementFactory.getDefaultSize(newElement).height;
    }
    if (!rules.allowed("shape.resize", { shape: newBusinessObject })) {
      newElement.height = elementFactory.getDefaultSize(newElement).height;
      newElement.width = elementFactory.getDefaultSize(newElement).width;
    }
    newBusinessObject.name = oldBusinessObject.name;
    if (isAny(oldBusinessObject, [
      "bpmn:ExclusiveGateway",
      "bpmn:InclusiveGateway",
      "bpmn:Activity"
    ]) && isAny(newBusinessObject, [
      "bpmn:ExclusiveGateway",
      "bpmn:InclusiveGateway",
      "bpmn:Activity"
    ])) {
      newBusinessObject.default = oldBusinessObject.default;
    }
    if (target.host && !is(oldBusinessObject, "bpmn:BoundaryEvent") && is(newBusinessObject, "bpmn:BoundaryEvent")) {
      newElement.host = target.host;
    }
    if (newElement.type === "bpmn:DataStoreReference" || newElement.type === "bpmn:DataObjectReference") {
      newElement.x = element.x + (element.width - newElement.width) / 2;
    }
    newElement = replace.replaceElement(element, newElement, hints);
    if (hints.select !== false) {
      selection.select(newElement);
    }
    return newElement;
  }
  this.replaceElement = replaceElement;
}
BpmnReplace.$inject = [
  "bpmnFactory",
  "elementFactory",
  "moddleCopy",
  "modeling",
  "replace",
  "rules",
  "selection"
];
function isSubProcess(bo) {
  return is(bo, "bpmn:SubProcess");
}
function hasEventDefinition2(element, type) {
  var bo = getBusinessObject(element);
  return type && bo.get("eventDefinitions").some(function(definition) {
    return is(definition, type);
  });
}
function intersection(a1, a22) {
  return a1.filter(function(el) {
    return a22.indexOf(el) !== -1;
  });
}

// node_modules/bpmn-js/lib/features/replace/index.js
var replace_default2 = {
  __depends__: [
    copy_paste_default2,
    replace_default,
    selection_default
  ],
  bpmnReplace: ["type", BpmnReplace]
};

// node_modules/bpmn-js/lib/features/popup-menu/util/TypeUtil.js
function isDifferentType(element) {
  return function(entry) {
    var target = entry.target;
    var businessObject = getBusinessObject(element), eventDefinition = businessObject.eventDefinitions && businessObject.eventDefinitions[0];
    var isTypeEqual = businessObject.$type === target.type;
    var isEventDefinitionEqual = (eventDefinition && eventDefinition.$type) === target.eventDefinitionType;
    var isTriggeredByEventEqual = !!target.triggeredByEvent === !!businessObject.triggeredByEvent;
    var isExpandedEqual = target.isExpanded === void 0 || target.isExpanded === isExpanded(element);
    return !isTypeEqual || !isEventDefinitionEqual || !isTriggeredByEventEqual || !isExpandedEqual;
  };
}

// node_modules/bpmn-js/lib/features/popup-menu/ReplaceMenuProvider.js
var import_min_dash64 = __toESM(require_dist());

// node_modules/bpmn-js/lib/features/replace/ReplaceOptions.js
var START_EVENT = [
  {
    label: "Start Event",
    actionName: "replace-with-none-start",
    className: "bpmn-icon-start-event-none",
    target: {
      type: "bpmn:StartEvent"
    }
  },
  {
    label: "Intermediate Throw Event",
    actionName: "replace-with-none-intermediate-throwing",
    className: "bpmn-icon-intermediate-event-none",
    target: {
      type: "bpmn:IntermediateThrowEvent"
    }
  },
  {
    label: "End Event",
    actionName: "replace-with-none-end",
    className: "bpmn-icon-end-event-none",
    target: {
      type: "bpmn:EndEvent"
    }
  },
  {
    label: "Message Start Event",
    actionName: "replace-with-message-start",
    className: "bpmn-icon-start-event-message",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Timer Start Event",
    actionName: "replace-with-timer-start",
    className: "bpmn-icon-start-event-timer",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition"
    }
  },
  {
    label: "Conditional Start Event",
    actionName: "replace-with-conditional-start",
    className: "bpmn-icon-start-event-condition",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition"
    }
  },
  {
    label: "Signal Start Event",
    actionName: "replace-with-signal-start",
    className: "bpmn-icon-start-event-signal",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  }
];
var START_EVENT_SUB_PROCESS = [
  {
    label: "Start Event",
    actionName: "replace-with-none-start",
    className: "bpmn-icon-start-event-none",
    target: {
      type: "bpmn:StartEvent"
    }
  },
  {
    label: "Intermediate Throw Event",
    actionName: "replace-with-none-intermediate-throwing",
    className: "bpmn-icon-intermediate-event-none",
    target: {
      type: "bpmn:IntermediateThrowEvent"
    }
  },
  {
    label: "End Event",
    actionName: "replace-with-none-end",
    className: "bpmn-icon-end-event-none",
    target: {
      type: "bpmn:EndEvent"
    }
  }
];
var INTERMEDIATE_EVENT = [
  {
    label: "Start Event",
    actionName: "replace-with-none-start",
    className: "bpmn-icon-start-event-none",
    target: {
      type: "bpmn:StartEvent"
    }
  },
  {
    label: "Intermediate Throw Event",
    actionName: "replace-with-none-intermediate-throw",
    className: "bpmn-icon-intermediate-event-none",
    target: {
      type: "bpmn:IntermediateThrowEvent"
    }
  },
  {
    label: "End Event",
    actionName: "replace-with-none-end",
    className: "bpmn-icon-end-event-none",
    target: {
      type: "bpmn:EndEvent"
    }
  },
  {
    label: "Message Intermediate Catch Event",
    actionName: "replace-with-message-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-message",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Message Intermediate Throw Event",
    actionName: "replace-with-message-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-message",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Timer Intermediate Catch Event",
    actionName: "replace-with-timer-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-timer",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition"
    }
  },
  {
    label: "Escalation Intermediate Throw Event",
    actionName: "replace-with-escalation-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-escalation",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition"
    }
  },
  {
    label: "Conditional Intermediate Catch Event",
    actionName: "replace-with-conditional-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-condition",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition"
    }
  },
  {
    label: "Link Intermediate Catch Event",
    actionName: "replace-with-link-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-link",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:LinkEventDefinition",
      eventDefinitionAttrs: {
        name: ""
      }
    }
  },
  {
    label: "Link Intermediate Throw Event",
    actionName: "replace-with-link-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-link",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:LinkEventDefinition",
      eventDefinitionAttrs: {
        name: ""
      }
    }
  },
  {
    label: "Compensation Intermediate Throw Event",
    actionName: "replace-with-compensation-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-compensation",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:CompensateEventDefinition"
    }
  },
  {
    label: "Signal Intermediate Catch Event",
    actionName: "replace-with-signal-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-signal",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  },
  {
    label: "Signal Intermediate Throw Event",
    actionName: "replace-with-signal-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-signal",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  }
];
var END_EVENT = [
  {
    label: "Start Event",
    actionName: "replace-with-none-start",
    className: "bpmn-icon-start-event-none",
    target: {
      type: "bpmn:StartEvent"
    }
  },
  {
    label: "Intermediate Throw Event",
    actionName: "replace-with-none-intermediate-throw",
    className: "bpmn-icon-intermediate-event-none",
    target: {
      type: "bpmn:IntermediateThrowEvent"
    }
  },
  {
    label: "End Event",
    actionName: "replace-with-none-end",
    className: "bpmn-icon-end-event-none",
    target: {
      type: "bpmn:EndEvent"
    }
  },
  {
    label: "Message End Event",
    actionName: "replace-with-message-end",
    className: "bpmn-icon-end-event-message",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Escalation End Event",
    actionName: "replace-with-escalation-end",
    className: "bpmn-icon-end-event-escalation",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition"
    }
  },
  {
    label: "Error End Event",
    actionName: "replace-with-error-end",
    className: "bpmn-icon-end-event-error",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:ErrorEventDefinition"
    }
  },
  {
    label: "Cancel End Event",
    actionName: "replace-with-cancel-end",
    className: "bpmn-icon-end-event-cancel",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:CancelEventDefinition"
    }
  },
  {
    label: "Compensation End Event",
    actionName: "replace-with-compensation-end",
    className: "bpmn-icon-end-event-compensation",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:CompensateEventDefinition"
    }
  },
  {
    label: "Signal End Event",
    actionName: "replace-with-signal-end",
    className: "bpmn-icon-end-event-signal",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  },
  {
    label: "Terminate End Event",
    actionName: "replace-with-terminate-end",
    className: "bpmn-icon-end-event-terminate",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:TerminateEventDefinition"
    }
  }
];
var GATEWAY = [
  {
    label: "Exclusive Gateway",
    actionName: "replace-with-exclusive-gateway",
    className: "bpmn-icon-gateway-xor",
    target: {
      type: "bpmn:ExclusiveGateway"
    }
  },
  {
    label: "Parallel Gateway",
    actionName: "replace-with-parallel-gateway",
    className: "bpmn-icon-gateway-parallel",
    target: {
      type: "bpmn:ParallelGateway"
    }
  },
  {
    label: "Inclusive Gateway",
    actionName: "replace-with-inclusive-gateway",
    className: "bpmn-icon-gateway-or",
    target: {
      type: "bpmn:InclusiveGateway"
    }
  },
  {
    label: "Complex Gateway",
    actionName: "replace-with-complex-gateway",
    className: "bpmn-icon-gateway-complex",
    target: {
      type: "bpmn:ComplexGateway"
    }
  },
  {
    label: "Event based Gateway",
    actionName: "replace-with-event-based-gateway",
    className: "bpmn-icon-gateway-eventbased",
    target: {
      type: "bpmn:EventBasedGateway",
      instantiate: false,
      eventGatewayType: "Exclusive"
    }
  }
];
var SUBPROCESS_EXPANDED = [
  {
    label: "Transaction",
    actionName: "replace-with-transaction",
    className: "bpmn-icon-transaction",
    target: {
      type: "bpmn:Transaction",
      isExpanded: true
    }
  },
  {
    label: "Event Sub Process",
    actionName: "replace-with-event-subprocess",
    className: "bpmn-icon-event-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      triggeredByEvent: true,
      isExpanded: true
    }
  },
  {
    label: "Sub Process (collapsed)",
    actionName: "replace-with-collapsed-subprocess",
    className: "bpmn-icon-subprocess-collapsed",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: false
    }
  }
];
var TRANSACTION = [
  {
    label: "Transaction",
    actionName: "replace-with-transaction",
    className: "bpmn-icon-transaction",
    target: {
      type: "bpmn:Transaction",
      isExpanded: true
    }
  },
  {
    label: "Sub Process",
    actionName: "replace-with-subprocess",
    className: "bpmn-icon-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: true
    }
  },
  {
    label: "Event Sub Process",
    actionName: "replace-with-event-subprocess",
    className: "bpmn-icon-event-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      triggeredByEvent: true,
      isExpanded: true
    }
  }
];
var EVENT_SUB_PROCESS = TRANSACTION;
var TASK = [
  {
    label: "Task",
    actionName: "replace-with-task",
    className: "bpmn-icon-task",
    target: {
      type: "bpmn:Task"
    }
  },
  {
    label: "Send Task",
    actionName: "replace-with-send-task",
    className: "bpmn-icon-send",
    target: {
      type: "bpmn:SendTask"
    }
  },
  {
    label: "Receive Task",
    actionName: "replace-with-receive-task",
    className: "bpmn-icon-receive",
    target: {
      type: "bpmn:ReceiveTask"
    }
  },
  {
    label: "User Task",
    actionName: "replace-with-user-task",
    className: "bpmn-icon-user",
    target: {
      type: "bpmn:UserTask"
    }
  },
  {
    label: "Manual Task",
    actionName: "replace-with-manual-task",
    className: "bpmn-icon-manual",
    target: {
      type: "bpmn:ManualTask"
    }
  },
  {
    label: "Business Rule Task",
    actionName: "replace-with-rule-task",
    className: "bpmn-icon-business-rule",
    target: {
      type: "bpmn:BusinessRuleTask"
    }
  },
  {
    label: "Service Task",
    actionName: "replace-with-service-task",
    className: "bpmn-icon-service",
    target: {
      type: "bpmn:ServiceTask"
    }
  },
  {
    label: "Script Task",
    actionName: "replace-with-script-task",
    className: "bpmn-icon-script",
    target: {
      type: "bpmn:ScriptTask"
    }
  },
  {
    label: "Call Activity",
    actionName: "replace-with-call-activity",
    className: "bpmn-icon-call-activity",
    target: {
      type: "bpmn:CallActivity"
    }
  },
  {
    label: "Sub Process (collapsed)",
    actionName: "replace-with-collapsed-subprocess",
    className: "bpmn-icon-subprocess-collapsed",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: false
    }
  },
  {
    label: "Sub Process (expanded)",
    actionName: "replace-with-expanded-subprocess",
    className: "bpmn-icon-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: true
    }
  }
];
var DATA_OBJECT_REFERENCE = [
  {
    label: "Data Store Reference",
    actionName: "replace-with-data-store-reference",
    className: "bpmn-icon-data-store",
    target: {
      type: "bpmn:DataStoreReference"
    }
  }
];
var DATA_STORE_REFERENCE = [
  {
    label: "Data Object Reference",
    actionName: "replace-with-data-object-reference",
    className: "bpmn-icon-data-object",
    target: {
      type: "bpmn:DataObjectReference"
    }
  }
];
var BOUNDARY_EVENT = [
  {
    label: "Message Boundary Event",
    actionName: "replace-with-message-boundary",
    className: "bpmn-icon-intermediate-event-catch-message",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Timer Boundary Event",
    actionName: "replace-with-timer-boundary",
    className: "bpmn-icon-intermediate-event-catch-timer",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition"
    }
  },
  {
    label: "Escalation Boundary Event",
    actionName: "replace-with-escalation-boundary",
    className: "bpmn-icon-intermediate-event-catch-escalation",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition"
    }
  },
  {
    label: "Conditional Boundary Event",
    actionName: "replace-with-conditional-boundary",
    className: "bpmn-icon-intermediate-event-catch-condition",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition"
    }
  },
  {
    label: "Error Boundary Event",
    actionName: "replace-with-error-boundary",
    className: "bpmn-icon-intermediate-event-catch-error",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:ErrorEventDefinition"
    }
  },
  {
    label: "Cancel Boundary Event",
    actionName: "replace-with-cancel-boundary",
    className: "bpmn-icon-intermediate-event-catch-cancel",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:CancelEventDefinition"
    }
  },
  {
    label: "Signal Boundary Event",
    actionName: "replace-with-signal-boundary",
    className: "bpmn-icon-intermediate-event-catch-signal",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  },
  {
    label: "Compensation Boundary Event",
    actionName: "replace-with-compensation-boundary",
    className: "bpmn-icon-intermediate-event-catch-compensation",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:CompensateEventDefinition"
    }
  },
  {
    label: "Message Boundary Event (non-interrupting)",
    actionName: "replace-with-non-interrupting-message-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-message",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition",
      cancelActivity: false
    }
  },
  {
    label: "Timer Boundary Event (non-interrupting)",
    actionName: "replace-with-non-interrupting-timer-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-timer",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition",
      cancelActivity: false
    }
  },
  {
    label: "Escalation Boundary Event (non-interrupting)",
    actionName: "replace-with-non-interrupting-escalation-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-escalation",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition",
      cancelActivity: false
    }
  },
  {
    label: "Conditional Boundary Event (non-interrupting)",
    actionName: "replace-with-non-interrupting-conditional-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-condition",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition",
      cancelActivity: false
    }
  },
  {
    label: "Signal Boundary Event (non-interrupting)",
    actionName: "replace-with-non-interrupting-signal-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-signal",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition",
      cancelActivity: false
    }
  }
];
var EVENT_SUB_PROCESS_START_EVENT = [
  {
    label: "Message Start Event",
    actionName: "replace-with-message-start",
    className: "bpmn-icon-start-event-message",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Timer Start Event",
    actionName: "replace-with-timer-start",
    className: "bpmn-icon-start-event-timer",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition"
    }
  },
  {
    label: "Conditional Start Event",
    actionName: "replace-with-conditional-start",
    className: "bpmn-icon-start-event-condition",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition"
    }
  },
  {
    label: "Signal Start Event",
    actionName: "replace-with-signal-start",
    className: "bpmn-icon-start-event-signal",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  },
  {
    label: "Error Start Event",
    actionName: "replace-with-error-start",
    className: "bpmn-icon-start-event-error",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:ErrorEventDefinition"
    }
  },
  {
    label: "Escalation Start Event",
    actionName: "replace-with-escalation-start",
    className: "bpmn-icon-start-event-escalation",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition"
    }
  },
  {
    label: "Compensation Start Event",
    actionName: "replace-with-compensation-start",
    className: "bpmn-icon-start-event-compensation",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:CompensateEventDefinition"
    }
  },
  {
    label: "Message Start Event (non-interrupting)",
    actionName: "replace-with-non-interrupting-message-start",
    className: "bpmn-icon-start-event-non-interrupting-message",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition",
      isInterrupting: false
    }
  },
  {
    label: "Timer Start Event (non-interrupting)",
    actionName: "replace-with-non-interrupting-timer-start",
    className: "bpmn-icon-start-event-non-interrupting-timer",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition",
      isInterrupting: false
    }
  },
  {
    label: "Conditional Start Event (non-interrupting)",
    actionName: "replace-with-non-interrupting-conditional-start",
    className: "bpmn-icon-start-event-non-interrupting-condition",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition",
      isInterrupting: false
    }
  },
  {
    label: "Signal Start Event (non-interrupting)",
    actionName: "replace-with-non-interrupting-signal-start",
    className: "bpmn-icon-start-event-non-interrupting-signal",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition",
      isInterrupting: false
    }
  },
  {
    label: "Escalation Start Event (non-interrupting)",
    actionName: "replace-with-non-interrupting-escalation-start",
    className: "bpmn-icon-start-event-non-interrupting-escalation",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition",
      isInterrupting: false
    }
  }
];
var SEQUENCE_FLOW = [
  {
    label: "Sequence Flow",
    actionName: "replace-with-sequence-flow",
    className: "bpmn-icon-connection"
  },
  {
    label: "Default Flow",
    actionName: "replace-with-default-flow",
    className: "bpmn-icon-default-flow"
  },
  {
    label: "Conditional Flow",
    actionName: "replace-with-conditional-flow",
    className: "bpmn-icon-conditional-flow"
  }
];
var PARTICIPANT = [
  {
    label: "Expanded Pool",
    actionName: "replace-with-expanded-pool",
    className: "bpmn-icon-participant",
    target: {
      type: "bpmn:Participant",
      isExpanded: true
    }
  },
  {
    label: function(element) {
      var label = "Empty Pool";
      if (element.children && element.children.length) {
        label += " (removes content)";
      }
      return label;
    },
    actionName: "replace-with-collapsed-pool",
    className: "bpmn-icon-lane",
    target: {
      type: "bpmn:Participant",
      isExpanded: false
    }
  }
];

// node_modules/bpmn-js/lib/features/popup-menu/ReplaceMenuProvider.js
function ReplaceMenuProvider(bpmnFactory, popupMenu, modeling, moddle, bpmnReplace, rules, translate3) {
  this._bpmnFactory = bpmnFactory;
  this._popupMenu = popupMenu;
  this._modeling = modeling;
  this._moddle = moddle;
  this._bpmnReplace = bpmnReplace;
  this._rules = rules;
  this._translate = translate3;
  this.register();
}
ReplaceMenuProvider.$inject = [
  "bpmnFactory",
  "popupMenu",
  "modeling",
  "moddle",
  "bpmnReplace",
  "rules",
  "translate"
];
ReplaceMenuProvider.prototype.register = function() {
  this._popupMenu.registerProvider("bpmn-replace", this);
};
ReplaceMenuProvider.prototype.getEntries = function(element) {
  var businessObject = element.businessObject;
  var rules = this._rules;
  var entries;
  if (!rules.allowed("shape.replace", { element })) {
    return [];
  }
  var differentType = isDifferentType(element);
  if (is(businessObject, "bpmn:DataObjectReference")) {
    return this._createEntries(element, DATA_OBJECT_REFERENCE);
  }
  if (is(businessObject, "bpmn:DataStoreReference") && !is(element.parent, "bpmn:Collaboration")) {
    return this._createEntries(element, DATA_STORE_REFERENCE);
  }
  if (is(businessObject, "bpmn:StartEvent") && !is(businessObject.$parent, "bpmn:SubProcess")) {
    entries = (0, import_min_dash64.filter)(START_EVENT, differentType);
    return this._createEntries(element, entries);
  }
  if (is(businessObject, "bpmn:Participant")) {
    entries = (0, import_min_dash64.filter)(PARTICIPANT, function(entry) {
      return isExpanded(element) !== entry.target.isExpanded;
    });
    return this._createEntries(element, entries);
  }
  if (is(businessObject, "bpmn:StartEvent") && isEventSubProcess(businessObject.$parent)) {
    entries = (0, import_min_dash64.filter)(EVENT_SUB_PROCESS_START_EVENT, function(entry) {
      var target = entry.target;
      var isInterrupting2 = target.isInterrupting !== false;
      var isInterruptingEqual = getBusinessObject(element).isInterrupting === isInterrupting2;
      return differentType(entry) || !differentType(entry) && !isInterruptingEqual;
    });
    return this._createEntries(element, entries);
  }
  if (is(businessObject, "bpmn:StartEvent") && !isEventSubProcess(businessObject.$parent) && is(businessObject.$parent, "bpmn:SubProcess")) {
    entries = (0, import_min_dash64.filter)(START_EVENT_SUB_PROCESS, differentType);
    return this._createEntries(element, entries);
  }
  if (is(businessObject, "bpmn:EndEvent")) {
    entries = (0, import_min_dash64.filter)(END_EVENT, function(entry) {
      var target = entry.target;
      if (target.eventDefinitionType == "bpmn:CancelEventDefinition" && !is(businessObject.$parent, "bpmn:Transaction")) {
        return false;
      }
      return differentType(entry);
    });
    return this._createEntries(element, entries);
  }
  if (is(businessObject, "bpmn:BoundaryEvent")) {
    entries = (0, import_min_dash64.filter)(BOUNDARY_EVENT, function(entry) {
      var target = entry.target;
      if (target.eventDefinitionType == "bpmn:CancelEventDefinition" && !is(businessObject.attachedToRef, "bpmn:Transaction")) {
        return false;
      }
      var cancelActivity = target.cancelActivity !== false;
      var isCancelActivityEqual = businessObject.cancelActivity == cancelActivity;
      return differentType(entry) || !differentType(entry) && !isCancelActivityEqual;
    });
    return this._createEntries(element, entries);
  }
  if (is(businessObject, "bpmn:IntermediateCatchEvent") || is(businessObject, "bpmn:IntermediateThrowEvent")) {
    entries = (0, import_min_dash64.filter)(INTERMEDIATE_EVENT, differentType);
    return this._createEntries(element, entries);
  }
  if (is(businessObject, "bpmn:Gateway")) {
    entries = (0, import_min_dash64.filter)(GATEWAY, differentType);
    return this._createEntries(element, entries);
  }
  if (is(businessObject, "bpmn:Transaction")) {
    entries = (0, import_min_dash64.filter)(TRANSACTION, differentType);
    return this._createEntries(element, entries);
  }
  if (isEventSubProcess(businessObject) && isExpanded(element)) {
    entries = (0, import_min_dash64.filter)(EVENT_SUB_PROCESS, differentType);
    return this._createEntries(element, entries);
  }
  if (is(businessObject, "bpmn:SubProcess") && isExpanded(element)) {
    entries = (0, import_min_dash64.filter)(SUBPROCESS_EXPANDED, differentType);
    return this._createEntries(element, entries);
  }
  if (is(businessObject, "bpmn:AdHocSubProcess") && !isExpanded(element)) {
    entries = (0, import_min_dash64.filter)(TASK, function(entry) {
      var target = entry.target;
      var isTargetSubProcess = target.type === "bpmn:SubProcess";
      var isTargetExpanded = target.isExpanded === true;
      return isDifferentType(element, target) && (!isTargetSubProcess || isTargetExpanded);
    });
    return this._createEntries(element, entries);
  }
  if (is(businessObject, "bpmn:SequenceFlow")) {
    return this._createSequenceFlowEntries(element, SEQUENCE_FLOW);
  }
  if (is(businessObject, "bpmn:FlowNode")) {
    entries = (0, import_min_dash64.filter)(TASK, differentType);
    if (is(businessObject, "bpmn:SubProcess") && !isExpanded(element)) {
      entries = (0, import_min_dash64.filter)(entries, function(entry) {
        return entry.label !== "Sub Process (collapsed)";
      });
    }
    return this._createEntries(element, entries);
  }
  return [];
};
ReplaceMenuProvider.prototype.getHeaderEntries = function(element) {
  var headerEntries = [];
  if (is(element, "bpmn:Activity") && !isEventSubProcess(element)) {
    headerEntries = headerEntries.concat(this._getLoopEntries(element));
  }
  if (is(element, "bpmn:DataObjectReference")) {
    headerEntries = headerEntries.concat(this._getDataObjectIsCollection(element));
  }
  if (is(element, "bpmn:Participant")) {
    headerEntries = headerEntries.concat(this._getParticipantMultiplicity(element));
  }
  if (is(element, "bpmn:SubProcess") && !is(element, "bpmn:Transaction") && !isEventSubProcess(element)) {
    headerEntries.push(this._getAdHocEntry(element));
  }
  return headerEntries;
};
ReplaceMenuProvider.prototype._createEntries = function(element, replaceOptions) {
  var menuEntries = [];
  var self2 = this;
  (0, import_min_dash64.forEach)(replaceOptions, function(definition) {
    var entry = self2._createMenuEntry(definition, element);
    menuEntries.push(entry);
  });
  return menuEntries;
};
ReplaceMenuProvider.prototype._createSequenceFlowEntries = function(element, replaceOptions) {
  var businessObject = getBusinessObject(element);
  var menuEntries = [];
  var modeling = this._modeling, moddle = this._moddle;
  var self2 = this;
  (0, import_min_dash64.forEach)(replaceOptions, function(entry) {
    switch (entry.actionName) {
      case "replace-with-default-flow":
        if (businessObject.sourceRef.default !== businessObject && (is(businessObject.sourceRef, "bpmn:ExclusiveGateway") || is(businessObject.sourceRef, "bpmn:InclusiveGateway") || is(businessObject.sourceRef, "bpmn:ComplexGateway") || is(businessObject.sourceRef, "bpmn:Activity"))) {
          menuEntries.push(self2._createMenuEntry(entry, element, function() {
            modeling.updateProperties(element.source, { default: businessObject });
          }));
        }
        break;
      case "replace-with-conditional-flow":
        if (!businessObject.conditionExpression && is(businessObject.sourceRef, "bpmn:Activity")) {
          menuEntries.push(self2._createMenuEntry(entry, element, function() {
            var conditionExpression = moddle.create("bpmn:FormalExpression", { body: "" });
            modeling.updateProperties(element, { conditionExpression });
          }));
        }
        break;
      default:
        if (is(businessObject.sourceRef, "bpmn:Activity") && businessObject.conditionExpression) {
          return menuEntries.push(self2._createMenuEntry(entry, element, function() {
            modeling.updateProperties(element, { conditionExpression: void 0 });
          }));
        }
        if ((is(businessObject.sourceRef, "bpmn:ExclusiveGateway") || is(businessObject.sourceRef, "bpmn:InclusiveGateway") || is(businessObject.sourceRef, "bpmn:ComplexGateway") || is(businessObject.sourceRef, "bpmn:Activity")) && businessObject.sourceRef.default === businessObject) {
          return menuEntries.push(self2._createMenuEntry(entry, element, function() {
            modeling.updateProperties(element.source, { default: void 0 });
          }));
        }
    }
  });
  return menuEntries;
};
ReplaceMenuProvider.prototype._createMenuEntry = function(definition, element, action) {
  var translate3 = this._translate;
  var replaceElement = this._bpmnReplace.replaceElement;
  var replaceAction = function() {
    return replaceElement(element, definition.target);
  };
  var label = definition.label;
  if (label && typeof label === "function") {
    label = label(element);
  }
  action = action || replaceAction;
  var menuEntry = {
    label: translate3(label),
    className: definition.className,
    id: definition.actionName,
    action
  };
  return menuEntry;
};
ReplaceMenuProvider.prototype._getLoopEntries = function(element) {
  var self2 = this;
  var translate3 = this._translate;
  function toggleLoopEntry(event2, entry) {
    var newLoopCharacteristics = getBusinessObject(element).loopCharacteristics;
    if (entry.active) {
      newLoopCharacteristics = void 0;
    } else {
      if ((0, import_min_dash64.isUndefined)(entry.options.isSequential) || !newLoopCharacteristics || !is(newLoopCharacteristics, entry.options.loopCharacteristics)) {
        newLoopCharacteristics = self2._moddle.create(entry.options.loopCharacteristics);
      }
      newLoopCharacteristics.isSequential = entry.options.isSequential;
    }
    self2._modeling.updateProperties(element, { loopCharacteristics: newLoopCharacteristics });
  }
  var businessObject = getBusinessObject(element), loopCharacteristics = businessObject.loopCharacteristics;
  var isSequential, isLoop, isParallel;
  if (loopCharacteristics) {
    isSequential = loopCharacteristics.isSequential;
    isLoop = loopCharacteristics.isSequential === void 0;
    isParallel = loopCharacteristics.isSequential !== void 0 && !loopCharacteristics.isSequential;
  }
  var loopEntries = [
    {
      id: "toggle-parallel-mi",
      className: "bpmn-icon-parallel-mi-marker",
      title: translate3("Parallel Multi Instance"),
      active: isParallel,
      action: toggleLoopEntry,
      options: {
        loopCharacteristics: "bpmn:MultiInstanceLoopCharacteristics",
        isSequential: false
      }
    },
    {
      id: "toggle-sequential-mi",
      className: "bpmn-icon-sequential-mi-marker",
      title: translate3("Sequential Multi Instance"),
      active: isSequential,
      action: toggleLoopEntry,
      options: {
        loopCharacteristics: "bpmn:MultiInstanceLoopCharacteristics",
        isSequential: true
      }
    },
    {
      id: "toggle-loop",
      className: "bpmn-icon-loop-marker",
      title: translate3("Loop"),
      active: isLoop,
      action: toggleLoopEntry,
      options: {
        loopCharacteristics: "bpmn:StandardLoopCharacteristics"
      }
    }
  ];
  return loopEntries;
};
ReplaceMenuProvider.prototype._getDataObjectIsCollection = function(element) {
  var self2 = this;
  var translate3 = this._translate;
  function toggleIsCollection(event2, entry) {
    self2._modeling.updateModdleProperties(element, dataObject, { isCollection: !entry.active });
  }
  var dataObject = element.businessObject.dataObjectRef, isCollection2 = dataObject.isCollection;
  var dataObjectEntries = [
    {
      id: "toggle-is-collection",
      className: "bpmn-icon-parallel-mi-marker",
      title: translate3("Collection"),
      active: isCollection2,
      action: toggleIsCollection
    }
  ];
  return dataObjectEntries;
};
ReplaceMenuProvider.prototype._getParticipantMultiplicity = function(element) {
  var self2 = this;
  var bpmnFactory = this._bpmnFactory;
  var translate3 = this._translate;
  function toggleParticipantMultiplicity(event2, entry) {
    var isActive = entry.active;
    var participantMultiplicity2;
    if (!isActive) {
      participantMultiplicity2 = bpmnFactory.create("bpmn:ParticipantMultiplicity");
    }
    self2._modeling.updateProperties(element, { participantMultiplicity: participantMultiplicity2 });
  }
  var participantMultiplicity = element.businessObject.participantMultiplicity;
  var participantEntries = [
    {
      id: "toggle-participant-multiplicity",
      className: "bpmn-icon-parallel-mi-marker",
      title: translate3("Participant Multiplicity"),
      active: !!participantMultiplicity,
      action: toggleParticipantMultiplicity
    }
  ];
  return participantEntries;
};
ReplaceMenuProvider.prototype._getAdHocEntry = function(element) {
  var translate3 = this._translate;
  var businessObject = getBusinessObject(element);
  var isAdHoc = is(businessObject, "bpmn:AdHocSubProcess");
  var replaceElement = this._bpmnReplace.replaceElement;
  var adHocEntry = {
    id: "toggle-adhoc",
    className: "bpmn-icon-ad-hoc-marker",
    title: translate3("Ad-hoc"),
    active: isAdHoc,
    action: function(event2, entry) {
      if (isAdHoc) {
        return replaceElement(element, { type: "bpmn:SubProcess" }, {
          autoResize: false,
          layoutConnection: false
        });
      } else {
        return replaceElement(element, { type: "bpmn:AdHocSubProcess" }, {
          autoResize: false,
          layoutConnection: false
        });
      }
    }
  };
  return adHocEntry;
};

// node_modules/bpmn-js/lib/features/popup-menu/index.js
var popup_menu_default2 = {
  __depends__: [
    popup_menu_default,
    replace_default2
  ],
  __init__: ["replaceMenuProvider"],
  replaceMenuProvider: ["type", ReplaceMenuProvider]
};

// node_modules/bpmn-js/lib/features/context-pad/ContextPadProvider.js
var import_min_dash66 = __toESM(require_dist());

// node_modules/diagram-js/lib/features/resize/ResizeUtil.js
var import_min_dash65 = __toESM(require_dist());
var max3 = Math.max;
var min2 = Math.min;
var DEFAULT_CHILD_BOX_PADDING = 20;
function substractTRBL(trblA, trblB) {
  return {
    top: trblA.top - trblB.top,
    right: trblA.right - trblB.right,
    bottom: trblA.bottom - trblB.bottom,
    left: trblA.left - trblB.left
  };
}
function resizeBounds(bounds, direction, delta2) {
  var dx = delta2.x, dy = delta2.y;
  var newBounds = {
    x: bounds.x,
    y: bounds.y,
    width: bounds.width,
    height: bounds.height
  };
  if (direction.indexOf("n") !== -1) {
    newBounds.y = bounds.y + dy;
    newBounds.height = bounds.height - dy;
  } else if (direction.indexOf("s") !== -1) {
    newBounds.height = bounds.height + dy;
  }
  if (direction.indexOf("e") !== -1) {
    newBounds.width = bounds.width + dx;
  } else if (direction.indexOf("w") !== -1) {
    newBounds.x = bounds.x + dx;
    newBounds.width = bounds.width - dx;
  }
  return newBounds;
}
function resizeTRBL(bounds, resize) {
  return {
    x: bounds.x + (resize.left || 0),
    y: bounds.y + (resize.top || 0),
    width: bounds.width - (resize.left || 0) + (resize.right || 0),
    height: bounds.height - (resize.top || 0) + (resize.bottom || 0)
  };
}
function applyConstraints(attr3, trbl, resizeConstraints) {
  var value = trbl[attr3], minValue = resizeConstraints.min && resizeConstraints.min[attr3], maxValue = resizeConstraints.max && resizeConstraints.max[attr3];
  if ((0, import_min_dash65.isNumber)(minValue)) {
    value = (/top|left/.test(attr3) ? min2 : max3)(value, minValue);
  }
  if ((0, import_min_dash65.isNumber)(maxValue)) {
    value = (/top|left/.test(attr3) ? max3 : min2)(value, maxValue);
  }
  return value;
}
function ensureConstraints2(currentBounds, resizeConstraints) {
  if (!resizeConstraints) {
    return currentBounds;
  }
  var currentTrbl = asTRBL(currentBounds);
  return asBounds({
    top: applyConstraints("top", currentTrbl, resizeConstraints),
    right: applyConstraints("right", currentTrbl, resizeConstraints),
    bottom: applyConstraints("bottom", currentTrbl, resizeConstraints),
    left: applyConstraints("left", currentTrbl, resizeConstraints)
  });
}
function getMinResizeBounds(direction, currentBounds, minDimensions, childrenBounds) {
  var currentBox = asTRBL(currentBounds);
  var minBox = {
    top: /n/.test(direction) ? currentBox.bottom - minDimensions.height : currentBox.top,
    left: /w/.test(direction) ? currentBox.right - minDimensions.width : currentBox.left,
    bottom: /s/.test(direction) ? currentBox.top + minDimensions.height : currentBox.bottom,
    right: /e/.test(direction) ? currentBox.left + minDimensions.width : currentBox.right
  };
  var childrenBox = childrenBounds ? asTRBL(childrenBounds) : minBox;
  var combinedBox = {
    top: min2(minBox.top, childrenBox.top),
    left: min2(minBox.left, childrenBox.left),
    bottom: max3(minBox.bottom, childrenBox.bottom),
    right: max3(minBox.right, childrenBox.right)
  };
  return asBounds(combinedBox);
}
function asPadding(mayBePadding, defaultValue) {
  if (typeof mayBePadding !== "undefined") {
    return mayBePadding;
  } else {
    return DEFAULT_CHILD_BOX_PADDING;
  }
}
function addPadding(bbox, padding) {
  var left, right, top, bottom;
  if (typeof padding === "object") {
    left = asPadding(padding.left);
    right = asPadding(padding.right);
    top = asPadding(padding.top);
    bottom = asPadding(padding.bottom);
  } else {
    left = right = top = bottom = asPadding(padding);
  }
  return {
    x: bbox.x - left,
    y: bbox.y - top,
    width: bbox.width + left + right,
    height: bbox.height + top + bottom
  };
}
function isBBoxChild(element) {
  if (element.waypoints) {
    return false;
  }
  if (element.type === "label") {
    return false;
  }
  return true;
}
function computeChildrenBBox(shapeOrChildren, padding) {
  var elements;
  if (shapeOrChildren.length === void 0) {
    elements = (0, import_min_dash65.filter)(shapeOrChildren.children, isBBoxChild);
  } else {
    elements = shapeOrChildren;
  }
  if (elements.length) {
    return addPadding(getBBox(elements), padding);
  }
}

// node_modules/bpmn-js/lib/features/modeling/util/LaneUtil.js
var abs3 = Math.abs;
function getTRBLResize(oldBounds, newBounds) {
  return substractTRBL(asTRBL(newBounds), asTRBL(oldBounds));
}
var LANE_PARENTS = [
  "bpmn:Participant",
  "bpmn:Process",
  "bpmn:SubProcess"
];
var LANE_INDENTATION = 30;
function collectLanes(shape, collectedShapes) {
  collectedShapes = collectedShapes || [];
  shape.children.filter(function(s5) {
    if (is(s5, "bpmn:Lane")) {
      collectLanes(s5, collectedShapes);
      collectedShapes.push(s5);
    }
  });
  return collectedShapes;
}
function getChildLanes(shape) {
  return shape.children.filter(function(c5) {
    return is(c5, "bpmn:Lane");
  });
}
function getLanesRoot(shape) {
  return getParent2(shape, LANE_PARENTS) || shape;
}
function computeLanesResize(shape, newBounds) {
  var rootElement = getLanesRoot(shape);
  var initialShapes = is(rootElement, "bpmn:Process") ? [] : [rootElement];
  var allLanes = collectLanes(rootElement, initialShapes), shapeTrbl = asTRBL(shape), shapeNewTrbl = asTRBL(newBounds), trblResize = getTRBLResize(shape, newBounds), resizeNeeded = [];
  allLanes.forEach(function(other) {
    if (other === shape) {
      return;
    }
    var topResize = 0, rightResize = trblResize.right, bottomResize = 0, leftResize = trblResize.left;
    var otherTrbl = asTRBL(other);
    if (trblResize.top) {
      if (abs3(otherTrbl.bottom - shapeTrbl.top) < 10) {
        bottomResize = shapeNewTrbl.top - otherTrbl.bottom;
      }
      if (abs3(otherTrbl.top - shapeTrbl.top) < 5) {
        topResize = shapeNewTrbl.top - otherTrbl.top;
      }
    }
    if (trblResize.bottom) {
      if (abs3(otherTrbl.top - shapeTrbl.bottom) < 10) {
        topResize = shapeNewTrbl.bottom - otherTrbl.top;
      }
      if (abs3(otherTrbl.bottom - shapeTrbl.bottom) < 5) {
        bottomResize = shapeNewTrbl.bottom - otherTrbl.bottom;
      }
    }
    if (topResize || rightResize || bottomResize || leftResize) {
      resizeNeeded.push({
        shape: other,
        newBounds: resizeTRBL(other, {
          top: topResize,
          right: rightResize,
          bottom: bottomResize,
          left: leftResize
        })
      });
    }
  });
  return resizeNeeded;
}

// node_modules/bpmn-js/lib/features/context-pad/ContextPadProvider.js
function ContextPadProvider(config, injector, eventBus, contextPad, modeling, elementFactory, connect, create3, popupMenu, canvas, rules, translate3) {
  config = config || {};
  contextPad.registerProvider(this);
  this._contextPad = contextPad;
  this._modeling = modeling;
  this._elementFactory = elementFactory;
  this._connect = connect;
  this._create = create3;
  this._popupMenu = popupMenu;
  this._canvas = canvas;
  this._rules = rules;
  this._translate = translate3;
  if (config.autoPlace !== false) {
    this._autoPlace = injector.get("autoPlace", false);
  }
  eventBus.on("create.end", 250, function(event2) {
    var context = event2.context, shape = context.shape;
    if (!hasPrimaryModifier(event2) || !contextPad.isOpen(shape)) {
      return;
    }
    var entries = contextPad.getEntries(shape);
    if (entries.replace) {
      entries.replace.action.click(event2, shape);
    }
  });
}
ContextPadProvider.$inject = [
  "config.contextPad",
  "injector",
  "eventBus",
  "contextPad",
  "modeling",
  "elementFactory",
  "connect",
  "create",
  "popupMenu",
  "canvas",
  "rules",
  "translate"
];
ContextPadProvider.prototype.getMultiElementContextPadEntries = function(elements) {
  var modeling = this._modeling;
  var actions = {};
  if (this._isDeleteAllowed(elements)) {
    (0, import_min_dash66.assign)(actions, {
      "delete": {
        group: "edit",
        className: "bpmn-icon-trash",
        title: this._translate("Remove"),
        action: {
          click: function(event2, elements2) {
            modeling.removeElements(elements2.slice());
          }
        }
      }
    });
  }
  return actions;
};
ContextPadProvider.prototype._isDeleteAllowed = function(elements) {
  var baseAllowed = this._rules.allowed("elements.delete", {
    elements
  });
  if ((0, import_min_dash66.isArray)(baseAllowed)) {
    return (0, import_min_dash66.every)(baseAllowed, function(element) {
      return includes2(baseAllowed, element);
    });
  }
  return baseAllowed;
};
ContextPadProvider.prototype.getContextPadEntries = function(element) {
  var contextPad = this._contextPad, modeling = this._modeling, elementFactory = this._elementFactory, connect = this._connect, create3 = this._create, popupMenu = this._popupMenu, rules = this._rules, autoPlace = this._autoPlace, translate3 = this._translate;
  var actions = {};
  if (element.type === "label") {
    return actions;
  }
  var businessObject = element.businessObject;
  function startConnect(event2, element2) {
    connect.start(event2, element2);
  }
  function removeElement2(e7, element2) {
    modeling.removeElements([element2]);
  }
  function getReplaceMenuPosition(element2) {
    var Y_OFFSET = 5;
    var pad = contextPad.getPad(element2).html;
    var padRect = pad.getBoundingClientRect();
    var pos = {
      x: padRect.left,
      y: padRect.bottom + Y_OFFSET
    };
    return pos;
  }
  function appendAction(type, className, title, options2) {
    if (typeof title !== "string") {
      options2 = title;
      title = translate3("Append {type}", { type: type.replace(/^bpmn:/, "") });
    }
    function appendStart(event2, element2) {
      var shape = elementFactory.createShape((0, import_min_dash66.assign)({ type }, options2));
      create3.start(event2, shape, {
        source: element2
      });
    }
    var append2 = autoPlace ? function(event2, element2) {
      var shape = elementFactory.createShape((0, import_min_dash66.assign)({ type }, options2));
      autoPlace.append(element2, shape);
    } : appendStart;
    return {
      group: "model",
      className,
      title,
      action: {
        dragstart: appendStart,
        click: append2
      }
    };
  }
  function splitLaneHandler(count) {
    return function(event2, element2) {
      modeling.splitLane(element2, count);
      contextPad.open(element2, true);
    };
  }
  if (isAny(businessObject, ["bpmn:Lane", "bpmn:Participant"]) && isExpanded(element)) {
    var childLanes = getChildLanes(element);
    (0, import_min_dash66.assign)(actions, {
      "lane-insert-above": {
        group: "lane-insert-above",
        className: "bpmn-icon-lane-insert-above",
        title: translate3("Add Lane above"),
        action: {
          click: function(event2, element2) {
            modeling.addLane(element2, "top");
          }
        }
      }
    });
    if (childLanes.length < 2) {
      if (element.height >= 120) {
        (0, import_min_dash66.assign)(actions, {
          "lane-divide-two": {
            group: "lane-divide",
            className: "bpmn-icon-lane-divide-two",
            title: translate3("Divide into two Lanes"),
            action: {
              click: splitLaneHandler(2)
            }
          }
        });
      }
      if (element.height >= 180) {
        (0, import_min_dash66.assign)(actions, {
          "lane-divide-three": {
            group: "lane-divide",
            className: "bpmn-icon-lane-divide-three",
            title: translate3("Divide into three Lanes"),
            action: {
              click: splitLaneHandler(3)
            }
          }
        });
      }
    }
    (0, import_min_dash66.assign)(actions, {
      "lane-insert-below": {
        group: "lane-insert-below",
        className: "bpmn-icon-lane-insert-below",
        title: translate3("Add Lane below"),
        action: {
          click: function(event2, element2) {
            modeling.addLane(element2, "bottom");
          }
        }
      }
    });
  }
  if (is(businessObject, "bpmn:FlowNode")) {
    if (is(businessObject, "bpmn:EventBasedGateway")) {
      (0, import_min_dash66.assign)(actions, {
        "append.receive-task": appendAction("bpmn:ReceiveTask", "bpmn-icon-receive-task", translate3("Append ReceiveTask")),
        "append.message-intermediate-event": appendAction("bpmn:IntermediateCatchEvent", "bpmn-icon-intermediate-event-catch-message", translate3("Append MessageIntermediateCatchEvent"), { eventDefinitionType: "bpmn:MessageEventDefinition" }),
        "append.timer-intermediate-event": appendAction("bpmn:IntermediateCatchEvent", "bpmn-icon-intermediate-event-catch-timer", translate3("Append TimerIntermediateCatchEvent"), { eventDefinitionType: "bpmn:TimerEventDefinition" }),
        "append.condition-intermediate-event": appendAction("bpmn:IntermediateCatchEvent", "bpmn-icon-intermediate-event-catch-condition", translate3("Append ConditionIntermediateCatchEvent"), { eventDefinitionType: "bpmn:ConditionalEventDefinition" }),
        "append.signal-intermediate-event": appendAction("bpmn:IntermediateCatchEvent", "bpmn-icon-intermediate-event-catch-signal", translate3("Append SignalIntermediateCatchEvent"), { eventDefinitionType: "bpmn:SignalEventDefinition" })
      });
    } else if (isEventType(businessObject, "bpmn:BoundaryEvent", "bpmn:CompensateEventDefinition")) {
      (0, import_min_dash66.assign)(actions, {
        "append.compensation-activity": appendAction("bpmn:Task", "bpmn-icon-task", translate3("Append compensation activity"), {
          isForCompensation: true
        })
      });
    } else if (!is(businessObject, "bpmn:EndEvent") && !businessObject.isForCompensation && !isEventType(businessObject, "bpmn:IntermediateThrowEvent", "bpmn:LinkEventDefinition") && !isEventSubProcess(businessObject)) {
      (0, import_min_dash66.assign)(actions, {
        "append.end-event": appendAction("bpmn:EndEvent", "bpmn-icon-end-event-none", translate3("Append EndEvent")),
        "append.gateway": appendAction("bpmn:ExclusiveGateway", "bpmn-icon-gateway-none", translate3("Append Gateway")),
        "append.append-task": appendAction("bpmn:Task", "bpmn-icon-task", translate3("Append Task")),
        "append.intermediate-event": appendAction("bpmn:IntermediateThrowEvent", "bpmn-icon-intermediate-event-none", translate3("Append Intermediate/Boundary Event"))
      });
    }
  }
  if (!popupMenu.isEmpty(element, "bpmn-replace")) {
    (0, import_min_dash66.assign)(actions, {
      "replace": {
        group: "edit",
        className: "bpmn-icon-screw-wrench",
        title: translate3("Change type"),
        action: {
          click: function(event2, element2) {
            var position = (0, import_min_dash66.assign)(getReplaceMenuPosition(element2), {
              cursor: { x: event2.x, y: event2.y }
            });
            popupMenu.open(element2, "bpmn-replace", position, {
              title: translate3("Change element"),
              width: 300,
              search: true
            });
          }
        }
      }
    });
  }
  if (is(businessObject, "bpmn:SequenceFlow")) {
    (0, import_min_dash66.assign)(actions, {
      "append.text-annotation": appendAction("bpmn:TextAnnotation", "bpmn-icon-text-annotation")
    });
  }
  if (isAny(businessObject, [
    "bpmn:FlowNode",
    "bpmn:InteractionNode",
    "bpmn:DataObjectReference",
    "bpmn:DataStoreReference"
  ])) {
    (0, import_min_dash66.assign)(actions, {
      "append.text-annotation": appendAction("bpmn:TextAnnotation", "bpmn-icon-text-annotation"),
      "connect": {
        group: "connect",
        className: "bpmn-icon-connection-multi",
        title: translate3("Connect using " + (businessObject.isForCompensation ? "" : "Sequence/MessageFlow or ") + "Association"),
        action: {
          click: startConnect,
          dragstart: startConnect
        }
      }
    });
  }
  if (is(businessObject, "bpmn:TextAnnotation")) {
    (0, import_min_dash66.assign)(actions, {
      "connect": {
        group: "connect",
        className: "bpmn-icon-connection-multi",
        title: translate3("Connect using Association"),
        action: {
          click: startConnect,
          dragstart: startConnect
        }
      }
    });
  }
  if (isAny(businessObject, ["bpmn:DataObjectReference", "bpmn:DataStoreReference"])) {
    (0, import_min_dash66.assign)(actions, {
      "connect": {
        group: "connect",
        className: "bpmn-icon-connection-multi",
        title: translate3("Connect using DataInputAssociation"),
        action: {
          click: startConnect,
          dragstart: startConnect
        }
      }
    });
  }
  if (is(businessObject, "bpmn:Group")) {
    (0, import_min_dash66.assign)(actions, {
      "append.text-annotation": appendAction("bpmn:TextAnnotation", "bpmn-icon-text-annotation")
    });
  }
  var deleteAllowed = rules.allowed("elements.delete", { elements: [element] });
  if ((0, import_min_dash66.isArray)(deleteAllowed)) {
    deleteAllowed = deleteAllowed[0] === element;
  }
  if (deleteAllowed) {
    (0, import_min_dash66.assign)(actions, {
      "delete": {
        group: "edit",
        className: "bpmn-icon-trash",
        title: translate3("Remove"),
        action: {
          click: removeElement2
        }
      }
    });
  }
  return actions;
};
function isEventType(eventBo, type, definition) {
  var isType2 = eventBo.$instanceOf(type);
  var isDefinition = false;
  var definitions = eventBo.eventDefinitions || [];
  (0, import_min_dash66.forEach)(definitions, function(def) {
    if (def.$type === definition) {
      isDefinition = true;
    }
  });
  return isType2 && isDefinition;
}
function includes2(array, item) {
  return array.indexOf(item) !== -1;
}

// node_modules/bpmn-js/lib/features/context-pad/index.js
var context_pad_default2 = {
  __depends__: [
    diagram_js_direct_editing_default,
    context_pad_default,
    selection_default,
    connect_default,
    create_default,
    popup_menu_default2
  ],
  __init__: ["contextPadProvider"],
  contextPadProvider: ["type", ContextPadProvider]
};

// node_modules/diagram-js/lib/features/distribute-elements/DistributeElements.js
var import_min_dash67 = __toESM(require_dist());
var AXIS_DIMENSIONS = {
  horizontal: ["x", "width"],
  vertical: ["y", "height"]
};
var THRESHOLD2 = 5;
function DistributeElements(modeling, rules) {
  this._modeling = modeling;
  this._filters = [];
  this.registerFilter(function(elements) {
    var allowed = rules.allowed("elements.distribute", { elements });
    if ((0, import_min_dash67.isArray)(allowed)) {
      return allowed;
    }
    return allowed ? elements : [];
  });
}
DistributeElements.$inject = ["modeling", "rules"];
DistributeElements.prototype.registerFilter = function(filterFn) {
  if (typeof filterFn !== "function") {
    throw new Error("the filter has to be a function");
  }
  this._filters.push(filterFn);
};
DistributeElements.prototype.trigger = function(elements, orientation) {
  var modeling = this._modeling;
  var groups, distributableElements;
  if (elements.length < 3) {
    return;
  }
  this._setOrientation(orientation);
  distributableElements = this._filterElements(elements);
  groups = this._createGroups(distributableElements);
  if (groups.length <= 2) {
    return;
  }
  modeling.distributeElements(groups, this._axis, this._dimension);
  return groups;
};
DistributeElements.prototype._filterElements = function(elements) {
  var filters = this._filters, axis = this._axis, dimension = this._dimension, distributableElements = [].concat(elements);
  if (!filters.length) {
    return elements;
  }
  (0, import_min_dash67.forEach)(filters, function(filterFn) {
    distributableElements = filterFn(distributableElements, axis, dimension);
  });
  return distributableElements;
};
DistributeElements.prototype._createGroups = function(elements) {
  var rangeGroups = [], self2 = this, axis = this._axis, dimension = this._dimension;
  if (!axis) {
    throw new Error('must have a defined "axis" and "dimension"');
  }
  var sortedElements = (0, import_min_dash67.sortBy)(elements, axis);
  (0, import_min_dash67.forEach)(sortedElements, function(element, idx) {
    var elementRange = self2._findRange(element, axis, dimension), range;
    var previous = rangeGroups[rangeGroups.length - 1];
    if (previous && self2._hasIntersection(previous.range, elementRange)) {
      rangeGroups[rangeGroups.length - 1].elements.push(element);
    } else {
      range = { range: elementRange, elements: [element] };
      rangeGroups.push(range);
    }
  });
  return rangeGroups;
};
DistributeElements.prototype._setOrientation = function(direction) {
  var orientation = AXIS_DIMENSIONS[direction];
  this._axis = orientation[0];
  this._dimension = orientation[1];
};
DistributeElements.prototype._hasIntersection = function(rangeA, rangeB) {
  return Math.max(rangeA.min, rangeA.max) >= Math.min(rangeB.min, rangeB.max) && Math.min(rangeA.min, rangeA.max) <= Math.max(rangeB.min, rangeB.max);
};
DistributeElements.prototype._findRange = function(element) {
  var axis = element[this._axis], dimension = element[this._dimension];
  return {
    min: axis + THRESHOLD2,
    max: axis + dimension - THRESHOLD2
  };
};

// node_modules/diagram-js/lib/features/distribute-elements/index.js
var distribute_elements_default = {
  __init__: ["distributeElements"],
  distributeElements: ["type", DistributeElements]
};

// node_modules/bpmn-js/lib/features/distribute-elements/BpmnDistributeElements.js
var import_min_dash68 = __toESM(require_dist());
function BpmnDistributeElements(distributeElements, eventBus, rules) {
  RuleProvider.call(this, eventBus);
}
BpmnDistributeElements.$inject = ["distributeElements", "eventBus", "rules"];
e(BpmnDistributeElements, RuleProvider);
BpmnDistributeElements.prototype.init = function() {
  this.addRule("elements.distribute", function(context) {
    var elements = context.elements;
    elements = (0, import_min_dash68.filter)(elements, function(element) {
      var cannotDistribute = isAny(element, [
        "bpmn:Association",
        "bpmn:BoundaryEvent",
        "bpmn:DataInputAssociation",
        "bpmn:DataOutputAssociation",
        "bpmn:Lane",
        "bpmn:MessageFlow",
        "bpmn:SequenceFlow",
        "bpmn:TextAnnotation"
      ]);
      return !(element.labelTarget || cannotDistribute);
    });
    elements = getParents(elements);
    if (elements.length < 3) {
      return false;
    }
    return elements;
  });
};

// node_modules/bpmn-js/lib/features/distribute-elements/DistributeElementsIcons.js
var icons2 = {
  horizontal: "data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%201800%201800%22%3E%3Cpath%20style%3D%22fill%3Anone%3Bstroke%3AcurrentColor%3Bstroke-width%3A100%3Bstroke-linejoin%3Around%22%20d%3D%22M450%20400V150h900v250%22%2F%3E%3Crect%20x%3D%22150%22%20y%3D%22450%22%20width%3D%22600%22%20height%3D%221200%22%20rx%3D%221%22%20style%3D%22fill%3Anone%3Bstroke%3AcurrentColor%3Bstroke-width%3A100%22%2F%3E%3Crect%20x%3D%221050%22%20y%3D%22450%22%20width%3D%22600%22%20height%3D%22800%22%20rx%3D%221%22%20style%3D%22fill%3AcurrentColor%3Bstroke%3AcurrentColor%3Bstroke-width%3A100%3Bopacity%3A.5%22%2F%3E%3C%2Fsvg%3E",
  vertical: "data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%201800%201800%22%3E%3Cpath%20style%3D%22fill%3Anone%3Bstroke%3AcurrentColor%3Bstroke-width%3A100%3Bstroke-linejoin%3Around%22%20d%3D%22M400%201350H150V450h250%22%2F%3E%3Crect%20x%3D%22450%22%20y%3D%22150%22%20width%3D%221200%22%20height%3D%22600%22%20rx%3D%221%22%20style%3D%22fill%3Anone%3Bstroke%3AcurrentColor%3Bstroke-width%3A100%22%2F%3E%3Crect%20x%3D%22450%22%20y%3D%221050%22%20width%3D%22800%22%20height%3D%22600%22%20rx%3D%221%22%20style%3D%22fill%3AcurrentColor%3Bstroke%3AcurrentColor%3Bstroke-width%3A100%3Bopacity%3A.5%22%2F%3E%3C%2Fsvg%3E"
};
var DistributeElementsIcons_default = icons2;

// node_modules/bpmn-js/lib/features/distribute-elements/DistributeElementsMenuProvider.js
var import_min_dash69 = __toESM(require_dist());
var LOW_PRIORITY11 = 900;
function DistributeElementsMenuProvider(popupMenu, distributeElements, translate3, rules) {
  this._distributeElements = distributeElements;
  this._translate = translate3;
  this._popupMenu = popupMenu;
  this._rules = rules;
  popupMenu.registerProvider("align-elements", LOW_PRIORITY11, this);
}
DistributeElementsMenuProvider.$inject = [
  "popupMenu",
  "distributeElements",
  "translate",
  "rules"
];
DistributeElementsMenuProvider.prototype.getPopupMenuEntries = function(elements) {
  var entries = {};
  if (this._isAllowed(elements)) {
    (0, import_min_dash69.assign)(entries, this._getEntries(elements));
  }
  return entries;
};
DistributeElementsMenuProvider.prototype._isAllowed = function(elements) {
  return this._rules.allowed("elements.distribute", { elements });
};
DistributeElementsMenuProvider.prototype._getEntries = function(elements) {
  var distributeElements = this._distributeElements, translate3 = this._translate, popupMenu = this._popupMenu;
  var entries = {
    "distribute-elements-horizontal": {
      group: "distribute",
      title: translate3("Distribute elements horizontally"),
      className: "bjs-align-elements-menu-entry",
      imageUrl: DistributeElementsIcons_default["horizontal"],
      action: function(event2, entry) {
        distributeElements.trigger(elements, "horizontal");
        popupMenu.close();
      }
    },
    "distribute-elements-vertical": {
      group: "distribute",
      title: translate3("Distribute elements vertically"),
      imageUrl: DistributeElementsIcons_default["vertical"],
      action: function(event2, entry) {
        distributeElements.trigger(elements, "vertical");
        popupMenu.close();
      }
    }
  };
  return entries;
};

// node_modules/bpmn-js/lib/features/distribute-elements/index.js
var distribute_elements_default2 = {
  __depends__: [
    popup_menu_default,
    distribute_elements_default
  ],
  __init__: [
    "bpmnDistributeElements",
    "distributeElementsMenuProvider"
  ],
  bpmnDistributeElements: ["type", BpmnDistributeElements],
  distributeElementsMenuProvider: ["type", DistributeElementsMenuProvider]
};

// node_modules/diagram-js/lib/features/editor-actions/EditorActions.js
var import_min_dash70 = __toESM(require_dist());
var NOT_REGISTERED_ERROR = "is not a registered action";
var IS_REGISTERED_ERROR = "is already registered";
function EditorActions(eventBus, injector) {
  this._actions = {};
  var self2 = this;
  eventBus.on("diagram.init", function() {
    self2._registerDefaultActions(injector);
    eventBus.fire("editorActions.init", {
      editorActions: self2
    });
  });
}
EditorActions.$inject = [
  "eventBus",
  "injector"
];
EditorActions.prototype._registerDefaultActions = function(injector) {
  var commandStack = injector.get("commandStack", false);
  var modeling = injector.get("modeling", false);
  var selection = injector.get("selection", false);
  var zoomScroll = injector.get("zoomScroll", false);
  var copyPaste = injector.get("copyPaste", false);
  var canvas = injector.get("canvas", false);
  var rules = injector.get("rules", false);
  var keyboardMove = injector.get("keyboardMove", false);
  var keyboardMoveSelection = injector.get("keyboardMoveSelection", false);
  if (commandStack) {
    this.register("undo", function() {
      commandStack.undo();
    });
    this.register("redo", function() {
      commandStack.redo();
    });
  }
  if (copyPaste && selection) {
    this.register("copy", function() {
      var selectedElements = selection.get();
      if (selectedElements.length) {
        return copyPaste.copy(selectedElements);
      }
    });
  }
  if (copyPaste) {
    this.register("paste", function() {
      copyPaste.paste();
    });
  }
  if (zoomScroll) {
    this.register("stepZoom", function(opts) {
      zoomScroll.stepZoom(opts.value);
    });
  }
  if (canvas) {
    this.register("zoom", function(opts) {
      canvas.zoom(opts.value);
    });
  }
  if (modeling && selection && rules) {
    this.register("removeSelection", function() {
      var selectedElements = selection.get();
      if (!selectedElements.length) {
        return;
      }
      var allowed = rules.allowed("elements.delete", { elements: selectedElements }), removableElements;
      if (allowed === false) {
        return;
      } else if ((0, import_min_dash70.isArray)(allowed)) {
        removableElements = allowed;
      } else {
        removableElements = selectedElements;
      }
      if (removableElements.length) {
        modeling.removeElements(removableElements.slice());
      }
    });
  }
  if (keyboardMove) {
    this.register("moveCanvas", function(opts) {
      keyboardMove.moveCanvas(opts);
    });
  }
  if (keyboardMoveSelection) {
    this.register("moveSelection", function(opts) {
      keyboardMoveSelection.moveSelection(opts.direction, opts.accelerated);
    });
  }
};
EditorActions.prototype.trigger = function(action, opts) {
  if (!this._actions[action]) {
    throw error3(action, NOT_REGISTERED_ERROR);
  }
  return this._actions[action](opts);
};
EditorActions.prototype.register = function(actions, listener) {
  var self2 = this;
  if (typeof actions === "string") {
    return this._registerAction(actions, listener);
  }
  (0, import_min_dash70.forEach)(actions, function(listener2, action) {
    self2._registerAction(action, listener2);
  });
};
EditorActions.prototype._registerAction = function(action, listener) {
  if (this.isRegistered(action)) {
    throw error3(action, IS_REGISTERED_ERROR);
  }
  this._actions[action] = listener;
};
EditorActions.prototype.unregister = function(action) {
  if (!this.isRegistered(action)) {
    throw error3(action, NOT_REGISTERED_ERROR);
  }
  this._actions[action] = void 0;
};
EditorActions.prototype.getActions = function() {
  return Object.keys(this._actions);
};
EditorActions.prototype.isRegistered = function(action) {
  return !!this._actions[action];
};
function error3(action, message) {
  return new Error(action + " " + message);
}

// node_modules/diagram-js/lib/features/editor-actions/index.js
var editor_actions_default = {
  __init__: ["editorActions"],
  editorActions: ["type", EditorActions]
};

// node_modules/bpmn-js/lib/features/editor-actions/BpmnEditorActions.js
var import_min_dash71 = __toESM(require_dist());
function BpmnEditorActions(injector) {
  injector.invoke(EditorActions, this);
}
e(BpmnEditorActions, EditorActions);
BpmnEditorActions.$inject = [
  "injector"
];
BpmnEditorActions.prototype._registerDefaultActions = function(injector) {
  EditorActions.prototype._registerDefaultActions.call(this, injector);
  var canvas = injector.get("canvas", false);
  var elementRegistry = injector.get("elementRegistry", false);
  var selection = injector.get("selection", false);
  var spaceTool = injector.get("spaceTool", false);
  var lassoTool = injector.get("lassoTool", false);
  var handTool = injector.get("handTool", false);
  var globalConnect = injector.get("globalConnect", false);
  var distributeElements = injector.get("distributeElements", false);
  var alignElements = injector.get("alignElements", false);
  var directEditing = injector.get("directEditing", false);
  var searchPad = injector.get("searchPad", false);
  var modeling = injector.get("modeling", false);
  var contextPad = injector.get("contextPad", false);
  if (canvas && elementRegistry && selection) {
    this._registerAction("selectElements", function() {
      var rootElement = canvas.getRootElement();
      var elements = elementRegistry.filter(function(element) {
        return element !== rootElement;
      });
      selection.select(elements);
      return elements;
    });
  }
  if (spaceTool) {
    this._registerAction("spaceTool", function() {
      spaceTool.toggle();
    });
  }
  if (lassoTool) {
    this._registerAction("lassoTool", function() {
      lassoTool.toggle();
    });
  }
  if (handTool) {
    this._registerAction("handTool", function() {
      handTool.toggle();
    });
  }
  if (globalConnect) {
    this._registerAction("globalConnectTool", function() {
      globalConnect.toggle();
    });
  }
  if (selection && distributeElements) {
    this._registerAction("distributeElements", function(opts) {
      var currentSelection = selection.get(), type = opts.type;
      if (currentSelection.length) {
        distributeElements.trigger(currentSelection, type);
      }
    });
  }
  if (selection && alignElements) {
    this._registerAction("alignElements", function(opts) {
      var currentSelection = selection.get(), aligneableElements = [], type = opts.type;
      if (currentSelection.length) {
        aligneableElements = (0, import_min_dash71.filter)(currentSelection, function(element) {
          return !is(element, "bpmn:Lane");
        });
        alignElements.trigger(aligneableElements, type);
      }
    });
  }
  if (selection && modeling) {
    this._registerAction("setColor", function(opts) {
      var currentSelection = selection.get();
      if (currentSelection.length) {
        modeling.setColor(currentSelection, opts);
      }
    });
  }
  if (selection && directEditing) {
    this._registerAction("directEditing", function() {
      var currentSelection = selection.get();
      if (currentSelection.length) {
        directEditing.activate(currentSelection[0]);
      }
    });
  }
  if (searchPad) {
    this._registerAction("find", function() {
      searchPad.toggle();
    });
  }
  if (canvas && modeling) {
    this._registerAction("moveToOrigin", function() {
      var rootElement = canvas.getRootElement(), boundingBox, elements;
      if (is(rootElement, "bpmn:Collaboration")) {
        elements = elementRegistry.filter(function(element) {
          return is(element.parent, "bpmn:Collaboration");
        });
      } else {
        elements = elementRegistry.filter(function(element) {
          return element !== rootElement && !is(element.parent, "bpmn:SubProcess");
        });
      }
      boundingBox = getBBox(elements);
      modeling.moveElements(elements, { x: -boundingBox.x, y: -boundingBox.y }, rootElement);
    });
  }
  if (selection && contextPad) {
    this._registerAction("replaceElement", function(event2) {
      contextPad.triggerEntry("replace", "click", event2);
    });
  }
};

// node_modules/bpmn-js/lib/features/editor-actions/index.js
var editor_actions_default2 = {
  __depends__: [
    editor_actions_default
  ],
  editorActions: ["type", BpmnEditorActions]
};

// node_modules/bpmn-js/lib/features/grid-snapping/BpmnGridSnapping.js
function BpmnGridSnapping(eventBus) {
  eventBus.on([
    "create.init",
    "shape.move.init"
  ], function(event2) {
    var context = event2.context, shape = event2.shape;
    if (isAny(shape, [
      "bpmn:Participant",
      "bpmn:SubProcess",
      "bpmn:TextAnnotation"
    ])) {
      if (!context.gridSnappingContext) {
        context.gridSnappingContext = {};
      }
      context.gridSnappingContext.snapLocation = "top-left";
    }
  });
}
BpmnGridSnapping.$inject = ["eventBus"];

// node_modules/diagram-js/lib/features/grid-snapping/GridSnapping.js
var import_min_dash72 = __toESM(require_dist());

// node_modules/diagram-js/lib/features/grid-snapping/GridUtil.js
var SPACING = 10;
function quantize(value, quantum, fn2) {
  if (!fn2) {
    fn2 = "round";
  }
  return Math[fn2](value / quantum) * quantum;
}

// node_modules/diagram-js/lib/features/grid-snapping/GridSnapping.js
var LOWER_PRIORITY = 1200;
var LOW_PRIORITY12 = 800;
function GridSnapping(elementRegistry, eventBus, config) {
  var active = !config || config.active !== false;
  this._eventBus = eventBus;
  var self2 = this;
  eventBus.on("diagram.init", LOW_PRIORITY12, function() {
    self2.setActive(active);
  });
  eventBus.on([
    "create.move",
    "create.end",
    "bendpoint.move.move",
    "bendpoint.move.end",
    "connect.move",
    "connect.end",
    "connectionSegment.move.move",
    "connectionSegment.move.end",
    "resize.move",
    "resize.end",
    "shape.move.move",
    "shape.move.end"
  ], LOWER_PRIORITY, function(event2) {
    var originalEvent = event2.originalEvent;
    if (!self2.active || originalEvent && isCmd(originalEvent)) {
      return;
    }
    var context = event2.context, gridSnappingContext = context.gridSnappingContext;
    if (!gridSnappingContext) {
      gridSnappingContext = context.gridSnappingContext = {};
    }
    ["x", "y"].forEach(function(axis) {
      var options2 = {};
      var snapOffset = getSnapOffset(event2, axis, elementRegistry);
      if (snapOffset) {
        options2.offset = snapOffset;
      }
      var snapConstraints = getSnapConstraints(event2, axis);
      if (snapConstraints) {
        (0, import_min_dash72.assign)(options2, snapConstraints);
      }
      if (!isSnapped(event2, axis)) {
        self2.snapEvent(event2, axis, options2);
      }
    });
  });
}
GridSnapping.prototype.snapEvent = function(event2, axis, options2) {
  var snappedValue = this.snapValue(event2[axis], options2);
  setSnapped(event2, axis, snappedValue);
};
GridSnapping.prototype.getGridSpacing = function() {
  return SPACING;
};
GridSnapping.prototype.snapValue = function(value, options2) {
  var offset = 0;
  if (options2 && options2.offset) {
    offset = options2.offset;
  }
  value += offset;
  value = quantize(value, SPACING);
  var min5, max8;
  if (options2 && options2.min) {
    min5 = options2.min;
    if ((0, import_min_dash72.isNumber)(min5)) {
      min5 = quantize(min5 + offset, SPACING, "ceil");
      value = Math.max(value, min5);
    }
  }
  if (options2 && options2.max) {
    max8 = options2.max;
    if ((0, import_min_dash72.isNumber)(max8)) {
      max8 = quantize(max8 + offset, SPACING, "floor");
      value = Math.min(value, max8);
    }
  }
  value -= offset;
  return value;
};
GridSnapping.prototype.isActive = function() {
  return this.active;
};
GridSnapping.prototype.setActive = function(active) {
  this.active = active;
  this._eventBus.fire("gridSnapping.toggle", { active });
};
GridSnapping.prototype.toggleActive = function() {
  this.setActive(!this.active);
};
GridSnapping.$inject = [
  "elementRegistry",
  "eventBus",
  "config.gridSnapping"
];
function getSnapConstraints(event2, axis) {
  var context = event2.context, createConstraints = context.createConstraints, resizeConstraints = context.resizeConstraints || {}, gridSnappingContext = context.gridSnappingContext, snapConstraints = gridSnappingContext.snapConstraints;
  if (snapConstraints && snapConstraints[axis]) {
    return snapConstraints[axis];
  }
  if (!snapConstraints) {
    snapConstraints = gridSnappingContext.snapConstraints = {};
  }
  if (!snapConstraints[axis]) {
    snapConstraints[axis] = {};
  }
  var direction = context.direction;
  if (createConstraints) {
    if (isHorizontal(axis)) {
      snapConstraints.x.min = createConstraints.left;
      snapConstraints.x.max = createConstraints.right;
    } else {
      snapConstraints.y.min = createConstraints.top;
      snapConstraints.y.max = createConstraints.bottom;
    }
  }
  var minResizeConstraints = resizeConstraints.min, maxResizeConstraints = resizeConstraints.max;
  if (minResizeConstraints) {
    if (isHorizontal(axis)) {
      if (isWest(direction)) {
        snapConstraints.x.max = minResizeConstraints.left;
      } else {
        snapConstraints.x.min = minResizeConstraints.right;
      }
    } else {
      if (isNorth(direction)) {
        snapConstraints.y.max = minResizeConstraints.top;
      } else {
        snapConstraints.y.min = minResizeConstraints.bottom;
      }
    }
  }
  if (maxResizeConstraints) {
    if (isHorizontal(axis)) {
      if (isWest(direction)) {
        snapConstraints.x.min = maxResizeConstraints.left;
      } else {
        snapConstraints.x.max = maxResizeConstraints.right;
      }
    } else {
      if (isNorth(direction)) {
        snapConstraints.y.min = maxResizeConstraints.top;
      } else {
        snapConstraints.y.max = maxResizeConstraints.bottom;
      }
    }
  }
  return snapConstraints[axis];
}
function getSnapOffset(event2, axis, elementRegistry) {
  var context = event2.context, shape = event2.shape, gridSnappingContext = context.gridSnappingContext, snapLocation = gridSnappingContext.snapLocation, snapOffset = gridSnappingContext.snapOffset;
  if (snapOffset && (0, import_min_dash72.isNumber)(snapOffset[axis])) {
    return snapOffset[axis];
  }
  if (!snapOffset) {
    snapOffset = gridSnappingContext.snapOffset = {};
  }
  if (!(0, import_min_dash72.isNumber)(snapOffset[axis])) {
    snapOffset[axis] = 0;
  }
  if (!shape) {
    return snapOffset[axis];
  }
  if (!elementRegistry.get(shape.id)) {
    if (isHorizontal(axis)) {
      snapOffset[axis] += shape[axis] + shape.width / 2;
    } else {
      snapOffset[axis] += shape[axis] + shape.height / 2;
    }
  }
  if (!snapLocation) {
    return snapOffset[axis];
  }
  if (axis === "x") {
    if (/left/.test(snapLocation)) {
      snapOffset[axis] -= shape.width / 2;
    } else if (/right/.test(snapLocation)) {
      snapOffset[axis] += shape.width / 2;
    }
  } else {
    if (/top/.test(snapLocation)) {
      snapOffset[axis] -= shape.height / 2;
    } else if (/bottom/.test(snapLocation)) {
      snapOffset[axis] += shape.height / 2;
    }
  }
  return snapOffset[axis];
}
function isHorizontal(axis) {
  return axis === "x";
}
function isNorth(direction) {
  return direction.indexOf("n") !== -1;
}
function isWest(direction) {
  return direction.indexOf("w") !== -1;
}

// node_modules/diagram-js/lib/features/grid-snapping/behavior/ResizeBehavior.js
var import_min_dash73 = __toESM(require_dist());
function ResizeBehavior(eventBus, gridSnapping) {
  CommandInterceptor.call(this, eventBus);
  this._gridSnapping = gridSnapping;
  var self2 = this;
  this.preExecute("shape.resize", function(event2) {
    var context = event2.context, hints = context.hints || {}, autoResize = hints.autoResize;
    if (!autoResize) {
      return;
    }
    var shape = context.shape, newBounds = context.newBounds;
    if ((0, import_min_dash73.isString)(autoResize)) {
      context.newBounds = self2.snapComplex(newBounds, autoResize);
    } else {
      context.newBounds = self2.snapSimple(shape, newBounds);
    }
  });
}
ResizeBehavior.$inject = [
  "eventBus",
  "gridSnapping",
  "modeling"
];
e(ResizeBehavior, CommandInterceptor);
ResizeBehavior.prototype.snapSimple = function(shape, newBounds) {
  var gridSnapping = this._gridSnapping;
  newBounds.width = gridSnapping.snapValue(newBounds.width, {
    min: newBounds.width
  });
  newBounds.height = gridSnapping.snapValue(newBounds.height, {
    min: newBounds.height
  });
  newBounds.x = shape.x + shape.width / 2 - newBounds.width / 2;
  newBounds.y = shape.y + shape.height / 2 - newBounds.height / 2;
  return newBounds;
};
ResizeBehavior.prototype.snapComplex = function(newBounds, directions2) {
  if (/w|e/.test(directions2)) {
    newBounds = this.snapHorizontally(newBounds, directions2);
  }
  if (/n|s/.test(directions2)) {
    newBounds = this.snapVertically(newBounds, directions2);
  }
  return newBounds;
};
ResizeBehavior.prototype.snapHorizontally = function(newBounds, directions2) {
  var gridSnapping = this._gridSnapping, west = /w/.test(directions2), east = /e/.test(directions2);
  var snappedNewBounds = {};
  snappedNewBounds.width = gridSnapping.snapValue(newBounds.width, {
    min: newBounds.width
  });
  if (east) {
    if (west) {
      snappedNewBounds.x = gridSnapping.snapValue(newBounds.x, {
        max: newBounds.x
      });
      snappedNewBounds.width += gridSnapping.snapValue(newBounds.x - snappedNewBounds.x, {
        min: newBounds.x - snappedNewBounds.x
      });
    } else {
      newBounds.x = newBounds.x + newBounds.width - snappedNewBounds.width;
    }
  }
  (0, import_min_dash73.assign)(newBounds, snappedNewBounds);
  return newBounds;
};
ResizeBehavior.prototype.snapVertically = function(newBounds, directions2) {
  var gridSnapping = this._gridSnapping, north = /n/.test(directions2), south = /s/.test(directions2);
  var snappedNewBounds = {};
  snappedNewBounds.height = gridSnapping.snapValue(newBounds.height, {
    min: newBounds.height
  });
  if (north) {
    if (south) {
      snappedNewBounds.y = gridSnapping.snapValue(newBounds.y, {
        max: newBounds.y
      });
      snappedNewBounds.height += gridSnapping.snapValue(newBounds.y - snappedNewBounds.y, {
        min: newBounds.y - snappedNewBounds.y
      });
    } else {
      newBounds.y = newBounds.y + newBounds.height - snappedNewBounds.height;
    }
  }
  (0, import_min_dash73.assign)(newBounds, snappedNewBounds);
  return newBounds;
};

// node_modules/diagram-js/lib/features/grid-snapping/behavior/SpaceToolBehavior.js
var HIGH_PRIORITY5 = 2e3;
function SpaceToolBehavior(eventBus, gridSnapping) {
  eventBus.on([
    "spaceTool.move",
    "spaceTool.end"
  ], HIGH_PRIORITY5, function(event2) {
    var context = event2.context;
    if (!context.initialized) {
      return;
    }
    var axis = context.axis;
    var snapped;
    if (axis === "x") {
      snapped = gridSnapping.snapValue(event2.dx);
      event2.x = event2.x + snapped - event2.dx;
      event2.dx = snapped;
    } else {
      snapped = gridSnapping.snapValue(event2.dy);
      event2.y = event2.y + snapped - event2.dy;
      event2.dy = snapped;
    }
  });
}
SpaceToolBehavior.$inject = [
  "eventBus",
  "gridSnapping"
];

// node_modules/diagram-js/lib/features/grid-snapping/behavior/index.js
var behavior_default = {
  __init__: [
    "gridSnappingResizeBehavior",
    "gridSnappingSpaceToolBehavior"
  ],
  gridSnappingResizeBehavior: ["type", ResizeBehavior],
  gridSnappingSpaceToolBehavior: ["type", SpaceToolBehavior]
};

// node_modules/diagram-js/lib/features/grid-snapping/index.js
var grid_snapping_default = {
  __depends__: [behavior_default],
  __init__: ["gridSnapping"],
  gridSnapping: ["type", GridSnapping]
};

// node_modules/bpmn-js/lib/features/grid-snapping/behavior/GridSnappingAutoPlaceBehavior.js
var HIGH_PRIORITY6 = 2e3;
function GridSnappingAutoPlaceBehavior(eventBus, gridSnapping) {
  eventBus.on("autoPlace", HIGH_PRIORITY6, function(context) {
    var source = context.source, sourceMid = getMid(source), shape = context.shape;
    var position = getNewShapePosition2(source, shape);
    ["x", "y"].forEach(function(axis) {
      var options2 = {};
      if (position[axis] === sourceMid[axis]) {
        return;
      }
      if (position[axis] > sourceMid[axis]) {
        options2.min = position[axis];
      } else {
        options2.max = position[axis];
      }
      if (is(shape, "bpmn:TextAnnotation")) {
        if (isHorizontal2(axis)) {
          options2.offset = -shape.width / 2;
        } else {
          options2.offset = -shape.height / 2;
        }
      }
      position[axis] = gridSnapping.snapValue(position[axis], options2);
    });
    return position;
  });
}
GridSnappingAutoPlaceBehavior.$inject = [
  "eventBus",
  "gridSnapping"
];
function isHorizontal2(axis) {
  return axis === "x";
}

// node_modules/bpmn-js/lib/features/grid-snapping/behavior/GridSnappingParticipantBehavior.js
var HIGHER_PRIORITY = 1750;
function GridSnappingParticipantBehavior(canvas, eventBus, gridSnapping) {
  eventBus.on([
    "create.start",
    "shape.move.start"
  ], HIGHER_PRIORITY, function(event2) {
    var context = event2.context, shape = context.shape, rootElement = canvas.getRootElement();
    if (!is(shape, "bpmn:Participant") || !is(rootElement, "bpmn:Process") || !rootElement.children.length) {
      return;
    }
    var createConstraints = context.createConstraints;
    if (!createConstraints) {
      return;
    }
    shape.width = gridSnapping.snapValue(shape.width, { min: shape.width });
    shape.height = gridSnapping.snapValue(shape.height, { min: shape.height });
  });
}
GridSnappingParticipantBehavior.$inject = [
  "canvas",
  "eventBus",
  "gridSnapping"
];

// node_modules/bpmn-js/lib/features/grid-snapping/behavior/GridSnappingLayoutConnectionBehavior.js
var import_min_dash74 = __toESM(require_dist());
var HIGH_PRIORITY7 = 3e3;
function GridSnappingLayoutConnectionBehavior(eventBus, gridSnapping, modeling) {
  CommandInterceptor.call(this, eventBus);
  this._gridSnapping = gridSnapping;
  var self2 = this;
  this.postExecuted([
    "connection.create",
    "connection.layout"
  ], HIGH_PRIORITY7, function(event2) {
    var context = event2.context, connection = context.connection, hints = context.hints || {}, waypoints = connection.waypoints;
    if (hints.connectionStart || hints.connectionEnd || hints.createElementsBehavior === false) {
      return;
    }
    if (!hasMiddleSegments(waypoints)) {
      return;
    }
    modeling.updateWaypoints(connection, self2.snapMiddleSegments(waypoints));
  });
}
GridSnappingLayoutConnectionBehavior.$inject = [
  "eventBus",
  "gridSnapping",
  "modeling"
];
e(GridSnappingLayoutConnectionBehavior, CommandInterceptor);
GridSnappingLayoutConnectionBehavior.prototype.snapMiddleSegments = function(waypoints) {
  var gridSnapping = this._gridSnapping, snapped;
  waypoints = waypoints.slice();
  for (var i6 = 1; i6 < waypoints.length - 2; i6++) {
    snapped = snapSegment(gridSnapping, waypoints[i6], waypoints[i6 + 1]);
    waypoints[i6] = snapped[0];
    waypoints[i6 + 1] = snapped[1];
  }
  return waypoints;
};
function hasMiddleSegments(waypoints) {
  return waypoints.length > 3;
}
function horizontallyAligned(aligned) {
  return aligned === "h";
}
function verticallyAligned(aligned) {
  return aligned === "v";
}
function snapSegment(gridSnapping, segmentStart, segmentEnd) {
  var aligned = pointsAligned(segmentStart, segmentEnd);
  var snapped = {};
  if (horizontallyAligned(aligned)) {
    snapped.y = gridSnapping.snapValue(segmentStart.y);
  }
  if (verticallyAligned(aligned)) {
    snapped.x = gridSnapping.snapValue(segmentStart.x);
  }
  if ("x" in snapped || "y" in snapped) {
    segmentStart = (0, import_min_dash74.assign)({}, segmentStart, snapped);
    segmentEnd = (0, import_min_dash74.assign)({}, segmentEnd, snapped);
  }
  return [segmentStart, segmentEnd];
}

// node_modules/bpmn-js/lib/features/grid-snapping/behavior/index.js
var behavior_default2 = {
  __init__: [
    "gridSnappingAutoPlaceBehavior",
    "gridSnappingParticipantBehavior",
    "gridSnappingLayoutConnectionBehavior"
  ],
  gridSnappingAutoPlaceBehavior: ["type", GridSnappingAutoPlaceBehavior],
  gridSnappingParticipantBehavior: ["type", GridSnappingParticipantBehavior],
  gridSnappingLayoutConnectionBehavior: ["type", GridSnappingLayoutConnectionBehavior]
};

// node_modules/bpmn-js/lib/features/grid-snapping/index.js
var grid_snapping_default2 = {
  __depends__: [
    grid_snapping_default,
    behavior_default2
  ],
  __init__: ["bpmnGridSnapping"],
  bpmnGridSnapping: ["type", BpmnGridSnapping]
};

// node_modules/bpmn-js/lib/features/interaction-events/BpmnInteractionEvents.js
var LABEL_WIDTH = 30;
var LABEL_HEIGHT = 30;
function BpmnInteractionEvents(eventBus, interactionEvents) {
  this._interactionEvents = interactionEvents;
  var self2 = this;
  eventBus.on([
    "interactionEvents.createHit",
    "interactionEvents.updateHit"
  ], function(context) {
    var element = context.element, gfx = context.gfx;
    if (is(element, "bpmn:Lane")) {
      return self2.createParticipantHit(element, gfx);
    } else if (is(element, "bpmn:Participant")) {
      if (isExpanded(element)) {
        return self2.createParticipantHit(element, gfx);
      } else {
        return self2.createDefaultHit(element, gfx);
      }
    } else if (is(element, "bpmn:SubProcess")) {
      if (isExpanded(element)) {
        return self2.createSubProcessHit(element, gfx);
      } else {
        return self2.createDefaultHit(element, gfx);
      }
    }
  });
}
BpmnInteractionEvents.$inject = [
  "eventBus",
  "interactionEvents"
];
BpmnInteractionEvents.prototype.createDefaultHit = function(element, gfx) {
  this._interactionEvents.removeHits(gfx);
  this._interactionEvents.createDefaultHit(element, gfx);
  return true;
};
BpmnInteractionEvents.prototype.createParticipantHit = function(element, gfx) {
  this._interactionEvents.removeHits(gfx);
  this._interactionEvents.createBoxHit(gfx, "no-move", {
    width: element.width,
    height: element.height
  });
  this._interactionEvents.createBoxHit(gfx, "click-stroke", {
    width: element.width,
    height: element.height
  });
  this._interactionEvents.createBoxHit(gfx, "all", {
    width: LABEL_WIDTH,
    height: element.height
  });
  return true;
};
BpmnInteractionEvents.prototype.createSubProcessHit = function(element, gfx) {
  this._interactionEvents.removeHits(gfx);
  this._interactionEvents.createBoxHit(gfx, "no-move", {
    width: element.width,
    height: element.height
  });
  this._interactionEvents.createBoxHit(gfx, "click-stroke", {
    width: element.width,
    height: element.height
  });
  this._interactionEvents.createBoxHit(gfx, "all", {
    width: element.width,
    height: LABEL_HEIGHT
  });
  return true;
};

// node_modules/bpmn-js/lib/features/interaction-events/index.js
var interaction_events_default2 = {
  __init__: ["bpmnInteractionEvents"],
  bpmnInteractionEvents: ["type", BpmnInteractionEvents]
};

// node_modules/bpmn-js/lib/features/keyboard/BpmnKeyboardBindings.js
function BpmnKeyboardBindings(injector) {
  injector.invoke(KeyboardBindings, this);
}
e(BpmnKeyboardBindings, KeyboardBindings);
BpmnKeyboardBindings.$inject = [
  "injector"
];
BpmnKeyboardBindings.prototype.registerBindings = function(keyboard, editorActions) {
  KeyboardBindings.prototype.registerBindings.call(this, keyboard, editorActions);
  function addListener(action, fn2) {
    if (editorActions.isRegistered(action)) {
      keyboard.addListener(fn2);
    }
  }
  addListener("selectElements", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.isKey(["a", "A"], event2) && keyboard.isCmd(event2)) {
      editorActions.trigger("selectElements");
      return true;
    }
  });
  addListener("find", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.isKey(["f", "F"], event2) && keyboard.isCmd(event2)) {
      editorActions.trigger("find");
      return true;
    }
  });
  addListener("spaceTool", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.hasModifier(event2)) {
      return;
    }
    if (keyboard.isKey(["s", "S"], event2)) {
      editorActions.trigger("spaceTool");
      return true;
    }
  });
  addListener("lassoTool", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.hasModifier(event2)) {
      return;
    }
    if (keyboard.isKey(["l", "L"], event2)) {
      editorActions.trigger("lassoTool");
      return true;
    }
  });
  addListener("handTool", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.hasModifier(event2)) {
      return;
    }
    if (keyboard.isKey(["h", "H"], event2)) {
      editorActions.trigger("handTool");
      return true;
    }
  });
  addListener("globalConnectTool", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.hasModifier(event2)) {
      return;
    }
    if (keyboard.isKey(["c", "C"], event2)) {
      editorActions.trigger("globalConnectTool");
      return true;
    }
  });
  addListener("directEditing", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.hasModifier(event2)) {
      return;
    }
    if (keyboard.isKey(["e", "E"], event2)) {
      editorActions.trigger("directEditing");
      return true;
    }
  });
  addListener("replaceElement", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.hasModifier(event2)) {
      return;
    }
    if (keyboard.isKey(["r", "R"], event2)) {
      editorActions.trigger("replaceElement", event2);
      return true;
    }
  });
};

// node_modules/bpmn-js/lib/features/keyboard/index.js
var keyboard_default2 = {
  __depends__: [
    keyboard_default
  ],
  __init__: ["keyboardBindings"],
  keyboardBindings: ["type", BpmnKeyboardBindings]
};

// node_modules/diagram-js/lib/features/keyboard-move-selection/KeyboardMoveSelection.js
var import_min_dash75 = __toESM(require_dist());
var DEFAULT_CONFIG2 = {
  moveSpeed: 1,
  moveSpeedAccelerated: 10
};
var HIGHER_PRIORITY2 = 1500;
var LEFT = "left";
var UP = "up";
var RIGHT = "right";
var DOWN = "down";
var KEY_TO_DIRECTION = {
  ArrowLeft: LEFT,
  Left: LEFT,
  ArrowUp: UP,
  Up: UP,
  ArrowRight: RIGHT,
  Right: RIGHT,
  ArrowDown: DOWN,
  Down: DOWN
};
var DIRECTIONS_DELTA = {
  left: function(speed) {
    return {
      x: -speed,
      y: 0
    };
  },
  up: function(speed) {
    return {
      x: 0,
      y: -speed
    };
  },
  right: function(speed) {
    return {
      x: speed,
      y: 0
    };
  },
  down: function(speed) {
    return {
      x: 0,
      y: speed
    };
  }
};
function KeyboardMoveSelection(config, keyboard, modeling, rules, selection) {
  var self2 = this;
  this._config = (0, import_min_dash75.assign)({}, DEFAULT_CONFIG2, config || {});
  keyboard.addListener(HIGHER_PRIORITY2, function(event2) {
    var keyEvent = event2.keyEvent;
    var direction = KEY_TO_DIRECTION[keyEvent.key];
    if (!direction) {
      return;
    }
    if (keyboard.isCmd(keyEvent)) {
      return;
    }
    var accelerated = keyboard.isShift(keyEvent);
    self2.moveSelection(direction, accelerated);
    return true;
  });
  this.moveSelection = function(direction, accelerated) {
    var selectedElements = selection.get();
    if (!selectedElements.length) {
      return;
    }
    var speed = this._config[accelerated ? "moveSpeedAccelerated" : "moveSpeed"];
    var delta2 = DIRECTIONS_DELTA[direction](speed);
    var canMove2 = rules.allowed("elements.move", {
      shapes: selectedElements
    });
    if (canMove2) {
      modeling.moveElements(selectedElements, delta2);
    }
  };
}
KeyboardMoveSelection.$inject = [
  "config.keyboardMoveSelection",
  "keyboard",
  "modeling",
  "rules",
  "selection"
];

// node_modules/diagram-js/lib/features/keyboard-move-selection/index.js
var keyboard_move_selection_default = {
  __depends__: [
    keyboard_default,
    selection_default
  ],
  __init__: [
    "keyboardMoveSelection"
  ],
  keyboardMoveSelection: ["type", KeyboardMoveSelection]
};

// node_modules/diagram-js/lib/features/resize/Resize.js
var import_min_dash76 = __toESM(require_dist());
var DEFAULT_MIN_WIDTH = 10;
function Resize(eventBus, rules, modeling, dragging) {
  this._dragging = dragging;
  this._rules = rules;
  var self2 = this;
  function handleMove(context, delta2) {
    var shape = context.shape, direction = context.direction, resizeConstraints = context.resizeConstraints, newBounds;
    context.delta = delta2;
    newBounds = resizeBounds(shape, direction, delta2);
    context.newBounds = ensureConstraints2(newBounds, resizeConstraints);
    context.canExecute = self2.canResize(context);
  }
  function handleStart(context) {
    var resizeConstraints = context.resizeConstraints, minBounds = context.minBounds;
    if (resizeConstraints !== void 0) {
      return;
    }
    if (minBounds === void 0) {
      minBounds = self2.computeMinResizeBox(context);
    }
    context.resizeConstraints = {
      min: asTRBL(minBounds)
    };
  }
  function handleEnd(context) {
    var shape = context.shape, canExecute = context.canExecute, newBounds = context.newBounds;
    if (canExecute) {
      newBounds = roundBounds(newBounds);
      if (!boundsChanged2(shape, newBounds)) {
        return;
      }
      modeling.resizeShape(shape, newBounds);
    }
  }
  eventBus.on("resize.start", function(event2) {
    handleStart(event2.context);
  });
  eventBus.on("resize.move", function(event2) {
    var delta2 = {
      x: event2.dx,
      y: event2.dy
    };
    handleMove(event2.context, delta2);
  });
  eventBus.on("resize.end", function(event2) {
    handleEnd(event2.context);
  });
}
Resize.prototype.canResize = function(context) {
  var rules = this._rules;
  var ctx = (0, import_min_dash76.pick)(context, ["newBounds", "shape", "delta", "direction"]);
  return rules.allowed("shape.resize", ctx);
};
Resize.prototype.activate = function(event2, shape, contextOrDirection) {
  var dragging = this._dragging, context, direction;
  if (typeof contextOrDirection === "string") {
    contextOrDirection = {
      direction: contextOrDirection
    };
  }
  context = (0, import_min_dash76.assign)({ shape }, contextOrDirection);
  direction = context.direction;
  if (!direction) {
    throw new Error("must provide a direction (n|w|s|e|nw|se|ne|sw)");
  }
  dragging.init(event2, getReferencePoint(shape, direction), "resize", {
    autoActivate: true,
    cursor: getCursor(direction),
    data: {
      shape,
      context
    }
  });
};
Resize.prototype.computeMinResizeBox = function(context) {
  var shape = context.shape, direction = context.direction, minDimensions, childrenBounds;
  minDimensions = context.minDimensions || {
    width: DEFAULT_MIN_WIDTH,
    height: DEFAULT_MIN_WIDTH
  };
  childrenBounds = computeChildrenBBox(shape, context.childrenBoxPadding);
  return getMinResizeBounds(direction, shape, minDimensions, childrenBounds);
};
Resize.$inject = [
  "eventBus",
  "rules",
  "modeling",
  "dragging"
];
function boundsChanged2(shape, newBounds) {
  return shape.x !== newBounds.x || shape.y !== newBounds.y || shape.width !== newBounds.width || shape.height !== newBounds.height;
}
function getReferencePoint(shape, direction) {
  var mid4 = getMid(shape), trbl = asTRBL(shape);
  var referencePoint = {
    x: mid4.x,
    y: mid4.y
  };
  if (direction.indexOf("n") !== -1) {
    referencePoint.y = trbl.top;
  } else if (direction.indexOf("s") !== -1) {
    referencePoint.y = trbl.bottom;
  }
  if (direction.indexOf("e") !== -1) {
    referencePoint.x = trbl.right;
  } else if (direction.indexOf("w") !== -1) {
    referencePoint.x = trbl.left;
  }
  return referencePoint;
}
function getCursor(direction) {
  var prefix3 = "resize-";
  if (direction === "n" || direction === "s") {
    return prefix3 + "ns";
  } else if (direction === "e" || direction === "w") {
    return prefix3 + "ew";
  } else if (direction === "nw" || direction === "se") {
    return prefix3 + "nwse";
  } else {
    return prefix3 + "nesw";
  }
}

// node_modules/diagram-js/lib/features/resize/ResizePreview.js
var MARKER_RESIZING = "djs-resizing";
var MARKER_RESIZE_NOT_OK = "resize-not-ok";
var LOW_PRIORITY13 = 500;
function ResizePreview(eventBus, canvas, previewSupport) {
  function updateFrame(context) {
    var shape = context.shape, bounds = context.newBounds, frame = context.frame;
    if (!frame) {
      frame = context.frame = previewSupport.addFrame(shape, canvas.getActiveLayer());
      canvas.addMarker(shape, MARKER_RESIZING);
    }
    if (bounds.width > 5) {
      attr(frame, { x: bounds.x, width: bounds.width });
    }
    if (bounds.height > 5) {
      attr(frame, { y: bounds.y, height: bounds.height });
    }
    if (context.canExecute) {
      classes(frame).remove(MARKER_RESIZE_NOT_OK);
    } else {
      classes(frame).add(MARKER_RESIZE_NOT_OK);
    }
  }
  function removeFrame(context) {
    var shape = context.shape, frame = context.frame;
    if (frame) {
      remove(context.frame);
    }
    canvas.removeMarker(shape, MARKER_RESIZING);
  }
  eventBus.on("resize.move", LOW_PRIORITY13, function(event2) {
    updateFrame(event2.context);
  });
  eventBus.on("resize.cleanup", function(event2) {
    removeFrame(event2.context);
  });
}
ResizePreview.$inject = [
  "eventBus",
  "canvas",
  "previewSupport"
];

// node_modules/diagram-js/lib/features/resize/ResizeHandles.js
var import_min_dash77 = __toESM(require_dist());
var HANDLE_OFFSET = -6;
var HANDLE_SIZE = 8;
var HANDLE_HIT_SIZE = 20;
var CLS_RESIZER = "djs-resizer";
var directions = ["n", "w", "s", "e", "nw", "ne", "se", "sw"];
function ResizeHandles(eventBus, canvas, selection, resize) {
  this._resize = resize;
  this._canvas = canvas;
  var self2 = this;
  eventBus.on("selection.changed", function(e7) {
    var newSelection = e7.newSelection;
    self2.removeResizers();
    if (newSelection.length === 1) {
      (0, import_min_dash77.forEach)(newSelection, (0, import_min_dash77.bind)(self2.addResizer, self2));
    }
  });
  eventBus.on("shape.changed", function(e7) {
    var shape = e7.element;
    if (selection.isSelected(shape)) {
      self2.removeResizers();
      self2.addResizer(shape);
    }
  });
}
ResizeHandles.prototype.makeDraggable = function(element, gfx, direction) {
  var resize = this._resize;
  function startResize(event2) {
    if (isPrimaryButton(event2)) {
      resize.activate(event2, element, direction);
    }
  }
  event.bind(gfx, "mousedown", startResize);
  event.bind(gfx, "touchstart", startResize);
};
ResizeHandles.prototype._createResizer = function(element, x4, y4, direction) {
  var resizersParent = this._getResizersParent();
  var offset = getHandleOffset(direction);
  var group = create("g");
  classes(group).add(CLS_RESIZER);
  classes(group).add(CLS_RESIZER + "-" + element.id);
  classes(group).add(CLS_RESIZER + "-" + direction);
  append(resizersParent, group);
  var visual = create("rect");
  attr(visual, {
    x: -HANDLE_SIZE / 2 + offset.x,
    y: -HANDLE_SIZE / 2 + offset.y,
    width: HANDLE_SIZE,
    height: HANDLE_SIZE
  });
  classes(visual).add(CLS_RESIZER + "-visual");
  append(group, visual);
  var hit = create("rect");
  attr(hit, {
    x: -HANDLE_HIT_SIZE / 2 + offset.x,
    y: -HANDLE_HIT_SIZE / 2 + offset.y,
    width: HANDLE_HIT_SIZE,
    height: HANDLE_HIT_SIZE
  });
  classes(hit).add(CLS_RESIZER + "-hit");
  append(group, hit);
  transform2(group, x4, y4);
  return group;
};
ResizeHandles.prototype.createResizer = function(element, direction) {
  var point = getReferencePoint(element, direction);
  var resizer = this._createResizer(element, point.x, point.y, direction);
  this.makeDraggable(element, resizer, direction);
};
ResizeHandles.prototype.addResizer = function(element) {
  var self2 = this;
  if (isConnection6(element) || !this._resize.canResize({ shape: element })) {
    return;
  }
  (0, import_min_dash77.forEach)(directions, function(direction) {
    self2.createResizer(element, direction);
  });
};
ResizeHandles.prototype.removeResizers = function() {
  var resizersParent = this._getResizersParent();
  clear(resizersParent);
};
ResizeHandles.prototype._getResizersParent = function() {
  return this._canvas.getLayer("resizers");
};
ResizeHandles.$inject = [
  "eventBus",
  "canvas",
  "selection",
  "resize"
];
function getHandleOffset(direction) {
  var offset = {
    x: 0,
    y: 0
  };
  if (direction.indexOf("e") !== -1) {
    offset.x = -HANDLE_OFFSET;
  } else if (direction.indexOf("w") !== -1) {
    offset.x = HANDLE_OFFSET;
  }
  if (direction.indexOf("s") !== -1) {
    offset.y = -HANDLE_OFFSET;
  } else if (direction.indexOf("n") !== -1) {
    offset.y = HANDLE_OFFSET;
  }
  return offset;
}
function isConnection6(element) {
  return !!element.waypoints;
}

// node_modules/diagram-js/lib/features/resize/index.js
var resize_default = {
  __depends__: [
    rules_default,
    dragging_default,
    preview_support_default
  ],
  __init__: [
    "resize",
    "resizePreview",
    "resizeHandles"
  ],
  resize: ["type", Resize],
  resizePreview: ["type", ResizePreview],
  resizeHandles: ["type", ResizeHandles]
};

// node_modules/bpmn-js/lib/features/label-editing/LabelEditingProvider.js
var import_min_dash78 = __toESM(require_dist());
var HIGH_PRIORITY8 = 2e3;
function LabelEditingProvider(eventBus, bpmnFactory, canvas, directEditing, modeling, resizeHandles, textRenderer) {
  this._bpmnFactory = bpmnFactory;
  this._canvas = canvas;
  this._modeling = modeling;
  this._textRenderer = textRenderer;
  directEditing.registerProvider(this);
  eventBus.on("element.dblclick", function(event2) {
    activateDirectEdit(event2.element, true);
  });
  eventBus.on([
    "autoPlace.start",
    "canvas.viewbox.changing",
    "drag.init",
    "element.mousedown",
    "popupMenu.open",
    "root.set",
    "selection.changed"
  ], function(event2) {
    if (directEditing.isActive()) {
      directEditing.complete();
    }
  });
  eventBus.on([
    "shape.remove",
    "connection.remove"
  ], HIGH_PRIORITY8, function(event2) {
    if (directEditing.isActive(event2.element)) {
      directEditing.cancel();
    }
  });
  eventBus.on(["commandStack.changed"], function(e7) {
    if (directEditing.isActive()) {
      directEditing.cancel();
    }
  });
  eventBus.on("directEditing.activate", function(event2) {
    resizeHandles.removeResizers();
  });
  eventBus.on("create.end", 500, function(event2) {
    var context = event2.context, element = context.shape, canExecute = event2.context.canExecute, isTouch = event2.isTouch;
    if (isTouch) {
      return;
    }
    if (!canExecute) {
      return;
    }
    if (context.hints && context.hints.createElementsBehavior === false) {
      return;
    }
    activateDirectEdit(element);
  });
  eventBus.on("autoPlace.end", 500, function(event2) {
    activateDirectEdit(event2.shape);
  });
  function activateDirectEdit(element, force) {
    if (force || isAny(element, ["bpmn:Task", "bpmn:TextAnnotation"]) || isCollapsedSubProcess(element)) {
      directEditing.activate(element);
    }
  }
}
LabelEditingProvider.$inject = [
  "eventBus",
  "bpmnFactory",
  "canvas",
  "directEditing",
  "modeling",
  "resizeHandles",
  "textRenderer"
];
LabelEditingProvider.prototype.activate = function(element) {
  var text = getLabel(element);
  if (text === void 0) {
    return;
  }
  var context = {
    text
  };
  var bounds = this.getEditingBBox(element);
  (0, import_min_dash78.assign)(context, bounds);
  var options2 = {};
  if (isAny(element, [
    "bpmn:Task",
    "bpmn:Participant",
    "bpmn:Lane",
    "bpmn:CallActivity"
  ]) || isCollapsedSubProcess(element)) {
    (0, import_min_dash78.assign)(options2, {
      centerVertically: true
    });
  }
  if (isLabelExternal(element)) {
    (0, import_min_dash78.assign)(options2, {
      autoResize: true
    });
  }
  if (is(element, "bpmn:TextAnnotation")) {
    (0, import_min_dash78.assign)(options2, {
      resizable: true,
      autoResize: true
    });
  }
  (0, import_min_dash78.assign)(context, {
    options: options2
  });
  return context;
};
LabelEditingProvider.prototype.getEditingBBox = function(element) {
  var canvas = this._canvas;
  var target = element.label || element;
  var bbox = canvas.getAbsoluteBBox(target);
  var mid4 = {
    x: bbox.x + bbox.width / 2,
    y: bbox.y + bbox.height / 2
  };
  var bounds = { x: bbox.x, y: bbox.y };
  var zoom2 = canvas.zoom();
  var defaultStyle = this._textRenderer.getDefaultStyle(), externalStyle = this._textRenderer.getExternalStyle();
  var externalFontSize = externalStyle.fontSize * zoom2, externalLineHeight = externalStyle.lineHeight, defaultFontSize = defaultStyle.fontSize * zoom2, defaultLineHeight = defaultStyle.lineHeight;
  var style = {
    fontFamily: this._textRenderer.getDefaultStyle().fontFamily,
    fontWeight: this._textRenderer.getDefaultStyle().fontWeight
  };
  if (is(element, "bpmn:Lane") || isExpandedPool(element)) {
    (0, import_min_dash78.assign)(bounds, {
      width: bbox.height,
      height: 30 * zoom2,
      x: bbox.x - bbox.height / 2 + 15 * zoom2,
      y: mid4.y - 30 * zoom2 / 2
    });
    (0, import_min_dash78.assign)(style, {
      fontSize: defaultFontSize + "px",
      lineHeight: defaultLineHeight,
      paddingTop: 7 * zoom2 + "px",
      paddingBottom: 7 * zoom2 + "px",
      paddingLeft: 5 * zoom2 + "px",
      paddingRight: 5 * zoom2 + "px",
      transform: "rotate(-90deg)"
    });
  }
  if (isAny(element, ["bpmn:Task", "bpmn:CallActivity"]) || isCollapsedPool(element) || isCollapsedSubProcess(element)) {
    (0, import_min_dash78.assign)(bounds, {
      width: bbox.width,
      height: bbox.height
    });
    (0, import_min_dash78.assign)(style, {
      fontSize: defaultFontSize + "px",
      lineHeight: defaultLineHeight,
      paddingTop: 7 * zoom2 + "px",
      paddingBottom: 7 * zoom2 + "px",
      paddingLeft: 5 * zoom2 + "px",
      paddingRight: 5 * zoom2 + "px"
    });
  }
  if (isExpandedSubProcess(element)) {
    (0, import_min_dash78.assign)(bounds, {
      width: bbox.width,
      x: bbox.x
    });
    (0, import_min_dash78.assign)(style, {
      fontSize: defaultFontSize + "px",
      lineHeight: defaultLineHeight,
      paddingTop: 7 * zoom2 + "px",
      paddingBottom: 7 * zoom2 + "px",
      paddingLeft: 5 * zoom2 + "px",
      paddingRight: 5 * zoom2 + "px"
    });
  }
  var width = 90 * zoom2, paddingTop = 7 * zoom2, paddingBottom = 4 * zoom2;
  if (target.labelTarget) {
    (0, import_min_dash78.assign)(bounds, {
      width,
      height: bbox.height + paddingTop + paddingBottom,
      x: mid4.x - width / 2,
      y: bbox.y - paddingTop
    });
    (0, import_min_dash78.assign)(style, {
      fontSize: externalFontSize + "px",
      lineHeight: externalLineHeight,
      paddingTop: paddingTop + "px",
      paddingBottom: paddingBottom + "px"
    });
  }
  if (isLabelExternal(target) && !hasExternalLabel(target) && !isLabel(target)) {
    var externalLabelMid = getExternalLabelMid(element);
    var absoluteBBox = canvas.getAbsoluteBBox({
      x: externalLabelMid.x,
      y: externalLabelMid.y,
      width: 0,
      height: 0
    });
    var height = externalFontSize + paddingTop + paddingBottom;
    (0, import_min_dash78.assign)(bounds, {
      width,
      height,
      x: absoluteBBox.x - width / 2,
      y: absoluteBBox.y - height / 2
    });
    (0, import_min_dash78.assign)(style, {
      fontSize: externalFontSize + "px",
      lineHeight: externalLineHeight,
      paddingTop: paddingTop + "px",
      paddingBottom: paddingBottom + "px"
    });
  }
  if (is(element, "bpmn:TextAnnotation")) {
    (0, import_min_dash78.assign)(bounds, {
      width: bbox.width,
      height: bbox.height,
      minWidth: 30 * zoom2,
      minHeight: 10 * zoom2
    });
    (0, import_min_dash78.assign)(style, {
      textAlign: "left",
      paddingTop: 5 * zoom2 + "px",
      paddingBottom: 7 * zoom2 + "px",
      paddingLeft: 7 * zoom2 + "px",
      paddingRight: 5 * zoom2 + "px",
      fontSize: defaultFontSize + "px",
      lineHeight: defaultLineHeight
    });
  }
  return { bounds, style };
};
LabelEditingProvider.prototype.update = function(element, newLabel, activeContextText, bounds) {
  var newBounds, bbox;
  if (is(element, "bpmn:TextAnnotation")) {
    bbox = this._canvas.getAbsoluteBBox(element);
    newBounds = {
      x: element.x,
      y: element.y,
      width: element.width / bbox.width * bounds.width,
      height: element.height / bbox.height * bounds.height
    };
  }
  if (isEmptyText(newLabel)) {
    newLabel = null;
  }
  this._modeling.updateLabel(element, newLabel, newBounds);
};
function isCollapsedSubProcess(element) {
  return is(element, "bpmn:SubProcess") && !isExpanded(element);
}
function isExpandedSubProcess(element) {
  return is(element, "bpmn:SubProcess") && isExpanded(element);
}
function isCollapsedPool(element) {
  return is(element, "bpmn:Participant") && !isExpanded(element);
}
function isExpandedPool(element) {
  return is(element, "bpmn:Participant") && isExpanded(element);
}
function isEmptyText(label) {
  return !label || !label.trim();
}

// node_modules/bpmn-js/lib/features/label-editing/LabelEditingPreview.js
var MARKER_HIDDEN = "djs-element-hidden";
var MARKER_LABEL_HIDDEN = "djs-label-hidden";
function LabelEditingPreview(eventBus, canvas, elementRegistry, pathMap) {
  var self2 = this;
  var defaultLayer = canvas.getDefaultLayer();
  var element, absoluteElementBBox, gfx;
  eventBus.on("directEditing.activate", function(context) {
    var activeProvider = context.active;
    element = activeProvider.element.label || activeProvider.element;
    if (is(element, "bpmn:TextAnnotation")) {
      absoluteElementBBox = canvas.getAbsoluteBBox(element);
      gfx = create("g");
      var textPathData = pathMap.getScaledPath("TEXT_ANNOTATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0,
          my: 0
        }
      });
      var path = self2.path = create("path");
      attr(path, {
        d: textPathData,
        strokeWidth: 2,
        stroke: getStrokeColor2(element)
      });
      append(gfx, path);
      append(defaultLayer, gfx);
      translate(gfx, element.x, element.y);
    }
    if (is(element, "bpmn:TextAnnotation") || element.labelTarget) {
      canvas.addMarker(element, MARKER_HIDDEN);
    } else if (is(element, "bpmn:Task") || is(element, "bpmn:CallActivity") || is(element, "bpmn:SubProcess") || is(element, "bpmn:Participant")) {
      canvas.addMarker(element, MARKER_LABEL_HIDDEN);
    }
  });
  eventBus.on("directEditing.resize", function(context) {
    if (is(element, "bpmn:TextAnnotation")) {
      var height = context.height, dy = context.dy;
      var newElementHeight = Math.max(element.height / absoluteElementBBox.height * (height + dy), 0);
      var textPathData = pathMap.getScaledPath("TEXT_ANNOTATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: newElementHeight,
        position: {
          mx: 0,
          my: 0
        }
      });
      attr(self2.path, {
        d: textPathData
      });
    }
  });
  eventBus.on(["directEditing.complete", "directEditing.cancel"], function(context) {
    var activeProvider = context.active;
    if (activeProvider) {
      canvas.removeMarker(activeProvider.element.label || activeProvider.element, MARKER_HIDDEN);
      canvas.removeMarker(element, MARKER_LABEL_HIDDEN);
    }
    element = void 0;
    absoluteElementBBox = void 0;
    if (gfx) {
      remove(gfx);
      gfx = void 0;
    }
  });
}
LabelEditingPreview.$inject = [
  "eventBus",
  "canvas",
  "elementRegistry",
  "pathMap"
];
function getStrokeColor2(element, defaultColor) {
  var di = getDi(element);
  return di.get("stroke") || defaultColor || "black";
}

// node_modules/bpmn-js/lib/features/label-editing/index.js
var label_editing_default = {
  __depends__: [
    change_support_default,
    resize_default,
    diagram_js_direct_editing_default
  ],
  __init__: [
    "labelEditingProvider",
    "labelEditingPreview"
  ],
  labelEditingProvider: ["type", LabelEditingProvider],
  labelEditingPreview: ["type", LabelEditingPreview]
};

// node_modules/bpmn-js/lib/features/modeling/behavior/AdaptiveLabelPositioningBehavior.js
var ALIGNMENTS = [
  "top",
  "bottom",
  "left",
  "right"
];
var ELEMENT_LABEL_DISTANCE2 = 10;
function AdaptiveLabelPositioningBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.postExecuted([
    "connection.create",
    "connection.layout",
    "connection.updateWaypoints"
  ], function(event2) {
    var context = event2.context, connection = context.connection, source = connection.source, target = connection.target, hints = context.hints || {};
    if (hints.createElementsBehavior !== false) {
      checkLabelAdjustment(source);
      checkLabelAdjustment(target);
    }
  });
  this.postExecuted([
    "label.create"
  ], function(event2) {
    var context = event2.context, shape = context.shape, hints = context.hints || {};
    if (hints.createElementsBehavior !== false) {
      checkLabelAdjustment(shape.labelTarget);
    }
  });
  this.postExecuted([
    "elements.create"
  ], function(event2) {
    var context = event2.context, elements = context.elements, hints = context.hints || {};
    if (hints.createElementsBehavior !== false) {
      elements.forEach(function(element) {
        checkLabelAdjustment(element);
      });
    }
  });
  function checkLabelAdjustment(element) {
    if (!hasExternalLabel(element)) {
      return;
    }
    var optimalPosition = getOptimalPosition(element);
    if (!optimalPosition) {
      return;
    }
    adjustLabelPosition(element, optimalPosition);
  }
  function adjustLabelPosition(element, orientation) {
    var elementMid = getMid(element), label = element.label, labelMid = getMid(label);
    if (!label.parent) {
      return;
    }
    var elementTrbl = asTRBL(element);
    var newLabelMid;
    switch (orientation) {
      case "top":
        newLabelMid = {
          x: elementMid.x,
          y: elementTrbl.top - ELEMENT_LABEL_DISTANCE2 - label.height / 2
        };
        break;
      case "left":
        newLabelMid = {
          x: elementTrbl.left - ELEMENT_LABEL_DISTANCE2 - label.width / 2,
          y: elementMid.y
        };
        break;
      case "bottom":
        newLabelMid = {
          x: elementMid.x,
          y: elementTrbl.bottom + ELEMENT_LABEL_DISTANCE2 + label.height / 2
        };
        break;
      case "right":
        newLabelMid = {
          x: elementTrbl.right + ELEMENT_LABEL_DISTANCE2 + label.width / 2,
          y: elementMid.y
        };
        break;
    }
    var delta2 = delta(newLabelMid, labelMid);
    modeling.moveShape(label, delta2);
  }
}
e(AdaptiveLabelPositioningBehavior, CommandInterceptor);
AdaptiveLabelPositioningBehavior.$inject = [
  "eventBus",
  "modeling"
];
function getTakenHostAlignments(element) {
  var hostElement = element.host, elementMid = getMid(element), hostOrientation = getOrientation(elementMid, hostElement);
  var freeAlignments;
  if (hostOrientation.indexOf("-") >= 0) {
    freeAlignments = hostOrientation.split("-");
  } else {
    freeAlignments = [hostOrientation];
  }
  var takenAlignments = ALIGNMENTS.filter(function(alignment) {
    return freeAlignments.indexOf(alignment) === -1;
  });
  return takenAlignments;
}
function getTakenConnectionAlignments(element) {
  var elementMid = getMid(element);
  var takenAlignments = [].concat(element.incoming.map(function(c5) {
    return c5.waypoints[c5.waypoints.length - 2];
  }), element.outgoing.map(function(c5) {
    return c5.waypoints[1];
  })).map(function(point) {
    return getApproximateOrientation(elementMid, point);
  });
  return takenAlignments;
}
function getOptimalPosition(element) {
  var labelMid = getMid(element.label);
  var elementMid = getMid(element);
  var labelOrientation = getApproximateOrientation(elementMid, labelMid);
  if (!isAligned(labelOrientation)) {
    return;
  }
  var takenAlignments = getTakenConnectionAlignments(element);
  if (element.host) {
    var takenHostAlignments = getTakenHostAlignments(element);
    takenAlignments = takenAlignments.concat(takenHostAlignments);
  }
  var freeAlignments = ALIGNMENTS.filter(function(alignment) {
    return takenAlignments.indexOf(alignment) === -1;
  });
  if (freeAlignments.indexOf(labelOrientation) !== -1) {
    return;
  }
  return freeAlignments[0];
}
function getApproximateOrientation(p0, p1) {
  return getOrientation(p1, p0, 5);
}
function isAligned(orientation) {
  return ALIGNMENTS.indexOf(orientation) !== -1;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/AppendBehavior.js
function AppendBehavior(eventBus, elementFactory, bpmnRules) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("shape.append", function(context) {
    var source = context.source, shape = context.shape;
    if (!context.position) {
      if (is(shape, "bpmn:TextAnnotation")) {
        context.position = {
          x: source.x + source.width / 2 + 75,
          y: source.y - 50 - shape.height / 2
        };
      } else {
        context.position = {
          x: source.x + source.width + 80 + shape.width / 2,
          y: source.y + source.height / 2
        };
      }
    }
  }, true);
}
e(AppendBehavior, CommandInterceptor);
AppendBehavior.$inject = [
  "eventBus",
  "elementFactory",
  "bpmnRules"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/AssociationBehavior.js
var import_min_dash79 = __toESM(require_dist());
function AssociationBehavior(injector, modeling) {
  injector.invoke(CommandInterceptor, this);
  this.postExecute("shape.move", function(context) {
    var newParent = context.newParent, shape = context.shape;
    var associations2 = (0, import_min_dash79.filter)(shape.incoming.concat(shape.outgoing), function(connection) {
      return is(connection, "bpmn:Association");
    });
    (0, import_min_dash79.forEach)(associations2, function(association) {
      modeling.moveConnection(association, { x: 0, y: 0 }, newParent);
    });
  }, true);
}
e(AssociationBehavior, CommandInterceptor);
AssociationBehavior.$inject = [
  "injector",
  "modeling"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/AttachEventBehavior.js
var LOW_PRIORITY14 = 500;
function AttachEventBehavior(bpmnReplace, injector) {
  injector.invoke(CommandInterceptor, this);
  this._bpmnReplace = bpmnReplace;
  var self2 = this;
  this.postExecuted("elements.create", LOW_PRIORITY14, function(context) {
    var elements = context.elements;
    elements = elements.filter(function(shape) {
      var host = shape.host;
      return shouldReplace(shape, host);
    });
    if (elements.length !== 1) {
      return;
    }
    elements.map(function(element) {
      return elements.indexOf(element);
    }).forEach(function(index2) {
      var host = elements[index2];
      context.elements[index2] = self2.replaceShape(elements[index2], host);
    });
  }, true);
  this.preExecute("elements.move", LOW_PRIORITY14, function(context) {
    var shapes = context.shapes, host = context.newHost;
    if (shapes.length !== 1) {
      return;
    }
    var shape = shapes[0];
    if (shouldReplace(shape, host)) {
      context.shapes = [self2.replaceShape(shape, host)];
    }
  }, true);
}
AttachEventBehavior.$inject = [
  "bpmnReplace",
  "injector"
];
e(AttachEventBehavior, CommandInterceptor);
AttachEventBehavior.prototype.replaceShape = function(shape, host) {
  var eventDefinition = getEventDefinition(shape);
  var boundaryEvent = {
    type: "bpmn:BoundaryEvent",
    host
  };
  if (eventDefinition) {
    boundaryEvent.eventDefinitionType = eventDefinition.$type;
  }
  return this._bpmnReplace.replaceElement(shape, boundaryEvent, { layoutConnection: false });
};
function getEventDefinition(element) {
  var businessObject = getBusinessObject(element), eventDefinitions = businessObject.eventDefinitions;
  return eventDefinitions && eventDefinitions[0];
}
function shouldReplace(shape, host) {
  return !isLabel(shape) && isAny(shape, ["bpmn:IntermediateThrowEvent", "bpmn:IntermediateCatchEvent"]) && !!host;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/BoundaryEventBehavior.js
var import_min_dash80 = __toESM(require_dist());
function BoundaryEventBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  function getBoundaryEvents(element) {
    return (0, import_min_dash80.filter)(element.attachers, function(attacher) {
      return is(attacher, "bpmn:BoundaryEvent");
    });
  }
  this.postExecute("connection.create", function(event2) {
    var source = event2.context.source, target = event2.context.target, boundaryEvents = getBoundaryEvents(target);
    if (is(source, "bpmn:EventBasedGateway") && is(target, "bpmn:ReceiveTask") && boundaryEvents.length > 0) {
      modeling.removeElements(boundaryEvents);
    }
  });
  this.postExecute("connection.reconnect", function(event2) {
    var oldSource = event2.context.oldSource, newSource = event2.context.newSource;
    if (is(oldSource, "bpmn:Gateway") && is(newSource, "bpmn:EventBasedGateway")) {
      (0, import_min_dash80.forEach)(newSource.outgoing, function(connection) {
        var target = connection.target, attachedboundaryEvents = getBoundaryEvents(target);
        if (is(target, "bpmn:ReceiveTask") && attachedboundaryEvents.length > 0) {
          modeling.removeElements(attachedboundaryEvents);
        }
      });
    }
  });
}
BoundaryEventBehavior.$inject = [
  "eventBus",
  "modeling"
];
e(BoundaryEventBehavior, CommandInterceptor);

// node_modules/bpmn-js/lib/features/modeling/behavior/CreateBehavior.js
function CreateBehavior(injector) {
  injector.invoke(CommandInterceptor, this);
  this.preExecute("shape.create", 1500, function(event2) {
    var context = event2.context, parent = context.parent, shape = context.shape;
    if (is(parent, "bpmn:Lane") && !is(shape, "bpmn:Lane")) {
      context.parent = getParent2(parent, "bpmn:Participant");
    }
  });
}
CreateBehavior.$inject = ["injector"];
e(CreateBehavior, CommandInterceptor);

// node_modules/bpmn-js/lib/features/modeling/behavior/CreateDataObjectBehavior.js
function CreateDataObjectBehavior(eventBus, bpmnFactory, moddle) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("shape.create", function(event2) {
    var context = event2.context, shape = context.shape;
    if (is(shape, "bpmn:DataObjectReference") && shape.type !== "label") {
      var dataObject = bpmnFactory.create("bpmn:DataObject");
      shape.businessObject.dataObjectRef = dataObject;
    }
  });
}
CreateDataObjectBehavior.$inject = [
  "eventBus",
  "bpmnFactory",
  "moddle"
];
e(CreateDataObjectBehavior, CommandInterceptor);

// node_modules/bpmn-js/lib/features/modeling/behavior/CreateParticipantBehavior.js
var import_min_dash81 = __toESM(require_dist());
var HORIZONTAL_PARTICIPANT_PADDING = 20;
var VERTICAL_PARTICIPANT_PADDING = 20;
var PARTICIPANT_BORDER_WIDTH = 30;
var HIGH_PRIORITY9 = 2e3;
function CreateParticipantBehavior(canvas, eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  eventBus.on([
    "create.start",
    "shape.move.start"
  ], HIGH_PRIORITY9, function(event2) {
    var context = event2.context, shape = context.shape, rootElement = canvas.getRootElement();
    if (!is(shape, "bpmn:Participant") || !is(rootElement, "bpmn:Process") || !rootElement.children.length) {
      return;
    }
    var children = rootElement.children.filter(function(element) {
      return !is(element, "bpmn:Group") && !isLabel(element) && !isConnection7(element);
    });
    if (!children.length) {
      return;
    }
    var childrenBBox = getBBox(children);
    var participantBounds = getParticipantBounds(shape, childrenBBox);
    (0, import_min_dash81.assign)(shape, participantBounds);
    context.createConstraints = getParticipantCreateConstraints(shape, childrenBBox);
  });
  eventBus.on("create.start", HIGH_PRIORITY9, function(event2) {
    var context = event2.context, shape = context.shape, rootElement = canvas.getRootElement(), rootElementGfx = canvas.getGraphics(rootElement);
    function ensureHoveringProcess(event3) {
      event3.element = rootElement;
      event3.gfx = rootElementGfx;
    }
    if (is(shape, "bpmn:Participant") && is(rootElement, "bpmn:Process")) {
      eventBus.on("element.hover", HIGH_PRIORITY9, ensureHoveringProcess);
      eventBus.once("create.cleanup", function() {
        eventBus.off("element.hover", ensureHoveringProcess);
      });
    }
  });
  function getOrCreateCollaboration() {
    var rootElement = canvas.getRootElement();
    if (is(rootElement, "bpmn:Collaboration")) {
      return rootElement;
    }
    return modeling.makeCollaboration();
  }
  this.preExecute("elements.create", HIGH_PRIORITY9, function(context) {
    var elements = context.elements, parent = context.parent, participant = findParticipant(elements), hints;
    if (participant && is(parent, "bpmn:Process")) {
      context.parent = getOrCreateCollaboration();
      hints = context.hints = context.hints || {};
      hints.participant = participant;
      hints.process = parent;
      hints.processRef = getBusinessObject(participant).get("processRef");
    }
  }, true);
  this.preExecute("shape.create", function(context) {
    var parent = context.parent, shape = context.shape;
    if (is(shape, "bpmn:Participant") && is(parent, "bpmn:Process")) {
      context.parent = getOrCreateCollaboration();
      context.process = parent;
      context.processRef = getBusinessObject(shape).get("processRef");
    }
  }, true);
  this.execute("shape.create", function(context) {
    var hints = context.hints || {}, process2 = context.process || hints.process, shape = context.shape, participant = hints.participant;
    if (process2 && (!participant || shape === participant)) {
      getBusinessObject(shape).set("processRef", getBusinessObject(process2));
    }
  }, true);
  this.revert("shape.create", function(context) {
    var hints = context.hints || {}, process2 = context.process || hints.process, processRef = context.processRef || hints.processRef, shape = context.shape, participant = hints.participant;
    if (process2 && (!participant || shape === participant)) {
      getBusinessObject(shape).set("processRef", processRef);
    }
  }, true);
  this.postExecute("shape.create", function(context) {
    var hints = context.hints || {}, process2 = context.process || context.hints.process, shape = context.shape, participant = hints.participant;
    if (process2) {
      var children = process2.children.slice();
      if (!participant) {
        modeling.moveElements(children, { x: 0, y: 0 }, shape);
      } else if (shape === participant) {
        modeling.moveElements(children, { x: 0, y: 0 }, participant);
      }
    }
  }, true);
}
CreateParticipantBehavior.$inject = [
  "canvas",
  "eventBus",
  "modeling"
];
e(CreateParticipantBehavior, CommandInterceptor);
function getParticipantBounds(shape, childrenBBox) {
  childrenBBox = {
    width: childrenBBox.width + HORIZONTAL_PARTICIPANT_PADDING * 2 + PARTICIPANT_BORDER_WIDTH,
    height: childrenBBox.height + VERTICAL_PARTICIPANT_PADDING * 2
  };
  var width = Math.max(shape.width, childrenBBox.width), height = Math.max(shape.height, childrenBBox.height);
  return {
    x: -width / 2,
    y: -height / 2,
    width,
    height
  };
}
function getParticipantCreateConstraints(shape, childrenBBox) {
  childrenBBox = asTRBL(childrenBBox);
  return {
    bottom: childrenBBox.top + shape.height / 2 - VERTICAL_PARTICIPANT_PADDING,
    left: childrenBBox.right - shape.width / 2 + HORIZONTAL_PARTICIPANT_PADDING,
    top: childrenBBox.bottom - shape.height / 2 + VERTICAL_PARTICIPANT_PADDING,
    right: childrenBBox.left + shape.width / 2 - HORIZONTAL_PARTICIPANT_PADDING - PARTICIPANT_BORDER_WIDTH
  };
}
function isConnection7(element) {
  return !!element.waypoints;
}
function findParticipant(elements) {
  return (0, import_min_dash81.find)(elements, function(element) {
    return is(element, "bpmn:Participant");
  });
}

// node_modules/bpmn-js/lib/features/modeling/behavior/DataInputAssociationBehavior.js
var import_min_dash82 = __toESM(require_dist());
var TARGET_REF_PLACEHOLDER_NAME = "__targetRef_placeholder";
function DataInputAssociationBehavior(eventBus, bpmnFactory) {
  CommandInterceptor.call(this, eventBus);
  this.executed([
    "connection.create",
    "connection.delete",
    "connection.move",
    "connection.reconnect"
  ], ifDataInputAssociation(fixTargetRef));
  this.reverted([
    "connection.create",
    "connection.delete",
    "connection.move",
    "connection.reconnect"
  ], ifDataInputAssociation(fixTargetRef));
  function usesTargetRef(element, targetRef, removedConnection) {
    var inputAssociations = element.get("dataInputAssociations");
    return (0, import_min_dash82.find)(inputAssociations, function(association) {
      return association !== removedConnection && association.targetRef === targetRef;
    });
  }
  function getTargetRef(element, create3) {
    var properties = element.get("properties");
    var targetRefProp = (0, import_min_dash82.find)(properties, function(p6) {
      return p6.name === TARGET_REF_PLACEHOLDER_NAME;
    });
    if (!targetRefProp && create3) {
      targetRefProp = bpmnFactory.create("bpmn:Property", {
        name: TARGET_REF_PLACEHOLDER_NAME
      });
      add2(properties, targetRefProp);
    }
    return targetRefProp;
  }
  function cleanupTargetRef(element, connection) {
    var targetRefProp = getTargetRef(element);
    if (!targetRefProp) {
      return;
    }
    if (!usesTargetRef(element, targetRefProp, connection)) {
      remove3(element.get("properties"), targetRefProp);
    }
  }
  function fixTargetRef(event2) {
    var context = event2.context, connection = context.connection, connectionBo = connection.businessObject, target = connection.target, targetBo = target && target.businessObject, newTarget = context.newTarget, newTargetBo = newTarget && newTarget.businessObject, oldTarget = context.oldTarget || context.target, oldTargetBo = oldTarget && oldTarget.businessObject;
    var dataAssociation = connection.businessObject, targetRefProp;
    if (oldTargetBo && oldTargetBo !== targetBo) {
      cleanupTargetRef(oldTargetBo, connectionBo);
    }
    if (newTargetBo && newTargetBo !== targetBo) {
      cleanupTargetRef(newTargetBo, connectionBo);
    }
    if (targetBo) {
      targetRefProp = getTargetRef(targetBo, true);
      dataAssociation.targetRef = targetRefProp;
    } else {
      dataAssociation.targetRef = null;
    }
  }
}
DataInputAssociationBehavior.$inject = [
  "eventBus",
  "bpmnFactory"
];
e(DataInputAssociationBehavior, CommandInterceptor);
function ifDataInputAssociation(fn2) {
  return function(event2) {
    var context = event2.context, connection = context.connection;
    if (is(connection, "bpmn:DataInputAssociation")) {
      return fn2(event2);
    }
  };
}

// node_modules/bpmn-js/lib/features/modeling/cmd/UpdateSemanticParentHandler.js
function UpdateSemanticParentHandler(bpmnUpdater) {
  this._bpmnUpdater = bpmnUpdater;
}
UpdateSemanticParentHandler.$inject = ["bpmnUpdater"];
UpdateSemanticParentHandler.prototype.execute = function(context) {
  var dataStoreBo = context.dataStoreBo, dataStoreDi = context.dataStoreDi, newSemanticParent = context.newSemanticParent, newDiParent = context.newDiParent;
  context.oldSemanticParent = dataStoreBo.$parent;
  context.oldDiParent = dataStoreDi.$parent;
  this._bpmnUpdater.updateSemanticParent(dataStoreBo, newSemanticParent);
  this._bpmnUpdater.updateDiParent(dataStoreDi, newDiParent);
};
UpdateSemanticParentHandler.prototype.revert = function(context) {
  var dataStoreBo = context.dataStoreBo, dataStoreDi = context.dataStoreDi, oldSemanticParent = context.oldSemanticParent, oldDiParent = context.oldDiParent;
  this._bpmnUpdater.updateSemanticParent(dataStoreBo, oldSemanticParent);
  this._bpmnUpdater.updateDiParent(dataStoreDi, oldDiParent);
};

// node_modules/bpmn-js/lib/features/modeling/behavior/DataStoreBehavior.js
function DataStoreBehavior(canvas, commandStack, elementRegistry, eventBus) {
  CommandInterceptor.call(this, eventBus);
  commandStack.registerHandler("dataStore.updateContainment", UpdateSemanticParentHandler);
  function getFirstParticipantWithProcessRef() {
    return elementRegistry.filter(function(element) {
      return is(element, "bpmn:Participant") && getBusinessObject(element).processRef;
    })[0];
  }
  function getDataStores(element) {
    return element.children.filter(function(child) {
      return is(child, "bpmn:DataStoreReference") && !child.labelTarget;
    });
  }
  function updateDataStoreParent(dataStore, newDataStoreParent) {
    var dataStoreBo = dataStore.businessObject || dataStore;
    newDataStoreParent = newDataStoreParent || getFirstParticipantWithProcessRef();
    if (newDataStoreParent) {
      var newDataStoreParentBo = newDataStoreParent.businessObject || newDataStoreParent;
      commandStack.execute("dataStore.updateContainment", {
        dataStoreBo,
        dataStoreDi: getDi(dataStore),
        newSemanticParent: newDataStoreParentBo.processRef || newDataStoreParentBo,
        newDiParent: getDi(newDataStoreParent)
      });
    }
  }
  this.preExecute("shape.create", function(event2) {
    var context = event2.context, shape = context.shape;
    if (is(shape, "bpmn:DataStoreReference") && shape.type !== "label") {
      if (!context.hints) {
        context.hints = {};
      }
      context.hints.autoResize = false;
    }
  });
  this.preExecute("elements.move", function(event2) {
    var context = event2.context, shapes = context.shapes;
    var dataStoreReferences = shapes.filter(function(shape) {
      return is(shape, "bpmn:DataStoreReference");
    });
    if (dataStoreReferences.length) {
      if (!context.hints) {
        context.hints = {};
      }
      context.hints.autoResize = shapes.filter(function(shape) {
        return !is(shape, "bpmn:DataStoreReference");
      });
    }
  });
  this.postExecute("shape.create", function(event2) {
    var context = event2.context, shape = context.shape, parent = shape.parent;
    if (is(shape, "bpmn:DataStoreReference") && shape.type !== "label" && is(parent, "bpmn:Collaboration")) {
      updateDataStoreParent(shape);
    }
  });
  this.postExecute("shape.move", function(event2) {
    var context = event2.context, shape = context.shape, oldParent = context.oldParent, parent = shape.parent;
    if (is(oldParent, "bpmn:Collaboration")) {
      return;
    }
    if (is(shape, "bpmn:DataStoreReference") && shape.type !== "label" && is(parent, "bpmn:Collaboration")) {
      var participant = is(oldParent, "bpmn:Participant") ? oldParent : getAncestor(oldParent, "bpmn:Participant");
      updateDataStoreParent(shape, participant);
    }
  });
  this.postExecute("shape.delete", function(event2) {
    var context = event2.context, shape = context.shape, rootElement = canvas.getRootElement();
    if (isAny(shape, ["bpmn:Participant", "bpmn:SubProcess"]) && is(rootElement, "bpmn:Collaboration")) {
      getDataStores(rootElement).filter(function(dataStore) {
        return isDescendant(dataStore, shape);
      }).forEach(function(dataStore) {
        updateDataStoreParent(dataStore);
      });
    }
  });
  this.postExecute("canvas.updateRoot", function(event2) {
    var context = event2.context, oldRoot = context.oldRoot, newRoot = context.newRoot;
    var dataStores = getDataStores(oldRoot);
    dataStores.forEach(function(dataStore) {
      if (is(newRoot, "bpmn:Process")) {
        updateDataStoreParent(dataStore, newRoot);
      }
    });
  });
}
DataStoreBehavior.$inject = [
  "canvas",
  "commandStack",
  "elementRegistry",
  "eventBus"
];
e(DataStoreBehavior, CommandInterceptor);
function isDescendant(descendant, ancestor) {
  var descendantBo = descendant.businessObject || descendant, ancestorBo = ancestor.businessObject || ancestor;
  while (descendantBo.$parent) {
    if (descendantBo.$parent === ancestorBo.processRef || ancestorBo) {
      return true;
    }
    descendantBo = descendantBo.$parent;
  }
  return false;
}
function getAncestor(element, type) {
  while (element.parent) {
    if (is(element.parent, type)) {
      return element.parent;
    }
    element = element.parent;
  }
}

// node_modules/bpmn-js/lib/features/modeling/behavior/DeleteLaneBehavior.js
var LOW_PRIORITY15 = 500;
function DeleteLaneBehavior(eventBus, modeling, spaceTool) {
  CommandInterceptor.call(this, eventBus);
  function compensateLaneDelete(shape, oldParent) {
    var siblings = getChildLanes(oldParent);
    var topAffected = [];
    var bottomAffected = [];
    eachElement(siblings, function(element) {
      if (element.y > shape.y) {
        bottomAffected.push(element);
      } else {
        topAffected.push(element);
      }
      return element.children;
    });
    if (!siblings.length) {
      return;
    }
    var offset;
    if (bottomAffected.length && topAffected.length) {
      offset = shape.height / 2;
    } else {
      offset = shape.height;
    }
    var topAdjustments, bottomAdjustments;
    if (topAffected.length) {
      topAdjustments = spaceTool.calculateAdjustments(topAffected, "y", offset, shape.y - 10);
      spaceTool.makeSpace(topAdjustments.movingShapes, topAdjustments.resizingShapes, { x: 0, y: offset }, "s");
    }
    if (bottomAffected.length) {
      bottomAdjustments = spaceTool.calculateAdjustments(bottomAffected, "y", -offset, shape.y + shape.height + 10);
      spaceTool.makeSpace(bottomAdjustments.movingShapes, bottomAdjustments.resizingShapes, { x: 0, y: -offset }, "n");
    }
  }
  this.postExecuted("shape.delete", LOW_PRIORITY15, function(event2) {
    var context = event2.context, hints = context.hints, shape = context.shape, oldParent = context.oldParent;
    if (!is(shape, "bpmn:Lane")) {
      return;
    }
    if (hints && hints.nested) {
      return;
    }
    compensateLaneDelete(shape, oldParent);
  });
}
DeleteLaneBehavior.$inject = [
  "eventBus",
  "modeling",
  "spaceTool"
];
e(DeleteLaneBehavior, CommandInterceptor);

// node_modules/bpmn-js/lib/features/modeling/behavior/DetachEventBehavior.js
var LOW_PRIORITY16 = 500;
function DetachEventBehavior(bpmnReplace, injector) {
  injector.invoke(CommandInterceptor, this);
  this._bpmnReplace = bpmnReplace;
  var self2 = this;
  this.postExecuted("elements.create", LOW_PRIORITY16, function(context) {
    var elements = context.elements;
    elements.filter(function(shape) {
      var host = shape.host;
      return shouldReplace2(shape, host);
    }).map(function(shape) {
      return elements.indexOf(shape);
    }).forEach(function(index2) {
      context.elements[index2] = self2.replaceShape(elements[index2]);
    });
  }, true);
  this.preExecute("elements.move", LOW_PRIORITY16, function(context) {
    var shapes = context.shapes, newHost = context.newHost;
    shapes.forEach(function(shape, index2) {
      var host = shape.host;
      if (shouldReplace2(shape, includes3(shapes, host) ? host : newHost)) {
        shapes[index2] = self2.replaceShape(shape);
      }
    });
  }, true);
}
DetachEventBehavior.$inject = [
  "bpmnReplace",
  "injector"
];
e(DetachEventBehavior, CommandInterceptor);
DetachEventBehavior.prototype.replaceShape = function(shape) {
  var eventDefinition = getEventDefinition2(shape), intermediateEvent;
  if (eventDefinition) {
    intermediateEvent = {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: eventDefinition.$type
    };
  } else {
    intermediateEvent = {
      type: "bpmn:IntermediateThrowEvent"
    };
  }
  return this._bpmnReplace.replaceElement(shape, intermediateEvent, { layoutConnection: false });
};
function getEventDefinition2(element) {
  var businessObject = getBusinessObject(element), eventDefinitions = businessObject.eventDefinitions;
  return eventDefinitions && eventDefinitions[0];
}
function shouldReplace2(shape, host) {
  return !isLabel(shape) && is(shape, "bpmn:BoundaryEvent") && !host;
}
function includes3(array, item) {
  return array.indexOf(item) !== -1;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/DropOnFlowBehavior.js
var import_min_dash83 = __toESM(require_dist());
function DropOnFlowBehavior(eventBus, bpmnRules, modeling) {
  CommandInterceptor.call(this, eventBus);
  function insertShape(shape, targetFlow, positionOrBounds) {
    var waypoints = targetFlow.waypoints, waypointsBefore, waypointsAfter, dockingPoint, source, target, incomingConnection, outgoingConnection, oldOutgoing = shape.outgoing.slice(), oldIncoming = shape.incoming.slice();
    var mid4;
    if ((0, import_min_dash83.isNumber)(positionOrBounds.width)) {
      mid4 = getMid(positionOrBounds);
    } else {
      mid4 = positionOrBounds;
    }
    var intersection2 = getApproxIntersection(waypoints, mid4);
    if (intersection2) {
      waypointsBefore = waypoints.slice(0, intersection2.index);
      waypointsAfter = waypoints.slice(intersection2.index + (intersection2.bendpoint ? 1 : 0));
      if (!waypointsBefore.length || !waypointsAfter.length) {
        return;
      }
      dockingPoint = intersection2.bendpoint ? waypoints[intersection2.index] : mid4;
      if (waypointsBefore.length === 1 || !isPointInsideBBox2(shape, waypointsBefore[waypointsBefore.length - 1])) {
        waypointsBefore.push(copy(dockingPoint));
      }
      if (waypointsAfter.length === 1 || !isPointInsideBBox2(shape, waypointsAfter[0])) {
        waypointsAfter.unshift(copy(dockingPoint));
      }
    }
    source = targetFlow.source;
    target = targetFlow.target;
    if (bpmnRules.canConnect(source, shape, targetFlow)) {
      modeling.reconnectEnd(targetFlow, shape, waypointsBefore || mid4);
      incomingConnection = targetFlow;
    }
    if (bpmnRules.canConnect(shape, target, targetFlow)) {
      if (!incomingConnection) {
        modeling.reconnectStart(targetFlow, shape, waypointsAfter || mid4);
        outgoingConnection = targetFlow;
      } else {
        outgoingConnection = modeling.connect(shape, target, { type: targetFlow.type, waypoints: waypointsAfter });
      }
    }
    var duplicateConnections = [].concat(incomingConnection && (0, import_min_dash83.filter)(oldIncoming, function(connection) {
      return connection.source === incomingConnection.source;
    }) || [], outgoingConnection && (0, import_min_dash83.filter)(oldOutgoing, function(connection) {
      return connection.target === outgoingConnection.target;
    }) || []);
    if (duplicateConnections.length) {
      modeling.removeElements(duplicateConnections);
    }
  }
  this.preExecute("elements.move", function(context) {
    var newParent = context.newParent, shapes = context.shapes, delta2 = context.delta, shape = shapes[0];
    if (!shape || !newParent) {
      return;
    }
    if (newParent && newParent.waypoints) {
      context.newParent = newParent = newParent.parent;
    }
    var shapeMid = getMid(shape);
    var newShapeMid = {
      x: shapeMid.x + delta2.x,
      y: shapeMid.y + delta2.y
    };
    var connection = (0, import_min_dash83.find)(newParent.children, function(element) {
      var canInsert2 = bpmnRules.canInsert(shapes, element);
      return canInsert2 && getApproxIntersection(element.waypoints, newShapeMid);
    });
    if (connection) {
      context.targetFlow = connection;
      context.position = newShapeMid;
    }
  }, true);
  this.postExecuted("elements.move", function(context) {
    var shapes = context.shapes, targetFlow = context.targetFlow, position = context.position;
    if (targetFlow) {
      insertShape(shapes[0], targetFlow, position);
    }
  }, true);
  this.preExecute("shape.create", function(context) {
    var parent = context.parent, shape = context.shape;
    if (bpmnRules.canInsert(shape, parent)) {
      context.targetFlow = parent;
      context.parent = parent.parent;
    }
  }, true);
  this.postExecuted("shape.create", function(context) {
    var shape = context.shape, targetFlow = context.targetFlow, positionOrBounds = context.position;
    if (targetFlow) {
      insertShape(shape, targetFlow, positionOrBounds);
    }
  }, true);
}
e(DropOnFlowBehavior, CommandInterceptor);
DropOnFlowBehavior.$inject = [
  "eventBus",
  "bpmnRules",
  "modeling"
];
function isPointInsideBBox2(bbox, point) {
  var x4 = point.x, y4 = point.y;
  return x4 >= bbox.x && x4 <= bbox.x + bbox.width && y4 >= bbox.y && y4 <= bbox.y + bbox.height;
}
function copy(obj) {
  return (0, import_min_dash83.assign)({}, obj);
}

// node_modules/bpmn-js/lib/features/modeling/behavior/EventBasedGatewayBehavior.js
function EventBasedGatewayBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.preExecuted("connection.create", function(event2) {
    var context = event2.context, connection = context.connection, source = context.source, target = context.target, hints = context.hints;
    if (hints && hints.createElementsBehavior === false) {
      return;
    }
    if (!isSequenceFlow(connection)) {
      return;
    }
    var sequenceFlows = [];
    if (is(source, "bpmn:EventBasedGateway")) {
      sequenceFlows = target.incoming.filter(isSequenceFlow);
    } else {
      sequenceFlows = target.incoming.filter(function(connection2) {
        return isSequenceFlow(connection2) && is(connection2.source, "bpmn:EventBasedGateway");
      });
    }
    sequenceFlows.forEach(function(sequenceFlow) {
      modeling.removeConnection(sequenceFlow);
    });
  });
  this.preExecuted("shape.replace", function(event2) {
    var context = event2.context, newShape = context.newShape;
    if (!is(newShape, "bpmn:EventBasedGateway")) {
      return;
    }
    var targets = newShape.outgoing.filter(isSequenceFlow).reduce(function(targets2, sequenceFlow) {
      if (!targets2.includes(sequenceFlow.target)) {
        return targets2.concat(sequenceFlow.target);
      }
      return targets2;
    }, []);
    targets.forEach(function(target) {
      target.incoming.filter(isSequenceFlow).forEach(function(sequenceFlow) {
        const sequenceFlowsFromNewShape = target.incoming.filter(isSequenceFlow).filter(function(sequenceFlow2) {
          return sequenceFlow2.source === newShape;
        });
        if (sequenceFlow.source !== newShape || sequenceFlowsFromNewShape.length > 1) {
          modeling.removeConnection(sequenceFlow);
        }
      });
    });
  });
}
EventBasedGatewayBehavior.$inject = [
  "eventBus",
  "modeling"
];
e(EventBasedGatewayBehavior, CommandInterceptor);
function isSequenceFlow(connection) {
  return is(connection, "bpmn:SequenceFlow");
}

// node_modules/bpmn-js/lib/features/modeling/behavior/FixHoverBehavior.js
var HIGH_PRIORITY10 = 1500;
var HIGHEST_PRIORITY = 2e3;
function FixHoverBehavior(elementRegistry, eventBus, canvas) {
  eventBus.on([
    "create.hover",
    "create.move",
    "create.out",
    "create.end",
    "shape.move.hover",
    "shape.move.move",
    "shape.move.out",
    "shape.move.end"
  ], HIGH_PRIORITY10, function(event2) {
    var context = event2.context, shape = context.shape || event2.shape, hover = event2.hover;
    if (is(hover, "bpmn:Lane") && !isAny(shape, ["bpmn:Lane", "bpmn:Participant"])) {
      event2.hover = getLanesRoot(hover);
      event2.hoverGfx = elementRegistry.getGraphics(event2.hover);
    }
    var rootElement = canvas.getRootElement();
    if (hover !== rootElement && (shape.labelTarget || is(shape, "bpmn:Group"))) {
      event2.hover = rootElement;
      event2.hoverGfx = elementRegistry.getGraphics(event2.hover);
    }
  });
  eventBus.on([
    "connect.hover",
    "connect.out",
    "connect.end",
    "connect.cleanup",
    "global-connect.hover",
    "global-connect.out",
    "global-connect.end",
    "global-connect.cleanup"
  ], HIGH_PRIORITY10, function(event2) {
    var hover = event2.hover;
    if (is(hover, "bpmn:Lane")) {
      event2.hover = getLanesRoot(hover) || hover;
      event2.hoverGfx = elementRegistry.getGraphics(event2.hover);
    }
  });
  eventBus.on([
    "bendpoint.move.hover"
  ], HIGH_PRIORITY10, function(event2) {
    var context = event2.context, hover = event2.hover, type = context.type;
    if (is(hover, "bpmn:Lane") && /reconnect/.test(type)) {
      event2.hover = getLanesRoot(hover) || hover;
      event2.hoverGfx = elementRegistry.getGraphics(event2.hover);
    }
  });
  eventBus.on([
    "connect.start"
  ], HIGH_PRIORITY10, function(event2) {
    var context = event2.context, start = context.start;
    if (is(start, "bpmn:Lane")) {
      context.start = getLanesRoot(start) || start;
    }
  });
  eventBus.on("shape.move.start", HIGHEST_PRIORITY, function(event2) {
    var shape = event2.shape;
    if (is(shape, "bpmn:Lane")) {
      event2.shape = getLanesRoot(shape) || shape;
    }
  });
}
FixHoverBehavior.$inject = [
  "elementRegistry",
  "eventBus",
  "canvas"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/util/CategoryUtil.js
function createCategory(bpmnFactory) {
  return bpmnFactory.create("bpmn:Category");
}
function createCategoryValue(bpmnFactory) {
  return bpmnFactory.create("bpmn:CategoryValue");
}
function linkCategoryValue(categoryValue, category, definitions) {
  add2(category.get("categoryValue"), categoryValue);
  categoryValue.$parent = category;
  add2(definitions.get("rootElements"), category);
  category.$parent = definitions;
  return categoryValue;
}
function unlinkCategoryValue(categoryValue) {
  var category = categoryValue.$parent;
  if (category) {
    remove3(category.get("categoryValue"), categoryValue);
    categoryValue.$parent = null;
  }
  return categoryValue;
}
function unlinkCategory(category) {
  var definitions = category.$parent;
  if (definitions) {
    remove3(definitions.get("rootElements"), category);
    category.$parent = null;
  }
  return category;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/GroupBehavior.js
var LOWER_PRIORITY2 = 770;
function GroupBehavior(bpmnFactory, bpmnjs, elementRegistry, eventBus, injector, moddleCopy) {
  injector.invoke(CommandInterceptor, this);
  function getGroupElements() {
    return elementRegistry.filter(function(e7) {
      return is(e7, "bpmn:Group");
    });
  }
  function isReferencedCategory(elements, category) {
    return elements.some(function(element) {
      var businessObject = getBusinessObject(element);
      var _category = businessObject.categoryValueRef && businessObject.categoryValueRef.$parent;
      return _category === category;
    });
  }
  function isReferencedCategoryValue(elements, categoryValue) {
    return elements.some(function(element) {
      var businessObject = getBusinessObject(element);
      return businessObject.categoryValueRef === categoryValue;
    });
  }
  function removeCategoryValue(categoryValue, category, businessObject) {
    var groups = getGroupElements().filter(function(element) {
      return element.businessObject !== businessObject;
    });
    if (category && !isReferencedCategory(groups, category)) {
      unlinkCategory(category);
    }
    if (categoryValue && !isReferencedCategoryValue(groups, categoryValue)) {
      unlinkCategoryValue(categoryValue);
    }
  }
  function addCategoryValue(categoryValue, category) {
    return linkCategoryValue(categoryValue, category, bpmnjs.getDefinitions());
  }
  function setCategoryValue(element, context) {
    var businessObject = getBusinessObject(element), categoryValue = businessObject.categoryValueRef;
    if (!categoryValue) {
      categoryValue = businessObject.categoryValueRef = context.categoryValue = context.categoryValue || createCategoryValue(bpmnFactory);
    }
    var category = categoryValue.$parent;
    if (!category) {
      category = categoryValue.$parent = context.category = context.category || createCategory(bpmnFactory);
    }
    addCategoryValue(categoryValue, category, bpmnjs.getDefinitions());
  }
  function unsetCategoryValue(element, context) {
    var category = context.category, categoryValue = context.categoryValue, businessObject = getBusinessObject(element);
    if (categoryValue) {
      businessObject.categoryValueRef = null;
      removeCategoryValue(categoryValue, category, businessObject);
    } else {
      removeCategoryValue(null, businessObject.categoryValueRef.$parent, businessObject);
    }
  }
  this.execute("label.create", function(event2) {
    var context = event2.context, labelTarget = context.labelTarget;
    if (!is(labelTarget, "bpmn:Group")) {
      return;
    }
    setCategoryValue(labelTarget, context);
  });
  this.revert("label.create", function(event2) {
    var context = event2.context, labelTarget = context.labelTarget;
    if (!is(labelTarget, "bpmn:Group")) {
      return;
    }
    unsetCategoryValue(labelTarget, context);
  });
  this.execute("shape.delete", function(event2) {
    var context = event2.context, shape = context.shape, businessObject = getBusinessObject(shape);
    if (!is(shape, "bpmn:Group") || shape.labelTarget) {
      return;
    }
    var categoryValue = context.categoryValue = businessObject.categoryValueRef, category;
    if (categoryValue) {
      category = context.category = categoryValue.$parent;
      removeCategoryValue(categoryValue, category, businessObject);
      businessObject.categoryValueRef = null;
    }
  });
  this.reverted("shape.delete", function(event2) {
    var context = event2.context, shape = context.shape;
    if (!is(shape, "bpmn:Group") || shape.labelTarget) {
      return;
    }
    var category = context.category, categoryValue = context.categoryValue, businessObject = getBusinessObject(shape);
    if (categoryValue) {
      businessObject.categoryValueRef = categoryValue;
      addCategoryValue(categoryValue, category);
    }
  });
  this.execute("shape.create", function(event2) {
    var context = event2.context, shape = context.shape;
    if (!is(shape, "bpmn:Group") || shape.labelTarget) {
      return;
    }
    if (getBusinessObject(shape).categoryValueRef) {
      setCategoryValue(shape, context);
    }
  });
  this.reverted("shape.create", function(event2) {
    var context = event2.context, shape = context.shape;
    if (!is(shape, "bpmn:Group") || shape.labelTarget) {
      return;
    }
    if (getBusinessObject(shape).categoryValueRef) {
      unsetCategoryValue(shape, context);
    }
  });
  function copy2(bo, clone2) {
    var targetBo = bpmnFactory.create(bo.$type);
    return moddleCopy.copyElement(bo, targetBo, null, clone2);
  }
  eventBus.on("copyPaste.copyElement", LOWER_PRIORITY2, function(context) {
    var descriptor = context.descriptor, element = context.element;
    if (!is(element, "bpmn:Group") || element.labelTarget) {
      return;
    }
    var groupBo = getBusinessObject(element);
    if (groupBo.categoryValueRef) {
      var categoryValue = groupBo.categoryValueRef;
      descriptor.categoryValue = copy2(categoryValue, true);
      if (categoryValue.$parent) {
        descriptor.category = copy2(categoryValue.$parent, true);
      }
    }
  });
  eventBus.on("copyPaste.pasteElement", LOWER_PRIORITY2, function(context) {
    var descriptor = context.descriptor, businessObject = descriptor.businessObject, categoryValue = descriptor.categoryValue, category = descriptor.category;
    if (categoryValue) {
      categoryValue = businessObject.categoryValueRef = copy2(categoryValue);
    }
    if (category) {
      categoryValue.$parent = copy2(category);
    }
    delete descriptor.category;
    delete descriptor.categoryValue;
  });
}
GroupBehavior.$inject = [
  "bpmnFactory",
  "bpmnjs",
  "elementRegistry",
  "eventBus",
  "injector",
  "moddleCopy"
];
e(GroupBehavior, CommandInterceptor);

// node_modules/bpmn-js/lib/features/modeling/behavior/util/LineIntersect.js
function lineIntersect(l1s, l1e, l2s, l2e) {
  var denominator, a6, b5, c5, numerator;
  denominator = (l2e.y - l2s.y) * (l1e.x - l1s.x) - (l2e.x - l2s.x) * (l1e.y - l1s.y);
  if (denominator == 0) {
    return null;
  }
  a6 = l1s.y - l2s.y;
  b5 = l1s.x - l2s.x;
  numerator = (l2e.x - l2s.x) * a6 - (l2e.y - l2s.y) * b5;
  c5 = numerator / denominator;
  return {
    x: Math.round(l1s.x + c5 * (l1e.x - l1s.x)),
    y: Math.round(l1s.y + c5 * (l1e.y - l1s.y))
  };
}

// node_modules/bpmn-js/lib/features/modeling/behavior/ImportDockingFix.js
function ImportDockingFix(eventBus) {
  function adjustDocking(startPoint, nextPoint, elementMid) {
    var elementTop = {
      x: elementMid.x,
      y: elementMid.y - 50
    };
    var elementLeft = {
      x: elementMid.x - 50,
      y: elementMid.y
    };
    var verticalIntersect = lineIntersect(startPoint, nextPoint, elementMid, elementTop), horizontalIntersect = lineIntersect(startPoint, nextPoint, elementMid, elementLeft);
    var centerIntersect;
    if (verticalIntersect && horizontalIntersect) {
      if (getDistance(verticalIntersect, elementMid) > getDistance(horizontalIntersect, elementMid)) {
        centerIntersect = horizontalIntersect;
      } else {
        centerIntersect = verticalIntersect;
      }
    } else {
      centerIntersect = verticalIntersect || horizontalIntersect;
    }
    startPoint.original = centerIntersect;
  }
  function fixDockings(connection) {
    var waypoints = connection.waypoints;
    adjustDocking(waypoints[0], waypoints[1], getMid(connection.source));
    adjustDocking(waypoints[waypoints.length - 1], waypoints[waypoints.length - 2], getMid(connection.target));
  }
  eventBus.on("bpmnElement.added", function(e7) {
    var element = e7.element;
    if (element.waypoints) {
      fixDockings(element);
    }
  });
}
ImportDockingFix.$inject = [
  "eventBus"
];
function getDistance(p1, p22) {
  return Math.sqrt(Math.pow(p1.x - p22.x, 2) + Math.pow(p1.y - p22.y, 2));
}

// node_modules/bpmn-js/lib/features/modeling/behavior/IsHorizontalFix.js
function IsHorizontalFix(eventBus) {
  CommandInterceptor.call(this, eventBus);
  var elementTypesToUpdate = [
    "bpmn:Participant",
    "bpmn:Lane"
  ];
  this.executed(["shape.move", "shape.create", "shape.resize"], function(event2) {
    var shape = event2.context.shape, bo = getBusinessObject(shape), di = getDi(shape);
    if (isAny(bo, elementTypesToUpdate) && !di.get("isHorizontal")) {
      di.set("isHorizontal", true);
    }
  });
}
IsHorizontalFix.$inject = ["eventBus"];
e(IsHorizontalFix, CommandInterceptor);

// node_modules/bpmn-js/lib/features/modeling/behavior/LabelBehavior.js
var import_min_dash84 = __toESM(require_dist());

// node_modules/bpmn-js/lib/features/modeling/behavior/util/LineAttachmentUtil.js
var sqrt = Math.sqrt;
var min3 = Math.min;
var max4 = Math.max;
var abs4 = Math.abs;
function sq(n5) {
  return Math.pow(n5, 2);
}
function getDistance2(p1, p22) {
  return sqrt(sq(p1.x - p22.x) + sq(p1.y - p22.y));
}
function getAttachment(point, line) {
  var idx = 0, segmentStart, segmentEnd, segmentStartDistance, segmentEndDistance, attachmentPosition, minDistance, intersections, attachment, attachmentDistance, closestAttachmentDistance, closestAttachment;
  for (idx = 0; idx < line.length - 1; idx++) {
    segmentStart = line[idx];
    segmentEnd = line[idx + 1];
    if (pointsEqual(segmentStart, segmentEnd)) {
      intersections = [segmentStart];
    } else {
      segmentStartDistance = getDistance2(point, segmentStart);
      segmentEndDistance = getDistance2(point, segmentEnd);
      minDistance = min3(segmentStartDistance, segmentEndDistance);
      intersections = getCircleSegmentIntersections(segmentStart, segmentEnd, point, minDistance);
    }
    if (intersections.length < 1) {
      throw new Error("expected between [1, 2] circle -> line intersections");
    }
    if (intersections.length === 1) {
      attachment = {
        type: "bendpoint",
        position: intersections[0],
        segmentIndex: idx,
        bendpointIndex: pointsEqual(segmentStart, intersections[0]) ? idx : idx + 1
      };
    }
    if (intersections.length === 2) {
      attachmentPosition = mid2(intersections[0], intersections[1]);
      attachment = {
        type: "segment",
        position: attachmentPosition,
        segmentIndex: idx,
        relativeLocation: getDistance2(segmentStart, attachmentPosition) / getDistance2(segmentStart, segmentEnd)
      };
    }
    attachmentDistance = getDistance2(attachment.position, point);
    if (!closestAttachment || closestAttachmentDistance > attachmentDistance) {
      closestAttachment = attachment;
      closestAttachmentDistance = attachmentDistance;
    }
  }
  return closestAttachment;
}
function getCircleSegmentIntersections(s1, s22, cc, cr) {
  var baX = s22.x - s1.x;
  var baY = s22.y - s1.y;
  var caX = cc.x - s1.x;
  var caY = cc.y - s1.y;
  var a6 = baX * baX + baY * baY;
  var bBy2 = baX * caX + baY * caY;
  var c5 = caX * caX + caY * caY - cr * cr;
  var pBy2 = bBy2 / a6;
  var q3 = c5 / a6;
  var disc = pBy2 * pBy2 - q3;
  if (disc < 0 && disc > -1e-6) {
    disc = 0;
  }
  if (disc < 0) {
    return [];
  }
  var tmpSqrt = sqrt(disc);
  var abScalingFactor1 = -pBy2 + tmpSqrt;
  var abScalingFactor2 = -pBy2 - tmpSqrt;
  var i1 = {
    x: s1.x - baX * abScalingFactor1,
    y: s1.y - baY * abScalingFactor1
  };
  if (disc === 0) {
    return [i1];
  }
  var i22 = {
    x: s1.x - baX * abScalingFactor2,
    y: s1.y - baY * abScalingFactor2
  };
  return [i1, i22].filter(function(p6) {
    return isPointInSegment(p6, s1, s22);
  });
}
function isPointInSegment(p6, segmentStart, segmentEnd) {
  return fenced(p6.x, segmentStart.x, segmentEnd.x) && fenced(p6.y, segmentStart.y, segmentEnd.y);
}
function fenced(n5, rangeStart, rangeEnd) {
  return n5 >= min3(rangeStart, rangeEnd) - EQUAL_THRESHOLD && n5 <= max4(rangeStart, rangeEnd) + EQUAL_THRESHOLD;
}
function mid2(p1, p22) {
  return {
    x: (p1.x + p22.x) / 2,
    y: (p1.y + p22.y) / 2
  };
}
var EQUAL_THRESHOLD = 0.1;
function pointsEqual(p1, p22) {
  return abs4(p1.x - p22.x) <= EQUAL_THRESHOLD && abs4(p1.y - p22.y) <= EQUAL_THRESHOLD;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/util/LayoutUtil.js
function findNewLineStartIndex(oldWaypoints, newWaypoints, attachment, hints) {
  var index2 = attachment.segmentIndex;
  var offset = newWaypoints.length - oldWaypoints.length;
  if (hints.segmentMove) {
    var oldSegmentStartIndex = hints.segmentMove.segmentStartIndex, newSegmentStartIndex = hints.segmentMove.newSegmentStartIndex;
    if (index2 === oldSegmentStartIndex) {
      return newSegmentStartIndex;
    }
    if (index2 >= newSegmentStartIndex) {
      return index2 + offset < newSegmentStartIndex ? newSegmentStartIndex : index2 + offset;
    }
    return index2;
  }
  if (hints.bendpointMove) {
    var insert = hints.bendpointMove.insert, bendpointIndex = hints.bendpointMove.bendpointIndex, newIndex;
    if (offset === 0) {
      return index2;
    }
    if (index2 >= bendpointIndex) {
      newIndex = insert ? index2 + 1 : index2 - 1;
    }
    if (index2 < bendpointIndex) {
      newIndex = index2;
      if (insert && attachment.type !== "bendpoint" && bendpointIndex - 1 === index2) {
        var rel = relativePositionMidWaypoint(newWaypoints, bendpointIndex);
        if (rel < attachment.relativeLocation) {
          newIndex++;
        }
      }
    }
    return newIndex;
  }
  if (offset === 0) {
    return index2;
  }
  if (hints.connectionStart && index2 === 0) {
    return 0;
  }
  if (hints.connectionEnd && index2 === oldWaypoints.length - 2) {
    return newWaypoints.length - 2;
  }
  return Math.floor((newWaypoints.length - 2) / 2);
}
function getAnchorPointAdjustment(position, newWaypoints, oldWaypoints, hints) {
  var dx = 0, dy = 0;
  var oldPosition = {
    point: position,
    delta: { x: 0, y: 0 }
  };
  var attachment = getAttachment(position, oldWaypoints), oldLabelLineIndex = attachment.segmentIndex, newLabelLineIndex = findNewLineStartIndex(oldWaypoints, newWaypoints, attachment, hints);
  if (newLabelLineIndex < 0 || newLabelLineIndex > newWaypoints.length - 2 || newLabelLineIndex === null) {
    return oldPosition;
  }
  var oldLabelLine = getLine(oldWaypoints, oldLabelLineIndex), newLabelLine = getLine(newWaypoints, newLabelLineIndex), oldFoot = attachment.position;
  var relativeFootPosition = getRelativeFootPosition(oldLabelLine, oldFoot), angleDelta = getAngleDelta(oldLabelLine, newLabelLine);
  if (attachment.type === "bendpoint") {
    var offset = newWaypoints.length - oldWaypoints.length, oldBendpointIndex = attachment.bendpointIndex, oldBendpoint = oldWaypoints[oldBendpointIndex];
    if (newWaypoints.indexOf(oldBendpoint) !== -1) {
      return oldPosition;
    }
    if (offset === 0) {
      var newBendpoint = newWaypoints[oldBendpointIndex];
      dx = newBendpoint.x - attachment.position.x, dy = newBendpoint.y - attachment.position.y;
      return {
        delta: {
          x: dx,
          y: dy
        },
        point: {
          x: position.x + dx,
          y: position.y + dy
        }
      };
    }
    if (offset < 0 && oldBendpointIndex !== 0 && oldBendpointIndex < oldWaypoints.length - 1) {
      relativeFootPosition = relativePositionMidWaypoint(oldWaypoints, oldBendpointIndex);
    }
  }
  var newFoot = {
    x: (newLabelLine[1].x - newLabelLine[0].x) * relativeFootPosition + newLabelLine[0].x,
    y: (newLabelLine[1].y - newLabelLine[0].y) * relativeFootPosition + newLabelLine[0].y
  };
  var newLabelVector = rotateVector({
    x: position.x - oldFoot.x,
    y: position.y - oldFoot.y
  }, angleDelta);
  dx = newFoot.x + newLabelVector.x - position.x;
  dy = newFoot.y + newLabelVector.y - position.y;
  return {
    point: roundPoint(newFoot),
    delta: roundPoint({
      x: dx,
      y: dy
    })
  };
}
function relativePositionMidWaypoint(waypoints, idx) {
  var distanceSegment1 = getDistancePointPoint(waypoints[idx - 1], waypoints[idx]), distanceSegment2 = getDistancePointPoint(waypoints[idx], waypoints[idx + 1]);
  var relativePosition = distanceSegment1 / (distanceSegment1 + distanceSegment2);
  return relativePosition;
}
function getAngleDelta(l1, l22) {
  var a1 = getAngle(l1), a22 = getAngle(l22);
  return a22 - a1;
}
function getLine(waypoints, idx) {
  return [waypoints[idx], waypoints[idx + 1]];
}
function getRelativeFootPosition(line, foot) {
  var length2 = getDistancePointPoint(line[0], line[1]), lengthToFoot = getDistancePointPoint(line[0], foot);
  return length2 === 0 ? 0 : lengthToFoot / length2;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/util/LabelLayoutUtil.js
function getLabelAdjustment(label, newWaypoints, oldWaypoints, hints) {
  var labelPosition = getLabelMid(label);
  return getAnchorPointAdjustment(labelPosition, newWaypoints, oldWaypoints, hints).delta;
}
function getLabelMid(label) {
  return {
    x: label.x + label.width / 2,
    y: label.y + label.height / 2
  };
}

// node_modules/diagram-js/lib/util/AttachUtil.js
function getNewAttachPoint(point, oldBounds, newBounds) {
  var oldCenter = center(oldBounds), newCenter = center(newBounds), oldDelta = delta(point, oldCenter);
  var newDelta = {
    x: oldDelta.x * (newBounds.width / oldBounds.width),
    y: oldDelta.y * (newBounds.height / oldBounds.height)
  };
  return roundPoint({
    x: newCenter.x + newDelta.x,
    y: newCenter.y + newDelta.y
  });
}
function getNewAttachShapeDelta(shape, oldBounds, newBounds) {
  var shapeCenter = center(shape), oldCenter = center(oldBounds), newCenter = center(newBounds), shapeDelta = delta(shape, shapeCenter), oldCenterDelta = delta(shapeCenter, oldCenter), stickyPositionDelta = getStickyPositionDelta(shapeCenter, oldBounds, newBounds);
  if (stickyPositionDelta) {
    return stickyPositionDelta;
  }
  var newCenterDelta = {
    x: oldCenterDelta.x * (newBounds.width / oldBounds.width),
    y: oldCenterDelta.y * (newBounds.height / oldBounds.height)
  };
  var newShapeCenter = {
    x: newCenter.x + newCenterDelta.x,
    y: newCenter.y + newCenterDelta.y
  };
  return roundPoint({
    x: newShapeCenter.x + shapeDelta.x - shape.x,
    y: newShapeCenter.y + shapeDelta.y - shape.y
  });
}
function getStickyPositionDelta(oldShapeCenter, oldBounds, newBounds) {
  var oldTRBL = asTRBL(oldBounds), newTRBL = asTRBL(newBounds);
  if (isMoved(oldTRBL, newTRBL)) {
    return null;
  }
  var oldOrientation = getOrientation(oldBounds, oldShapeCenter), stickyPositionDelta, newShapeCenter, newOrientation;
  if (oldOrientation === "top") {
    stickyPositionDelta = {
      x: 0,
      y: newTRBL.bottom - oldTRBL.bottom
    };
  } else if (oldOrientation === "bottom") {
    stickyPositionDelta = {
      x: 0,
      y: newTRBL.top - oldTRBL.top
    };
  } else if (oldOrientation === "right") {
    stickyPositionDelta = {
      x: newTRBL.left - oldTRBL.left,
      y: 0
    };
  } else if (oldOrientation === "left") {
    stickyPositionDelta = {
      x: newTRBL.right - oldTRBL.right,
      y: 0
    };
  } else {
    return null;
  }
  newShapeCenter = {
    x: oldShapeCenter.x + stickyPositionDelta.x,
    y: oldShapeCenter.y + stickyPositionDelta.y
  };
  newOrientation = getOrientation(newBounds, newShapeCenter);
  if (newOrientation !== oldOrientation) {
    return null;
  }
  return stickyPositionDelta;
}
function isMoved(oldTRBL, newTRBL) {
  return isHorizontallyMoved(oldTRBL, newTRBL) || isVerticallyMoved(oldTRBL, newTRBL);
}
function isHorizontallyMoved(oldTRBL, newTRBL) {
  return oldTRBL.right !== newTRBL.right && oldTRBL.left !== newTRBL.left;
}
function isVerticallyMoved(oldTRBL, newTRBL) {
  return oldTRBL.top !== newTRBL.top && oldTRBL.bottom !== newTRBL.bottom;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/LabelBehavior.js
var import_min_dash85 = __toESM(require_dist());
var DEFAULT_LABEL_DIMENSIONS = {
  width: 90,
  height: 20
};
var NAME_PROPERTY = "name";
var TEXT_PROPERTY = "text";
function LabelBehavior(eventBus, modeling, bpmnFactory, textRenderer) {
  CommandInterceptor.call(this, eventBus);
  this.postExecute("element.updateProperties", function(e7) {
    var context = e7.context, element = context.element, properties = context.properties;
    if (NAME_PROPERTY in properties) {
      modeling.updateLabel(element, properties[NAME_PROPERTY]);
    }
    if (TEXT_PROPERTY in properties && is(element, "bpmn:TextAnnotation")) {
      var newBounds = textRenderer.getTextAnnotationBounds({
        x: element.x,
        y: element.y,
        width: element.width,
        height: element.height
      }, properties[TEXT_PROPERTY] || "");
      modeling.updateLabel(element, properties.text, newBounds);
    }
  });
  this.postExecute(["shape.create", "connection.create"], function(e7) {
    var context = e7.context, hints = context.hints || {};
    if (hints.createElementsBehavior === false) {
      return;
    }
    var element = context.shape || context.connection, businessObject = element.businessObject;
    if (isLabel(element) || !isLabelExternal(element)) {
      return;
    }
    if (!getLabel(element)) {
      return;
    }
    var labelCenter = getExternalLabelMid(element);
    var labelDimensions = textRenderer.getExternalLabelBounds(DEFAULT_LABEL_DIMENSIONS, getLabel(element));
    modeling.createLabel(element, labelCenter, {
      id: businessObject.id + "_label",
      businessObject,
      width: labelDimensions.width,
      height: labelDimensions.height
    });
  });
  this.postExecute("shape.delete", function(event2) {
    var context = event2.context, labelTarget = context.labelTarget, hints = context.hints || {};
    if (labelTarget && hints.unsetLabel !== false) {
      modeling.updateLabel(labelTarget, null, null, { removeShape: false });
    }
  });
  this.postExecute(["label.create"], function(event2) {
    var context = event2.context, element = context.shape, labelTarget = context.labelTarget, di;
    if (!labelTarget) {
      return;
    }
    if (!is(labelTarget, "bpmn:BaseElement")) {
      return;
    }
    di = getDi(labelTarget);
    if (!di.label) {
      di.label = bpmnFactory.create("bpmndi:BPMNLabel", {
        bounds: bpmnFactory.create("dc:Bounds")
      });
      element.di = di;
    }
    (0, import_min_dash84.assign)(di.label.bounds, {
      x: element.x,
      y: element.y,
      width: element.width,
      height: element.height
    });
  });
  function getVisibleLabelAdjustment(event2) {
    var context = event2.context, connection = context.connection, label = connection.label, hints = (0, import_min_dash84.assign)({}, context.hints), newWaypoints = context.newWaypoints || connection.waypoints, oldWaypoints = context.oldWaypoints;
    if (typeof hints.startChanged === "undefined") {
      hints.startChanged = !!hints.connectionStart;
    }
    if (typeof hints.endChanged === "undefined") {
      hints.endChanged = !!hints.connectionEnd;
    }
    return getLabelAdjustment(label, newWaypoints, oldWaypoints, hints);
  }
  this.postExecute([
    "connection.layout",
    "connection.updateWaypoints"
  ], function(event2) {
    var context = event2.context, hints = context.hints || {};
    if (hints.labelBehavior === false) {
      return;
    }
    var connection = context.connection, label = connection.label, labelAdjustment;
    if (!label || !label.parent) {
      return;
    }
    labelAdjustment = getVisibleLabelAdjustment(event2);
    modeling.moveShape(label, labelAdjustment);
  });
  this.postExecute(["shape.replace"], function(event2) {
    var context = event2.context, newShape = context.newShape, oldShape = context.oldShape;
    var businessObject = getBusinessObject(newShape);
    if (businessObject && isLabelExternal(businessObject) && oldShape.label && newShape.label) {
      newShape.label.x = oldShape.label.x;
      newShape.label.y = oldShape.label.y;
    }
  });
  this.postExecute("shape.resize", function(event2) {
    var context = event2.context, shape = context.shape, newBounds = context.newBounds, oldBounds = context.oldBounds;
    if (hasExternalLabel(shape)) {
      var label = shape.label, labelMid = getMid(label), edges = asEdges(oldBounds);
      var referencePoint = getReferencePoint2(labelMid, edges);
      var delta2 = getReferencePointDelta(referencePoint, oldBounds, newBounds);
      modeling.moveShape(label, delta2);
    }
  });
}
e(LabelBehavior, CommandInterceptor);
LabelBehavior.$inject = [
  "eventBus",
  "modeling",
  "bpmnFactory",
  "textRenderer"
];
function getReferencePointDelta(referencePoint, oldBounds, newBounds) {
  var newReferencePoint = getNewAttachPoint(referencePoint, oldBounds, newBounds);
  return roundPoint(delta(newReferencePoint, referencePoint));
}
function getReferencePoint2(point, lines) {
  if (!lines.length) {
    return;
  }
  var nearestLine = getNearestLine(point, lines);
  return perpendicularFoot(point, nearestLine);
}
function asEdges(bounds) {
  return [
    [
      {
        x: bounds.x,
        y: bounds.y
      },
      {
        x: bounds.x + (bounds.width || 0),
        y: bounds.y
      }
    ],
    [
      {
        x: bounds.x + (bounds.width || 0),
        y: bounds.y
      },
      {
        x: bounds.x + (bounds.width || 0),
        y: bounds.y + (bounds.height || 0)
      }
    ],
    [
      {
        x: bounds.x,
        y: bounds.y + (bounds.height || 0)
      },
      {
        x: bounds.x + (bounds.width || 0),
        y: bounds.y + (bounds.height || 0)
      }
    ],
    [
      {
        x: bounds.x,
        y: bounds.y
      },
      {
        x: bounds.x,
        y: bounds.y + (bounds.height || 0)
      }
    ]
  ];
}
function getNearestLine(point, lines) {
  var distances = lines.map(function(l6) {
    return {
      line: l6,
      distance: getDistancePointLine(point, l6)
    };
  });
  var sorted = (0, import_min_dash85.sortBy)(distances, "distance");
  return sorted[0].line;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/LayoutConnectionBehavior.js
var import_min_dash86 = __toESM(require_dist());

// node_modules/bpmn-js/lib/features/modeling/behavior/util/ConnectionLayoutUtil.js
function getConnectionAdjustment(position, newWaypoints, oldWaypoints, hints) {
  return getAnchorPointAdjustment(position, newWaypoints, oldWaypoints, hints).point;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/LayoutConnectionBehavior.js
function LayoutConnectionBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  function getnewAnchorPoint(event2, point) {
    var context = event2.context, connection = context.connection, hints = (0, import_min_dash86.assign)({}, context.hints), newWaypoints = context.newWaypoints || connection.waypoints, oldWaypoints = context.oldWaypoints;
    if (typeof hints.startChanged === "undefined") {
      hints.startChanged = !!hints.connectionStart;
    }
    if (typeof hints.endChanged === "undefined") {
      hints.endChanged = !!hints.connectionEnd;
    }
    return getConnectionAdjustment(point, newWaypoints, oldWaypoints, hints);
  }
  this.postExecute([
    "connection.layout",
    "connection.updateWaypoints"
  ], function(event2) {
    var context = event2.context;
    var connection = context.connection, outgoing = connection.outgoing, incoming = connection.incoming;
    incoming.forEach(function(connection2) {
      var endPoint = connection2.waypoints[connection2.waypoints.length - 1];
      var newEndpoint = getnewAnchorPoint(event2, endPoint);
      var newWaypoints = [].concat(connection2.waypoints.slice(0, -1), [newEndpoint]);
      modeling.updateWaypoints(connection2, newWaypoints);
    });
    outgoing.forEach(function(connection2) {
      var startpoint = connection2.waypoints[0];
      var newStartpoint = getnewAnchorPoint(event2, startpoint);
      var newWaypoints = [].concat([newStartpoint], connection2.waypoints.slice(1));
      modeling.updateWaypoints(connection2, newWaypoints);
    });
  });
  this.postExecute([
    "connection.move"
  ], function(event2) {
    var context = event2.context;
    var connection = context.connection, outgoing = connection.outgoing, incoming = connection.incoming, delta2 = context.delta;
    incoming.forEach(function(connection2) {
      var endPoint = connection2.waypoints[connection2.waypoints.length - 1];
      var newEndpoint = {
        x: endPoint.x + delta2.x,
        y: endPoint.y + delta2.y
      };
      var newWaypoints = [].concat(connection2.waypoints.slice(0, -1), [newEndpoint]);
      modeling.updateWaypoints(connection2, newWaypoints);
    });
    outgoing.forEach(function(connection2) {
      var startpoint = connection2.waypoints[0];
      var newStartpoint = {
        x: startpoint.x + delta2.x,
        y: startpoint.y + delta2.y
      };
      var newWaypoints = [].concat([newStartpoint], connection2.waypoints.slice(1));
      modeling.updateWaypoints(connection2, newWaypoints);
    });
  });
}
e(LayoutConnectionBehavior, CommandInterceptor);
LayoutConnectionBehavior.$inject = [
  "eventBus",
  "modeling"
];

// node_modules/diagram-js/lib/features/modeling/cmd/helper/AnchorsHelper.js
var import_min_dash87 = __toESM(require_dist());
function getResizedSourceAnchor(connection, shape, oldBounds) {
  var waypoints = safeGetWaypoints(connection), waypointsInsideNewBounds = getWaypointsInsideBounds(waypoints, shape), oldAnchor = waypoints[0];
  if (waypointsInsideNewBounds.length) {
    return waypointsInsideNewBounds[waypointsInsideNewBounds.length - 1];
  }
  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, shape);
}
function getResizedTargetAnchor(connection, shape, oldBounds) {
  var waypoints = safeGetWaypoints(connection), waypointsInsideNewBounds = getWaypointsInsideBounds(waypoints, shape), oldAnchor = waypoints[waypoints.length - 1];
  if (waypointsInsideNewBounds.length) {
    return waypointsInsideNewBounds[0];
  }
  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, shape);
}
function getMovedSourceAnchor(connection, source, moveDelta) {
  var waypoints = safeGetWaypoints(connection), oldBounds = subtract(source, moveDelta), oldAnchor = waypoints[0];
  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, source);
}
function getMovedTargetAnchor(connection, target, moveDelta) {
  var waypoints = safeGetWaypoints(connection), oldBounds = subtract(target, moveDelta), oldAnchor = waypoints[waypoints.length - 1];
  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, target);
}
function subtract(bounds, delta2) {
  return {
    x: bounds.x - delta2.x,
    y: bounds.y - delta2.y,
    width: bounds.width,
    height: bounds.height
  };
}
function safeGetWaypoints(connection) {
  var waypoints = connection.waypoints;
  if (!waypoints.length) {
    throw new Error("connection#" + connection.id + ": no waypoints");
  }
  return waypoints;
}
function getWaypointsInsideBounds(waypoints, bounds) {
  var originalWaypoints = (0, import_min_dash87.map)(waypoints, getOriginal2);
  return (0, import_min_dash87.filter)(originalWaypoints, function(waypoint) {
    return isInsideBounds(waypoint, bounds);
  });
}
function isInsideBounds(point, bounds) {
  return getOrientation(bounds, point, 1) === "intersect";
}
function getOriginal2(point) {
  return point.original || point;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/MessageFlowBehavior.js
function MessageFlowBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.postExecute("shape.replace", function(context) {
    var oldShape = context.oldShape, newShape = context.newShape;
    if (!isParticipantCollapse(oldShape, newShape)) {
      return;
    }
    var messageFlows = getMessageFlows(oldShape);
    messageFlows.incoming.forEach(function(incoming) {
      var anchor = getResizedTargetAnchor(incoming, newShape, oldShape);
      modeling.reconnectEnd(incoming, newShape, anchor);
    });
    messageFlows.outgoing.forEach(function(outgoing) {
      var anchor = getResizedSourceAnchor(outgoing, newShape, oldShape);
      modeling.reconnectStart(outgoing, newShape, anchor);
    });
  }, true);
}
MessageFlowBehavior.$inject = ["eventBus", "modeling"];
e(MessageFlowBehavior, CommandInterceptor);
function isParticipantCollapse(oldShape, newShape) {
  return is(oldShape, "bpmn:Participant") && isExpanded(oldShape) && is(newShape, "bpmn:Participant") && !isExpanded(newShape);
}
function getMessageFlows(parent) {
  var elements = selfAndAllChildren([parent], false);
  var incoming = [], outgoing = [];
  elements.forEach(function(element) {
    if (element === parent) {
      return;
    }
    element.incoming.forEach(function(connection) {
      if (is(connection, "bpmn:MessageFlow")) {
        incoming.push(connection);
      }
    });
    element.outgoing.forEach(function(connection) {
      if (is(connection, "bpmn:MessageFlow")) {
        outgoing.push(connection);
      }
    });
  }, []);
  return {
    incoming,
    outgoing
  };
}

// node_modules/bpmn-js/lib/features/modeling/behavior/ModelingFeedback.js
var COLLAB_ERR_MSG = "flow elements must be children of pools/participants";
function ModelingFeedback(eventBus, tooltips2, translate3) {
  function showError(position, message, timeout) {
    tooltips2.add({
      position: {
        x: position.x + 5,
        y: position.y + 5
      },
      type: "error",
      timeout: timeout || 2e3,
      html: "<div>" + message + "</div>"
    });
  }
  eventBus.on(["shape.move.rejected", "create.rejected"], function(event2) {
    var context = event2.context, shape = context.shape, target = context.target;
    if (is(target, "bpmn:Collaboration") && is(shape, "bpmn:FlowNode")) {
      showError(event2, translate3(COLLAB_ERR_MSG));
    }
  });
}
ModelingFeedback.$inject = [
  "eventBus",
  "tooltips",
  "translate"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/RemoveEmbeddedLabelBoundsBehavior.js
function RemoveEmbeddedLabelBoundsBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("shape.resize", function(context) {
    var shape = context.shape;
    var di = getDi(shape), label = di && di.get("label"), bounds = label && label.get("bounds");
    if (bounds) {
      modeling.updateModdleProperties(shape, label, {
        bounds: void 0
      });
    }
  }, true);
}
e(RemoveEmbeddedLabelBoundsBehavior, CommandInterceptor);
RemoveEmbeddedLabelBoundsBehavior.$inject = [
  "eventBus",
  "modeling"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/RemoveElementBehavior.js
function RemoveElementBehavior(eventBus, bpmnRules, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("shape.delete", function(e7) {
    var shape = e7.context.shape;
    if (shape.incoming.length !== 1 || shape.outgoing.length !== 1) {
      return;
    }
    var inConnection = shape.incoming[0], outConnection = shape.outgoing[0];
    if (!is(inConnection, "bpmn:SequenceFlow") || !is(outConnection, "bpmn:SequenceFlow")) {
      return;
    }
    if (bpmnRules.canConnect(inConnection.source, outConnection.target, inConnection)) {
      var newWaypoints = getNewWaypoints(inConnection.waypoints, outConnection.waypoints);
      modeling.reconnectEnd(inConnection, outConnection.target, newWaypoints);
    }
  });
}
e(RemoveElementBehavior, CommandInterceptor);
RemoveElementBehavior.$inject = [
  "eventBus",
  "bpmnRules",
  "modeling"
];
function getDocking2(point) {
  return point.original || point;
}
function getNewWaypoints(inWaypoints, outWaypoints) {
  var intersection2 = lineIntersect(getDocking2(inWaypoints[inWaypoints.length - 2]), getDocking2(inWaypoints[inWaypoints.length - 1]), getDocking2(outWaypoints[1]), getDocking2(outWaypoints[0]));
  if (intersection2) {
    return [].concat(inWaypoints.slice(0, inWaypoints.length - 1), [intersection2], outWaypoints.slice(1));
  } else {
    return [
      getDocking2(inWaypoints[0]),
      getDocking2(outWaypoints[outWaypoints.length - 1])
    ];
  }
}

// node_modules/bpmn-js/lib/features/modeling/behavior/RemoveParticipantBehavior.js
function RemoveParticipantBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("shape.delete", function(context) {
    var shape = context.shape, parent = shape.parent;
    if (is(shape, "bpmn:Participant")) {
      context.collaborationRoot = parent;
    }
  }, true);
  this.postExecute("shape.delete", function(context) {
    var collaborationRoot = context.collaborationRoot;
    if (collaborationRoot && !collaborationRoot.businessObject.participants.length) {
      modeling.makeProcess();
    }
  }, true);
}
RemoveParticipantBehavior.$inject = ["eventBus", "modeling"];
e(RemoveParticipantBehavior, CommandInterceptor);

// node_modules/bpmn-js/lib/features/modeling/behavior/ReplaceConnectionBehavior.js
var import_min_dash88 = __toESM(require_dist());
function ReplaceConnectionBehavior(eventBus, modeling, bpmnRules, injector) {
  CommandInterceptor.call(this, eventBus);
  var dragging = injector.get("dragging", false);
  function fixConnection(connection) {
    var source = connection.source, target = connection.target, parent = connection.parent;
    if (!parent) {
      return;
    }
    var replacementType, remove5;
    if (is(connection, "bpmn:SequenceFlow")) {
      if (!bpmnRules.canConnectSequenceFlow(source, target)) {
        remove5 = true;
      }
      if (bpmnRules.canConnectMessageFlow(source, target)) {
        replacementType = "bpmn:MessageFlow";
      }
    }
    if (is(connection, "bpmn:MessageFlow")) {
      if (!bpmnRules.canConnectMessageFlow(source, target)) {
        remove5 = true;
      }
      if (bpmnRules.canConnectSequenceFlow(source, target)) {
        replacementType = "bpmn:SequenceFlow";
      }
    }
    if (is(connection, "bpmn:Association") && !bpmnRules.canConnectAssociation(source, target)) {
      remove5 = true;
    }
    if (remove5) {
      modeling.removeConnection(connection);
    }
    if (replacementType) {
      modeling.connect(source, target, {
        type: replacementType,
        waypoints: connection.waypoints.slice()
      });
    }
  }
  function replaceReconnectedConnection(event2) {
    var context = event2.context, connection = context.connection, source = context.newSource || connection.source, target = context.newTarget || connection.target, allowed, replacement;
    allowed = bpmnRules.canConnect(source, target);
    if (!allowed || allowed.type === connection.type) {
      return;
    }
    replacement = modeling.connect(source, target, {
      type: allowed.type,
      waypoints: connection.waypoints.slice()
    });
    modeling.removeConnection(connection);
    context.connection = replacement;
    if (dragging) {
      cleanDraggingSelection(connection, replacement);
    }
  }
  function cleanDraggingSelection(oldConnection, newConnection) {
    var context = dragging.context(), previousSelection = context && context.payload.previousSelection, index2;
    if (!previousSelection || !previousSelection.length) {
      return;
    }
    index2 = previousSelection.indexOf(oldConnection);
    if (index2 === -1) {
      return;
    }
    previousSelection.splice(index2, 1, newConnection);
  }
  this.postExecuted("elements.move", function(context) {
    var closure = context.closure, allConnections = closure.allConnections;
    (0, import_min_dash88.forEach)(allConnections, fixConnection);
  }, true);
  this.preExecute("connection.reconnect", replaceReconnectedConnection);
  this.postExecuted("element.updateProperties", function(event2) {
    var context = event2.context, properties = context.properties, element = context.element, businessObject = element.businessObject, connection;
    if (properties.default) {
      connection = (0, import_min_dash88.find)(element.outgoing, (0, import_min_dash88.matchPattern)({ id: element.businessObject.default.id }));
      if (connection) {
        modeling.updateProperties(connection, { conditionExpression: void 0 });
      }
    }
    if (properties.conditionExpression && businessObject.sourceRef.default === businessObject) {
      modeling.updateProperties(element.source, { default: void 0 });
    }
  });
}
e(ReplaceConnectionBehavior, CommandInterceptor);
ReplaceConnectionBehavior.$inject = [
  "eventBus",
  "modeling",
  "bpmnRules",
  "injector"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/ReplaceElementBehaviour.js
var import_min_dash89 = __toESM(require_dist());
function ReplaceElementBehaviour(bpmnReplace, bpmnRules, elementRegistry, injector, modeling, selection) {
  injector.invoke(CommandInterceptor, this);
  this._bpmnReplace = bpmnReplace;
  this._elementRegistry = elementRegistry;
  this._selection = selection;
  this.postExecuted(["elements.create"], 500, function(event2) {
    var context = event2.context, target = context.parent, elements = context.elements;
    var elementReplacements = (0, import_min_dash89.reduce)(elements, function(replacements, element) {
      var canReplace2 = bpmnRules.canReplace([element], element.host || element.parent || target);
      return canReplace2 ? replacements.concat(canReplace2.replacements) : replacements;
    }, []);
    if (elementReplacements.length) {
      this.replaceElements(elements, elementReplacements);
    }
  }, this);
  this.postExecuted(["elements.move"], 500, function(event2) {
    var context = event2.context, target = context.newParent, newHost = context.newHost, elements = [];
    (0, import_min_dash89.forEach)(context.closure.topLevel, function(topLevelElements) {
      if (isEventSubProcess(topLevelElements)) {
        elements = elements.concat(topLevelElements.children);
      } else {
        elements = elements.concat(topLevelElements);
      }
    });
    if (elements.length === 1 && newHost) {
      target = newHost;
    }
    var canReplace2 = bpmnRules.canReplace(elements, target);
    if (canReplace2) {
      this.replaceElements(elements, canReplace2.replacements, newHost);
    }
  }, this);
  this.postExecute(["shape.replace"], 1500, function(e7) {
    var context = e7.context, oldShape = context.oldShape, newShape = context.newShape, attachers = oldShape.attachers, canReplace2;
    if (attachers && attachers.length) {
      canReplace2 = bpmnRules.canReplace(attachers, newShape);
      this.replaceElements(attachers, canReplace2.replacements);
    }
  }, this);
  this.postExecuted(["shape.replace"], 1500, function(e7) {
    var context = e7.context, oldShape = context.oldShape, newShape = context.newShape;
    modeling.unclaimId(oldShape.businessObject.id, oldShape.businessObject);
    modeling.updateProperties(newShape, { id: oldShape.id });
  });
}
e(ReplaceElementBehaviour, CommandInterceptor);
ReplaceElementBehaviour.prototype.replaceElements = function(elements, newElements) {
  var elementRegistry = this._elementRegistry, bpmnReplace = this._bpmnReplace, selection = this._selection;
  (0, import_min_dash89.forEach)(newElements, function(replacement) {
    var newElement = {
      type: replacement.newElementType
    };
    var oldElement = elementRegistry.get(replacement.oldElementId);
    var idx = elements.indexOf(oldElement);
    elements[idx] = bpmnReplace.replaceElement(oldElement, newElement, { select: false });
  });
  if (newElements) {
    selection.select(elements);
  }
};
ReplaceElementBehaviour.$inject = [
  "bpmnReplace",
  "bpmnRules",
  "elementRegistry",
  "injector",
  "modeling",
  "selection"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/ResizeBehavior.js
var HIGH_PRIORITY11 = 1500;
var GROUP_MIN_DIMENSIONS = { width: 140, height: 120 };
var LANE_MIN_DIMENSIONS = { width: 300, height: 60 };
var PARTICIPANT_MIN_DIMENSIONS = { width: 300, height: 150 };
var SUB_PROCESS_MIN_DIMENSIONS = { width: 140, height: 120 };
var TEXT_ANNOTATION_MIN_DIMENSIONS = { width: 50, height: 30 };
function ResizeBehavior2(eventBus) {
  eventBus.on("resize.start", HIGH_PRIORITY11, function(event2) {
    var context = event2.context, shape = context.shape, direction = context.direction, balanced = context.balanced;
    if (is(shape, "bpmn:Lane") || is(shape, "bpmn:Participant")) {
      context.resizeConstraints = getParticipantResizeConstraints(shape, direction, balanced);
    }
    if (is(shape, "bpmn:Participant")) {
      context.minDimensions = PARTICIPANT_MIN_DIMENSIONS;
    }
    if (is(shape, "bpmn:SubProcess") && isExpanded(shape)) {
      context.minDimensions = SUB_PROCESS_MIN_DIMENSIONS;
    }
    if (is(shape, "bpmn:TextAnnotation")) {
      context.minDimensions = TEXT_ANNOTATION_MIN_DIMENSIONS;
    }
  });
}
ResizeBehavior2.$inject = ["eventBus"];
var abs5 = Math.abs;
var min4 = Math.min;
var max5 = Math.max;
function addToTrbl(trbl, attr3, value, choice) {
  var current = trbl[attr3];
  trbl[attr3] = current === void 0 ? value : choice(value, current);
}
function addMin(trbl, attr3, value) {
  return addToTrbl(trbl, attr3, value, min4);
}
function addMax(trbl, attr3, value) {
  return addToTrbl(trbl, attr3, value, max5);
}
var LANE_RIGHT_PADDING = 20;
var LANE_LEFT_PADDING = 50;
var LANE_TOP_PADDING = 20;
var LANE_BOTTOM_PADDING = 20;
function getParticipantResizeConstraints(laneShape, resizeDirection, balanced) {
  var lanesRoot = getLanesRoot(laneShape);
  var isFirst = true, isLast = true;
  var allLanes = collectLanes(lanesRoot, [lanesRoot]);
  var laneTrbl = asTRBL(laneShape);
  var maxTrbl = {}, minTrbl = {};
  if (/e/.test(resizeDirection)) {
    minTrbl.right = laneTrbl.left + LANE_MIN_DIMENSIONS.width;
  } else if (/w/.test(resizeDirection)) {
    minTrbl.left = laneTrbl.right - LANE_MIN_DIMENSIONS.width;
  }
  allLanes.forEach(function(other) {
    var otherTrbl = asTRBL(other);
    if (/n/.test(resizeDirection)) {
      if (otherTrbl.top < laneTrbl.top - 10) {
        isFirst = false;
      }
      if (balanced && abs5(laneTrbl.top - otherTrbl.bottom) < 10) {
        addMax(maxTrbl, "top", otherTrbl.top + LANE_MIN_DIMENSIONS.height);
      }
      if (abs5(laneTrbl.top - otherTrbl.top) < 5) {
        addMin(minTrbl, "top", otherTrbl.bottom - LANE_MIN_DIMENSIONS.height);
      }
    }
    if (/s/.test(resizeDirection)) {
      if (otherTrbl.bottom > laneTrbl.bottom + 10) {
        isLast = false;
      }
      if (balanced && abs5(laneTrbl.bottom - otherTrbl.top) < 10) {
        addMin(maxTrbl, "bottom", otherTrbl.bottom - LANE_MIN_DIMENSIONS.height);
      }
      if (abs5(laneTrbl.bottom - otherTrbl.bottom) < 5) {
        addMax(minTrbl, "bottom", otherTrbl.top + LANE_MIN_DIMENSIONS.height);
      }
    }
  });
  var flowElements = lanesRoot.children.filter(function(s5) {
    return !s5.hidden && !s5.waypoints && (is(s5, "bpmn:FlowElement") || is(s5, "bpmn:Artifact"));
  });
  flowElements.forEach(function(flowElement) {
    var flowElementTrbl = asTRBL(flowElement);
    if (isFirst && /n/.test(resizeDirection)) {
      addMin(minTrbl, "top", flowElementTrbl.top - LANE_TOP_PADDING);
    }
    if (/e/.test(resizeDirection)) {
      addMax(minTrbl, "right", flowElementTrbl.right + LANE_RIGHT_PADDING);
    }
    if (isLast && /s/.test(resizeDirection)) {
      addMax(minTrbl, "bottom", flowElementTrbl.bottom + LANE_BOTTOM_PADDING);
    }
    if (/w/.test(resizeDirection)) {
      addMin(minTrbl, "left", flowElementTrbl.left - LANE_LEFT_PADDING);
    }
  });
  return {
    min: minTrbl,
    max: maxTrbl
  };
}

// node_modules/bpmn-js/lib/features/modeling/behavior/ResizeLaneBehavior.js
var SLIGHTLY_HIGHER_PRIORITY = 1001;
function ResizeLaneBehavior(eventBus, modeling) {
  eventBus.on("resize.start", SLIGHTLY_HIGHER_PRIORITY + 500, function(event2) {
    var context = event2.context, shape = context.shape;
    if (is(shape, "bpmn:Lane") || is(shape, "bpmn:Participant")) {
      context.balanced = !hasPrimaryModifier(event2);
    }
  });
  eventBus.on("resize.end", SLIGHTLY_HIGHER_PRIORITY, function(event2) {
    var context = event2.context, shape = context.shape, canExecute = context.canExecute, newBounds = context.newBounds;
    if (is(shape, "bpmn:Lane") || is(shape, "bpmn:Participant")) {
      if (canExecute) {
        newBounds = roundBounds(newBounds);
        modeling.resizeLane(shape, newBounds, context.balanced);
      }
      return false;
    }
  });
}
ResizeLaneBehavior.$inject = [
  "eventBus",
  "modeling"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/RootElementReferenceBehavior.js
var import_min_dash90 = __toESM(require_dist());
var LOW_PRIORITY17 = 500;
function RootElementReferenceBehavior(bpmnjs, eventBus, injector, moddleCopy, bpmnFactory) {
  injector.invoke(CommandInterceptor, this);
  function canHaveRootElementReference(element) {
    return isAny(element, ["bpmn:ReceiveTask", "bpmn:SendTask"]) || hasAnyEventDefinition(element, [
      "bpmn:ErrorEventDefinition",
      "bpmn:EscalationEventDefinition",
      "bpmn:MessageEventDefinition",
      "bpmn:SignalEventDefinition"
    ]);
  }
  function hasRootElement(rootElement) {
    var definitions = bpmnjs.getDefinitions(), rootElements = definitions.get("rootElements");
    return !!(0, import_min_dash90.find)(rootElements, (0, import_min_dash90.matchPattern)({ id: rootElement.id }));
  }
  function getRootElementReferencePropertyName(eventDefinition) {
    if (is(eventDefinition, "bpmn:ErrorEventDefinition")) {
      return "errorRef";
    } else if (is(eventDefinition, "bpmn:EscalationEventDefinition")) {
      return "escalationRef";
    } else if (is(eventDefinition, "bpmn:MessageEventDefinition")) {
      return "messageRef";
    } else if (is(eventDefinition, "bpmn:SignalEventDefinition")) {
      return "signalRef";
    }
  }
  function getRootElement3(businessObject) {
    if (isAny(businessObject, ["bpmn:ReceiveTask", "bpmn:SendTask"])) {
      return businessObject.get("messageRef");
    }
    var eventDefinitions = businessObject.get("eventDefinitions"), eventDefinition = eventDefinitions[0];
    return eventDefinition.get(getRootElementReferencePropertyName(eventDefinition));
  }
  function setRootElement(businessObject, rootElement) {
    if (isAny(businessObject, ["bpmn:ReceiveTask", "bpmn:SendTask"])) {
      return businessObject.set("messageRef", rootElement);
    }
    var eventDefinitions = businessObject.get("eventDefinitions"), eventDefinition = eventDefinitions[0];
    return eventDefinition.set(getRootElementReferencePropertyName(eventDefinition), rootElement);
  }
  this.executed("shape.create", function(context) {
    var shape = context.shape;
    if (!canHaveRootElementReference(shape)) {
      return;
    }
    var businessObject = getBusinessObject(shape), rootElement = getRootElement3(businessObject), rootElements;
    if (rootElement && !hasRootElement(rootElement)) {
      rootElements = bpmnjs.getDefinitions().get("rootElements");
      add2(rootElements, rootElement);
      context.addedRootElement = rootElement;
    }
  }, true);
  this.reverted("shape.create", function(context) {
    var addedRootElement = context.addedRootElement;
    if (!addedRootElement) {
      return;
    }
    var rootElements = bpmnjs.getDefinitions().get("rootElements");
    remove3(rootElements, addedRootElement);
  }, true);
  eventBus.on("copyPaste.copyElement", function(context) {
    var descriptor = context.descriptor, element = context.element;
    if (element.labelTarget || !canHaveRootElementReference(element)) {
      return;
    }
    var businessObject = getBusinessObject(element), rootElement = getRootElement3(businessObject);
    if (rootElement) {
      descriptor.referencedRootElement = rootElement;
    }
  });
  eventBus.on("copyPaste.pasteElement", LOW_PRIORITY17, function(context) {
    var descriptor = context.descriptor, businessObject = descriptor.businessObject, referencedRootElement = descriptor.referencedRootElement;
    if (!referencedRootElement) {
      return;
    }
    if (!hasRootElement(referencedRootElement)) {
      referencedRootElement = moddleCopy.copyElement(referencedRootElement, bpmnFactory.create(referencedRootElement.$type));
    }
    setRootElement(businessObject, referencedRootElement);
    delete descriptor.referencedRootElement;
  });
}
RootElementReferenceBehavior.$inject = [
  "bpmnjs",
  "eventBus",
  "injector",
  "moddleCopy",
  "bpmnFactory"
];
e(RootElementReferenceBehavior, CommandInterceptor);
function hasAnyEventDefinition(element, types3) {
  if (!(0, import_min_dash90.isArray)(types3)) {
    types3 = [types3];
  }
  return (0, import_min_dash90.some)(types3, function(type) {
    return hasEventDefinition(element, type);
  });
}

// node_modules/bpmn-js/lib/features/modeling/behavior/SpaceToolBehavior.js
var import_min_dash91 = __toESM(require_dist());
var max6 = Math.max;
function SpaceToolBehavior2(eventBus) {
  eventBus.on("spaceTool.getMinDimensions", function(context) {
    var shapes = context.shapes, axis = context.axis, start = context.start, minDimensions = {};
    (0, import_min_dash91.forEach)(shapes, function(shape) {
      var id = shape.id;
      if (is(shape, "bpmn:Participant")) {
        if (isHorizontal3(axis)) {
          minDimensions[id] = PARTICIPANT_MIN_DIMENSIONS;
        } else {
          minDimensions[id] = {
            width: PARTICIPANT_MIN_DIMENSIONS.width,
            height: getParticipantMinHeight(shape, start)
          };
        }
      }
      if (is(shape, "bpmn:SubProcess") && isExpanded(shape)) {
        minDimensions[id] = SUB_PROCESS_MIN_DIMENSIONS;
      }
      if (is(shape, "bpmn:TextAnnotation")) {
        minDimensions[id] = TEXT_ANNOTATION_MIN_DIMENSIONS;
      }
      if (is(shape, "bpmn:Group")) {
        minDimensions[id] = GROUP_MIN_DIMENSIONS;
      }
    });
    return minDimensions;
  });
}
SpaceToolBehavior2.$inject = ["eventBus"];
function isHorizontal3(axis) {
  return axis === "x";
}
function getParticipantMinHeight(participant, start) {
  var lanesMinHeight;
  if (!hasChildLanes(participant)) {
    return PARTICIPANT_MIN_DIMENSIONS.height;
  }
  lanesMinHeight = getLanesMinHeight(participant, start);
  return max6(PARTICIPANT_MIN_DIMENSIONS.height, lanesMinHeight);
}
function hasChildLanes(element) {
  return !!getChildLanes(element).length;
}
function getLanesMinHeight(participant, resizeStart) {
  var lanes = getChildLanes(participant), resizedLane;
  resizedLane = findResizedLane(lanes, resizeStart);
  return participant.height - resizedLane.height + LANE_MIN_DIMENSIONS.height;
}
function findResizedLane(lanes, resizeStart) {
  var i6, lane, childLanes;
  for (i6 = 0; i6 < lanes.length; i6++) {
    lane = lanes[i6];
    if (resizeStart >= lane.y && resizeStart <= lane.y + lane.height) {
      childLanes = getChildLanes(lane);
      if (childLanes.length) {
        return findResizedLane(childLanes, resizeStart);
      }
      return lane;
    }
  }
}

// node_modules/bpmn-js/lib/features/modeling/behavior/SubProcessPlaneBehavior.js
var import_min_dash92 = __toESM(require_dist());
var LOW_PRIORITY18 = 400;
var HIGH_PRIORITY12 = 600;
var DEFAULT_POSITION2 = {
  x: 180,
  y: 160
};
function SubProcessPlaneBehavior(canvas, eventBus, modeling, elementFactory, bpmnFactory, bpmnjs, elementRegistry) {
  CommandInterceptor.call(this, eventBus);
  this._canvas = canvas;
  this._eventBus = eventBus;
  this._modeling = modeling;
  this._elementFactory = elementFactory;
  this._bpmnFactory = bpmnFactory;
  this._bpmnjs = bpmnjs;
  this._elementRegistry = elementRegistry;
  var self2 = this;
  function isCollapsedSubProcess2(element) {
    return is(element, "bpmn:SubProcess") && !isExpanded(element);
  }
  function createRoot3(context) {
    var shape = context.shape, rootElement = context.newRootElement;
    var businessObject = getBusinessObject(shape);
    rootElement = self2._addDiagram(rootElement || businessObject);
    context.newRootElement = canvas.addRootElement(rootElement);
  }
  function removeRoot(context) {
    var shape = context.shape;
    var businessObject = getBusinessObject(shape);
    self2._removeDiagram(businessObject);
    var rootElement = context.newRootElement = elementRegistry.get(getPlaneIdFromShape(businessObject));
    canvas.removeRootElement(rootElement);
  }
  this.executed("shape.create", function(context) {
    var shape = context.shape;
    if (!isCollapsedSubProcess2(shape)) {
      return;
    }
    createRoot3(context);
  }, true);
  this.postExecuted("shape.create", function(context) {
    var shape = context.shape, rootElement = context.newRootElement;
    if (!rootElement || !shape.children) {
      return;
    }
    self2._showRecursively(shape.children);
    self2._moveChildrenToShape(shape, rootElement);
  }, true);
  this.reverted("shape.create", function(context) {
    var shape = context.shape;
    if (!isCollapsedSubProcess2(shape)) {
      return;
    }
    removeRoot(context);
  }, true);
  this.preExecuted("shape.delete", function(context) {
    var shape = context.shape;
    if (!isCollapsedSubProcess2(shape)) {
      return;
    }
    var attachedRoot = elementRegistry.get(getPlaneIdFromShape(shape));
    if (!attachedRoot) {
      return;
    }
    modeling.removeElements(attachedRoot.children.slice());
  }, true);
  this.executed("shape.delete", function(context) {
    var shape = context.shape;
    if (!isCollapsedSubProcess2(shape)) {
      return;
    }
    removeRoot(context);
  }, true);
  this.reverted("shape.delete", function(context) {
    var shape = context.shape;
    if (!isCollapsedSubProcess2(shape)) {
      return;
    }
    createRoot3(context);
  }, true);
  this.preExecuted("shape.replace", function(context) {
    var oldShape = context.oldShape;
    var newShape = context.newShape;
    if (!isCollapsedSubProcess2(oldShape) || !isCollapsedSubProcess2(newShape)) {
      return;
    }
    context.oldRoot = canvas.removeRootElement(getPlaneIdFromShape(oldShape));
  }, true);
  this.postExecuted("shape.replace", function(context) {
    var newShape = context.newShape, source = context.oldRoot, target = canvas.findRoot(getPlaneIdFromShape(newShape));
    if (!source || !target) {
      return;
    }
    var elements = source.children;
    modeling.moveElements(elements, { x: 0, y: 0 }, target);
  }, true);
  this.executed("element.updateProperties", function(context) {
    var shape = context.element;
    if (!is(shape, "bpmn:SubProcess")) {
      return;
    }
    var properties = context.properties;
    var oldProperties = context.oldProperties;
    var oldId = oldProperties.id, newId = properties.id;
    if (oldId === newId) {
      return;
    }
    if (isPlane(shape)) {
      elementRegistry.updateId(shape, toPlaneId(newId));
      elementRegistry.updateId(oldId, newId);
      return;
    }
    var planeElement = elementRegistry.get(toPlaneId(oldId));
    if (!planeElement) {
      return;
    }
    elementRegistry.updateId(toPlaneId(oldId), toPlaneId(newId));
  }, true);
  this.reverted("element.updateProperties", function(context) {
    var shape = context.element;
    if (!is(shape, "bpmn:SubProcess")) {
      return;
    }
    var properties = context.properties;
    var oldProperties = context.oldProperties;
    var oldId = oldProperties.id, newId = properties.id;
    if (oldId === newId) {
      return;
    }
    if (isPlane(shape)) {
      elementRegistry.updateId(shape, toPlaneId(oldId));
      elementRegistry.updateId(newId, oldId);
      return;
    }
    var planeElement = elementRegistry.get(toPlaneId(newId));
    if (!planeElement) {
      return;
    }
    elementRegistry.updateId(planeElement, toPlaneId(oldId));
  }, true);
  eventBus.on("element.changed", function(context) {
    var element = context.element;
    if (!isPlane(element)) {
      return;
    }
    var plane = element;
    var primaryShape = elementRegistry.get(getShapeIdFromPlane(plane));
    if (!primaryShape || primaryShape === plane) {
      return;
    }
    eventBus.fire("element.changed", { element: primaryShape });
  });
  this.executed("shape.toggleCollapse", LOW_PRIORITY18, function(context) {
    var shape = context.shape;
    if (!is(shape, "bpmn:SubProcess")) {
      return;
    }
    if (!isExpanded(shape)) {
      createRoot3(context);
      self2._showRecursively(shape.children);
    } else {
      removeRoot(context);
    }
  }, true);
  this.reverted("shape.toggleCollapse", LOW_PRIORITY18, function(context) {
    var shape = context.shape;
    if (!is(shape, "bpmn:SubProcess")) {
      return;
    }
    if (!isExpanded(shape)) {
      createRoot3(context);
      self2._showRecursively(shape.children);
    } else {
      removeRoot(context);
    }
  }, true);
  this.postExecuted("shape.toggleCollapse", HIGH_PRIORITY12, function(context) {
    var shape = context.shape;
    if (!is(shape, "bpmn:SubProcess")) {
      return;
    }
    var rootElement = context.newRootElement;
    if (!rootElement) {
      return;
    }
    if (!isExpanded(shape)) {
      self2._moveChildrenToShape(shape, rootElement);
    } else {
      self2._moveChildrenToShape(rootElement, shape);
    }
  }, true);
  eventBus.on("copyPaste.createTree", function(context) {
    var element = context.element, children = context.children;
    if (!isCollapsedSubProcess2(element)) {
      return;
    }
    var id = getPlaneIdFromShape(element);
    var parent = elementRegistry.get(id);
    if (parent) {
      children.push.apply(children, parent.children);
    }
  });
  eventBus.on("copyPaste.copyElement", function(context) {
    var descriptor = context.descriptor, element = context.element, elements = context.elements;
    var parent = element.parent;
    var isPlane3 = is(getDi(parent), "bpmndi:BPMNPlane");
    if (!isPlane3) {
      return;
    }
    var parentId = getShapeIdFromPlane(parent);
    var referencedShape = (0, import_min_dash92.find)(elements, function(element2) {
      return element2.id === parentId;
    });
    if (!referencedShape) {
      return;
    }
    descriptor.parent = referencedShape.id;
  });
  eventBus.on("copyPaste.pasteElement", function(context) {
    var descriptor = context.descriptor;
    if (!descriptor.parent) {
      return;
    }
    if (isCollapsedSubProcess2(descriptor.parent) || descriptor.parent.hidden) {
      descriptor.hidden = true;
    }
  });
}
e(SubProcessPlaneBehavior, CommandInterceptor);
SubProcessPlaneBehavior.prototype._moveChildrenToShape = function(source, target) {
  var modeling = this._modeling;
  var children = source.children;
  var offset;
  if (!children) {
    return;
  }
  children = children.concat(children.reduce(function(labels, child) {
    if (child.label && child.label.parent !== source) {
      return labels.concat(child.label);
    }
    return labels;
  }, []));
  var visibleChildren = children.filter(function(child) {
    return !child.hidden;
  });
  if (!visibleChildren.length) {
    modeling.moveElements(children, { x: 0, y: 0 }, target, { autoResize: false });
    return;
  }
  var childrenBounds = getBBox(visibleChildren);
  if (!target.x) {
    offset = {
      x: DEFAULT_POSITION2.x - childrenBounds.x,
      y: DEFAULT_POSITION2.y - childrenBounds.y
    };
  } else {
    var targetMid = getMid(target);
    var childrenMid = getMid(childrenBounds);
    offset = {
      x: targetMid.x - childrenMid.x,
      y: targetMid.y - childrenMid.y
    };
  }
  modeling.moveElements(children, offset, target, { autoResize: false });
};
SubProcessPlaneBehavior.prototype._showRecursively = function(elements, hidden) {
  var self2 = this;
  var result = [];
  elements.forEach(function(element) {
    element.hidden = !!hidden;
    result = result.concat(element);
    if (element.children) {
      result = result.concat(self2._showRecursively(element.children, element.collapsed || hidden));
    }
  });
  return result;
};
SubProcessPlaneBehavior.prototype._addDiagram = function(planeElement) {
  var bpmnjs = this._bpmnjs;
  var diagrams = bpmnjs.getDefinitions().diagrams;
  if (!planeElement.businessObject) {
    planeElement = this._createNewDiagram(planeElement);
  }
  diagrams.push(planeElement.di.$parent);
  return planeElement;
};
SubProcessPlaneBehavior.prototype._createNewDiagram = function(bpmnElement) {
  var bpmnFactory = this._bpmnFactory;
  var elementFactory = this._elementFactory;
  var diPlane = bpmnFactory.create("bpmndi:BPMNPlane", {
    bpmnElement
  });
  var diDiagram = bpmnFactory.create("bpmndi:BPMNDiagram", {
    plane: diPlane
  });
  diPlane.$parent = diDiagram;
  var planeElement = elementFactory.createRoot({
    id: getPlaneIdFromShape(bpmnElement),
    type: bpmnElement.$type,
    di: diPlane,
    businessObject: bpmnElement,
    collapsed: true
  });
  return planeElement;
};
SubProcessPlaneBehavior.prototype._removeDiagram = function(rootElement) {
  var bpmnjs = this._bpmnjs;
  var diagrams = bpmnjs.getDefinitions().diagrams;
  var removedDiagram = (0, import_min_dash92.find)(diagrams, function(diagram) {
    return diagram.plane.bpmnElement.id === rootElement.id;
  });
  diagrams.splice(diagrams.indexOf(removedDiagram), 1);
  return removedDiagram;
};
SubProcessPlaneBehavior.$inject = [
  "canvas",
  "eventBus",
  "modeling",
  "elementFactory",
  "bpmnFactory",
  "bpmnjs",
  "elementRegistry"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/SubProcessStartEventBehavior.js
function SubProcessStartEventBehavior(injector, modeling) {
  injector.invoke(CommandInterceptor, this);
  this.postExecuted("shape.replace", function(event2) {
    var oldShape = event2.context.oldShape, newShape = event2.context.newShape;
    if (!is(newShape, "bpmn:SubProcess") || !(is(oldShape, "bpmn:Task") || is(oldShape, "bpmn:CallActivity")) || !isExpanded(newShape)) {
      return;
    }
    var position = getStartEventPosition(newShape);
    modeling.createShape({ type: "bpmn:StartEvent" }, position, newShape);
  });
}
SubProcessStartEventBehavior.$inject = [
  "injector",
  "modeling"
];
e(SubProcessStartEventBehavior, CommandInterceptor);
function getStartEventPosition(shape) {
  return {
    x: shape.x + shape.width / 6,
    y: shape.y + shape.height / 2
  };
}

// node_modules/bpmn-js/lib/features/modeling/behavior/ToggleCollapseConnectionBehaviour.js
var import_min_dash93 = __toESM(require_dist());
function ToggleCollapseConnectionBehaviour(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.postExecuted("shape.toggleCollapse", 1500, function(context) {
    var shape = context.shape;
    if (isExpanded(shape)) {
      return;
    }
    var allChildren = selfAndAllChildren(shape);
    allChildren.forEach(function(child) {
      var incomingConnections = child.incoming.slice(), outgoingConnections = child.outgoing.slice();
      (0, import_min_dash93.forEach)(incomingConnections, function(c5) {
        handleConnection(c5, true);
      });
      (0, import_min_dash93.forEach)(outgoingConnections, function(c5) {
        handleConnection(c5, false);
      });
    });
    function handleConnection(c5, incoming) {
      if (allChildren.indexOf(c5.source) !== -1 && allChildren.indexOf(c5.target) !== -1) {
        return;
      }
      if (incoming) {
        modeling.reconnectEnd(c5, shape, getMid(shape));
      } else {
        modeling.reconnectStart(c5, shape, getMid(shape));
      }
    }
  }, true);
}
e(ToggleCollapseConnectionBehaviour, CommandInterceptor);
ToggleCollapseConnectionBehaviour.$inject = [
  "eventBus",
  "modeling"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/ToggleElementCollapseBehaviour.js
var LOW_PRIORITY19 = 500;
function ToggleElementCollapseBehaviour(eventBus, elementFactory, modeling, resize) {
  CommandInterceptor.call(this, eventBus);
  function hideEmptyLabels(children) {
    if (children.length) {
      children.forEach(function(child) {
        if (child.type === "label" && !child.businessObject.name) {
          child.hidden = true;
        }
      });
    }
  }
  function expandedBounds(shape, defaultSize) {
    var children = shape.children, newBounds = defaultSize, visibleElements, visibleBBox;
    visibleElements = filterVisible(children).concat([shape]);
    visibleBBox = computeChildrenBBox(visibleElements);
    if (visibleBBox) {
      newBounds.width = Math.max(visibleBBox.width, newBounds.width);
      newBounds.height = Math.max(visibleBBox.height, newBounds.height);
      newBounds.x = visibleBBox.x + (visibleBBox.width - newBounds.width) / 2;
      newBounds.y = visibleBBox.y + (visibleBBox.height - newBounds.height) / 2;
    } else {
      newBounds.x = shape.x + (shape.width - newBounds.width) / 2;
      newBounds.y = shape.y + (shape.height - newBounds.height) / 2;
    }
    return newBounds;
  }
  function collapsedBounds(shape, defaultSize) {
    return {
      x: shape.x + (shape.width - defaultSize.width) / 2,
      y: shape.y + (shape.height - defaultSize.height) / 2,
      width: defaultSize.width,
      height: defaultSize.height
    };
  }
  this.executed(["shape.toggleCollapse"], LOW_PRIORITY19, function(e7) {
    var context = e7.context, shape = context.shape;
    if (!is(shape, "bpmn:SubProcess")) {
      return;
    }
    if (!shape.collapsed) {
      hideEmptyLabels(shape.children);
      getDi(shape).isExpanded = true;
    } else {
      getDi(shape).isExpanded = false;
    }
  });
  this.reverted(["shape.toggleCollapse"], LOW_PRIORITY19, function(e7) {
    var context = e7.context;
    var shape = context.shape;
    if (!shape.collapsed) {
      getDi(shape).isExpanded = true;
    } else {
      getDi(shape).isExpanded = false;
    }
  });
  this.postExecuted(["shape.toggleCollapse"], LOW_PRIORITY19, function(e7) {
    var shape = e7.context.shape, defaultSize = elementFactory.getDefaultSize(shape), newBounds;
    if (shape.collapsed) {
      newBounds = collapsedBounds(shape, defaultSize);
    } else {
      newBounds = expandedBounds(shape, defaultSize);
    }
    modeling.resizeShape(shape, newBounds, null, {
      autoResize: shape.collapsed ? false : "nwse"
    });
  });
}
e(ToggleElementCollapseBehaviour, CommandInterceptor);
ToggleElementCollapseBehaviour.$inject = [
  "eventBus",
  "elementFactory",
  "modeling"
];
function filterVisible(elements) {
  return elements.filter(function(e7) {
    return !e7.hidden;
  });
}

// node_modules/bpmn-js/lib/features/modeling/behavior/UnclaimIdBehavior.js
function UnclaimIdBehavior(canvas, injector, moddle, modeling) {
  injector.invoke(CommandInterceptor, this);
  this.preExecute("shape.delete", function(event2) {
    var context = event2.context, shape = context.shape, shapeBo = shape.businessObject;
    if (isLabel(shape)) {
      return;
    }
    if (is(shape, "bpmn:Participant") && isExpanded(shape)) {
      moddle.ids.unclaim(shapeBo.processRef.id);
    }
    modeling.unclaimId(shapeBo.id, shapeBo);
  });
  this.preExecute("connection.delete", function(event2) {
    var context = event2.context, connection = context.connection, connectionBo = connection.businessObject;
    modeling.unclaimId(connectionBo.id, connectionBo);
  });
  this.preExecute("canvas.updateRoot", function() {
    var rootElement = canvas.getRootElement(), rootElementBo = rootElement.businessObject;
    if (is(rootElement, "bpmn:Collaboration")) {
      moddle.ids.unclaim(rootElementBo.id);
    }
  });
}
e(UnclaimIdBehavior, CommandInterceptor);
UnclaimIdBehavior.$inject = ["canvas", "injector", "moddle", "modeling"];

// node_modules/bpmn-js/lib/features/modeling/behavior/UnsetDefaultFlowBehavior.js
function DeleteSequenceFlowBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("connection.delete", function(event2) {
    var context = event2.context, connection = context.connection, source = connection.source;
    if (isDefaultFlow(connection, source)) {
      modeling.updateProperties(source, {
        "default": null
      });
    }
  });
}
e(DeleteSequenceFlowBehavior, CommandInterceptor);
DeleteSequenceFlowBehavior.$inject = [
  "eventBus",
  "modeling"
];
function isDefaultFlow(connection, source) {
  if (!is(connection, "bpmn:SequenceFlow")) {
    return false;
  }
  var sourceBo = getBusinessObject(source), sequenceFlow = getBusinessObject(connection);
  return sourceBo.get("default") === sequenceFlow;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/UpdateFlowNodeRefsBehavior.js
var LOW_PRIORITY20 = 500;
var HIGH_PRIORITY13 = 5e3;
function UpdateFlowNodeRefsBehavior(eventBus, modeling, translate3) {
  CommandInterceptor.call(this, eventBus);
  var context;
  function initContext() {
    context = context || new UpdateContext();
    context.enter();
    return context;
  }
  function getContext() {
    if (!context) {
      throw new Error(translate3("out of bounds release"));
    }
    return context;
  }
  function releaseContext() {
    if (!context) {
      throw new Error(translate3("out of bounds release"));
    }
    var triggerUpdate = context.leave();
    if (triggerUpdate) {
      modeling.updateLaneRefs(context.flowNodes, context.lanes);
      context = null;
    }
    return triggerUpdate;
  }
  var laneRefUpdateEvents = [
    "spaceTool",
    "lane.add",
    "lane.resize",
    "lane.split",
    "elements.create",
    "elements.delete",
    "elements.move",
    "shape.create",
    "shape.delete",
    "shape.move",
    "shape.resize"
  ];
  this.preExecute(laneRefUpdateEvents, HIGH_PRIORITY13, function(event2) {
    initContext();
  });
  this.postExecuted(laneRefUpdateEvents, LOW_PRIORITY20, function(event2) {
    releaseContext();
  });
  this.preExecute([
    "shape.create",
    "shape.move",
    "shape.delete",
    "shape.resize"
  ], function(event2) {
    var context2 = event2.context, shape = context2.shape;
    var updateContext = getContext();
    if (shape.labelTarget) {
      return;
    }
    if (is(shape, "bpmn:Lane")) {
      updateContext.addLane(shape);
    }
    if (is(shape, "bpmn:FlowNode")) {
      updateContext.addFlowNode(shape);
    }
  });
}
UpdateFlowNodeRefsBehavior.$inject = [
  "eventBus",
  "modeling",
  "translate"
];
e(UpdateFlowNodeRefsBehavior, CommandInterceptor);
function UpdateContext() {
  this.flowNodes = [];
  this.lanes = [];
  this.counter = 0;
  this.addLane = function(lane) {
    this.lanes.push(lane);
  };
  this.addFlowNode = function(flowNode) {
    this.flowNodes.push(flowNode);
  };
  this.enter = function() {
    this.counter++;
  };
  this.leave = function() {
    this.counter--;
    return !this.counter;
  };
}

// node_modules/bpmn-js/lib/features/modeling/behavior/index.js
var behavior_default3 = {
  __init__: [
    "adaptiveLabelPositioningBehavior",
    "appendBehavior",
    "associationBehavior",
    "attachEventBehavior",
    "boundaryEventBehavior",
    "createBehavior",
    "createDataObjectBehavior",
    "createParticipantBehavior",
    "dataInputAssociationBehavior",
    "dataStoreBehavior",
    "deleteLaneBehavior",
    "detachEventBehavior",
    "dropOnFlowBehavior",
    "eventBasedGatewayBehavior",
    "fixHoverBehavior",
    "groupBehavior",
    "importDockingFix",
    "isHorizontalFix",
    "labelBehavior",
    "layoutConnectionBehavior",
    "messageFlowBehavior",
    "modelingFeedback",
    "removeElementBehavior",
    "removeEmbeddedLabelBoundsBehavior",
    "removeParticipantBehavior",
    "replaceConnectionBehavior",
    "replaceElementBehaviour",
    "resizeBehavior",
    "resizeLaneBehavior",
    "rootElementReferenceBehavior",
    "spaceToolBehavior",
    "subProcessPlaneBehavior",
    "subProcessStartEventBehavior",
    "toggleCollapseConnectionBehaviour",
    "toggleElementCollapseBehaviour",
    "unclaimIdBehavior",
    "updateFlowNodeRefsBehavior",
    "unsetDefaultFlowBehavior"
  ],
  adaptiveLabelPositioningBehavior: ["type", AdaptiveLabelPositioningBehavior],
  appendBehavior: ["type", AppendBehavior],
  associationBehavior: ["type", AssociationBehavior],
  attachEventBehavior: ["type", AttachEventBehavior],
  boundaryEventBehavior: ["type", BoundaryEventBehavior],
  createBehavior: ["type", CreateBehavior],
  createDataObjectBehavior: ["type", CreateDataObjectBehavior],
  createParticipantBehavior: ["type", CreateParticipantBehavior],
  dataInputAssociationBehavior: ["type", DataInputAssociationBehavior],
  dataStoreBehavior: ["type", DataStoreBehavior],
  deleteLaneBehavior: ["type", DeleteLaneBehavior],
  detachEventBehavior: ["type", DetachEventBehavior],
  dropOnFlowBehavior: ["type", DropOnFlowBehavior],
  eventBasedGatewayBehavior: ["type", EventBasedGatewayBehavior],
  fixHoverBehavior: ["type", FixHoverBehavior],
  groupBehavior: ["type", GroupBehavior],
  importDockingFix: ["type", ImportDockingFix],
  isHorizontalFix: ["type", IsHorizontalFix],
  labelBehavior: ["type", LabelBehavior],
  layoutConnectionBehavior: ["type", LayoutConnectionBehavior],
  messageFlowBehavior: ["type", MessageFlowBehavior],
  modelingFeedback: ["type", ModelingFeedback],
  removeElementBehavior: ["type", RemoveElementBehavior],
  removeEmbeddedLabelBoundsBehavior: ["type", RemoveEmbeddedLabelBoundsBehavior],
  removeParticipantBehavior: ["type", RemoveParticipantBehavior],
  replaceConnectionBehavior: ["type", ReplaceConnectionBehavior],
  replaceElementBehaviour: ["type", ReplaceElementBehaviour],
  resizeBehavior: ["type", ResizeBehavior2],
  resizeLaneBehavior: ["type", ResizeLaneBehavior],
  rootElementReferenceBehavior: ["type", RootElementReferenceBehavior],
  spaceToolBehavior: ["type", SpaceToolBehavior2],
  subProcessPlaneBehavior: ["type", SubProcessPlaneBehavior],
  subProcessStartEventBehavior: ["type", SubProcessStartEventBehavior],
  toggleCollapseConnectionBehaviour: ["type", ToggleCollapseConnectionBehaviour],
  toggleElementCollapseBehaviour: ["type", ToggleElementCollapseBehaviour],
  unclaimIdBehavior: ["type", UnclaimIdBehavior],
  unsetDefaultFlowBehavior: ["type", DeleteSequenceFlowBehavior],
  updateFlowNodeRefsBehavior: ["type", UpdateFlowNodeRefsBehavior]
};

// node_modules/bpmn-js/lib/features/rules/BpmnRules.js
var import_min_dash94 = __toESM(require_dist());

// node_modules/bpmn-js/lib/features/snapping/BpmnSnappingUtil.js
function getBoundaryAttachment(position, targetBounds) {
  var orientation = getOrientation(position, targetBounds, -15);
  if (orientation !== "intersect") {
    return orientation;
  } else {
    return null;
  }
}

// node_modules/bpmn-js/lib/features/rules/BpmnRules.js
function BpmnRules(eventBus) {
  RuleProvider.call(this, eventBus);
}
e(BpmnRules, RuleProvider);
BpmnRules.$inject = ["eventBus"];
BpmnRules.prototype.init = function() {
  this.addRule("connection.start", function(context) {
    var source = context.source;
    return canStartConnection(source);
  });
  this.addRule("connection.create", function(context) {
    var source = context.source, target = context.target, hints = context.hints || {}, targetParent = hints.targetParent, targetAttach = hints.targetAttach;
    if (targetAttach) {
      return false;
    }
    if (targetParent) {
      target.parent = targetParent;
    }
    try {
      return canConnect(source, target);
    } finally {
      if (targetParent) {
        target.parent = null;
      }
    }
  });
  this.addRule("connection.reconnect", function(context) {
    var connection = context.connection, source = context.source, target = context.target;
    return canConnect(source, target, connection);
  });
  this.addRule("connection.updateWaypoints", function(context) {
    return {
      type: context.connection.type
    };
  });
  this.addRule("shape.resize", function(context) {
    var shape = context.shape, newBounds = context.newBounds;
    return canResize(shape, newBounds);
  });
  this.addRule("elements.create", function(context) {
    var elements = context.elements, position = context.position, target = context.target;
    if (isConnection8(target) && !canInsert(elements, target, position)) {
      return false;
    }
    return (0, import_min_dash94.every)(elements, function(element) {
      if (isConnection8(element)) {
        return canConnect(element.source, element.target, element);
      }
      if (element.host) {
        return canAttach(element, element.host, null, position);
      }
      return canCreate(element, target, null, position);
    });
  });
  this.addRule("elements.move", function(context) {
    var target = context.target, shapes = context.shapes, position = context.position;
    return canAttach(shapes, target, null, position) || canReplace(shapes, target, position) || canMove(shapes, target, position) || canInsert(shapes, target, position);
  });
  this.addRule("shape.create", function(context) {
    return canCreate(context.shape, context.target, context.source, context.position);
  });
  this.addRule("shape.attach", function(context) {
    return canAttach(context.shape, context.target, null, context.position);
  });
  this.addRule("element.copy", function(context) {
    var element = context.element, elements = context.elements;
    return canCopy(elements, element);
  });
};
BpmnRules.prototype.canConnectMessageFlow = canConnectMessageFlow;
BpmnRules.prototype.canConnectSequenceFlow = canConnectSequenceFlow;
BpmnRules.prototype.canConnectDataAssociation = canConnectDataAssociation;
BpmnRules.prototype.canConnectAssociation = canConnectAssociation;
BpmnRules.prototype.canMove = canMove;
BpmnRules.prototype.canAttach = canAttach;
BpmnRules.prototype.canReplace = canReplace;
BpmnRules.prototype.canDrop = canDrop;
BpmnRules.prototype.canInsert = canInsert;
BpmnRules.prototype.canCreate = canCreate;
BpmnRules.prototype.canConnect = canConnect;
BpmnRules.prototype.canResize = canResize;
BpmnRules.prototype.canCopy = canCopy;
function canStartConnection(element) {
  if (nonExistingOrLabel(element)) {
    return null;
  }
  return isAny(element, [
    "bpmn:FlowNode",
    "bpmn:InteractionNode",
    "bpmn:DataObjectReference",
    "bpmn:DataStoreReference",
    "bpmn:Group",
    "bpmn:TextAnnotation"
  ]);
}
function nonExistingOrLabel(element) {
  return !element || isLabel(element);
}
function isSame(a6, b5) {
  return a6 === b5;
}
function getOrganizationalParent(element) {
  do {
    if (is(element, "bpmn:Process")) {
      return getBusinessObject(element);
    }
    if (is(element, "bpmn:Participant")) {
      return getBusinessObject(element).processRef || getBusinessObject(element);
    }
  } while (element = element.parent);
}
function isTextAnnotation(element) {
  return is(element, "bpmn:TextAnnotation");
}
function isGroup(element) {
  return is(element, "bpmn:Group") && !element.labelTarget;
}
function isCompensationBoundary(element) {
  return is(element, "bpmn:BoundaryEvent") && hasEventDefinition3(element, "bpmn:CompensateEventDefinition");
}
function isForCompensation(e7) {
  return getBusinessObject(e7).isForCompensation;
}
function isSameOrganization(a6, b5) {
  var parentA = getOrganizationalParent(a6), parentB = getOrganizationalParent(b5);
  return parentA === parentB;
}
function isMessageFlowSource(element) {
  return is(element, "bpmn:InteractionNode") && !is(element, "bpmn:BoundaryEvent") && (!is(element, "bpmn:Event") || is(element, "bpmn:ThrowEvent") && hasEventDefinitionOrNone(element, "bpmn:MessageEventDefinition"));
}
function isMessageFlowTarget(element) {
  return is(element, "bpmn:InteractionNode") && !isForCompensation(element) && (!is(element, "bpmn:Event") || is(element, "bpmn:CatchEvent") && hasEventDefinitionOrNone(element, "bpmn:MessageEventDefinition")) && !(is(element, "bpmn:BoundaryEvent") && !hasEventDefinition3(element, "bpmn:MessageEventDefinition"));
}
function getScopeParent(element) {
  var parent = element;
  while (parent = parent.parent) {
    if (is(parent, "bpmn:FlowElementsContainer")) {
      return getBusinessObject(parent);
    }
    if (is(parent, "bpmn:Participant")) {
      return getBusinessObject(parent).processRef;
    }
  }
  return null;
}
function isSameScope(a6, b5) {
  var scopeParentA = getScopeParent(a6), scopeParentB = getScopeParent(b5);
  return scopeParentA === scopeParentB;
}
function hasEventDefinition3(element, eventDefinition) {
  var bo = getBusinessObject(element);
  return !!(0, import_min_dash94.find)(bo.eventDefinitions || [], function(definition) {
    return is(definition, eventDefinition);
  });
}
function hasEventDefinitionOrNone(element, eventDefinition) {
  var bo = getBusinessObject(element);
  return (bo.eventDefinitions || []).every(function(definition) {
    return is(definition, eventDefinition);
  });
}
function isSequenceFlowSource(element) {
  return is(element, "bpmn:FlowNode") && !is(element, "bpmn:EndEvent") && !isEventSubProcess(element) && !(is(element, "bpmn:IntermediateThrowEvent") && hasEventDefinition3(element, "bpmn:LinkEventDefinition")) && !isCompensationBoundary(element) && !isForCompensation(element);
}
function isSequenceFlowTarget(element) {
  return is(element, "bpmn:FlowNode") && !is(element, "bpmn:StartEvent") && !is(element, "bpmn:BoundaryEvent") && !isEventSubProcess(element) && !(is(element, "bpmn:IntermediateCatchEvent") && hasEventDefinition3(element, "bpmn:LinkEventDefinition")) && !isForCompensation(element);
}
function isEventBasedTarget(element) {
  return is(element, "bpmn:ReceiveTask") || is(element, "bpmn:IntermediateCatchEvent") && (hasEventDefinition3(element, "bpmn:MessageEventDefinition") || hasEventDefinition3(element, "bpmn:TimerEventDefinition") || hasEventDefinition3(element, "bpmn:ConditionalEventDefinition") || hasEventDefinition3(element, "bpmn:SignalEventDefinition"));
}
function isConnection8(element) {
  return element.waypoints;
}
function getParents2(element) {
  var parents = [];
  while (element) {
    element = element.parent;
    if (element) {
      parents.push(element);
    }
  }
  return parents;
}
function isParent(possibleParent, element) {
  var allParents = getParents2(element);
  return allParents.indexOf(possibleParent) !== -1;
}
function canConnect(source, target, connection) {
  if (nonExistingOrLabel(source) || nonExistingOrLabel(target)) {
    return null;
  }
  if (!is(connection, "bpmn:DataAssociation")) {
    if (canConnectMessageFlow(source, target)) {
      return { type: "bpmn:MessageFlow" };
    }
    if (canConnectSequenceFlow(source, target)) {
      return { type: "bpmn:SequenceFlow" };
    }
  }
  var connectDataAssociation = canConnectDataAssociation(source, target);
  if (connectDataAssociation) {
    return connectDataAssociation;
  }
  if (isCompensationBoundary(source) && isForCompensation(target)) {
    return {
      type: "bpmn:Association",
      associationDirection: "One"
    };
  }
  if (canConnectAssociation(source, target)) {
    return {
      type: "bpmn:Association"
    };
  }
  return false;
}
function canDrop(element, target, position) {
  if (isLabel(element) || isGroup(element)) {
    return true;
  }
  if (is(target, "bpmn:Participant") && !isExpanded(target)) {
    return false;
  }
  if (is(element, "bpmn:Participant")) {
    return is(target, "bpmn:Process") || is(target, "bpmn:Collaboration");
  }
  if (isAny(element, ["bpmn:DataInput", "bpmn:DataOutput"])) {
    if (element.parent) {
      return target === element.parent;
    }
  }
  if (is(element, "bpmn:Lane")) {
    return is(target, "bpmn:Participant") || is(target, "bpmn:Lane");
  }
  if (is(element, "bpmn:BoundaryEvent") && !isDroppableBoundaryEvent(element)) {
    return false;
  }
  if (is(element, "bpmn:FlowElement") && !is(element, "bpmn:DataStoreReference")) {
    if (is(target, "bpmn:FlowElementsContainer")) {
      return isExpanded(target);
    }
    return isAny(target, ["bpmn:Participant", "bpmn:Lane"]);
  }
  if (is(element, "bpmn:DataStoreReference") && is(target, "bpmn:Collaboration")) {
    return (0, import_min_dash94.some)(getBusinessObject(target).get("participants"), function(participant) {
      return !!participant.get("processRef");
    });
  }
  if (isAny(element, ["bpmn:Artifact", "bpmn:DataAssociation", "bpmn:DataStoreReference"])) {
    return isAny(target, [
      "bpmn:Collaboration",
      "bpmn:Lane",
      "bpmn:Participant",
      "bpmn:Process",
      "bpmn:SubProcess"
    ]);
  }
  if (is(element, "bpmn:MessageFlow")) {
    return is(target, "bpmn:Collaboration") || element.source.parent == target || element.target.parent == target;
  }
  return false;
}
function isDroppableBoundaryEvent(event2) {
  return getBusinessObject(event2).cancelActivity && (hasNoEventDefinition(event2) || hasCommonBoundaryIntermediateEventDefinition(event2));
}
function isBoundaryEvent(element) {
  return !isLabel(element) && is(element, "bpmn:BoundaryEvent");
}
function isLane(element) {
  return is(element, "bpmn:Lane");
}
function isBoundaryCandidate(element) {
  if (isBoundaryEvent(element)) {
    return true;
  }
  if (is(element, "bpmn:IntermediateThrowEvent") && hasNoEventDefinition(element)) {
    return true;
  }
  return is(element, "bpmn:IntermediateCatchEvent") && hasCommonBoundaryIntermediateEventDefinition(element);
}
function hasNoEventDefinition(element) {
  var bo = getBusinessObject(element);
  return bo && !(bo.eventDefinitions && bo.eventDefinitions.length);
}
function hasCommonBoundaryIntermediateEventDefinition(element) {
  return hasOneOfEventDefinitions(element, [
    "bpmn:MessageEventDefinition",
    "bpmn:TimerEventDefinition",
    "bpmn:SignalEventDefinition",
    "bpmn:ConditionalEventDefinition"
  ]);
}
function hasOneOfEventDefinitions(element, eventDefinitions) {
  return eventDefinitions.some(function(definition) {
    return hasEventDefinition3(element, definition);
  });
}
function isReceiveTaskAfterEventBasedGateway(element) {
  return is(element, "bpmn:ReceiveTask") && (0, import_min_dash94.find)(element.incoming, function(incoming) {
    return is(incoming.source, "bpmn:EventBasedGateway");
  });
}
function canAttach(elements, target, source, position) {
  if (!Array.isArray(elements)) {
    elements = [elements];
  }
  if (elements.length !== 1) {
    return false;
  }
  var element = elements[0];
  if (isLabel(element)) {
    return false;
  }
  if (!isBoundaryCandidate(element)) {
    return false;
  }
  if (isEventSubProcess(target)) {
    return false;
  }
  if (!is(target, "bpmn:Activity") || isForCompensation(target)) {
    return false;
  }
  if (position && !getBoundaryAttachment(position, target)) {
    return false;
  }
  if (isReceiveTaskAfterEventBasedGateway(target)) {
    return false;
  }
  return "attach";
}
function canReplace(elements, target, position) {
  if (!target) {
    return false;
  }
  var canExecute = {
    replacements: []
  };
  (0, import_min_dash94.forEach)(elements, function(element) {
    if (!isEventSubProcess(target)) {
      if (is(element, "bpmn:StartEvent") && element.type !== "label" && canDrop(element, target)) {
        if (!isInterrupting(element)) {
          canExecute.replacements.push({
            oldElementId: element.id,
            newElementType: "bpmn:StartEvent"
          });
        }
        if (hasErrorEventDefinition(element) || hasEscalationEventDefinition(element) || hasCompensateEventDefinition(element)) {
          canExecute.replacements.push({
            oldElementId: element.id,
            newElementType: "bpmn:StartEvent"
          });
        }
        if (hasOneOfEventDefinitions(element, [
          "bpmn:MessageEventDefinition",
          "bpmn:TimerEventDefinition",
          "bpmn:SignalEventDefinition",
          "bpmn:ConditionalEventDefinition"
        ]) && is(target, "bpmn:SubProcess")) {
          canExecute.replacements.push({
            oldElementId: element.id,
            newElementType: "bpmn:StartEvent"
          });
        }
      }
    }
    if (!is(target, "bpmn:Transaction")) {
      if (hasEventDefinition3(element, "bpmn:CancelEventDefinition") && element.type !== "label") {
        if (is(element, "bpmn:EndEvent") && canDrop(element, target)) {
          canExecute.replacements.push({
            oldElementId: element.id,
            newElementType: "bpmn:EndEvent"
          });
        }
        if (is(element, "bpmn:BoundaryEvent") && canAttach(element, target, null, position)) {
          canExecute.replacements.push({
            oldElementId: element.id,
            newElementType: "bpmn:BoundaryEvent"
          });
        }
      }
    }
  });
  return canExecute.replacements.length ? canExecute : false;
}
function canMove(elements, target) {
  if ((0, import_min_dash94.some)(elements, isLane)) {
    return false;
  }
  if (!target) {
    return true;
  }
  return elements.every(function(element) {
    return canDrop(element, target);
  });
}
function canCreate(shape, target, source, position) {
  if (!target) {
    return false;
  }
  if (isLabel(shape) || isGroup(shape)) {
    return true;
  }
  if (isSame(source, target)) {
    return false;
  }
  if (source && isParent(source, target)) {
    return false;
  }
  return canDrop(shape, target, position) || canInsert(shape, target, position);
}
function canResize(shape, newBounds) {
  if (is(shape, "bpmn:SubProcess")) {
    return isExpanded(shape) && (!newBounds || newBounds.width >= 100 && newBounds.height >= 80);
  }
  if (is(shape, "bpmn:Lane")) {
    return !newBounds || newBounds.width >= 130 && newBounds.height >= 60;
  }
  if (is(shape, "bpmn:Participant")) {
    return !newBounds || newBounds.width >= 250 && newBounds.height >= 50;
  }
  if (isTextAnnotation(shape)) {
    return true;
  }
  if (isGroup(shape)) {
    return true;
  }
  return false;
}
function isOneTextAnnotation(source, target) {
  var sourceTextAnnotation = isTextAnnotation(source), targetTextAnnotation = isTextAnnotation(target);
  return (sourceTextAnnotation || targetTextAnnotation) && sourceTextAnnotation !== targetTextAnnotation;
}
function canConnectAssociation(source, target) {
  if (isCompensationBoundary(source) && isForCompensation(target)) {
    return true;
  }
  if (isParent(target, source) || isParent(source, target)) {
    return false;
  }
  if (isOneTextAnnotation(source, target)) {
    return true;
  }
  return !!canConnectDataAssociation(source, target);
}
function canConnectMessageFlow(source, target) {
  if (getRootElement(source) && !getRootElement(target)) {
    return false;
  }
  return isMessageFlowSource(source) && isMessageFlowTarget(target) && !isSameOrganization(source, target);
}
function canConnectSequenceFlow(source, target) {
  return isSequenceFlowSource(source) && isSequenceFlowTarget(target) && isSameScope(source, target) && !(is(source, "bpmn:EventBasedGateway") && !isEventBasedTarget(target));
}
function canConnectDataAssociation(source, target) {
  if (isAny(source, ["bpmn:DataObjectReference", "bpmn:DataStoreReference"]) && isAny(target, ["bpmn:Activity", "bpmn:ThrowEvent"])) {
    return { type: "bpmn:DataInputAssociation" };
  }
  if (isAny(target, ["bpmn:DataObjectReference", "bpmn:DataStoreReference"]) && isAny(source, ["bpmn:Activity", "bpmn:CatchEvent"])) {
    return { type: "bpmn:DataOutputAssociation" };
  }
  return false;
}
function canInsert(shape, flow, position) {
  if (!flow) {
    return false;
  }
  if (Array.isArray(shape)) {
    if (shape.length !== 1) {
      return false;
    }
    shape = shape[0];
  }
  if (flow.source === shape || flow.target === shape) {
    return false;
  }
  return isAny(flow, ["bpmn:SequenceFlow", "bpmn:MessageFlow"]) && !isLabel(flow) && is(shape, "bpmn:FlowNode") && !is(shape, "bpmn:BoundaryEvent") && canDrop(shape, flow.parent, position);
}
function includes4(elements, element) {
  return elements && element && elements.indexOf(element) !== -1;
}
function canCopy(elements, element) {
  if (isLabel(element)) {
    return true;
  }
  if (is(element, "bpmn:Lane") && !includes4(elements, element.parent)) {
    return false;
  }
  return true;
}
function getRootElement(element) {
  return getParent2(element, "bpmn:Process") || getParent2(element, "bpmn:Collaboration");
}

// node_modules/bpmn-js/lib/features/rules/index.js
var rules_default2 = {
  __depends__: [
    rules_default
  ],
  __init__: ["bpmnRules"],
  bpmnRules: ["type", BpmnRules]
};

// node_modules/bpmn-js/lib/features/di-ordering/BpmnDiOrdering.js
var import_min_dash95 = __toESM(require_dist());
var HIGH_PRIORITY14 = 2e3;
function BpmnDiOrdering(eventBus, canvas) {
  eventBus.on("saveXML.start", HIGH_PRIORITY14, orderDi);
  function orderDi() {
    var rootElements = canvas.getRootElements();
    (0, import_min_dash95.forEach)(rootElements, function(root) {
      var rootDi = getDi(root), elements, diElements;
      elements = selfAndAllChildren([root], false);
      elements = (0, import_min_dash95.filter)(elements, function(element) {
        return element !== root && !element.labelTarget;
      });
      diElements = (0, import_min_dash95.map)(elements, getDi);
      rootDi.set("planeElement", diElements);
    });
  }
}
BpmnDiOrdering.$inject = ["eventBus", "canvas"];

// node_modules/bpmn-js/lib/features/di-ordering/index.js
var di_ordering_default = {
  __init__: [
    "bpmnDiOrdering"
  ],
  bpmnDiOrdering: ["type", BpmnDiOrdering]
};

// node_modules/diagram-js/lib/features/ordering/OrderingProvider.js
function OrderingProvider(eventBus) {
  CommandInterceptor.call(this, eventBus);
  var self2 = this;
  this.preExecute(["shape.create", "connection.create"], function(event2) {
    var context = event2.context, element = context.shape || context.connection, parent = context.parent;
    var ordering = self2.getOrdering(element, parent);
    if (ordering) {
      if (ordering.parent !== void 0) {
        context.parent = ordering.parent;
      }
      context.parentIndex = ordering.index;
    }
  });
  this.preExecute(["shape.move", "connection.move"], function(event2) {
    var context = event2.context, element = context.shape || context.connection, parent = context.newParent || element.parent;
    var ordering = self2.getOrdering(element, parent);
    if (ordering) {
      if (ordering.parent !== void 0) {
        context.newParent = ordering.parent;
      }
      context.newParentIndex = ordering.index;
    }
  });
}
OrderingProvider.prototype.getOrdering = function(element, newParent) {
  return null;
};
e(OrderingProvider, CommandInterceptor);

// node_modules/bpmn-js/lib/features/ordering/BpmnOrderingProvider.js
var import_min_dash96 = __toESM(require_dist());
function BpmnOrderingProvider(eventBus, canvas, translate3) {
  OrderingProvider.call(this, eventBus);
  var orders = [
    { type: "bpmn:SubProcess", order: { level: 6 } },
    {
      type: "bpmn:SequenceFlow",
      order: {
        level: 9,
        containers: [
          "bpmn:Participant",
          "bpmn:FlowElementsContainer"
        ]
      }
    },
    {
      type: "bpmn:DataAssociation",
      order: {
        level: 9,
        containers: [
          "bpmn:Collaboration",
          "bpmn:FlowElementsContainer"
        ]
      }
    },
    {
      type: "bpmn:MessageFlow",
      order: {
        level: 9,
        containers: ["bpmn:Collaboration"]
      }
    },
    {
      type: "bpmn:Association",
      order: {
        level: 6,
        containers: [
          "bpmn:Participant",
          "bpmn:FlowElementsContainer",
          "bpmn:Collaboration"
        ]
      }
    },
    { type: "bpmn:BoundaryEvent", order: { level: 8 } },
    {
      type: "bpmn:Group",
      order: {
        level: 10,
        containers: [
          "bpmn:Collaboration",
          "bpmn:FlowElementsContainer"
        ]
      }
    },
    { type: "bpmn:FlowElement", order: { level: 5 } },
    { type: "bpmn:Participant", order: { level: -2 } },
    { type: "bpmn:Lane", order: { level: -1 } }
  ];
  function computeOrder(element) {
    if (element.labelTarget) {
      return { level: 10 };
    }
    var entry = (0, import_min_dash96.find)(orders, function(o7) {
      return isAny(element, [o7.type]);
    });
    return entry && entry.order || { level: 1 };
  }
  function getOrder(element) {
    var order = element.order;
    if (!order) {
      element.order = order = computeOrder(element);
    }
    if (!order) {
      throw new Error("no order for <" + element.id + ">");
    }
    return order;
  }
  function findActualParent(element, newParent, containers) {
    var actualParent = newParent;
    while (actualParent) {
      if (isAny(actualParent, containers)) {
        break;
      }
      actualParent = actualParent.parent;
    }
    if (!actualParent) {
      throw new Error("no parent for <" + element.id + "> in <" + (newParent && newParent.id) + ">");
    }
    return actualParent;
  }
  this.getOrdering = function(element, newParent) {
    if (element.labelTarget) {
      return {
        parent: canvas.findRoot(newParent) || canvas.getRootElement(),
        index: -1
      };
    }
    var elementOrder = getOrder(element);
    if (elementOrder.containers) {
      newParent = findActualParent(element, newParent, elementOrder.containers);
    }
    var currentIndex = newParent.children.indexOf(element);
    var insertIndex = (0, import_min_dash96.findIndex)(newParent.children, function(child) {
      if (!element.labelTarget && child.labelTarget) {
        return false;
      }
      return elementOrder.level < getOrder(child).level;
    });
    if (insertIndex !== -1) {
      if (currentIndex !== -1 && currentIndex < insertIndex) {
        insertIndex -= 1;
      }
    }
    return {
      index: insertIndex,
      parent: newParent
    };
  };
}
BpmnOrderingProvider.$inject = ["eventBus", "canvas", "translate"];
e(BpmnOrderingProvider, OrderingProvider);

// node_modules/bpmn-js/lib/features/ordering/index.js
var ordering_default = {
  __depends__: [
    translate_default
  ],
  __init__: ["bpmnOrderingProvider"],
  bpmnOrderingProvider: ["type", BpmnOrderingProvider]
};

// node_modules/diagram-js/lib/features/tool-manager/ToolManager.js
var import_min_dash97 = __toESM(require_dist());
var LOW_PRIORITY21 = 250;
function ToolManager(eventBus, dragging) {
  this._eventBus = eventBus;
  this._dragging = dragging;
  this._tools = [];
  this._active = null;
}
ToolManager.$inject = ["eventBus", "dragging"];
ToolManager.prototype.registerTool = function(name3, events) {
  var tools = this._tools;
  if (!events) {
    throw new Error(`A tool has to be registered with it's "events"`);
  }
  tools.push(name3);
  this.bindEvents(name3, events);
};
ToolManager.prototype.isActive = function(tool) {
  return tool && this._active === tool;
};
ToolManager.prototype.length = function(tool) {
  return this._tools.length;
};
ToolManager.prototype.setActive = function(tool) {
  var eventBus = this._eventBus;
  if (this._active !== tool) {
    this._active = tool;
    eventBus.fire("tool-manager.update", { tool });
  }
};
ToolManager.prototype.bindEvents = function(name3, events) {
  var eventBus = this._eventBus, dragging = this._dragging;
  var eventsToRegister = [];
  eventBus.on(events.tool + ".init", function(event2) {
    var context = event2.context;
    if (!context.reactivate && this.isActive(name3)) {
      this.setActive(null);
      dragging.cancel();
      return;
    }
    this.setActive(name3);
  }, this);
  (0, import_min_dash97.forEach)(events, function(event2) {
    eventsToRegister.push(event2 + ".ended");
    eventsToRegister.push(event2 + ".canceled");
  });
  eventBus.on(eventsToRegister, LOW_PRIORITY21, function(event2) {
    if (!this._active) {
      return;
    }
    if (isPaletteClick(event2)) {
      return;
    }
    this.setActive(null);
  }, this);
};
function isPaletteClick(event2) {
  var target = event2.originalEvent && event2.originalEvent.target;
  return target && closest(target, '.group[data-group="tools"]');
}

// node_modules/diagram-js/lib/features/tool-manager/index.js
var tool_manager_default = {
  __depends__: [
    dragging_default
  ],
  __init__: ["toolManager"],
  toolManager: ["type", ToolManager]
};

// node_modules/diagram-js/lib/features/space-tool/SpaceTool.js
var import_min_dash99 = __toESM(require_dist());

// node_modules/diagram-js/lib/features/space-tool/SpaceUtil.js
var import_min_dash98 = __toESM(require_dist());
function getDirection(axis, delta2) {
  if (axis === "x") {
    if (delta2 > 0) {
      return "e";
    }
    if (delta2 < 0) {
      return "w";
    }
  }
  if (axis === "y") {
    if (delta2 > 0) {
      return "s";
    }
    if (delta2 < 0) {
      return "n";
    }
  }
  return null;
}
function getWaypointsUpdatingConnections(movingShapes, resizingShapes) {
  var waypointsUpdatingConnections = [];
  (0, import_min_dash98.forEach)(movingShapes.concat(resizingShapes), function(shape) {
    var incoming = shape.incoming, outgoing = shape.outgoing;
    (0, import_min_dash98.forEach)(incoming.concat(outgoing), function(connection) {
      var source = connection.source, target = connection.target;
      if (includes5(movingShapes, source) || includes5(movingShapes, target) || includes5(resizingShapes, source) || includes5(resizingShapes, target)) {
        if (!includes5(waypointsUpdatingConnections, connection)) {
          waypointsUpdatingConnections.push(connection);
        }
      }
    });
  });
  return waypointsUpdatingConnections;
}
function includes5(array, item) {
  return array.indexOf(item) !== -1;
}
function resizeBounds2(bounds, direction, delta2) {
  var x4 = bounds.x, y4 = bounds.y, width = bounds.width, height = bounds.height, dx = delta2.x, dy = delta2.y;
  switch (direction) {
    case "n":
      return {
        x: x4,
        y: y4 + dy,
        width,
        height: height - dy
      };
    case "s":
      return {
        x: x4,
        y: y4,
        width,
        height: height + dy
      };
    case "w":
      return {
        x: x4 + dx,
        y: y4,
        width: width - dx,
        height
      };
    case "e":
      return {
        x: x4,
        y: y4,
        width: width + dx,
        height
      };
    default:
      throw new Error("unknown direction: " + direction);
  }
}

// node_modules/diagram-js/lib/features/space-tool/SpaceTool.js
var abs6 = Math.abs;
var round8 = Math.round;
var AXIS_TO_DIMENSION = {
  x: "width",
  y: "height"
};
var CURSOR_CROSSHAIR = "crosshair";
var DIRECTION_TO_TRBL = {
  n: "top",
  w: "left",
  s: "bottom",
  e: "right"
};
var HIGH_PRIORITY15 = 1500;
var DIRECTION_TO_OPPOSITE = {
  n: "s",
  w: "e",
  s: "n",
  e: "w"
};
var PADDING = 20;
function SpaceTool(canvas, dragging, eventBus, modeling, rules, toolManager, mouse) {
  this._canvas = canvas;
  this._dragging = dragging;
  this._eventBus = eventBus;
  this._modeling = modeling;
  this._rules = rules;
  this._toolManager = toolManager;
  this._mouse = mouse;
  var self2 = this;
  toolManager.registerTool("space", {
    tool: "spaceTool.selection",
    dragging: "spaceTool"
  });
  eventBus.on("spaceTool.selection.end", function(event2) {
    eventBus.once("spaceTool.selection.ended", function() {
      self2.activateMakeSpace(event2.originalEvent);
    });
  });
  eventBus.on("spaceTool.move", HIGH_PRIORITY15, function(event2) {
    var context = event2.context, initialized = context.initialized;
    if (!initialized) {
      initialized = context.initialized = self2.init(event2, context);
    }
    if (initialized) {
      ensureConstraints3(event2);
    }
  });
  eventBus.on("spaceTool.end", function(event2) {
    var context = event2.context, axis = context.axis, direction = context.direction, movingShapes = context.movingShapes, resizingShapes = context.resizingShapes, start = context.start;
    if (!context.initialized) {
      return;
    }
    ensureConstraints3(event2);
    var delta2 = {
      x: 0,
      y: 0
    };
    delta2[axis] = round8(event2["d" + axis]);
    self2.makeSpace(movingShapes, resizingShapes, delta2, direction, start);
    eventBus.once("spaceTool.ended", function(event3) {
      self2.activateSelection(event3.originalEvent, true, true);
    });
  });
}
SpaceTool.$inject = [
  "canvas",
  "dragging",
  "eventBus",
  "modeling",
  "rules",
  "toolManager",
  "mouse"
];
SpaceTool.prototype.activateSelection = function(event2, autoActivate, reactivate) {
  this._dragging.init(event2, "spaceTool.selection", {
    autoActivate,
    cursor: CURSOR_CROSSHAIR,
    data: {
      context: {
        reactivate
      }
    },
    trapClick: false
  });
};
SpaceTool.prototype.activateMakeSpace = function(event2) {
  this._dragging.init(event2, "spaceTool", {
    autoActivate: true,
    cursor: CURSOR_CROSSHAIR,
    data: {
      context: {}
    }
  });
};
SpaceTool.prototype.makeSpace = function(movingShapes, resizingShapes, delta2, direction, start) {
  return this._modeling.createSpace(movingShapes, resizingShapes, delta2, direction, start);
};
SpaceTool.prototype.init = function(event2, context) {
  var axis = abs6(event2.dx) > abs6(event2.dy) ? "x" : "y", delta2 = event2["d" + axis], start = event2[axis] - delta2;
  if (abs6(delta2) < 5) {
    return false;
  }
  if (delta2 < 0) {
    delta2 *= -1;
  }
  if (hasPrimaryModifier(event2)) {
    delta2 *= -1;
  }
  var direction = getDirection(axis, delta2);
  var root = this._canvas.getRootElement();
  var children = selfAndAllChildren(root, true);
  var elements = this.calculateAdjustments(children, axis, delta2, start);
  var minDimensions = this._eventBus.fire("spaceTool.getMinDimensions", {
    axis,
    direction,
    shapes: elements.resizingShapes,
    start
  });
  var spaceToolConstraints = getSpaceToolConstraints(elements, axis, direction, start, minDimensions);
  (0, import_min_dash99.assign)(context, elements, {
    axis,
    direction,
    spaceToolConstraints,
    start
  });
  set2("resize-" + (axis === "x" ? "ew" : "ns"));
  return true;
};
SpaceTool.prototype.calculateAdjustments = function(elements, axis, delta2, start) {
  var rules = this._rules;
  var movingShapes = [], resizingShapes = [];
  var attachers = [], connections = [];
  function moveShape(shape) {
    if (!movingShapes.includes(shape)) {
      movingShapes.push(shape);
    }
    var label = shape.label;
    if (label && !movingShapes.includes(label)) {
      movingShapes.push(label);
    }
  }
  function resizeShape(shape) {
    if (!resizingShapes.includes(shape)) {
      resizingShapes.push(shape);
    }
  }
  (0, import_min_dash99.forEach)(elements, function(element) {
    if (!element.parent || isLabel5(element)) {
      return;
    }
    if (isConnection9(element)) {
      connections.push(element);
      return;
    }
    var shapeStart = element[axis], shapeEnd = shapeStart + element[AXIS_TO_DIMENSION[axis]];
    if (isAttacher2(element) && (delta2 > 0 && getMid(element)[axis] > start || delta2 < 0 && getMid(element)[axis] < start)) {
      attachers.push(element);
      return;
    }
    if (delta2 > 0 && shapeStart > start || delta2 < 0 && shapeEnd < start) {
      moveShape(element);
      return;
    }
    if (shapeStart < start && shapeEnd > start && rules.allowed("shape.resize", { shape: element })) {
      resizeShape(element);
      return;
    }
  });
  (0, import_min_dash99.forEach)(movingShapes, function(shape) {
    var attachers2 = shape.attachers;
    if (attachers2) {
      (0, import_min_dash99.forEach)(attachers2, function(attacher) {
        moveShape(attacher);
      });
    }
  });
  var allShapes = movingShapes.concat(resizingShapes);
  (0, import_min_dash99.forEach)(attachers, function(attacher) {
    var host = attacher.host;
    if (includes6(allShapes, host)) {
      moveShape(attacher);
    }
  });
  allShapes = movingShapes.concat(resizingShapes);
  (0, import_min_dash99.forEach)(connections, function(connection) {
    var source = connection.source, target = connection.target, label = connection.label;
    if (includes6(allShapes, source) && includes6(allShapes, target) && label) {
      moveShape(label);
    }
  });
  return {
    movingShapes,
    resizingShapes
  };
};
SpaceTool.prototype.toggle = function() {
  if (this.isActive()) {
    return this._dragging.cancel();
  }
  var mouseEvent = this._mouse.getLastMoveEvent();
  this.activateSelection(mouseEvent, !!mouseEvent);
};
SpaceTool.prototype.isActive = function() {
  var context = this._dragging.context();
  if (context) {
    return /^spaceTool/.test(context.prefix);
  }
  return false;
};
function addPadding2(trbl) {
  return {
    top: trbl.top - PADDING,
    right: trbl.right + PADDING,
    bottom: trbl.bottom + PADDING,
    left: trbl.left - PADDING
  };
}
function ensureConstraints3(event2) {
  var context = event2.context, spaceToolConstraints = context.spaceToolConstraints;
  if (!spaceToolConstraints) {
    return;
  }
  var x4, y4;
  if ((0, import_min_dash99.isNumber)(spaceToolConstraints.left)) {
    x4 = Math.max(event2.x, spaceToolConstraints.left);
    event2.dx = event2.dx + x4 - event2.x;
    event2.x = x4;
  }
  if ((0, import_min_dash99.isNumber)(spaceToolConstraints.right)) {
    x4 = Math.min(event2.x, spaceToolConstraints.right);
    event2.dx = event2.dx + x4 - event2.x;
    event2.x = x4;
  }
  if ((0, import_min_dash99.isNumber)(spaceToolConstraints.top)) {
    y4 = Math.max(event2.y, spaceToolConstraints.top);
    event2.dy = event2.dy + y4 - event2.y;
    event2.y = y4;
  }
  if ((0, import_min_dash99.isNumber)(spaceToolConstraints.bottom)) {
    y4 = Math.min(event2.y, spaceToolConstraints.bottom);
    event2.dy = event2.dy + y4 - event2.y;
    event2.y = y4;
  }
}
function getSpaceToolConstraints(elements, axis, direction, start, minDimensions) {
  var movingShapes = elements.movingShapes, resizingShapes = elements.resizingShapes;
  if (!resizingShapes.length) {
    return;
  }
  var spaceToolConstraints = {}, min5, max8;
  (0, import_min_dash99.forEach)(resizingShapes, function(resizingShape) {
    var attachers = resizingShape.attachers, children = resizingShape.children;
    var resizingShapeBBox = asTRBL(resizingShape);
    var nonMovingResizingChildren = (0, import_min_dash99.filter)(children, function(child) {
      return !isConnection9(child) && !isLabel5(child) && !includes6(movingShapes, child) && !includes6(resizingShapes, child);
    });
    var movingChildren = (0, import_min_dash99.filter)(children, function(child) {
      return !isConnection9(child) && !isLabel5(child) && includes6(movingShapes, child);
    });
    var minOrMax, nonMovingResizingChildrenBBox, movingChildrenBBox, movingAttachers = [], nonMovingAttachers = [], movingAttachersBBox, movingAttachersConstraint, nonMovingAttachersBBox, nonMovingAttachersConstraint;
    if (nonMovingResizingChildren.length) {
      nonMovingResizingChildrenBBox = addPadding2(asTRBL(getBBox(nonMovingResizingChildren)));
      minOrMax = start - resizingShapeBBox[DIRECTION_TO_TRBL[direction]] + nonMovingResizingChildrenBBox[DIRECTION_TO_TRBL[direction]];
      if (direction === "n") {
        spaceToolConstraints.bottom = max8 = (0, import_min_dash99.isNumber)(max8) ? Math.min(max8, minOrMax) : minOrMax;
      } else if (direction === "w") {
        spaceToolConstraints.right = max8 = (0, import_min_dash99.isNumber)(max8) ? Math.min(max8, minOrMax) : minOrMax;
      } else if (direction === "s") {
        spaceToolConstraints.top = min5 = (0, import_min_dash99.isNumber)(min5) ? Math.max(min5, minOrMax) : minOrMax;
      } else if (direction === "e") {
        spaceToolConstraints.left = min5 = (0, import_min_dash99.isNumber)(min5) ? Math.max(min5, minOrMax) : minOrMax;
      }
    }
    if (movingChildren.length) {
      movingChildrenBBox = addPadding2(asTRBL(getBBox(movingChildren)));
      minOrMax = start - movingChildrenBBox[DIRECTION_TO_TRBL[DIRECTION_TO_OPPOSITE[direction]]] + resizingShapeBBox[DIRECTION_TO_TRBL[DIRECTION_TO_OPPOSITE[direction]]];
      if (direction === "n") {
        spaceToolConstraints.bottom = max8 = (0, import_min_dash99.isNumber)(max8) ? Math.min(max8, minOrMax) : minOrMax;
      } else if (direction === "w") {
        spaceToolConstraints.right = max8 = (0, import_min_dash99.isNumber)(max8) ? Math.min(max8, minOrMax) : minOrMax;
      } else if (direction === "s") {
        spaceToolConstraints.top = min5 = (0, import_min_dash99.isNumber)(min5) ? Math.max(min5, minOrMax) : minOrMax;
      } else if (direction === "e") {
        spaceToolConstraints.left = min5 = (0, import_min_dash99.isNumber)(min5) ? Math.max(min5, minOrMax) : minOrMax;
      }
    }
    if (attachers && attachers.length) {
      attachers.forEach(function(attacher) {
        if (includes6(movingShapes, attacher)) {
          movingAttachers.push(attacher);
        } else {
          nonMovingAttachers.push(attacher);
        }
      });
      if (movingAttachers.length) {
        movingAttachersBBox = asTRBL(getBBox(movingAttachers.map(getMid)));
        movingAttachersConstraint = resizingShapeBBox[DIRECTION_TO_TRBL[DIRECTION_TO_OPPOSITE[direction]]] - (movingAttachersBBox[DIRECTION_TO_TRBL[DIRECTION_TO_OPPOSITE[direction]]] - start);
      }
      if (nonMovingAttachers.length) {
        nonMovingAttachersBBox = asTRBL(getBBox(nonMovingAttachers.map(getMid)));
        nonMovingAttachersConstraint = nonMovingAttachersBBox[DIRECTION_TO_TRBL[direction]] - (resizingShapeBBox[DIRECTION_TO_TRBL[direction]] - start);
      }
      if (direction === "n") {
        minOrMax = Math.min(movingAttachersConstraint || Infinity, nonMovingAttachersConstraint || Infinity);
        spaceToolConstraints.bottom = max8 = (0, import_min_dash99.isNumber)(max8) ? Math.min(max8, minOrMax) : minOrMax;
      } else if (direction === "w") {
        minOrMax = Math.min(movingAttachersConstraint || Infinity, nonMovingAttachersConstraint || Infinity);
        spaceToolConstraints.right = max8 = (0, import_min_dash99.isNumber)(max8) ? Math.min(max8, minOrMax) : minOrMax;
      } else if (direction === "s") {
        minOrMax = Math.max(movingAttachersConstraint || -Infinity, nonMovingAttachersConstraint || -Infinity);
        spaceToolConstraints.top = min5 = (0, import_min_dash99.isNumber)(min5) ? Math.max(min5, minOrMax) : minOrMax;
      } else if (direction === "e") {
        minOrMax = Math.max(movingAttachersConstraint || -Infinity, nonMovingAttachersConstraint || -Infinity);
        spaceToolConstraints.left = min5 = (0, import_min_dash99.isNumber)(min5) ? Math.max(min5, minOrMax) : minOrMax;
      }
    }
    var resizingShapeMinDimensions = minDimensions && minDimensions[resizingShape.id];
    if (resizingShapeMinDimensions) {
      if (direction === "n") {
        minOrMax = start + resizingShape[AXIS_TO_DIMENSION[axis]] - resizingShapeMinDimensions[AXIS_TO_DIMENSION[axis]];
        spaceToolConstraints.bottom = max8 = (0, import_min_dash99.isNumber)(max8) ? Math.min(max8, minOrMax) : minOrMax;
      } else if (direction === "w") {
        minOrMax = start + resizingShape[AXIS_TO_DIMENSION[axis]] - resizingShapeMinDimensions[AXIS_TO_DIMENSION[axis]];
        spaceToolConstraints.right = max8 = (0, import_min_dash99.isNumber)(max8) ? Math.min(max8, minOrMax) : minOrMax;
      } else if (direction === "s") {
        minOrMax = start - resizingShape[AXIS_TO_DIMENSION[axis]] + resizingShapeMinDimensions[AXIS_TO_DIMENSION[axis]];
        spaceToolConstraints.top = min5 = (0, import_min_dash99.isNumber)(min5) ? Math.max(min5, minOrMax) : minOrMax;
      } else if (direction === "e") {
        minOrMax = start - resizingShape[AXIS_TO_DIMENSION[axis]] + resizingShapeMinDimensions[AXIS_TO_DIMENSION[axis]];
        spaceToolConstraints.left = min5 = (0, import_min_dash99.isNumber)(min5) ? Math.max(min5, minOrMax) : minOrMax;
      }
    }
  });
  return spaceToolConstraints;
}
function includes6(array, item) {
  return array.indexOf(item) !== -1;
}
function isAttacher2(element) {
  return !!element.host;
}
function isConnection9(element) {
  return !!element.waypoints;
}
function isLabel5(element) {
  return !!element.labelTarget;
}

// node_modules/diagram-js/lib/features/space-tool/SpaceToolPreview.js
var import_min_dash100 = __toESM(require_dist());
var MARKER_DRAGGING = "djs-dragging";
var MARKER_RESIZING2 = "djs-resizing";
var LOW_PRIORITY22 = 250;
var max7 = Math.max;
function SpaceToolPreview(eventBus, elementRegistry, canvas, styles, previewSupport) {
  function addPreviewGfx(collection, dragGroup) {
    (0, import_min_dash100.forEach)(collection, function(element) {
      previewSupport.addDragger(element, dragGroup);
      canvas.addMarker(element, MARKER_DRAGGING);
    });
  }
  eventBus.on("spaceTool.selection.start", function(event2) {
    var space = canvas.getLayer("space"), context = event2.context;
    var orientation = {
      x: "M 0,-10000 L 0,10000",
      y: "M -10000,0 L 10000,0"
    };
    var crosshairGroup = create("g");
    attr(crosshairGroup, styles.cls("djs-crosshair-group", ["no-events"]));
    append(space, crosshairGroup);
    var pathX = create("path");
    attr(pathX, "d", orientation.x);
    classes(pathX).add("djs-crosshair");
    append(crosshairGroup, pathX);
    var pathY = create("path");
    attr(pathY, "d", orientation.y);
    classes(pathY).add("djs-crosshair");
    append(crosshairGroup, pathY);
    context.crosshairGroup = crosshairGroup;
  });
  eventBus.on("spaceTool.selection.move", function(event2) {
    var crosshairGroup = event2.context.crosshairGroup;
    translate(crosshairGroup, event2.x, event2.y);
  });
  eventBus.on("spaceTool.selection.cleanup", function(event2) {
    var context = event2.context, crosshairGroup = context.crosshairGroup;
    if (crosshairGroup) {
      remove(crosshairGroup);
    }
  });
  eventBus.on("spaceTool.move", LOW_PRIORITY22, function(event2) {
    var context = event2.context, line = context.line, axis = context.axis, movingShapes = context.movingShapes, resizingShapes = context.resizingShapes;
    if (!context.initialized) {
      return;
    }
    if (!context.dragGroup) {
      var spaceLayer = canvas.getLayer("space");
      line = create("path");
      attr(line, "d", "M0,0 L0,0");
      classes(line).add("djs-crosshair");
      append(spaceLayer, line);
      context.line = line;
      var dragGroup = create("g");
      attr(dragGroup, styles.cls("djs-drag-group", ["no-events"]));
      append(canvas.getActiveLayer(), dragGroup);
      addPreviewGfx(movingShapes, dragGroup);
      var movingConnections = context.movingConnections = elementRegistry.filter(function(element) {
        var sourceIsMoving = false;
        (0, import_min_dash100.forEach)(movingShapes, function(shape) {
          (0, import_min_dash100.forEach)(shape.outgoing, function(connection) {
            if (element === connection) {
              sourceIsMoving = true;
            }
          });
        });
        var targetIsMoving = false;
        (0, import_min_dash100.forEach)(movingShapes, function(shape) {
          (0, import_min_dash100.forEach)(shape.incoming, function(connection) {
            if (element === connection) {
              targetIsMoving = true;
            }
          });
        });
        var sourceIsResizing = false;
        (0, import_min_dash100.forEach)(resizingShapes, function(shape) {
          (0, import_min_dash100.forEach)(shape.outgoing, function(connection) {
            if (element === connection) {
              sourceIsResizing = true;
            }
          });
        });
        var targetIsResizing = false;
        (0, import_min_dash100.forEach)(resizingShapes, function(shape) {
          (0, import_min_dash100.forEach)(shape.incoming, function(connection) {
            if (element === connection) {
              targetIsResizing = true;
            }
          });
        });
        return isConnection10(element) && (sourceIsMoving || sourceIsResizing) && (targetIsMoving || targetIsResizing);
      });
      addPreviewGfx(movingConnections, dragGroup);
      context.dragGroup = dragGroup;
    }
    if (!context.frameGroup) {
      var frameGroup = create("g");
      attr(frameGroup, styles.cls("djs-frame-group", ["no-events"]));
      append(canvas.getActiveLayer(), frameGroup);
      var frames = [];
      (0, import_min_dash100.forEach)(resizingShapes, function(shape) {
        var frame = previewSupport.addFrame(shape, frameGroup);
        var initialBounds = frame.getBBox();
        frames.push({
          element: frame,
          initialBounds
        });
        canvas.addMarker(shape, MARKER_RESIZING2);
      });
      context.frameGroup = frameGroup;
      context.frames = frames;
    }
    var orientation = {
      x: "M" + event2.x + ", -10000 L" + event2.x + ", 10000",
      y: "M -10000, " + event2.y + " L 10000, " + event2.y
    };
    attr(line, { d: orientation[axis] });
    var opposite = { x: "y", y: "x" };
    var delta2 = { x: event2.dx, y: event2.dy };
    delta2[opposite[context.axis]] = 0;
    translate(context.dragGroup, delta2.x, delta2.y);
    (0, import_min_dash100.forEach)(context.frames, function(frame) {
      var element = frame.element, initialBounds = frame.initialBounds, width, height;
      if (context.direction === "e") {
        attr(element, {
          width: max7(initialBounds.width + delta2.x, 5)
        });
      } else {
        width = max7(initialBounds.width - delta2.x, 5);
        attr(element, {
          width,
          x: initialBounds.x + initialBounds.width - width
        });
      }
      if (context.direction === "s") {
        attr(element, {
          height: max7(initialBounds.height + delta2.y, 5)
        });
      } else {
        height = max7(initialBounds.height - delta2.y, 5);
        attr(element, {
          height,
          y: initialBounds.y + initialBounds.height - height
        });
      }
    });
  });
  eventBus.on("spaceTool.cleanup", function(event2) {
    var context = event2.context, movingShapes = context.movingShapes, movingConnections = context.movingConnections, resizingShapes = context.resizingShapes, line = context.line, dragGroup = context.dragGroup, frameGroup = context.frameGroup;
    (0, import_min_dash100.forEach)(movingShapes, function(shape) {
      canvas.removeMarker(shape, MARKER_DRAGGING);
    });
    (0, import_min_dash100.forEach)(movingConnections, function(connection) {
      canvas.removeMarker(connection, MARKER_DRAGGING);
    });
    if (dragGroup) {
      remove(line);
      remove(dragGroup);
    }
    (0, import_min_dash100.forEach)(resizingShapes, function(shape) {
      canvas.removeMarker(shape, MARKER_RESIZING2);
    });
    if (frameGroup) {
      remove(frameGroup);
    }
  });
}
SpaceToolPreview.$inject = [
  "eventBus",
  "elementRegistry",
  "canvas",
  "styles",
  "previewSupport"
];
function isConnection10(element) {
  return element.waypoints;
}

// node_modules/diagram-js/lib/features/space-tool/index.js
var space_tool_default = {
  __init__: ["spaceToolPreview"],
  __depends__: [
    dragging_default,
    rules_default,
    tool_manager_default,
    preview_support_default,
    mouse_default
  ],
  spaceTool: ["type", SpaceTool],
  spaceToolPreview: ["type", SpaceToolPreview]
};

// node_modules/bpmn-js/lib/features/space-tool/BpmnSpaceTool.js
function BpmnSpaceTool(injector) {
  injector.invoke(SpaceTool, this);
}
BpmnSpaceTool.$inject = [
  "injector"
];
e(BpmnSpaceTool, SpaceTool);
BpmnSpaceTool.prototype.calculateAdjustments = function(elements, axis, delta2, start) {
  var adjustments = SpaceTool.prototype.calculateAdjustments.call(this, elements, axis, delta2, start);
  adjustments.resizingShapes = adjustments.resizingShapes.filter(function(shape) {
    return !is(shape, "bpmn:TextAnnotation");
  });
  return adjustments;
};

// node_modules/bpmn-js/lib/features/space-tool/index.js
var space_tool_default2 = {
  __depends__: [space_tool_default],
  spaceTool: ["type", BpmnSpaceTool]
};

// node_modules/diagram-js/lib/command/CommandStack.js
var import_min_dash101 = __toESM(require_dist());
function CommandStack(eventBus, injector) {
  this._handlerMap = {};
  this._stack = [];
  this._stackIdx = -1;
  this._currentExecution = {
    actions: [],
    dirty: [],
    trigger: null
  };
  this._injector = injector;
  this._eventBus = eventBus;
  this._uid = 1;
  eventBus.on([
    "diagram.destroy",
    "diagram.clear"
  ], function() {
    this.clear(false);
  }, this);
}
CommandStack.$inject = ["eventBus", "injector"];
CommandStack.prototype.execute = function(command, context) {
  if (!command) {
    throw new Error("command required");
  }
  this._currentExecution.trigger = "execute";
  const action = { command, context };
  this._pushAction(action);
  this._internalExecute(action);
  this._popAction(action);
};
CommandStack.prototype.canExecute = function(command, context) {
  const action = { command, context };
  const handler = this._getHandler(command);
  let result = this._fire(command, "canExecute", action);
  if (result === void 0) {
    if (!handler) {
      return false;
    }
    if (handler.canExecute) {
      result = handler.canExecute(context);
    }
  }
  return result;
};
CommandStack.prototype.clear = function(emit) {
  this._stack.length = 0;
  this._stackIdx = -1;
  if (emit !== false) {
    this._fire("changed", { trigger: "clear" });
  }
};
CommandStack.prototype.undo = function() {
  let action = this._getUndoAction(), next;
  if (action) {
    this._currentExecution.trigger = "undo";
    this._pushAction(action);
    while (action) {
      this._internalUndo(action);
      next = this._getUndoAction();
      if (!next || next.id !== action.id) {
        break;
      }
      action = next;
    }
    this._popAction();
  }
};
CommandStack.prototype.redo = function() {
  let action = this._getRedoAction(), next;
  if (action) {
    this._currentExecution.trigger = "redo";
    this._pushAction(action);
    while (action) {
      this._internalExecute(action, true);
      next = this._getRedoAction();
      if (!next || next.id !== action.id) {
        break;
      }
      action = next;
    }
    this._popAction();
  }
};
CommandStack.prototype.register = function(command, handler) {
  this._setHandler(command, handler);
};
CommandStack.prototype.registerHandler = function(command, handlerCls) {
  if (!command || !handlerCls) {
    throw new Error("command and handlerCls must be defined");
  }
  const handler = this._injector.instantiate(handlerCls);
  this.register(command, handler);
};
CommandStack.prototype.canUndo = function() {
  return !!this._getUndoAction();
};
CommandStack.prototype.canRedo = function() {
  return !!this._getRedoAction();
};
CommandStack.prototype._getRedoAction = function() {
  return this._stack[this._stackIdx + 1];
};
CommandStack.prototype._getUndoAction = function() {
  return this._stack[this._stackIdx];
};
CommandStack.prototype._internalUndo = function(action) {
  const command = action.command, context = action.context;
  const handler = this._getHandler(command);
  this._atomicDo(() => {
    this._fire(command, "revert", action);
    if (handler.revert) {
      this._markDirty(handler.revert(context));
    }
    this._revertedAction(action);
    this._fire(command, "reverted", action);
  });
};
CommandStack.prototype._fire = function(command, qualifier, event2) {
  if (arguments.length < 3) {
    event2 = qualifier;
    qualifier = null;
  }
  const names = qualifier ? [command + "." + qualifier, qualifier] : [command];
  let result;
  event2 = this._eventBus.createEvent(event2);
  for (const name3 of names) {
    result = this._eventBus.fire("commandStack." + name3, event2);
    if (event2.cancelBubble) {
      break;
    }
  }
  return result;
};
CommandStack.prototype._createId = function() {
  return this._uid++;
};
CommandStack.prototype._atomicDo = function(fn2) {
  const execution = this._currentExecution;
  execution.atomic = true;
  try {
    fn2();
  } finally {
    execution.atomic = false;
  }
};
CommandStack.prototype._internalExecute = function(action, redo) {
  const command = action.command, context = action.context;
  const handler = this._getHandler(command);
  if (!handler) {
    throw new Error("no command handler registered for <" + command + ">");
  }
  this._pushAction(action);
  if (!redo) {
    this._fire(command, "preExecute", action);
    if (handler.preExecute) {
      handler.preExecute(context);
    }
    this._fire(command, "preExecuted", action);
  }
  this._atomicDo(() => {
    this._fire(command, "execute", action);
    if (handler.execute) {
      this._markDirty(handler.execute(context));
    }
    this._executedAction(action, redo);
    this._fire(command, "executed", action);
  });
  if (!redo) {
    this._fire(command, "postExecute", action);
    if (handler.postExecute) {
      handler.postExecute(context);
    }
    this._fire(command, "postExecuted", action);
  }
  this._popAction(action);
};
CommandStack.prototype._pushAction = function(action) {
  const execution = this._currentExecution, actions = execution.actions;
  const baseAction = actions[0];
  if (execution.atomic) {
    throw new Error("illegal invocation in <execute> or <revert> phase (action: " + action.command + ")");
  }
  if (!action.id) {
    action.id = baseAction && baseAction.id || this._createId();
  }
  actions.push(action);
};
CommandStack.prototype._popAction = function() {
  const execution = this._currentExecution, trigger = execution.trigger, actions = execution.actions, dirty = execution.dirty;
  actions.pop();
  if (!actions.length) {
    this._eventBus.fire("elements.changed", { elements: (0, import_min_dash101.uniqueBy)("id", dirty.reverse()) });
    dirty.length = 0;
    this._fire("changed", { trigger });
    execution.trigger = null;
  }
};
CommandStack.prototype._markDirty = function(elements) {
  const execution = this._currentExecution;
  if (!elements) {
    return;
  }
  elements = (0, import_min_dash101.isArray)(elements) ? elements : [elements];
  execution.dirty = execution.dirty.concat(elements);
};
CommandStack.prototype._executedAction = function(action, redo) {
  const stackIdx = ++this._stackIdx;
  if (!redo) {
    this._stack.splice(stackIdx, this._stack.length, action);
  }
};
CommandStack.prototype._revertedAction = function(action) {
  this._stackIdx--;
};
CommandStack.prototype._getHandler = function(command) {
  return this._handlerMap[command];
};
CommandStack.prototype._setHandler = function(command, handler) {
  if (!command || !handler) {
    throw new Error("command and handler required");
  }
  if (this._handlerMap[command]) {
    throw new Error("overriding handler for command <" + command + ">");
  }
  this._handlerMap[command] = handler;
};

// node_modules/diagram-js/lib/command/index.js
var command_default = {
  commandStack: ["type", CommandStack]
};

// node_modules/diagram-js/lib/features/tooltips/Tooltips.js
var import_min_dash102 = __toESM(require_dist());
var ids2 = new IdGenerator("tt");
function createRoot2(parentNode) {
  var root = domify$1('<div class="djs-tooltip-container" />');
  assign(root, {
    position: "absolute",
    width: "0",
    height: "0"
  });
  parentNode.insertBefore(root, parentNode.firstChild);
  return root;
}
function setPosition2(el, x4, y4) {
  assign(el, { left: x4 + "px", top: y4 + "px" });
}
function setVisible2(el, visible) {
  el.style.display = visible === false ? "none" : "";
}
var tooltipClass = "djs-tooltip";
var tooltipSelector = "." + tooltipClass;
function Tooltips(eventBus, canvas) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  this._ids = ids2;
  this._tooltipDefaults = {
    show: {
      minZoom: 0.7,
      maxZoom: 5
    }
  };
  this._tooltips = {};
  this._tooltipRoot = createRoot2(canvas.getContainer());
  var self2 = this;
  delegate.bind(this._tooltipRoot, tooltipSelector, "mousedown", function(event2) {
    event2.stopPropagation();
  });
  delegate.bind(this._tooltipRoot, tooltipSelector, "mouseover", function(event2) {
    self2.trigger("mouseover", event2);
  });
  delegate.bind(this._tooltipRoot, tooltipSelector, "mouseout", function(event2) {
    self2.trigger("mouseout", event2);
  });
  this._init();
}
Tooltips.$inject = ["eventBus", "canvas"];
Tooltips.prototype.add = function(tooltip) {
  if (!tooltip.position) {
    throw new Error("must specifiy tooltip position");
  }
  if (!tooltip.html) {
    throw new Error("must specifiy tooltip html");
  }
  var id = this._ids.next();
  tooltip = (0, import_min_dash102.assign)({}, this._tooltipDefaults, tooltip, {
    id
  });
  this._addTooltip(tooltip);
  if (tooltip.timeout) {
    this.setTimeout(tooltip);
  }
  return id;
};
Tooltips.prototype.trigger = function(action, event2) {
  var node2 = event2.delegateTarget || event2.target;
  var tooltip = this.get(attr2(node2, "data-tooltip-id"));
  if (!tooltip) {
    return;
  }
  if (action === "mouseover" && tooltip.timeout) {
    this.clearTimeout(tooltip);
  }
  if (action === "mouseout" && tooltip.timeout) {
    tooltip.timeout = 1e3;
    this.setTimeout(tooltip);
  }
};
Tooltips.prototype.get = function(id) {
  if (typeof id !== "string") {
    id = id.id;
  }
  return this._tooltips[id];
};
Tooltips.prototype.clearTimeout = function(tooltip) {
  tooltip = this.get(tooltip);
  if (!tooltip) {
    return;
  }
  var removeTimer = tooltip.removeTimer;
  if (removeTimer) {
    clearTimeout(removeTimer);
    tooltip.removeTimer = null;
  }
};
Tooltips.prototype.setTimeout = function(tooltip) {
  tooltip = this.get(tooltip);
  if (!tooltip) {
    return;
  }
  this.clearTimeout(tooltip);
  var self2 = this;
  tooltip.removeTimer = setTimeout(function() {
    self2.remove(tooltip);
  }, tooltip.timeout);
};
Tooltips.prototype.remove = function(id) {
  var tooltip = this.get(id);
  if (tooltip) {
    remove2(tooltip.html);
    remove2(tooltip.htmlContainer);
    delete tooltip.htmlContainer;
    delete this._tooltips[tooltip.id];
  }
};
Tooltips.prototype.show = function() {
  setVisible2(this._tooltipRoot);
};
Tooltips.prototype.hide = function() {
  setVisible2(this._tooltipRoot, false);
};
Tooltips.prototype._updateRoot = function(viewbox) {
  var a6 = viewbox.scale || 1;
  var d5 = viewbox.scale || 1;
  var matrix = "matrix(" + a6 + ",0,0," + d5 + "," + -1 * viewbox.x * a6 + "," + -1 * viewbox.y * d5 + ")";
  this._tooltipRoot.style.transform = matrix;
  this._tooltipRoot.style["-ms-transform"] = matrix;
};
Tooltips.prototype._addTooltip = function(tooltip) {
  var id = tooltip.id, html = tooltip.html, htmlContainer, tooltipRoot = this._tooltipRoot;
  if (html.get && html.constructor.prototype.jquery) {
    html = html.get(0);
  }
  if ((0, import_min_dash102.isString)(html)) {
    html = domify$1(html);
  }
  htmlContainer = domify$1('<div data-tooltip-id="' + id + '" class="' + tooltipClass + '">');
  assign(htmlContainer, { position: "absolute" });
  htmlContainer.appendChild(html);
  if (tooltip.type) {
    classes2(htmlContainer).add("djs-tooltip-" + tooltip.type);
  }
  if (tooltip.className) {
    classes2(htmlContainer).add(tooltip.className);
  }
  tooltip.htmlContainer = htmlContainer;
  tooltipRoot.appendChild(htmlContainer);
  this._tooltips[id] = tooltip;
  this._updateTooltip(tooltip);
};
Tooltips.prototype._updateTooltip = function(tooltip) {
  var position = tooltip.position, htmlContainer = tooltip.htmlContainer;
  setPosition2(htmlContainer, position.x, position.y);
};
Tooltips.prototype._updateTooltipVisibilty = function(viewbox) {
  (0, import_min_dash102.forEach)(this._tooltips, function(tooltip) {
    var show = tooltip.show, htmlContainer = tooltip.htmlContainer, visible = true;
    if (show) {
      if (show.minZoom > viewbox.scale || show.maxZoom < viewbox.scale) {
        visible = false;
      }
      setVisible2(htmlContainer, visible);
    }
  });
};
Tooltips.prototype._init = function() {
  var self2 = this;
  function updateViewbox(viewbox) {
    self2._updateRoot(viewbox);
    self2._updateTooltipVisibilty(viewbox);
    self2.show();
  }
  this._eventBus.on("canvas.viewbox.changing", function(event2) {
    self2.hide();
  });
  this._eventBus.on("canvas.viewbox.changed", function(event2) {
    updateViewbox(event2.viewbox);
  });
};

// node_modules/diagram-js/lib/features/tooltips/index.js
var tooltips_default = {
  __init__: ["tooltips"],
  tooltips: ["type", Tooltips]
};

// node_modules/diagram-js/lib/features/label-support/LabelSupport.js
var import_min_dash103 = __toESM(require_dist());

// node_modules/diagram-js/lib/util/Removal.js
function saveClear(collection, removeFn) {
  if (typeof removeFn !== "function") {
    throw new Error("removeFn iterator must be a function");
  }
  if (!collection) {
    return;
  }
  var e7;
  while (e7 = collection[0]) {
    removeFn(e7);
  }
  return collection;
}

// node_modules/diagram-js/lib/features/label-support/LabelSupport.js
var LOW_PRIORITY23 = 250;
var HIGH_PRIORITY16 = 1400;
function LabelSupport(injector, eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  var movePreview = injector.get("movePreview", false);
  eventBus.on("shape.move.start", HIGH_PRIORITY16, function(e7) {
    var context = e7.context, shapes = context.shapes, validatedShapes = context.validatedShapes;
    context.shapes = removeLabels(shapes);
    context.validatedShapes = removeLabels(validatedShapes);
  });
  movePreview && eventBus.on("shape.move.start", LOW_PRIORITY23, function(e7) {
    var context = e7.context, shapes = context.shapes;
    var labels = [];
    (0, import_min_dash103.forEach)(shapes, function(element) {
      (0, import_min_dash103.forEach)(element.labels, function(label) {
        if (!label.hidden && context.shapes.indexOf(label) === -1) {
          labels.push(label);
        }
        if (element.labelTarget) {
          labels.push(element);
        }
      });
    });
    (0, import_min_dash103.forEach)(labels, function(label) {
      movePreview.makeDraggable(context, label, true);
    });
  });
  this.preExecuted("elements.move", HIGH_PRIORITY16, function(e7) {
    var context = e7.context, closure = context.closure, enclosedElements = closure.enclosedElements;
    var enclosedLabels = [];
    (0, import_min_dash103.forEach)(enclosedElements, function(element) {
      (0, import_min_dash103.forEach)(element.labels, function(label) {
        if (!enclosedElements[label.id]) {
          enclosedLabels.push(label);
        }
      });
    });
    closure.addAll(enclosedLabels);
  });
  this.preExecute([
    "connection.delete",
    "shape.delete"
  ], function(e7) {
    var context = e7.context, element = context.connection || context.shape;
    saveClear(element.labels, function(label) {
      modeling.removeShape(label, { nested: true });
    });
  });
  this.execute("shape.delete", function(e7) {
    var context = e7.context, shape = context.shape, labelTarget = shape.labelTarget;
    if (labelTarget) {
      context.labelTargetIndex = indexOf(labelTarget.labels, shape);
      context.labelTarget = labelTarget;
      shape.labelTarget = null;
    }
  });
  this.revert("shape.delete", function(e7) {
    var context = e7.context, shape = context.shape, labelTarget = context.labelTarget, labelTargetIndex = context.labelTargetIndex;
    if (labelTarget) {
      add2(labelTarget.labels, shape, labelTargetIndex);
      shape.labelTarget = labelTarget;
    }
  });
}
e(LabelSupport, CommandInterceptor);
LabelSupport.$inject = [
  "injector",
  "eventBus",
  "modeling"
];
function removeLabels(elements) {
  return (0, import_min_dash103.filter)(elements, function(element) {
    return elements.indexOf(element.labelTarget) === -1;
  });
}

// node_modules/diagram-js/lib/features/label-support/index.js
var label_support_default = {
  __init__: ["labelSupport"],
  labelSupport: ["type", LabelSupport]
};

// node_modules/diagram-js/lib/features/attach-support/AttachSupport.js
var import_min_dash104 = __toESM(require_dist());
var LOW_PRIORITY24 = 251;
var HIGH_PRIORITY17 = 1401;
var MARKER_ATTACH2 = "attach-ok";
function AttachSupport(injector, eventBus, canvas, rules, modeling) {
  CommandInterceptor.call(this, eventBus);
  var movePreview = injector.get("movePreview", false);
  eventBus.on("shape.move.start", HIGH_PRIORITY17, function(e7) {
    var context = e7.context, shapes = context.shapes, validatedShapes = context.validatedShapes;
    context.shapes = addAttached(shapes);
    context.validatedShapes = removeAttached(validatedShapes);
  });
  movePreview && eventBus.on("shape.move.start", LOW_PRIORITY24, function(e7) {
    var context = e7.context, shapes = context.shapes, attachers = getAttachers(shapes);
    (0, import_min_dash104.forEach)(attachers, function(attacher) {
      movePreview.makeDraggable(context, attacher, true);
      (0, import_min_dash104.forEach)(attacher.labels, function(label) {
        movePreview.makeDraggable(context, label, true);
      });
    });
  });
  movePreview && eventBus.on("shape.move.start", function(event2) {
    var context = event2.context, shapes = context.shapes;
    if (shapes.length !== 1) {
      return;
    }
    var shape = shapes[0];
    var host = shape.host;
    if (host) {
      canvas.addMarker(host, MARKER_ATTACH2);
      eventBus.once([
        "shape.move.out",
        "shape.move.cleanup"
      ], function() {
        canvas.removeMarker(host, MARKER_ATTACH2);
      });
    }
  });
  this.preExecuted("elements.move", HIGH_PRIORITY17, function(e7) {
    var context = e7.context, closure = context.closure, shapes = context.shapes, attachers = getAttachers(shapes);
    (0, import_min_dash104.forEach)(attachers, function(attacher) {
      closure.add(attacher, closure.topLevel[attacher.host.id]);
    });
  });
  this.postExecuted("elements.move", function(e7) {
    var context = e7.context, shapes = context.shapes, newHost = context.newHost, attachers;
    if (newHost && shapes.length !== 1) {
      return;
    }
    if (newHost) {
      attachers = shapes;
    } else {
      attachers = (0, import_min_dash104.filter)(shapes, function(shape) {
        var host = shape.host;
        return isAttacher3(shape) && !includes7(shapes, host);
      });
    }
    (0, import_min_dash104.forEach)(attachers, function(attacher) {
      modeling.updateAttachment(attacher, newHost);
    });
  });
  this.postExecuted("elements.move", function(e7) {
    var shapes = e7.context.shapes;
    (0, import_min_dash104.forEach)(shapes, function(shape) {
      (0, import_min_dash104.forEach)(shape.attachers, function(attacher) {
        (0, import_min_dash104.forEach)(attacher.outgoing.slice(), function(connection) {
          var allowed = rules.allowed("connection.reconnect", {
            connection,
            source: connection.source,
            target: connection.target
          });
          if (!allowed) {
            modeling.removeConnection(connection);
          }
        });
        (0, import_min_dash104.forEach)(attacher.incoming.slice(), function(connection) {
          var allowed = rules.allowed("connection.reconnect", {
            connection,
            source: connection.source,
            target: connection.target
          });
          if (!allowed) {
            modeling.removeConnection(connection);
          }
        });
      });
    });
  });
  this.postExecute("shape.create", function(e7) {
    var context = e7.context, shape = context.shape, host = context.host;
    if (host) {
      modeling.updateAttachment(shape, host);
    }
  });
  this.postExecute("shape.replace", function(e7) {
    var context = e7.context, oldShape = context.oldShape, newShape = context.newShape;
    saveClear(oldShape.attachers, function(attacher) {
      var allowed = rules.allowed("elements.move", {
        target: newShape,
        shapes: [attacher]
      });
      if (allowed === "attach") {
        modeling.updateAttachment(attacher, newShape);
      } else {
        modeling.removeShape(attacher);
      }
    });
    if (newShape.attachers.length) {
      (0, import_min_dash104.forEach)(newShape.attachers, function(attacher) {
        var delta2 = getNewAttachShapeDelta(attacher, oldShape, newShape);
        modeling.moveShape(attacher, delta2, attacher.parent);
      });
    }
  });
  this.postExecute("shape.resize", function(event2) {
    var context = event2.context, shape = context.shape, oldBounds = context.oldBounds, newBounds = context.newBounds, attachers = shape.attachers, hints = context.hints || {};
    if (hints.attachSupport === false) {
      return;
    }
    (0, import_min_dash104.forEach)(attachers, function(attacher) {
      var delta2 = getNewAttachShapeDelta(attacher, oldBounds, newBounds);
      modeling.moveShape(attacher, delta2, attacher.parent);
      (0, import_min_dash104.forEach)(attacher.labels, function(label) {
        modeling.moveShape(label, delta2, label.parent);
      });
    });
  });
  this.preExecute("shape.delete", function(event2) {
    var shape = event2.context.shape;
    saveClear(shape.attachers, function(attacher) {
      modeling.removeShape(attacher);
    });
    if (shape.host) {
      modeling.updateAttachment(shape, null);
    }
  });
}
e(AttachSupport, CommandInterceptor);
AttachSupport.$inject = [
  "injector",
  "eventBus",
  "canvas",
  "rules",
  "modeling"
];
function getAttachers(shapes) {
  return (0, import_min_dash104.flatten)((0, import_min_dash104.map)(shapes, function(s5) {
    return s5.attachers || [];
  }));
}
function addAttached(elements) {
  var attachers = getAttachers(elements);
  return (0, import_min_dash104.unionBy)("id", elements, attachers);
}
function removeAttached(elements) {
  var ids3 = (0, import_min_dash104.groupBy)(elements, "id");
  return (0, import_min_dash104.filter)(elements, function(element) {
    while (element) {
      if (element.host && ids3[element.host.id]) {
        return false;
      }
      element = element.parent;
    }
    return true;
  });
}
function isAttacher3(shape) {
  return !!shape.host;
}
function includes7(array, item) {
  return array.indexOf(item) !== -1;
}

// node_modules/diagram-js/lib/features/attach-support/index.js
var attach_support_default = {
  __depends__: [
    rules_default
  ],
  __init__: ["attachSupport"],
  attachSupport: ["type", AttachSupport]
};

// node_modules/bpmn-js/lib/features/modeling/BpmnFactory.js
var import_min_dash105 = __toESM(require_dist());
function BpmnFactory(moddle) {
  this._model = moddle;
}
BpmnFactory.$inject = ["moddle"];
BpmnFactory.prototype._needsId = function(element) {
  return isAny(element, [
    "bpmn:RootElement",
    "bpmn:FlowElement",
    "bpmn:MessageFlow",
    "bpmn:DataAssociation",
    "bpmn:Artifact",
    "bpmn:Participant",
    "bpmn:Lane",
    "bpmn:LaneSet",
    "bpmn:Process",
    "bpmn:Collaboration",
    "bpmndi:BPMNShape",
    "bpmndi:BPMNEdge",
    "bpmndi:BPMNDiagram",
    "bpmndi:BPMNPlane",
    "bpmn:Property",
    "bpmn:CategoryValue"
  ]);
};
BpmnFactory.prototype._ensureId = function(element) {
  if (element.id) {
    this._model.ids.claim(element.id, element);
    return;
  }
  var prefix3;
  if (is(element, "bpmn:Activity")) {
    prefix3 = "Activity";
  } else if (is(element, "bpmn:Event")) {
    prefix3 = "Event";
  } else if (is(element, "bpmn:Gateway")) {
    prefix3 = "Gateway";
  } else if (isAny(element, ["bpmn:SequenceFlow", "bpmn:MessageFlow"])) {
    prefix3 = "Flow";
  } else {
    prefix3 = (element.$type || "").replace(/^[^:]*:/g, "");
  }
  prefix3 += "_";
  if (!element.id && this._needsId(element)) {
    element.id = this._model.ids.nextPrefixed(prefix3, element);
  }
};
BpmnFactory.prototype.create = function(type, attrs) {
  var element = this._model.create(type, attrs || {});
  this._ensureId(element);
  return element;
};
BpmnFactory.prototype.createDiLabel = function() {
  return this.create("bpmndi:BPMNLabel", {
    bounds: this.createDiBounds()
  });
};
BpmnFactory.prototype.createDiShape = function(semantic, attrs) {
  return this.create("bpmndi:BPMNShape", (0, import_min_dash105.assign)({
    bpmnElement: semantic,
    bounds: this.createDiBounds()
  }, attrs));
};
BpmnFactory.prototype.createDiBounds = function(bounds) {
  return this.create("dc:Bounds", bounds);
};
BpmnFactory.prototype.createDiWaypoints = function(waypoints) {
  var self2 = this;
  return (0, import_min_dash105.map)(waypoints, function(pos) {
    return self2.createDiWaypoint(pos);
  });
};
BpmnFactory.prototype.createDiWaypoint = function(point) {
  return this.create("dc:Point", (0, import_min_dash105.pick)(point, ["x", "y"]));
};
BpmnFactory.prototype.createDiEdge = function(semantic, attrs) {
  return this.create("bpmndi:BPMNEdge", (0, import_min_dash105.assign)({
    bpmnElement: semantic,
    waypoint: this.createDiWaypoints([])
  }, attrs));
};
BpmnFactory.prototype.createDiPlane = function(semantic, attrs) {
  return this.create("bpmndi:BPMNPlane", (0, import_min_dash105.assign)({
    bpmnElement: semantic
  }, attrs));
};

// node_modules/bpmn-js/lib/features/modeling/BpmnUpdater.js
var import_min_dash106 = __toESM(require_dist());
function BpmnUpdater(eventBus, bpmnFactory, connectionDocking, translate3) {
  CommandInterceptor.call(this, eventBus);
  this._bpmnFactory = bpmnFactory;
  this._translate = translate3;
  var self2 = this;
  function cropConnection(e7) {
    var context = e7.context, hints = context.hints || {}, connection;
    if (!context.cropped && hints.createElementsBehavior !== false) {
      connection = context.connection;
      connection.waypoints = connectionDocking.getCroppedWaypoints(connection);
      context.cropped = true;
    }
  }
  this.executed([
    "connection.layout",
    "connection.create"
  ], cropConnection);
  this.reverted(["connection.layout"], function(e7) {
    delete e7.context.cropped;
  });
  function updateParent(e7) {
    var context = e7.context;
    self2.updateParent(context.shape || context.connection, context.oldParent);
  }
  function reverseUpdateParent(e7) {
    var context = e7.context;
    var element = context.shape || context.connection, oldParent = context.parent || context.newParent;
    self2.updateParent(element, oldParent);
  }
  this.executed([
    "shape.move",
    "shape.create",
    "shape.delete",
    "connection.create",
    "connection.move",
    "connection.delete"
  ], ifBpmn(updateParent));
  this.reverted([
    "shape.move",
    "shape.create",
    "shape.delete",
    "connection.create",
    "connection.move",
    "connection.delete"
  ], ifBpmn(reverseUpdateParent));
  function updateRoot(event2) {
    var context = event2.context, oldRoot = context.oldRoot, children = oldRoot.children;
    (0, import_min_dash106.forEach)(children, function(child) {
      if (is(child, "bpmn:BaseElement")) {
        self2.updateParent(child);
      }
    });
  }
  this.executed(["canvas.updateRoot"], updateRoot);
  this.reverted(["canvas.updateRoot"], updateRoot);
  function updateBounds(e7) {
    var shape = e7.context.shape;
    if (!is(shape, "bpmn:BaseElement")) {
      return;
    }
    self2.updateBounds(shape);
  }
  this.executed(["shape.move", "shape.create", "shape.resize"], ifBpmn(function(event2) {
    if (event2.context.shape.type === "label") {
      return;
    }
    updateBounds(event2);
  }));
  this.reverted(["shape.move", "shape.create", "shape.resize"], ifBpmn(function(event2) {
    if (event2.context.shape.type === "label") {
      return;
    }
    updateBounds(event2);
  }));
  eventBus.on("shape.changed", function(event2) {
    if (event2.element.type === "label") {
      updateBounds({ context: { shape: event2.element } });
    }
  });
  function updateConnection(e7) {
    self2.updateConnection(e7.context);
  }
  this.executed([
    "connection.create",
    "connection.move",
    "connection.delete",
    "connection.reconnect"
  ], ifBpmn(updateConnection));
  this.reverted([
    "connection.create",
    "connection.move",
    "connection.delete",
    "connection.reconnect"
  ], ifBpmn(updateConnection));
  function updateConnectionWaypoints(e7) {
    self2.updateConnectionWaypoints(e7.context.connection);
  }
  this.executed([
    "connection.layout",
    "connection.move",
    "connection.updateWaypoints"
  ], ifBpmn(updateConnectionWaypoints));
  this.reverted([
    "connection.layout",
    "connection.move",
    "connection.updateWaypoints"
  ], ifBpmn(updateConnectionWaypoints));
  this.executed("connection.reconnect", ifBpmn(function(event2) {
    var context = event2.context, connection = context.connection, oldSource = context.oldSource, newSource = context.newSource, connectionBo = getBusinessObject(connection), oldSourceBo = getBusinessObject(oldSource), newSourceBo = getBusinessObject(newSource);
    if (connectionBo.conditionExpression && !isAny(newSourceBo, [
      "bpmn:Activity",
      "bpmn:ExclusiveGateway",
      "bpmn:InclusiveGateway"
    ])) {
      context.oldConditionExpression = connectionBo.conditionExpression;
      delete connectionBo.conditionExpression;
    }
    if (oldSource !== newSource && oldSourceBo.default === connectionBo) {
      context.oldDefault = oldSourceBo.default;
      delete oldSourceBo.default;
    }
  }));
  this.reverted("connection.reconnect", ifBpmn(function(event2) {
    var context = event2.context, connection = context.connection, oldSource = context.oldSource, newSource = context.newSource, connectionBo = getBusinessObject(connection), oldSourceBo = getBusinessObject(oldSource), newSourceBo = getBusinessObject(newSource);
    if (context.oldConditionExpression) {
      connectionBo.conditionExpression = context.oldConditionExpression;
    }
    if (context.oldDefault) {
      oldSourceBo.default = context.oldDefault;
      delete newSourceBo.default;
    }
  }));
  function updateAttachment(e7) {
    self2.updateAttachment(e7.context);
  }
  this.executed(["element.updateAttachment"], ifBpmn(updateAttachment));
  this.reverted(["element.updateAttachment"], ifBpmn(updateAttachment));
}
e(BpmnUpdater, CommandInterceptor);
BpmnUpdater.$inject = [
  "eventBus",
  "bpmnFactory",
  "connectionDocking",
  "translate"
];
BpmnUpdater.prototype.updateAttachment = function(context) {
  var shape = context.shape, businessObject = shape.businessObject, host = shape.host;
  businessObject.attachedToRef = host && host.businessObject;
};
BpmnUpdater.prototype.updateParent = function(element, oldParent) {
  if (element instanceof Label) {
    return;
  }
  if (is(element, "bpmn:DataStoreReference") && element.parent && is(element.parent, "bpmn:Collaboration")) {
    return;
  }
  var parentShape = element.parent;
  var businessObject = element.businessObject, di = getDi(element), parentBusinessObject = parentShape && parentShape.businessObject, parentDi = getDi(parentShape);
  if (is(element, "bpmn:FlowNode")) {
    this.updateFlowNodeRefs(businessObject, parentBusinessObject, oldParent && oldParent.businessObject);
  }
  if (is(element, "bpmn:DataOutputAssociation")) {
    if (element.source) {
      parentBusinessObject = element.source.businessObject;
    } else {
      parentBusinessObject = null;
    }
  }
  if (is(element, "bpmn:DataInputAssociation")) {
    if (element.target) {
      parentBusinessObject = element.target.businessObject;
    } else {
      parentBusinessObject = null;
    }
  }
  this.updateSemanticParent(businessObject, parentBusinessObject);
  if (is(element, "bpmn:DataObjectReference") && businessObject.dataObjectRef) {
    this.updateSemanticParent(businessObject.dataObjectRef, parentBusinessObject);
  }
  this.updateDiParent(di, parentDi);
};
BpmnUpdater.prototype.updateBounds = function(shape) {
  var di = getDi(shape), embeddedLabelBounds = getEmbeddedLabelBounds(shape);
  if (embeddedLabelBounds) {
    var embeddedLabelBoundsDelta = delta(embeddedLabelBounds, di.get("bounds"));
    (0, import_min_dash106.assign)(embeddedLabelBounds, {
      x: shape.x + embeddedLabelBoundsDelta.x,
      y: shape.y + embeddedLabelBoundsDelta.y
    });
  }
  var target = shape instanceof Label ? this._getLabel(di) : di;
  var bounds = target.bounds;
  if (!bounds) {
    bounds = this._bpmnFactory.createDiBounds();
    target.set("bounds", bounds);
  }
  (0, import_min_dash106.assign)(bounds, {
    x: shape.x,
    y: shape.y,
    width: shape.width,
    height: shape.height
  });
};
BpmnUpdater.prototype.updateFlowNodeRefs = function(businessObject, newContainment, oldContainment) {
  if (oldContainment === newContainment) {
    return;
  }
  var oldRefs, newRefs;
  if (is(oldContainment, "bpmn:Lane")) {
    oldRefs = oldContainment.get("flowNodeRef");
    remove3(oldRefs, businessObject);
  }
  if (is(newContainment, "bpmn:Lane")) {
    newRefs = newContainment.get("flowNodeRef");
    add2(newRefs, businessObject);
  }
};
BpmnUpdater.prototype.updateDiConnection = function(connection, newSource, newTarget) {
  var connectionDi = getDi(connection), newSourceDi = getDi(newSource), newTargetDi = getDi(newTarget);
  if (connectionDi.sourceElement && connectionDi.sourceElement.bpmnElement !== getBusinessObject(newSource)) {
    connectionDi.sourceElement = newSource && newSourceDi;
  }
  if (connectionDi.targetElement && connectionDi.targetElement.bpmnElement !== getBusinessObject(newTarget)) {
    connectionDi.targetElement = newTarget && newTargetDi;
  }
};
BpmnUpdater.prototype.updateDiParent = function(di, parentDi) {
  if (parentDi && !is(parentDi, "bpmndi:BPMNPlane")) {
    parentDi = parentDi.$parent;
  }
  if (di.$parent === parentDi) {
    return;
  }
  var planeElements = (parentDi || di.$parent).get("planeElement");
  if (parentDi) {
    planeElements.push(di);
    di.$parent = parentDi;
  } else {
    remove3(planeElements, di);
    di.$parent = null;
  }
};
function getDefinitions(element) {
  while (element && !is(element, "bpmn:Definitions")) {
    element = element.$parent;
  }
  return element;
}
BpmnUpdater.prototype.getLaneSet = function(container) {
  var laneSet, laneSets;
  if (is(container, "bpmn:Lane")) {
    laneSet = container.childLaneSet;
    if (!laneSet) {
      laneSet = this._bpmnFactory.create("bpmn:LaneSet");
      container.childLaneSet = laneSet;
      laneSet.$parent = container;
    }
    return laneSet;
  }
  if (is(container, "bpmn:Participant")) {
    container = container.processRef;
  }
  laneSets = container.get("laneSets");
  laneSet = laneSets[0];
  if (!laneSet) {
    laneSet = this._bpmnFactory.create("bpmn:LaneSet");
    laneSet.$parent = container;
    laneSets.push(laneSet);
  }
  return laneSet;
};
BpmnUpdater.prototype.updateSemanticParent = function(businessObject, newParent, visualParent) {
  var containment, translate3 = this._translate;
  if (businessObject.$parent === newParent) {
    return;
  }
  if (is(businessObject, "bpmn:DataInput") || is(businessObject, "bpmn:DataOutput")) {
    if (is(newParent, "bpmn:Participant") && "processRef" in newParent) {
      newParent = newParent.processRef;
    }
    if ("ioSpecification" in newParent && newParent.ioSpecification === businessObject.$parent) {
      return;
    }
  }
  if (is(businessObject, "bpmn:Lane")) {
    if (newParent) {
      newParent = this.getLaneSet(newParent);
    }
    containment = "lanes";
  } else if (is(businessObject, "bpmn:FlowElement")) {
    if (newParent) {
      if (is(newParent, "bpmn:Participant")) {
        newParent = newParent.processRef;
      } else if (is(newParent, "bpmn:Lane")) {
        do {
          newParent = newParent.$parent.$parent;
        } while (is(newParent, "bpmn:Lane"));
      }
    }
    containment = "flowElements";
  } else if (is(businessObject, "bpmn:Artifact")) {
    while (newParent && !is(newParent, "bpmn:Process") && !is(newParent, "bpmn:SubProcess") && !is(newParent, "bpmn:Collaboration")) {
      if (is(newParent, "bpmn:Participant")) {
        newParent = newParent.processRef;
        break;
      } else {
        newParent = newParent.$parent;
      }
    }
    containment = "artifacts";
  } else if (is(businessObject, "bpmn:MessageFlow")) {
    containment = "messageFlows";
  } else if (is(businessObject, "bpmn:Participant")) {
    containment = "participants";
    var process2 = businessObject.processRef, definitions;
    if (process2) {
      definitions = getDefinitions(businessObject.$parent || newParent);
      if (businessObject.$parent) {
        remove3(definitions.get("rootElements"), process2);
        process2.$parent = null;
      }
      if (newParent) {
        add2(definitions.get("rootElements"), process2);
        process2.$parent = definitions;
      }
    }
  } else if (is(businessObject, "bpmn:DataOutputAssociation")) {
    containment = "dataOutputAssociations";
  } else if (is(businessObject, "bpmn:DataInputAssociation")) {
    containment = "dataInputAssociations";
  }
  if (!containment) {
    throw new Error(translate3("no parent for {element} in {parent}", {
      element: businessObject.id,
      parent: newParent.id
    }));
  }
  var children;
  if (businessObject.$parent) {
    children = businessObject.$parent.get(containment);
    remove3(children, businessObject);
  }
  if (!newParent) {
    businessObject.$parent = null;
  } else {
    children = newParent.get(containment);
    children.push(businessObject);
    businessObject.$parent = newParent;
  }
  if (visualParent) {
    var diChildren = visualParent.get(containment);
    remove3(children, businessObject);
    if (newParent) {
      if (!diChildren) {
        diChildren = [];
        newParent.set(containment, diChildren);
      }
      diChildren.push(businessObject);
    }
  }
};
BpmnUpdater.prototype.updateConnectionWaypoints = function(connection) {
  var di = getDi(connection);
  di.set("waypoint", this._bpmnFactory.createDiWaypoints(connection.waypoints));
};
BpmnUpdater.prototype.updateConnection = function(context) {
  var connection = context.connection, businessObject = getBusinessObject(connection), newSource = connection.source, newSourceBo = getBusinessObject(newSource), newTarget = connection.target, newTargetBo = getBusinessObject(connection.target), visualParent;
  if (!is(businessObject, "bpmn:DataAssociation")) {
    var inverseSet = is(businessObject, "bpmn:SequenceFlow");
    if (businessObject.sourceRef !== newSourceBo) {
      if (inverseSet) {
        remove3(businessObject.sourceRef && businessObject.sourceRef.get("outgoing"), businessObject);
        if (newSourceBo && newSourceBo.get("outgoing")) {
          newSourceBo.get("outgoing").push(businessObject);
        }
      }
      businessObject.sourceRef = newSourceBo;
    }
    if (businessObject.targetRef !== newTargetBo) {
      if (inverseSet) {
        remove3(businessObject.targetRef && businessObject.targetRef.get("incoming"), businessObject);
        if (newTargetBo && newTargetBo.get("incoming")) {
          newTargetBo.get("incoming").push(businessObject);
        }
      }
      businessObject.targetRef = newTargetBo;
    }
  } else if (is(businessObject, "bpmn:DataInputAssociation")) {
    businessObject.get("sourceRef")[0] = newSourceBo;
    visualParent = context.parent || context.newParent || newTargetBo;
    this.updateSemanticParent(businessObject, newTargetBo, visualParent);
  } else if (is(businessObject, "bpmn:DataOutputAssociation")) {
    visualParent = context.parent || context.newParent || newSourceBo;
    this.updateSemanticParent(businessObject, newSourceBo, visualParent);
    businessObject.targetRef = newTargetBo;
  }
  this.updateConnectionWaypoints(connection);
  this.updateDiConnection(connection, newSource, newTarget);
};
BpmnUpdater.prototype._getLabel = function(di) {
  if (!di.label) {
    di.label = this._bpmnFactory.createDiLabel();
  }
  return di.label;
};
function ifBpmn(fn2) {
  return function(event2) {
    var context = event2.context, element = context.shape || context.connection;
    if (is(element, "bpmn:BaseElement")) {
      fn2(event2);
    }
  };
}
function getEmbeddedLabelBounds(shape) {
  if (!is(shape, "bpmn:Activity")) {
    return;
  }
  var di = getDi(shape);
  if (!di) {
    return;
  }
  var label = di.get("label");
  if (!label) {
    return;
  }
  return label.get("bounds");
}

// node_modules/bpmn-js/lib/features/modeling/ElementFactory.js
var import_min_dash107 = __toESM(require_dist());
function ElementFactory2(bpmnFactory, moddle, translate3) {
  ElementFactory.call(this);
  this._bpmnFactory = bpmnFactory;
  this._moddle = moddle;
  this._translate = translate3;
}
e(ElementFactory2, ElementFactory);
ElementFactory2.$inject = [
  "bpmnFactory",
  "moddle",
  "translate"
];
ElementFactory2.prototype.baseCreate = ElementFactory.prototype.create;
ElementFactory2.prototype.create = function(elementType, attrs) {
  if (elementType === "label") {
    var di = attrs.di || this._bpmnFactory.createDiLabel();
    return this.baseCreate(elementType, (0, import_min_dash107.assign)({ type: "label", di }, DEFAULT_LABEL_SIZE2, attrs));
  }
  return this.createBpmnElement(elementType, attrs);
};
ElementFactory2.prototype.createBpmnElement = function(elementType, attrs) {
  var size2, translate3 = this._translate;
  attrs = (0, import_min_dash107.assign)({}, attrs || {});
  var businessObject = attrs.businessObject, di = attrs.di;
  if (!businessObject) {
    if (!attrs.type) {
      throw new Error(translate3("no shape type specified"));
    }
    businessObject = this._bpmnFactory.create(attrs.type);
    ensureCompatDiRef(businessObject);
  }
  if (!isModdleDi(di)) {
    var diAttrs = (0, import_min_dash107.assign)({}, di || {}, { id: businessObject.id + "_di" });
    if (elementType === "root") {
      di = this._bpmnFactory.createDiPlane(businessObject, diAttrs);
    } else if (elementType === "connection") {
      di = this._bpmnFactory.createDiEdge(businessObject, diAttrs);
    } else {
      di = this._bpmnFactory.createDiShape(businessObject, diAttrs);
    }
  }
  if (is(businessObject, "bpmn:Group")) {
    attrs = (0, import_min_dash107.assign)({
      isFrame: true
    }, attrs);
  }
  attrs = applyAttributes(businessObject, attrs, [
    "processRef",
    "isInterrupting",
    "associationDirection",
    "isForCompensation"
  ]);
  if (attrs.isExpanded) {
    attrs = applyAttribute(di, attrs, "isExpanded");
  }
  if (is(businessObject, "bpmn:SubProcess")) {
    attrs.collapsed = !isExpanded(businessObject, di);
  }
  if (is(businessObject, "bpmn:ExclusiveGateway")) {
    di.isMarkerVisible = true;
  }
  var eventDefinitions, newEventDefinition;
  if (attrs.eventDefinitionType) {
    eventDefinitions = businessObject.get("eventDefinitions") || [];
    newEventDefinition = this._bpmnFactory.create(attrs.eventDefinitionType, attrs.eventDefinitionAttrs);
    if (attrs.eventDefinitionType === "bpmn:ConditionalEventDefinition") {
      newEventDefinition.condition = this._bpmnFactory.create("bpmn:FormalExpression");
    }
    eventDefinitions.push(newEventDefinition);
    newEventDefinition.$parent = businessObject;
    businessObject.eventDefinitions = eventDefinitions;
    delete attrs.eventDefinitionType;
  }
  size2 = this.getDefaultSize(businessObject, di);
  attrs = (0, import_min_dash107.assign)({
    id: businessObject.id
  }, size2, attrs, {
    businessObject,
    di
  });
  return this.baseCreate(elementType, attrs);
};
ElementFactory2.prototype.getDefaultSize = function(element, di) {
  var bo = getBusinessObject(element);
  di = di || getDi(element);
  if (is(bo, "bpmn:SubProcess")) {
    if (isExpanded(bo, di)) {
      return { width: 350, height: 200 };
    } else {
      return { width: 100, height: 80 };
    }
  }
  if (is(bo, "bpmn:Task")) {
    return { width: 100, height: 80 };
  }
  if (is(bo, "bpmn:Gateway")) {
    return { width: 50, height: 50 };
  }
  if (is(bo, "bpmn:Event")) {
    return { width: 36, height: 36 };
  }
  if (is(bo, "bpmn:Participant")) {
    if (isExpanded(bo, di)) {
      return { width: 600, height: 250 };
    } else {
      return { width: 400, height: 60 };
    }
  }
  if (is(bo, "bpmn:Lane")) {
    return { width: 400, height: 100 };
  }
  if (is(bo, "bpmn:DataObjectReference")) {
    return { width: 36, height: 50 };
  }
  if (is(bo, "bpmn:DataStoreReference")) {
    return { width: 50, height: 50 };
  }
  if (is(bo, "bpmn:TextAnnotation")) {
    return { width: 100, height: 30 };
  }
  if (is(bo, "bpmn:Group")) {
    return { width: 300, height: 300 };
  }
  return { width: 100, height: 80 };
};
ElementFactory2.prototype.createParticipantShape = function(attrs) {
  if (!(0, import_min_dash107.isObject)(attrs)) {
    attrs = { isExpanded: attrs };
  }
  attrs = (0, import_min_dash107.assign)({ type: "bpmn:Participant" }, attrs || {});
  if (attrs.isExpanded !== false) {
    attrs.processRef = this._bpmnFactory.create("bpmn:Process");
  }
  return this.createShape(attrs);
};
function applyAttributes(element, attrs, attributeNames) {
  (0, import_min_dash107.forEach)(attributeNames, function(property) {
    attrs = applyAttribute(element, attrs, property);
  });
  return attrs;
}
function applyAttribute(element, attrs, attributeName) {
  if (attrs[attributeName] === void 0) {
    return attrs;
  }
  element[attributeName] = attrs[attributeName];
  return (0, import_min_dash107.omit)(attrs, [attributeName]);
}
function isModdleDi(element) {
  return isAny(element, [
    "bpmndi:BPMNShape",
    "bpmndi:BPMNEdge",
    "bpmndi:BPMNDiagram",
    "bpmndi:BPMNPlane"
  ]);
}

// node_modules/diagram-js/lib/features/modeling/Modeling.js
var import_min_dash124 = __toESM(require_dist());

// node_modules/diagram-js/lib/features/modeling/cmd/AlignElementsHandler.js
var import_min_dash108 = __toESM(require_dist());
function AlignElements2(modeling, canvas) {
  this._modeling = modeling;
  this._canvas = canvas;
}
AlignElements2.$inject = ["modeling", "canvas"];
AlignElements2.prototype.preExecute = function(context) {
  var modeling = this._modeling;
  var elements = context.elements, alignment = context.alignment;
  (0, import_min_dash108.forEach)(elements, function(element) {
    var delta2 = {
      x: 0,
      y: 0
    };
    if (alignment.left) {
      delta2.x = alignment.left - element.x;
    } else if (alignment.right) {
      delta2.x = alignment.right - element.width - element.x;
    } else if (alignment.center) {
      delta2.x = alignment.center - Math.round(element.width / 2) - element.x;
    } else if (alignment.top) {
      delta2.y = alignment.top - element.y;
    } else if (alignment.bottom) {
      delta2.y = alignment.bottom - element.height - element.y;
    } else if (alignment.middle) {
      delta2.y = alignment.middle - Math.round(element.height / 2) - element.y;
    }
    modeling.moveElements([element], delta2, element.parent);
  });
};
AlignElements2.prototype.postExecute = function(context) {
};

// node_modules/diagram-js/lib/features/modeling/cmd/AppendShapeHandler.js
var import_min_dash109 = __toESM(require_dist());
function AppendShapeHandler(modeling) {
  this._modeling = modeling;
}
AppendShapeHandler.$inject = ["modeling"];
AppendShapeHandler.prototype.preExecute = function(context) {
  var source = context.source;
  if (!source) {
    throw new Error("source required");
  }
  var target = context.target || source.parent, shape = context.shape, hints = context.hints || {};
  shape = context.shape = this._modeling.createShape(shape, context.position, target, { attach: hints.attach });
  context.shape = shape;
};
AppendShapeHandler.prototype.postExecute = function(context) {
  var hints = context.hints || {};
  if (!existsConnection(context.source, context.shape)) {
    if (hints.connectionTarget === context.source) {
      this._modeling.connect(context.shape, context.source, context.connection);
    } else {
      this._modeling.connect(context.source, context.shape, context.connection);
    }
  }
};
function existsConnection(source, target) {
  return (0, import_min_dash109.some)(source.outgoing, function(c5) {
    return c5.target === target;
  });
}

// node_modules/diagram-js/lib/features/modeling/cmd/CreateConnectionHandler.js
function CreateConnectionHandler(canvas, layouter) {
  this._canvas = canvas;
  this._layouter = layouter;
}
CreateConnectionHandler.$inject = ["canvas", "layouter"];
CreateConnectionHandler.prototype.execute = function(context) {
  var connection = context.connection, source = context.source, target = context.target, parent = context.parent, parentIndex = context.parentIndex, hints = context.hints;
  if (!source || !target) {
    throw new Error("source and target required");
  }
  if (!parent) {
    throw new Error("parent required");
  }
  connection.source = source;
  connection.target = target;
  if (!connection.waypoints) {
    connection.waypoints = this._layouter.layoutConnection(connection, hints);
  }
  this._canvas.addConnection(connection, parent, parentIndex);
  return connection;
};
CreateConnectionHandler.prototype.revert = function(context) {
  var connection = context.connection;
  this._canvas.removeConnection(connection);
  connection.source = null;
  connection.target = null;
  return connection;
};

// node_modules/diagram-js/lib/features/modeling/cmd/CreateElementsHandler.js
var import_min_dash110 = __toESM(require_dist());
var round9 = Math.round;
function CreateElementsHandler(modeling) {
  this._modeling = modeling;
}
CreateElementsHandler.$inject = [
  "modeling"
];
CreateElementsHandler.prototype.preExecute = function(context) {
  var elements = context.elements, parent = context.parent, parentIndex = context.parentIndex, position = context.position, hints = context.hints;
  var modeling = this._modeling;
  (0, import_min_dash110.forEach)(elements, function(element) {
    if (!(0, import_min_dash110.isNumber)(element.x)) {
      element.x = 0;
    }
    if (!(0, import_min_dash110.isNumber)(element.y)) {
      element.y = 0;
    }
  });
  var visibleElements = (0, import_min_dash110.filter)(elements, function(element) {
    return !element.hidden;
  });
  var bbox = getBBox(visibleElements);
  (0, import_min_dash110.forEach)(elements, function(element) {
    if (isConnection11(element)) {
      element.waypoints = (0, import_min_dash110.map)(element.waypoints, function(waypoint) {
        return {
          x: round9(waypoint.x - bbox.x - bbox.width / 2 + position.x),
          y: round9(waypoint.y - bbox.y - bbox.height / 2 + position.y)
        };
      });
    }
    (0, import_min_dash110.assign)(element, {
      x: round9(element.x - bbox.x - bbox.width / 2 + position.x),
      y: round9(element.y - bbox.y - bbox.height / 2 + position.y)
    });
  });
  var parents = getParents(elements);
  var cache = {};
  (0, import_min_dash110.forEach)(elements, function(element) {
    if (isConnection11(element)) {
      cache[element.id] = (0, import_min_dash110.isNumber)(parentIndex) ? modeling.createConnection(cache[element.source.id], cache[element.target.id], parentIndex, element, element.parent || parent, hints) : modeling.createConnection(cache[element.source.id], cache[element.target.id], element, element.parent || parent, hints);
      return;
    }
    var createShapeHints = (0, import_min_dash110.assign)({}, hints);
    if (parents.indexOf(element) === -1) {
      createShapeHints.autoResize = false;
    }
    cache[element.id] = (0, import_min_dash110.isNumber)(parentIndex) ? modeling.createShape(element, (0, import_min_dash110.pick)(element, ["x", "y", "width", "height"]), element.parent || parent, parentIndex, createShapeHints) : modeling.createShape(element, (0, import_min_dash110.pick)(element, ["x", "y", "width", "height"]), element.parent || parent, createShapeHints);
  });
  context.elements = (0, import_min_dash110.values)(cache);
};
function isConnection11(element) {
  return !!element.waypoints;
}

// node_modules/diagram-js/lib/features/modeling/cmd/CreateShapeHandler.js
var import_min_dash111 = __toESM(require_dist());
var round10 = Math.round;
function CreateShapeHandler(canvas) {
  this._canvas = canvas;
}
CreateShapeHandler.$inject = ["canvas"];
CreateShapeHandler.prototype.execute = function(context) {
  var shape = context.shape, positionOrBounds = context.position, parent = context.parent, parentIndex = context.parentIndex;
  if (!parent) {
    throw new Error("parent required");
  }
  if (!positionOrBounds) {
    throw new Error("position required");
  }
  if (positionOrBounds.width !== void 0) {
    (0, import_min_dash111.assign)(shape, positionOrBounds);
  } else {
    (0, import_min_dash111.assign)(shape, {
      x: positionOrBounds.x - round10(shape.width / 2),
      y: positionOrBounds.y - round10(shape.height / 2)
    });
  }
  this._canvas.addShape(shape, parent, parentIndex);
  return shape;
};
CreateShapeHandler.prototype.revert = function(context) {
  var shape = context.shape;
  this._canvas.removeShape(shape);
  return shape;
};

// node_modules/diagram-js/lib/features/modeling/cmd/CreateLabelHandler.js
function CreateLabelHandler(canvas) {
  CreateShapeHandler.call(this, canvas);
}
e(CreateLabelHandler, CreateShapeHandler);
CreateLabelHandler.$inject = ["canvas"];
var originalExecute = CreateShapeHandler.prototype.execute;
CreateLabelHandler.prototype.execute = function(context) {
  var label = context.shape;
  ensureValidDimensions(label);
  label.labelTarget = context.labelTarget;
  return originalExecute.call(this, context);
};
var originalRevert = CreateShapeHandler.prototype.revert;
CreateLabelHandler.prototype.revert = function(context) {
  context.shape.labelTarget = null;
  return originalRevert.call(this, context);
};
function ensureValidDimensions(label) {
  ["width", "height"].forEach(function(prop) {
    if (typeof label[prop] === "undefined") {
      label[prop] = 0;
    }
  });
}

// node_modules/diagram-js/lib/features/modeling/cmd/DeleteConnectionHandler.js
function DeleteConnectionHandler(canvas, modeling) {
  this._canvas = canvas;
  this._modeling = modeling;
}
DeleteConnectionHandler.$inject = [
  "canvas",
  "modeling"
];
DeleteConnectionHandler.prototype.preExecute = function(context) {
  var modeling = this._modeling;
  var connection = context.connection;
  saveClear(connection.incoming, function(connection2) {
    modeling.removeConnection(connection2, { nested: true });
  });
  saveClear(connection.outgoing, function(connection2) {
    modeling.removeConnection(connection2, { nested: true });
  });
};
DeleteConnectionHandler.prototype.execute = function(context) {
  var connection = context.connection, parent = connection.parent;
  context.parent = parent;
  context.parentIndex = indexOf(parent.children, connection);
  context.source = connection.source;
  context.target = connection.target;
  this._canvas.removeConnection(connection);
  connection.source = null;
  connection.target = null;
  return connection;
};
DeleteConnectionHandler.prototype.revert = function(context) {
  var connection = context.connection, parent = context.parent, parentIndex = context.parentIndex;
  connection.source = context.source;
  connection.target = context.target;
  add2(parent.children, connection, parentIndex);
  this._canvas.addConnection(connection, parent);
  return connection;
};

// node_modules/diagram-js/lib/features/modeling/cmd/DeleteElementsHandler.js
var import_min_dash112 = __toESM(require_dist());
function DeleteElementsHandler(modeling, elementRegistry) {
  this._modeling = modeling;
  this._elementRegistry = elementRegistry;
}
DeleteElementsHandler.$inject = [
  "modeling",
  "elementRegistry"
];
DeleteElementsHandler.prototype.postExecute = function(context) {
  var modeling = this._modeling, elementRegistry = this._elementRegistry, elements = context.elements;
  (0, import_min_dash112.forEach)(elements, function(element) {
    if (!elementRegistry.get(element.id)) {
      return;
    }
    if (element.waypoints) {
      modeling.removeConnection(element);
    } else {
      modeling.removeShape(element);
    }
  });
};

// node_modules/diagram-js/lib/features/modeling/cmd/DeleteShapeHandler.js
function DeleteShapeHandler(canvas, modeling) {
  this._canvas = canvas;
  this._modeling = modeling;
}
DeleteShapeHandler.$inject = ["canvas", "modeling"];
DeleteShapeHandler.prototype.preExecute = function(context) {
  var modeling = this._modeling;
  var shape = context.shape;
  saveClear(shape.incoming, function(connection) {
    modeling.removeConnection(connection, { nested: true });
  });
  saveClear(shape.outgoing, function(connection) {
    modeling.removeConnection(connection, { nested: true });
  });
  saveClear(shape.children, function(child) {
    if (isConnection12(child)) {
      modeling.removeConnection(child, { nested: true });
    } else {
      modeling.removeShape(child, { nested: true });
    }
  });
};
DeleteShapeHandler.prototype.execute = function(context) {
  var canvas = this._canvas;
  var shape = context.shape, oldParent = shape.parent;
  context.oldParent = oldParent;
  context.oldParentIndex = indexOf(oldParent.children, shape);
  canvas.removeShape(shape);
  return shape;
};
DeleteShapeHandler.prototype.revert = function(context) {
  var canvas = this._canvas;
  var shape = context.shape, oldParent = context.oldParent, oldParentIndex = context.oldParentIndex;
  add2(oldParent.children, shape, oldParentIndex);
  canvas.addShape(shape, oldParent);
  return shape;
};
function isConnection12(element) {
  return element.waypoints;
}

// node_modules/diagram-js/lib/features/modeling/cmd/DistributeElementsHandler.js
var import_min_dash113 = __toESM(require_dist());
function DistributeElements2(modeling) {
  this._modeling = modeling;
}
DistributeElements2.$inject = ["modeling"];
var OFF_AXIS = {
  x: "y",
  y: "x"
};
DistributeElements2.prototype.preExecute = function(context) {
  var modeling = this._modeling;
  var groups = context.groups, axis = context.axis, dimension = context.dimension;
  function updateRange(group, element) {
    group.range.min = Math.min(element[axis], group.range.min);
    group.range.max = Math.max(element[axis] + element[dimension], group.range.max);
  }
  function center2(element) {
    return element[axis] + element[dimension] / 2;
  }
  function lastIdx(arr) {
    return arr.length - 1;
  }
  function rangeDiff(range) {
    return range.max - range.min;
  }
  function centerElement(refCenter, element) {
    var delta2 = { y: 0 };
    delta2[axis] = refCenter - center2(element);
    if (delta2[axis]) {
      delta2[OFF_AXIS[axis]] = 0;
      modeling.moveElements([element], delta2, element.parent);
    }
  }
  var firstGroup = groups[0], lastGroupIdx = lastIdx(groups), lastGroup = groups[lastGroupIdx];
  var margin, spaceInBetween, groupsSize = 0;
  (0, import_min_dash113.forEach)(groups, function(group, idx) {
    var sortedElements, refElem, refCenter;
    if (group.elements.length < 2) {
      if (idx && idx !== groups.length - 1) {
        updateRange(group, group.elements[0]);
        groupsSize += rangeDiff(group.range);
      }
      return;
    }
    sortedElements = (0, import_min_dash113.sortBy)(group.elements, axis);
    refElem = sortedElements[0];
    if (idx === lastGroupIdx) {
      refElem = sortedElements[lastIdx(sortedElements)];
    }
    refCenter = center2(refElem);
    group.range = null;
    (0, import_min_dash113.forEach)(sortedElements, function(element) {
      centerElement(refCenter, element);
      if (group.range === null) {
        group.range = {
          min: element[axis],
          max: element[axis] + element[dimension]
        };
        return;
      }
      updateRange(group, element);
    });
    if (idx && idx !== groups.length - 1) {
      groupsSize += rangeDiff(group.range);
    }
  });
  spaceInBetween = Math.abs(lastGroup.range.min - firstGroup.range.max);
  margin = Math.round((spaceInBetween - groupsSize) / (groups.length - 1));
  if (margin < groups.length - 1) {
    return;
  }
  (0, import_min_dash113.forEach)(groups, function(group, groupIdx) {
    var delta2 = {}, prevGroup;
    if (group === firstGroup || group === lastGroup) {
      return;
    }
    prevGroup = groups[groupIdx - 1];
    group.range.max = 0;
    (0, import_min_dash113.forEach)(group.elements, function(element, idx) {
      delta2[OFF_AXIS[axis]] = 0;
      delta2[axis] = prevGroup.range.max - element[axis] + margin;
      if (group.range.min !== element[axis]) {
        delta2[axis] += element[axis] - group.range.min;
      }
      if (delta2[axis]) {
        modeling.moveElements([element], delta2, element.parent);
      }
      group.range.max = Math.max(element[axis] + element[dimension], idx ? group.range.max : 0);
    });
  });
};
DistributeElements2.prototype.postExecute = function(context) {
};

// node_modules/diagram-js/lib/features/modeling/cmd/LayoutConnectionHandler.js
var import_min_dash114 = __toESM(require_dist());
function LayoutConnectionHandler(layouter, canvas) {
  this._layouter = layouter;
  this._canvas = canvas;
}
LayoutConnectionHandler.$inject = ["layouter", "canvas"];
LayoutConnectionHandler.prototype.execute = function(context) {
  var connection = context.connection;
  var oldWaypoints = connection.waypoints;
  (0, import_min_dash114.assign)(context, {
    oldWaypoints
  });
  connection.waypoints = this._layouter.layoutConnection(connection, context.hints);
  return connection;
};
LayoutConnectionHandler.prototype.revert = function(context) {
  var connection = context.connection;
  connection.waypoints = context.oldWaypoints;
  return connection;
};

// node_modules/diagram-js/lib/features/modeling/cmd/MoveConnectionHandler.js
var import_min_dash115 = __toESM(require_dist());
function MoveConnectionHandler() {
}
MoveConnectionHandler.prototype.execute = function(context) {
  var connection = context.connection, delta2 = context.delta;
  var newParent = context.newParent || connection.parent, newParentIndex = context.newParentIndex, oldParent = connection.parent;
  context.oldParent = oldParent;
  context.oldParentIndex = remove3(oldParent.children, connection);
  add2(newParent.children, connection, newParentIndex);
  connection.parent = newParent;
  (0, import_min_dash115.forEach)(connection.waypoints, function(p6) {
    p6.x += delta2.x;
    p6.y += delta2.y;
    if (p6.original) {
      p6.original.x += delta2.x;
      p6.original.y += delta2.y;
    }
  });
  return connection;
};
MoveConnectionHandler.prototype.revert = function(context) {
  var connection = context.connection, newParent = connection.parent, oldParent = context.oldParent, oldParentIndex = context.oldParentIndex, delta2 = context.delta;
  remove3(newParent.children, connection);
  add2(oldParent.children, connection, oldParentIndex);
  connection.parent = oldParent;
  (0, import_min_dash115.forEach)(connection.waypoints, function(p6) {
    p6.x -= delta2.x;
    p6.y -= delta2.y;
    if (p6.original) {
      p6.original.x -= delta2.x;
      p6.original.y -= delta2.y;
    }
  });
  return connection;
};

// node_modules/diagram-js/lib/features/modeling/cmd/helper/MoveHelper.js
var import_min_dash117 = __toESM(require_dist());

// node_modules/diagram-js/lib/features/modeling/cmd/helper/MoveClosure.js
var import_min_dash116 = __toESM(require_dist());
function MoveClosure() {
  this.allShapes = {};
  this.allConnections = {};
  this.enclosedElements = {};
  this.enclosedConnections = {};
  this.topLevel = {};
}
MoveClosure.prototype.add = function(element, isTopLevel) {
  return this.addAll([element], isTopLevel);
};
MoveClosure.prototype.addAll = function(elements, isTopLevel) {
  var newClosure = getClosure(elements, !!isTopLevel, this);
  (0, import_min_dash116.assign)(this, newClosure);
  return this;
};

// node_modules/diagram-js/lib/features/modeling/cmd/helper/MoveHelper.js
function MoveHelper(modeling) {
  this._modeling = modeling;
}
MoveHelper.prototype.moveRecursive = function(elements, delta2, newParent) {
  if (!elements) {
    return [];
  } else {
    return this.moveClosure(this.getClosure(elements), delta2, newParent);
  }
};
MoveHelper.prototype.moveClosure = function(closure, delta2, newParent, newHost, primaryShape) {
  var modeling = this._modeling;
  var allShapes = closure.allShapes, allConnections = closure.allConnections, enclosedConnections = closure.enclosedConnections, topLevel = closure.topLevel, keepParent = false;
  if (primaryShape && primaryShape.parent === newParent) {
    keepParent = true;
  }
  (0, import_min_dash117.forEach)(allShapes, function(shape) {
    modeling.moveShape(shape, delta2, topLevel[shape.id] && !keepParent && newParent, {
      recurse: false,
      layout: false
    });
  });
  (0, import_min_dash117.forEach)(allConnections, function(c5) {
    var sourceMoved = !!allShapes[c5.source.id], targetMoved = !!allShapes[c5.target.id];
    if (enclosedConnections[c5.id] && sourceMoved && targetMoved) {
      modeling.moveConnection(c5, delta2, topLevel[c5.id] && !keepParent && newParent);
    } else {
      modeling.layoutConnection(c5, {
        connectionStart: sourceMoved && getMovedSourceAnchor(c5, c5.source, delta2),
        connectionEnd: targetMoved && getMovedTargetAnchor(c5, c5.target, delta2)
      });
    }
  });
};
MoveHelper.prototype.getClosure = function(elements) {
  return new MoveClosure().addAll(elements, true);
};

// node_modules/diagram-js/lib/features/modeling/cmd/MoveElementsHandler.js
function MoveElementsHandler(modeling) {
  this._helper = new MoveHelper(modeling);
}
MoveElementsHandler.$inject = ["modeling"];
MoveElementsHandler.prototype.preExecute = function(context) {
  context.closure = this._helper.getClosure(context.shapes);
};
MoveElementsHandler.prototype.postExecute = function(context) {
  var hints = context.hints, primaryShape;
  if (hints && hints.primaryShape) {
    primaryShape = hints.primaryShape;
    hints.oldParent = primaryShape.parent;
  }
  this._helper.moveClosure(context.closure, context.delta, context.newParent, context.newHost, primaryShape);
};

// node_modules/diagram-js/lib/features/modeling/cmd/MoveShapeHandler.js
var import_min_dash118 = __toESM(require_dist());
function MoveShapeHandler(modeling) {
  this._modeling = modeling;
  this._helper = new MoveHelper(modeling);
}
MoveShapeHandler.$inject = ["modeling"];
MoveShapeHandler.prototype.execute = function(context) {
  var shape = context.shape, delta2 = context.delta, newParent = context.newParent || shape.parent, newParentIndex = context.newParentIndex, oldParent = shape.parent;
  context.oldBounds = (0, import_min_dash118.pick)(shape, ["x", "y", "width", "height"]);
  context.oldParent = oldParent;
  context.oldParentIndex = remove3(oldParent.children, shape);
  add2(newParent.children, shape, newParentIndex);
  (0, import_min_dash118.assign)(shape, {
    parent: newParent,
    x: shape.x + delta2.x,
    y: shape.y + delta2.y
  });
  return shape;
};
MoveShapeHandler.prototype.postExecute = function(context) {
  var shape = context.shape, delta2 = context.delta, hints = context.hints;
  var modeling = this._modeling;
  if (hints.layout !== false) {
    (0, import_min_dash118.forEach)(shape.incoming, function(c5) {
      modeling.layoutConnection(c5, {
        connectionEnd: getMovedTargetAnchor(c5, shape, delta2)
      });
    });
    (0, import_min_dash118.forEach)(shape.outgoing, function(c5) {
      modeling.layoutConnection(c5, {
        connectionStart: getMovedSourceAnchor(c5, shape, delta2)
      });
    });
  }
  if (hints.recurse !== false) {
    this.moveChildren(context);
  }
};
MoveShapeHandler.prototype.revert = function(context) {
  var shape = context.shape, oldParent = context.oldParent, oldParentIndex = context.oldParentIndex, delta2 = context.delta;
  add2(oldParent.children, shape, oldParentIndex);
  (0, import_min_dash118.assign)(shape, {
    parent: oldParent,
    x: shape.x - delta2.x,
    y: shape.y - delta2.y
  });
  return shape;
};
MoveShapeHandler.prototype.moveChildren = function(context) {
  var delta2 = context.delta, shape = context.shape;
  this._helper.moveRecursive(shape.children, delta2, null);
};
MoveShapeHandler.prototype.getNewParent = function(context) {
  return context.newParent || context.shape.parent;
};

// node_modules/diagram-js/lib/features/modeling/cmd/ReconnectConnectionHandler.js
var import_min_dash119 = __toESM(require_dist());
function ReconnectConnectionHandler(modeling) {
  this._modeling = modeling;
}
ReconnectConnectionHandler.$inject = ["modeling"];
ReconnectConnectionHandler.prototype.execute = function(context) {
  var newSource = context.newSource, newTarget = context.newTarget, connection = context.connection, dockingOrPoints = context.dockingOrPoints;
  if (!newSource && !newTarget) {
    throw new Error("newSource or newTarget required");
  }
  if ((0, import_min_dash119.isArray)(dockingOrPoints)) {
    context.oldWaypoints = connection.waypoints;
    connection.waypoints = dockingOrPoints;
  }
  if (newSource) {
    context.oldSource = connection.source;
    connection.source = newSource;
  }
  if (newTarget) {
    context.oldTarget = connection.target;
    connection.target = newTarget;
  }
  return connection;
};
ReconnectConnectionHandler.prototype.postExecute = function(context) {
  var connection = context.connection, newSource = context.newSource, newTarget = context.newTarget, dockingOrPoints = context.dockingOrPoints, hints = context.hints || {};
  var layoutConnectionHints = {};
  if (hints.connectionStart) {
    layoutConnectionHints.connectionStart = hints.connectionStart;
  }
  if (hints.connectionEnd) {
    layoutConnectionHints.connectionEnd = hints.connectionEnd;
  }
  if (hints.layoutConnection === false) {
    return;
  }
  if (newSource && (!newTarget || hints.docking === "source")) {
    layoutConnectionHints.connectionStart = layoutConnectionHints.connectionStart || getDocking3((0, import_min_dash119.isArray)(dockingOrPoints) ? dockingOrPoints[0] : dockingOrPoints);
  }
  if (newTarget && (!newSource || hints.docking === "target")) {
    layoutConnectionHints.connectionEnd = layoutConnectionHints.connectionEnd || getDocking3((0, import_min_dash119.isArray)(dockingOrPoints) ? dockingOrPoints[dockingOrPoints.length - 1] : dockingOrPoints);
  }
  if (hints.newWaypoints) {
    layoutConnectionHints.waypoints = hints.newWaypoints;
  }
  this._modeling.layoutConnection(connection, layoutConnectionHints);
};
ReconnectConnectionHandler.prototype.revert = function(context) {
  var oldSource = context.oldSource, oldTarget = context.oldTarget, oldWaypoints = context.oldWaypoints, connection = context.connection;
  if (oldSource) {
    connection.source = oldSource;
  }
  if (oldTarget) {
    connection.target = oldTarget;
  }
  if (oldWaypoints) {
    connection.waypoints = oldWaypoints;
  }
  return connection;
};
function getDocking3(point) {
  return point.original || point;
}

// node_modules/diagram-js/lib/features/modeling/cmd/ReplaceShapeHandler.js
var import_min_dash120 = __toESM(require_dist());
function ReplaceShapeHandler(modeling, rules) {
  this._modeling = modeling;
  this._rules = rules;
}
ReplaceShapeHandler.$inject = ["modeling", "rules"];
ReplaceShapeHandler.prototype.preExecute = function(context) {
  var self2 = this, modeling = this._modeling, rules = this._rules;
  var oldShape = context.oldShape, newData = context.newData, hints = context.hints || {}, newShape;
  function canReconnect(source, target, connection) {
    return rules.allowed("connection.reconnect", {
      connection,
      source,
      target
    });
  }
  var position = {
    x: newData.x,
    y: newData.y
  };
  var oldBounds = {
    x: oldShape.x,
    y: oldShape.y,
    width: oldShape.width,
    height: oldShape.height
  };
  newShape = context.newShape = context.newShape || self2.createShape(newData, position, oldShape.parent, hints);
  if (oldShape.host) {
    modeling.updateAttachment(newShape, oldShape.host);
  }
  var children;
  if (hints.moveChildren !== false) {
    children = oldShape.children.slice();
    modeling.moveElements(children, { x: 0, y: 0 }, newShape, hints);
  }
  var incoming = oldShape.incoming.slice(), outgoing = oldShape.outgoing.slice();
  (0, import_min_dash120.forEach)(incoming, function(connection) {
    var source = connection.source, allowed = canReconnect(source, newShape, connection);
    if (allowed) {
      self2.reconnectEnd(connection, newShape, getResizedTargetAnchor(connection, newShape, oldBounds), hints);
    }
  });
  (0, import_min_dash120.forEach)(outgoing, function(connection) {
    var target = connection.target, allowed = canReconnect(newShape, target, connection);
    if (allowed) {
      self2.reconnectStart(connection, newShape, getResizedSourceAnchor(connection, newShape, oldBounds), hints);
    }
  });
};
ReplaceShapeHandler.prototype.postExecute = function(context) {
  var oldShape = context.oldShape;
  this._modeling.removeShape(oldShape);
};
ReplaceShapeHandler.prototype.execute = function(context) {
};
ReplaceShapeHandler.prototype.revert = function(context) {
};
ReplaceShapeHandler.prototype.createShape = function(shape, position, target, hints) {
  return this._modeling.createShape(shape, position, target, hints);
};
ReplaceShapeHandler.prototype.reconnectStart = function(connection, newSource, dockingPoint, hints) {
  this._modeling.reconnectStart(connection, newSource, dockingPoint, hints);
};
ReplaceShapeHandler.prototype.reconnectEnd = function(connection, newTarget, dockingPoint, hints) {
  this._modeling.reconnectEnd(connection, newTarget, dockingPoint, hints);
};

// node_modules/diagram-js/lib/features/modeling/cmd/ResizeShapeHandler.js
var import_min_dash121 = __toESM(require_dist());
function ResizeShapeHandler(modeling) {
  this._modeling = modeling;
}
ResizeShapeHandler.$inject = ["modeling"];
ResizeShapeHandler.prototype.execute = function(context) {
  var shape = context.shape, newBounds = context.newBounds, minBounds = context.minBounds;
  if (newBounds.x === void 0 || newBounds.y === void 0 || newBounds.width === void 0 || newBounds.height === void 0) {
    throw new Error("newBounds must have {x, y, width, height} properties");
  }
  if (minBounds && (newBounds.width < minBounds.width || newBounds.height < minBounds.height)) {
    throw new Error("width and height cannot be less than minimum height and width");
  } else if (!minBounds && newBounds.width < 10 || newBounds.height < 10) {
    throw new Error("width and height cannot be less than 10px");
  }
  context.oldBounds = {
    width: shape.width,
    height: shape.height,
    x: shape.x,
    y: shape.y
  };
  (0, import_min_dash121.assign)(shape, {
    width: newBounds.width,
    height: newBounds.height,
    x: newBounds.x,
    y: newBounds.y
  });
  return shape;
};
ResizeShapeHandler.prototype.postExecute = function(context) {
  var modeling = this._modeling;
  var shape = context.shape, oldBounds = context.oldBounds, hints = context.hints || {};
  if (hints.layout === false) {
    return;
  }
  (0, import_min_dash121.forEach)(shape.incoming, function(c5) {
    modeling.layoutConnection(c5, {
      connectionEnd: getResizedTargetAnchor(c5, shape, oldBounds)
    });
  });
  (0, import_min_dash121.forEach)(shape.outgoing, function(c5) {
    modeling.layoutConnection(c5, {
      connectionStart: getResizedSourceAnchor(c5, shape, oldBounds)
    });
  });
};
ResizeShapeHandler.prototype.revert = function(context) {
  var shape = context.shape, oldBounds = context.oldBounds;
  (0, import_min_dash121.assign)(shape, {
    width: oldBounds.width,
    height: oldBounds.height,
    x: oldBounds.x,
    y: oldBounds.y
  });
  return shape;
};

// node_modules/diagram-js/lib/features/modeling/cmd/SpaceToolHandler.js
var import_min_dash122 = __toESM(require_dist());
function SpaceToolHandler(modeling) {
  this._modeling = modeling;
}
SpaceToolHandler.$inject = ["modeling"];
SpaceToolHandler.prototype.preExecute = function(context) {
  var delta2 = context.delta, direction = context.direction, movingShapes = context.movingShapes, resizingShapes = context.resizingShapes, start = context.start, oldBounds = {};
  this.moveShapes(movingShapes, delta2);
  (0, import_min_dash122.forEach)(resizingShapes, function(shape) {
    oldBounds[shape.id] = getBounds(shape);
  });
  this.resizeShapes(resizingShapes, delta2, direction);
  this.updateConnectionWaypoints(getWaypointsUpdatingConnections(movingShapes, resizingShapes), delta2, direction, start, movingShapes, resizingShapes, oldBounds);
};
SpaceToolHandler.prototype.execute = function() {
};
SpaceToolHandler.prototype.revert = function() {
};
SpaceToolHandler.prototype.moveShapes = function(shapes, delta2) {
  var self2 = this;
  (0, import_min_dash122.forEach)(shapes, function(element) {
    self2._modeling.moveShape(element, delta2, null, {
      autoResize: false,
      layout: false,
      recurse: false
    });
  });
};
SpaceToolHandler.prototype.resizeShapes = function(shapes, delta2, direction) {
  var self2 = this;
  (0, import_min_dash122.forEach)(shapes, function(shape) {
    var newBounds = resizeBounds2(shape, direction, delta2);
    self2._modeling.resizeShape(shape, newBounds, null, {
      attachSupport: false,
      autoResize: false,
      layout: false
    });
  });
};
SpaceToolHandler.prototype.updateConnectionWaypoints = function(connections, delta2, direction, start, movingShapes, resizingShapes, oldBounds) {
  var self2 = this, affectedShapes = movingShapes.concat(resizingShapes);
  (0, import_min_dash122.forEach)(connections, function(connection) {
    var source = connection.source, target = connection.target, waypoints = copyWaypoints2(connection), axis = getAxisFromDirection(direction), layoutHints = {};
    if (includes8(affectedShapes, source) && includes8(affectedShapes, target)) {
      waypoints = (0, import_min_dash122.map)(waypoints, function(waypoint) {
        if (shouldMoveWaypoint(waypoint, start, direction)) {
          waypoint[axis] = waypoint[axis] + delta2[axis];
        }
        if (waypoint.original && shouldMoveWaypoint(waypoint.original, start, direction)) {
          waypoint.original[axis] = waypoint.original[axis] + delta2[axis];
        }
        return waypoint;
      });
      self2._modeling.updateWaypoints(connection, waypoints, {
        labelBehavior: false
      });
    } else if (includes8(affectedShapes, source) || includes8(affectedShapes, target)) {
      if (includes8(movingShapes, source)) {
        layoutHints.connectionStart = getMovedSourceAnchor(connection, source, delta2);
      } else if (includes8(movingShapes, target)) {
        layoutHints.connectionEnd = getMovedTargetAnchor(connection, target, delta2);
      } else if (includes8(resizingShapes, source)) {
        layoutHints.connectionStart = getResizedSourceAnchor(connection, source, oldBounds[source.id]);
      } else if (includes8(resizingShapes, target)) {
        layoutHints.connectionEnd = getResizedTargetAnchor(connection, target, oldBounds[target.id]);
      }
      self2._modeling.layoutConnection(connection, layoutHints);
    }
  });
};
function copyWaypoint2(waypoint) {
  return (0, import_min_dash122.assign)({}, waypoint);
}
function copyWaypoints2(connection) {
  return (0, import_min_dash122.map)(connection.waypoints, function(waypoint) {
    waypoint = copyWaypoint2(waypoint);
    if (waypoint.original) {
      waypoint.original = copyWaypoint2(waypoint.original);
    }
    return waypoint;
  });
}
function getAxisFromDirection(direction) {
  switch (direction) {
    case "n":
      return "y";
    case "w":
      return "x";
    case "s":
      return "y";
    case "e":
      return "x";
  }
}
function shouldMoveWaypoint(waypoint, start, direction) {
  var relevantAxis = getAxisFromDirection(direction);
  if (/e|s/.test(direction)) {
    return waypoint[relevantAxis] > start;
  } else if (/n|w/.test(direction)) {
    return waypoint[relevantAxis] < start;
  }
}
function includes8(array, item) {
  return array.indexOf(item) !== -1;
}
function getBounds(shape) {
  return {
    x: shape.x,
    y: shape.y,
    height: shape.height,
    width: shape.width
  };
}

// node_modules/diagram-js/lib/features/modeling/cmd/ToggleShapeCollapseHandler.js
var import_min_dash123 = __toESM(require_dist());
function ToggleShapeCollapseHandler(modeling) {
  this._modeling = modeling;
}
ToggleShapeCollapseHandler.$inject = ["modeling"];
ToggleShapeCollapseHandler.prototype.execute = function(context) {
  var shape = context.shape, children = shape.children;
  context.oldChildrenVisibility = getElementsVisibilityRecursive(children);
  shape.collapsed = !shape.collapsed;
  var result = setHiddenRecursive(children, shape.collapsed);
  return [shape].concat(result);
};
ToggleShapeCollapseHandler.prototype.revert = function(context) {
  var shape = context.shape, oldChildrenVisibility = context.oldChildrenVisibility;
  var children = shape.children;
  var result = restoreVisibilityRecursive(children, oldChildrenVisibility);
  shape.collapsed = !shape.collapsed;
  return [shape].concat(result);
};
function getElementsVisibilityRecursive(elements) {
  var result = {};
  (0, import_min_dash123.forEach)(elements, function(element) {
    result[element.id] = element.hidden;
    if (element.children) {
      result = (0, import_min_dash123.assign)({}, result, getElementsVisibilityRecursive(element.children));
    }
  });
  return result;
}
function setHiddenRecursive(elements, newHidden) {
  var result = [];
  (0, import_min_dash123.forEach)(elements, function(element) {
    element.hidden = newHidden;
    result = result.concat(element);
    if (element.children) {
      result = result.concat(setHiddenRecursive(element.children, element.collapsed || newHidden));
    }
  });
  return result;
}
function restoreVisibilityRecursive(elements, lastState) {
  var result = [];
  (0, import_min_dash123.forEach)(elements, function(element) {
    element.hidden = lastState[element.id];
    result = result.concat(element);
    if (element.children) {
      result = result.concat(restoreVisibilityRecursive(element.children, lastState));
    }
  });
  return result;
}

// node_modules/diagram-js/lib/features/modeling/cmd/UpdateAttachmentHandler.js
function UpdateAttachmentHandler(modeling) {
  this._modeling = modeling;
}
UpdateAttachmentHandler.$inject = ["modeling"];
UpdateAttachmentHandler.prototype.execute = function(context) {
  var shape = context.shape, newHost = context.newHost, oldHost = shape.host;
  context.oldHost = oldHost;
  context.attacherIdx = removeAttacher(oldHost, shape);
  addAttacher(newHost, shape);
  shape.host = newHost;
  return shape;
};
UpdateAttachmentHandler.prototype.revert = function(context) {
  var shape = context.shape, newHost = context.newHost, oldHost = context.oldHost, attacherIdx = context.attacherIdx;
  shape.host = oldHost;
  removeAttacher(newHost, shape);
  addAttacher(oldHost, shape, attacherIdx);
  return shape;
};
function removeAttacher(host, attacher) {
  return remove3(host && host.attachers, attacher);
}
function addAttacher(host, attacher, idx) {
  if (!host) {
    return;
  }
  var attachers = host.attachers;
  if (!attachers) {
    host.attachers = attachers = [];
  }
  add2(attachers, attacher, idx);
}

// node_modules/diagram-js/lib/features/modeling/cmd/UpdateWaypointsHandler.js
function UpdateWaypointsHandler() {
}
UpdateWaypointsHandler.prototype.execute = function(context) {
  var connection = context.connection, newWaypoints = context.newWaypoints;
  context.oldWaypoints = connection.waypoints;
  connection.waypoints = newWaypoints;
  return connection;
};
UpdateWaypointsHandler.prototype.revert = function(context) {
  var connection = context.connection, oldWaypoints = context.oldWaypoints;
  connection.waypoints = oldWaypoints;
  return connection;
};

// node_modules/diagram-js/lib/features/modeling/Modeling.js
function Modeling(eventBus, elementFactory, commandStack) {
  this._eventBus = eventBus;
  this._elementFactory = elementFactory;
  this._commandStack = commandStack;
  var self2 = this;
  eventBus.on("diagram.init", function() {
    self2.registerHandlers(commandStack);
  });
}
Modeling.$inject = ["eventBus", "elementFactory", "commandStack"];
Modeling.prototype.getHandlers = function() {
  return {
    "shape.append": AppendShapeHandler,
    "shape.create": CreateShapeHandler,
    "shape.delete": DeleteShapeHandler,
    "shape.move": MoveShapeHandler,
    "shape.resize": ResizeShapeHandler,
    "shape.replace": ReplaceShapeHandler,
    "shape.toggleCollapse": ToggleShapeCollapseHandler,
    "spaceTool": SpaceToolHandler,
    "label.create": CreateLabelHandler,
    "connection.create": CreateConnectionHandler,
    "connection.delete": DeleteConnectionHandler,
    "connection.move": MoveConnectionHandler,
    "connection.layout": LayoutConnectionHandler,
    "connection.updateWaypoints": UpdateWaypointsHandler,
    "connection.reconnect": ReconnectConnectionHandler,
    "elements.create": CreateElementsHandler,
    "elements.move": MoveElementsHandler,
    "elements.delete": DeleteElementsHandler,
    "elements.distribute": DistributeElements2,
    "elements.align": AlignElements2,
    "element.updateAttachment": UpdateAttachmentHandler
  };
};
Modeling.prototype.registerHandlers = function(commandStack) {
  (0, import_min_dash124.forEach)(this.getHandlers(), function(handler, id) {
    commandStack.registerHandler(id, handler);
  });
};
Modeling.prototype.moveShape = function(shape, delta2, newParent, newParentIndex, hints) {
  if (typeof newParentIndex === "object") {
    hints = newParentIndex;
    newParentIndex = null;
  }
  var context = {
    shape,
    delta: delta2,
    newParent,
    newParentIndex,
    hints: hints || {}
  };
  this._commandStack.execute("shape.move", context);
};
Modeling.prototype.updateAttachment = function(shape, newHost) {
  var context = {
    shape,
    newHost
  };
  this._commandStack.execute("element.updateAttachment", context);
};
Modeling.prototype.moveElements = function(shapes, delta2, target, hints) {
  hints = hints || {};
  var attach = hints.attach;
  var newParent = target, newHost;
  if (attach === true) {
    newHost = target;
    newParent = target.parent;
  } else if (attach === false) {
    newHost = null;
  }
  var context = {
    shapes,
    delta: delta2,
    newParent,
    newHost,
    hints
  };
  this._commandStack.execute("elements.move", context);
};
Modeling.prototype.moveConnection = function(connection, delta2, newParent, newParentIndex, hints) {
  if (typeof newParentIndex === "object") {
    hints = newParentIndex;
    newParentIndex = void 0;
  }
  var context = {
    connection,
    delta: delta2,
    newParent,
    newParentIndex,
    hints: hints || {}
  };
  this._commandStack.execute("connection.move", context);
};
Modeling.prototype.layoutConnection = function(connection, hints) {
  var context = {
    connection,
    hints: hints || {}
  };
  this._commandStack.execute("connection.layout", context);
};
Modeling.prototype.createConnection = function(source, target, parentIndex, connection, parent, hints) {
  if (typeof parentIndex === "object") {
    hints = parent;
    parent = connection;
    connection = parentIndex;
    parentIndex = void 0;
  }
  connection = this._create("connection", connection);
  var context = {
    source,
    target,
    parent,
    parentIndex,
    connection,
    hints
  };
  this._commandStack.execute("connection.create", context);
  return context.connection;
};
Modeling.prototype.createShape = function(shape, position, target, parentIndex, hints) {
  if (typeof parentIndex !== "number") {
    hints = parentIndex;
    parentIndex = void 0;
  }
  hints = hints || {};
  var attach = hints.attach, parent, host;
  shape = this._create("shape", shape);
  if (attach) {
    parent = target.parent;
    host = target;
  } else {
    parent = target;
  }
  var context = {
    position,
    shape,
    parent,
    parentIndex,
    host,
    hints
  };
  this._commandStack.execute("shape.create", context);
  return context.shape;
};
Modeling.prototype.createElements = function(elements, position, parent, parentIndex, hints) {
  if (!(0, import_min_dash124.isArray)(elements)) {
    elements = [elements];
  }
  if (typeof parentIndex !== "number") {
    hints = parentIndex;
    parentIndex = void 0;
  }
  hints = hints || {};
  var context = {
    position,
    elements,
    parent,
    parentIndex,
    hints
  };
  this._commandStack.execute("elements.create", context);
  return context.elements;
};
Modeling.prototype.createLabel = function(labelTarget, position, label, parent) {
  label = this._create("label", label);
  var context = {
    labelTarget,
    position,
    parent: parent || labelTarget.parent,
    shape: label
  };
  this._commandStack.execute("label.create", context);
  return context.shape;
};
Modeling.prototype.appendShape = function(source, shape, position, target, hints) {
  hints = hints || {};
  shape = this._create("shape", shape);
  var context = {
    source,
    position,
    target,
    shape,
    connection: hints.connection,
    connectionParent: hints.connectionParent,
    hints
  };
  this._commandStack.execute("shape.append", context);
  return context.shape;
};
Modeling.prototype.removeElements = function(elements) {
  var context = {
    elements
  };
  this._commandStack.execute("elements.delete", context);
};
Modeling.prototype.distributeElements = function(groups, axis, dimension) {
  var context = {
    groups,
    axis,
    dimension
  };
  this._commandStack.execute("elements.distribute", context);
};
Modeling.prototype.removeShape = function(shape, hints) {
  var context = {
    shape,
    hints: hints || {}
  };
  this._commandStack.execute("shape.delete", context);
};
Modeling.prototype.removeConnection = function(connection, hints) {
  var context = {
    connection,
    hints: hints || {}
  };
  this._commandStack.execute("connection.delete", context);
};
Modeling.prototype.replaceShape = function(oldShape, newShape, hints) {
  var context = {
    oldShape,
    newData: newShape,
    hints: hints || {}
  };
  this._commandStack.execute("shape.replace", context);
  return context.newShape;
};
Modeling.prototype.alignElements = function(elements, alignment) {
  var context = {
    elements,
    alignment
  };
  this._commandStack.execute("elements.align", context);
};
Modeling.prototype.resizeShape = function(shape, newBounds, minBounds, hints) {
  var context = {
    shape,
    newBounds,
    minBounds,
    hints
  };
  this._commandStack.execute("shape.resize", context);
};
Modeling.prototype.createSpace = function(movingShapes, resizingShapes, delta2, direction, start) {
  var context = {
    delta: delta2,
    direction,
    movingShapes,
    resizingShapes,
    start
  };
  this._commandStack.execute("spaceTool", context);
};
Modeling.prototype.updateWaypoints = function(connection, newWaypoints, hints) {
  var context = {
    connection,
    newWaypoints,
    hints: hints || {}
  };
  this._commandStack.execute("connection.updateWaypoints", context);
};
Modeling.prototype.reconnect = function(connection, source, target, dockingOrPoints, hints) {
  var context = {
    connection,
    newSource: source,
    newTarget: target,
    dockingOrPoints,
    hints: hints || {}
  };
  this._commandStack.execute("connection.reconnect", context);
};
Modeling.prototype.reconnectStart = function(connection, newSource, dockingOrPoints, hints) {
  if (!hints) {
    hints = {};
  }
  this.reconnect(connection, newSource, connection.target, dockingOrPoints, (0, import_min_dash124.assign)(hints, {
    docking: "source"
  }));
};
Modeling.prototype.reconnectEnd = function(connection, newTarget, dockingOrPoints, hints) {
  if (!hints) {
    hints = {};
  }
  this.reconnect(connection, connection.source, newTarget, dockingOrPoints, (0, import_min_dash124.assign)(hints, {
    docking: "target"
  }));
};
Modeling.prototype.connect = function(source, target, attrs, hints) {
  return this.createConnection(source, target, attrs || {}, source.parent, hints);
};
Modeling.prototype._create = function(type, attrs) {
  if (attrs instanceof Base) {
    return attrs;
  } else {
    return this._elementFactory.create(type, attrs);
  }
};
Modeling.prototype.toggleCollapse = function(shape, hints) {
  var context = {
    shape,
    hints: hints || {}
  };
  this._commandStack.execute("shape.toggleCollapse", context);
};

// node_modules/bpmn-js/lib/features/modeling/cmd/UpdateModdlePropertiesHandler.js
var import_min_dash125 = __toESM(require_dist());
function UpdateModdlePropertiesHandler(elementRegistry) {
  this._elementRegistry = elementRegistry;
}
UpdateModdlePropertiesHandler.$inject = ["elementRegistry"];
UpdateModdlePropertiesHandler.prototype.execute = function(context) {
  var element = context.element, moddleElement = context.moddleElement, properties = context.properties;
  if (!moddleElement) {
    throw new Error("<moddleElement> required");
  }
  var changed = context.changed || this.getVisualReferences(moddleElement).concat(element);
  var oldProperties = context.oldProperties || getModdleProperties(moddleElement, (0, import_min_dash125.keys)(properties));
  setModdleProperties(moddleElement, properties);
  context.oldProperties = oldProperties;
  context.changed = changed;
  return changed;
};
UpdateModdlePropertiesHandler.prototype.revert = function(context) {
  var oldProperties = context.oldProperties, moddleElement = context.moddleElement, changed = context.changed;
  setModdleProperties(moddleElement, oldProperties);
  return changed;
};
UpdateModdlePropertiesHandler.prototype.getVisualReferences = function(moddleElement) {
  var elementRegistry = this._elementRegistry;
  if (is(moddleElement, "bpmn:DataObject")) {
    return getAllDataObjectReferences(moddleElement, elementRegistry);
  }
  return [];
};
function getModdleProperties(moddleElement, propertyNames) {
  return (0, import_min_dash125.reduce)(propertyNames, function(result, key) {
    result[key] = moddleElement.get(key);
    return result;
  }, {});
}
function setModdleProperties(moddleElement, properties) {
  (0, import_min_dash125.forEach)(properties, function(value, key) {
    moddleElement.set(key, value);
  });
}
function getAllDataObjectReferences(dataObject, elementRegistry) {
  return elementRegistry.filter(function(element) {
    return is(element, "bpmn:DataObjectReference") && getBusinessObject(element).dataObjectRef === dataObject;
  });
}

// node_modules/bpmn-js/lib/features/modeling/cmd/UpdatePropertiesHandler.js
var import_min_dash126 = __toESM(require_dist());
var DEFAULT_FLOW = "default";
var ID = "id";
var DI = "di";
var NULL_DIMENSIONS = {
  width: 0,
  height: 0
};
function UpdatePropertiesHandler(elementRegistry, moddle, translate3, modeling, textRenderer) {
  this._elementRegistry = elementRegistry;
  this._moddle = moddle;
  this._translate = translate3;
  this._modeling = modeling;
  this._textRenderer = textRenderer;
}
UpdatePropertiesHandler.$inject = [
  "elementRegistry",
  "moddle",
  "translate",
  "modeling",
  "textRenderer"
];
UpdatePropertiesHandler.prototype.execute = function(context) {
  var element = context.element, changed = [element], translate3 = this._translate;
  if (!element) {
    throw new Error(translate3("element required"));
  }
  var elementRegistry = this._elementRegistry, ids3 = this._moddle.ids;
  var businessObject = element.businessObject, properties = unwrapBusinessObjects(context.properties), oldProperties = context.oldProperties || getProperties(element, properties);
  if (isIdChange(properties, businessObject)) {
    ids3.unclaim(businessObject[ID]);
    elementRegistry.updateId(element, properties[ID]);
    ids3.claim(properties[ID], businessObject);
  }
  if (DEFAULT_FLOW in properties) {
    if (properties[DEFAULT_FLOW]) {
      changed.push(elementRegistry.get(properties[DEFAULT_FLOW].id));
    }
    if (businessObject[DEFAULT_FLOW]) {
      changed.push(elementRegistry.get(businessObject[DEFAULT_FLOW].id));
    }
  }
  setProperties(element, properties);
  context.oldProperties = oldProperties;
  context.changed = changed;
  return changed;
};
UpdatePropertiesHandler.prototype.postExecute = function(context) {
  var element = context.element, label = element.label;
  var text = label && getBusinessObject(label).name;
  if (!text) {
    return;
  }
  var newLabelBounds = this._textRenderer.getExternalLabelBounds(label, text);
  this._modeling.resizeShape(label, newLabelBounds, NULL_DIMENSIONS);
};
UpdatePropertiesHandler.prototype.revert = function(context) {
  var element = context.element, properties = context.properties, oldProperties = context.oldProperties, businessObject = element.businessObject, elementRegistry = this._elementRegistry, ids3 = this._moddle.ids;
  setProperties(element, oldProperties);
  if (isIdChange(properties, businessObject)) {
    ids3.unclaim(properties[ID]);
    elementRegistry.updateId(element, oldProperties[ID]);
    ids3.claim(oldProperties[ID], businessObject);
  }
  return context.changed;
};
function isIdChange(properties, businessObject) {
  return ID in properties && properties[ID] !== businessObject[ID];
}
function getProperties(element, properties) {
  var propertyNames = (0, import_min_dash126.keys)(properties), businessObject = element.businessObject, di = getDi(element);
  return (0, import_min_dash126.reduce)(propertyNames, function(result, key) {
    if (key !== DI) {
      result[key] = businessObject.get(key);
    } else {
      result[key] = getDiProperties(di, (0, import_min_dash126.keys)(properties.di));
    }
    return result;
  }, {});
}
function getDiProperties(di, propertyNames) {
  return (0, import_min_dash126.reduce)(propertyNames, function(result, key) {
    result[key] = di && di.get(key);
    return result;
  }, {});
}
function setProperties(element, properties) {
  var businessObject = element.businessObject, di = getDi(element);
  (0, import_min_dash126.forEach)(properties, function(value, key) {
    if (key !== DI) {
      businessObject.set(key, value);
    } else {
      if (di) {
        setDiProperties(di, value);
      }
    }
  });
}
function setDiProperties(di, properties) {
  (0, import_min_dash126.forEach)(properties, function(value, key) {
    di.set(key, value);
  });
}
var referencePropertyNames = ["default"];
function unwrapBusinessObjects(properties) {
  var unwrappedProps = (0, import_min_dash126.assign)({}, properties);
  referencePropertyNames.forEach(function(name3) {
    if (name3 in properties) {
      unwrappedProps[name3] = getBusinessObject(unwrappedProps[name3]);
    }
  });
  return unwrappedProps;
}

// node_modules/bpmn-js/lib/features/modeling/cmd/UpdateCanvasRootHandler.js
function UpdateCanvasRootHandler(canvas, modeling) {
  this._canvas = canvas;
  this._modeling = modeling;
}
UpdateCanvasRootHandler.$inject = [
  "canvas",
  "modeling"
];
UpdateCanvasRootHandler.prototype.execute = function(context) {
  var canvas = this._canvas;
  var newRoot = context.newRoot, newRootBusinessObject = newRoot.businessObject, oldRoot = canvas.getRootElement(), oldRootBusinessObject = oldRoot.businessObject, bpmnDefinitions = oldRootBusinessObject.$parent, diPlane = getDi(oldRoot);
  canvas.setRootElement(newRoot);
  canvas.removeRootElement(oldRoot);
  add2(bpmnDefinitions.rootElements, newRootBusinessObject);
  newRootBusinessObject.$parent = bpmnDefinitions;
  remove3(bpmnDefinitions.rootElements, oldRootBusinessObject);
  oldRootBusinessObject.$parent = null;
  oldRoot.di = null;
  diPlane.bpmnElement = newRootBusinessObject;
  newRoot.di = diPlane;
  context.oldRoot = oldRoot;
};
UpdateCanvasRootHandler.prototype.revert = function(context) {
  var canvas = this._canvas;
  var newRoot = context.newRoot, newRootBusinessObject = newRoot.businessObject, oldRoot = context.oldRoot, oldRootBusinessObject = oldRoot.businessObject, bpmnDefinitions = newRootBusinessObject.$parent, diPlane = getDi(newRoot);
  canvas.setRootElement(oldRoot);
  canvas.removeRootElement(newRoot);
  remove3(bpmnDefinitions.rootElements, newRootBusinessObject);
  newRootBusinessObject.$parent = null;
  add2(bpmnDefinitions.rootElements, oldRootBusinessObject);
  oldRootBusinessObject.$parent = bpmnDefinitions;
  newRoot.di = null;
  diPlane.bpmnElement = oldRootBusinessObject;
  oldRoot.di = diPlane;
};

// node_modules/bpmn-js/lib/features/modeling/cmd/AddLaneHandler.js
var import_min_dash127 = __toESM(require_dist());
function AddLaneHandler(modeling, spaceTool) {
  this._modeling = modeling;
  this._spaceTool = spaceTool;
}
AddLaneHandler.$inject = [
  "modeling",
  "spaceTool"
];
AddLaneHandler.prototype.preExecute = function(context) {
  var spaceTool = this._spaceTool, modeling = this._modeling;
  var shape = context.shape, location = context.location;
  var lanesRoot = getLanesRoot(shape);
  var isRoot = lanesRoot === shape, laneParent = isRoot ? shape : shape.parent;
  var existingChildLanes = getChildLanes(laneParent);
  if (!existingChildLanes.length) {
    modeling.createShape({ type: "bpmn:Lane" }, {
      x: shape.x + LANE_INDENTATION,
      y: shape.y,
      width: shape.width - LANE_INDENTATION,
      height: shape.height
    }, laneParent);
  }
  var allAffected = [];
  eachElement(lanesRoot, function(element) {
    allAffected.push(element);
    if (element.label) {
      allAffected.push(element.label);
    }
    if (element === shape) {
      return [];
    }
    return (0, import_min_dash127.filter)(element.children, function(c5) {
      return c5 !== shape;
    });
  });
  var offset = location === "top" ? -120 : 120, lanePosition = location === "top" ? shape.y : shape.y + shape.height, spacePos = lanePosition + (location === "top" ? 10 : -10), direction = location === "top" ? "n" : "s";
  var adjustments = spaceTool.calculateAdjustments(allAffected, "y", offset, spacePos);
  spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: 0, y: offset }, direction, spacePos);
  context.newLane = modeling.createShape({ type: "bpmn:Lane" }, {
    x: shape.x + (isRoot ? LANE_INDENTATION : 0),
    y: lanePosition - (location === "top" ? 120 : 0),
    width: shape.width - (isRoot ? LANE_INDENTATION : 0),
    height: 120
  }, laneParent);
};

// node_modules/bpmn-js/lib/features/modeling/cmd/SplitLaneHandler.js
function SplitLaneHandler(modeling, translate3) {
  this._modeling = modeling;
  this._translate = translate3;
}
SplitLaneHandler.$inject = [
  "modeling",
  "translate"
];
SplitLaneHandler.prototype.preExecute = function(context) {
  var modeling = this._modeling, translate3 = this._translate;
  var shape = context.shape, newLanesCount = context.count;
  var childLanes = getChildLanes(shape), existingLanesCount = childLanes.length;
  if (existingLanesCount > newLanesCount) {
    throw new Error(translate3("more than {count} child lanes", { count: newLanesCount }));
  }
  var newLanesHeight = Math.round(shape.height / newLanesCount);
  var laneY, laneHeight, laneBounds, newLaneAttrs, idx;
  for (idx = 0; idx < newLanesCount; idx++) {
    laneY = shape.y + idx * newLanesHeight;
    if (idx === newLanesCount - 1) {
      laneHeight = shape.height - newLanesHeight * idx;
    } else {
      laneHeight = newLanesHeight;
    }
    laneBounds = {
      x: shape.x + LANE_INDENTATION,
      y: laneY,
      width: shape.width - LANE_INDENTATION,
      height: laneHeight
    };
    if (idx < existingLanesCount) {
      modeling.resizeShape(childLanes[idx], laneBounds);
    } else {
      newLaneAttrs = {
        type: "bpmn:Lane"
      };
      modeling.createShape(newLaneAttrs, laneBounds, shape);
    }
  }
};

// node_modules/bpmn-js/lib/features/modeling/cmd/ResizeLaneHandler.js
function ResizeLaneHandler(modeling, spaceTool) {
  this._modeling = modeling;
  this._spaceTool = spaceTool;
}
ResizeLaneHandler.$inject = [
  "modeling",
  "spaceTool"
];
ResizeLaneHandler.prototype.preExecute = function(context) {
  var shape = context.shape, newBounds = context.newBounds, balanced = context.balanced;
  if (balanced !== false) {
    this.resizeBalanced(shape, newBounds);
  } else {
    this.resizeSpace(shape, newBounds);
  }
};
ResizeLaneHandler.prototype.resizeBalanced = function(shape, newBounds) {
  var modeling = this._modeling;
  var resizeNeeded = computeLanesResize(shape, newBounds);
  modeling.resizeShape(shape, newBounds);
  resizeNeeded.forEach(function(r6) {
    modeling.resizeShape(r6.shape, r6.newBounds);
  });
};
ResizeLaneHandler.prototype.resizeSpace = function(shape, newBounds) {
  var spaceTool = this._spaceTool;
  var shapeTrbl = asTRBL(shape), newTrbl = asTRBL(newBounds);
  var trblDiff = substractTRBL(newTrbl, shapeTrbl);
  var lanesRoot = getLanesRoot(shape);
  var allAffected = [], allLanes = [];
  eachElement(lanesRoot, function(element) {
    allAffected.push(element);
    if (is(element, "bpmn:Lane") || is(element, "bpmn:Participant")) {
      allLanes.push(element);
    }
    return element.children;
  });
  var change, spacePos, direction, offset, adjustments;
  if (trblDiff.bottom || trblDiff.top) {
    change = trblDiff.bottom || trblDiff.top;
    spacePos = shape.y + (trblDiff.bottom ? shape.height : 0) + (trblDiff.bottom ? -10 : 10);
    direction = trblDiff.bottom ? "s" : "n";
    offset = trblDiff.top > 0 || trblDiff.bottom < 0 ? -change : change;
    adjustments = spaceTool.calculateAdjustments(allAffected, "y", offset, spacePos);
    spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: 0, y: change }, direction);
  }
  if (trblDiff.left || trblDiff.right) {
    change = trblDiff.right || trblDiff.left;
    spacePos = shape.x + (trblDiff.right ? shape.width : 0) + (trblDiff.right ? -10 : 100);
    direction = trblDiff.right ? "e" : "w";
    offset = trblDiff.left > 0 || trblDiff.right < 0 ? -change : change;
    adjustments = spaceTool.calculateAdjustments(allLanes, "x", offset, spacePos);
    spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: change, y: 0 }, direction);
  }
};

// node_modules/bpmn-js/lib/features/modeling/cmd/UpdateFlowNodeRefsHandler.js
var FLOW_NODE_REFS_ATTR = "flowNodeRef";
var LANES_ATTR = "lanes";
function UpdateFlowNodeRefsHandler(elementRegistry) {
  this._elementRegistry = elementRegistry;
}
UpdateFlowNodeRefsHandler.$inject = [
  "elementRegistry"
];
UpdateFlowNodeRefsHandler.prototype.computeUpdates = function(flowNodeShapes, laneShapes) {
  var handledNodes = [];
  var updates = [];
  var participantCache = {};
  var allFlowNodeShapes = [];
  function isInLaneShape(element, laneShape) {
    var laneTrbl = asTRBL(laneShape);
    var elementMid = {
      x: element.x + element.width / 2,
      y: element.y + element.height / 2
    };
    return elementMid.x > laneTrbl.left && elementMid.x < laneTrbl.right && elementMid.y > laneTrbl.top && elementMid.y < laneTrbl.bottom;
  }
  function addFlowNodeShape(flowNodeShape) {
    if (handledNodes.indexOf(flowNodeShape) === -1) {
      allFlowNodeShapes.push(flowNodeShape);
      handledNodes.push(flowNodeShape);
    }
  }
  function getAllLaneShapes(flowNodeShape) {
    var root = getLanesRoot(flowNodeShape);
    if (!participantCache[root.id]) {
      participantCache[root.id] = collectLanes(root);
    }
    return participantCache[root.id];
  }
  function getNewLanes(flowNodeShape) {
    if (!flowNodeShape.parent) {
      return [];
    }
    var allLaneShapes = getAllLaneShapes(flowNodeShape);
    return allLaneShapes.filter(function(l6) {
      return isInLaneShape(flowNodeShape, l6);
    }).map(function(shape) {
      return shape.businessObject;
    });
  }
  laneShapes.forEach(function(laneShape) {
    var root = getLanesRoot(laneShape);
    if (!root || handledNodes.indexOf(root) !== -1) {
      return;
    }
    var children = root.children.filter(function(c5) {
      return is(c5, "bpmn:FlowNode");
    });
    children.forEach(addFlowNodeShape);
    handledNodes.push(root);
  });
  flowNodeShapes.forEach(addFlowNodeShape);
  allFlowNodeShapes.forEach(function(flowNodeShape) {
    var flowNode = flowNodeShape.businessObject;
    var lanes = flowNode.get(LANES_ATTR), remove5 = lanes.slice(), add3 = getNewLanes(flowNodeShape);
    updates.push({ flowNode, remove: remove5, add: add3 });
  });
  laneShapes.forEach(function(laneShape) {
    var lane = laneShape.businessObject;
    if (!laneShape.parent) {
      lane.get(FLOW_NODE_REFS_ATTR).forEach(function(flowNode) {
        updates.push({ flowNode, remove: [lane], add: [] });
      });
    }
  });
  return updates;
};
UpdateFlowNodeRefsHandler.prototype.execute = function(context) {
  var updates = context.updates;
  if (!updates) {
    updates = context.updates = this.computeUpdates(context.flowNodeShapes, context.laneShapes);
  }
  updates.forEach(function(update) {
    var flowNode = update.flowNode, lanes = flowNode.get(LANES_ATTR);
    update.remove.forEach(function(oldLane) {
      remove3(lanes, oldLane);
      remove3(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);
    });
    update.add.forEach(function(newLane) {
      add2(lanes, newLane);
      add2(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);
    });
  });
};
UpdateFlowNodeRefsHandler.prototype.revert = function(context) {
  var updates = context.updates;
  updates.forEach(function(update) {
    var flowNode = update.flowNode, lanes = flowNode.get(LANES_ATTR);
    update.add.forEach(function(newLane) {
      remove3(lanes, newLane);
      remove3(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);
    });
    update.remove.forEach(function(oldLane) {
      add2(lanes, oldLane);
      add2(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);
    });
  });
};

// node_modules/bpmn-js/lib/features/modeling/cmd/IdClaimHandler.js
function IdClaimHandler(moddle) {
  this._moddle = moddle;
}
IdClaimHandler.$inject = ["moddle"];
IdClaimHandler.prototype.execute = function(context) {
  var ids3 = this._moddle.ids, id = context.id, element = context.element, claiming = context.claiming;
  if (claiming) {
    ids3.claim(id, element);
  } else {
    ids3.unclaim(id);
  }
};
IdClaimHandler.prototype.revert = function(context) {
  var ids3 = this._moddle.ids, id = context.id, element = context.element, claiming = context.claiming;
  if (claiming) {
    ids3.unclaim(id);
  } else {
    ids3.claim(id, element);
  }
};

// node_modules/bpmn-js/lib/features/modeling/cmd/SetColorHandler.js
var import_min_dash128 = __toESM(require_dist());
var DEFAULT_COLORS = {
  fill: void 0,
  stroke: void 0
};
function SetColorHandler(commandStack) {
  this._commandStack = commandStack;
  this._normalizeColor = function(color) {
    if (!color) {
      return void 0;
    }
    if ((0, import_min_dash128.isString)(color)) {
      var hexColor = colorToHex(color);
      if (hexColor) {
        return hexColor;
      }
    }
    throw new Error("invalid color value: " + color);
  };
}
SetColorHandler.$inject = [
  "commandStack"
];
SetColorHandler.prototype.postExecute = function(context) {
  var elements = context.elements, colors = context.colors || DEFAULT_COLORS;
  var self2 = this;
  var di = {};
  if ("fill" in colors) {
    (0, import_min_dash128.assign)(di, {
      "background-color": this._normalizeColor(colors.fill)
    });
  }
  if ("stroke" in colors) {
    (0, import_min_dash128.assign)(di, {
      "border-color": this._normalizeColor(colors.stroke)
    });
  }
  (0, import_min_dash128.forEach)(elements, function(element) {
    var assignedDi = isConnection13(element) ? (0, import_min_dash128.pick)(di, ["border-color"]) : di, elementDi = getDi(element);
    ensureLegacySupport(assignedDi);
    if (isLabel(element)) {
      self2._commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: elementDi.label,
        properties: {
          color: di["border-color"]
        }
      });
    } else {
      if (!isAny(elementDi, ["bpmndi:BPMNEdge", "bpmndi:BPMNShape"])) {
        return;
      }
      self2._commandStack.execute("element.updateProperties", {
        element,
        properties: {
          di: assignedDi
        }
      });
    }
  });
};
function colorToHex(color) {
  var context = document.createElement("canvas").getContext("2d");
  context.fillStyle = "transparent";
  context.fillStyle = color;
  return /^#[0-9a-fA-F]{6}$/.test(context.fillStyle) ? context.fillStyle : null;
}
function isConnection13(element) {
  return !!element.waypoints;
}
function ensureLegacySupport(di) {
  if ("border-color" in di) {
    di.stroke = di["border-color"];
  }
  if ("background-color" in di) {
    di.fill = di["background-color"];
  }
}

// node_modules/bpmn-js/lib/features/label-editing/cmd/UpdateLabelHandler.js
var NULL_DIMENSIONS2 = {
  width: 0,
  height: 0
};
function UpdateLabelHandler(modeling, textRenderer, bpmnFactory) {
  function ensureInternalLabelDi(element, text) {
    if (isLabelExternal(element)) {
      return;
    }
    var di = getDi(element);
    if (text && !di.label) {
      di.label = bpmnFactory.create("bpmndi:BPMNLabel");
    }
    if (!text && di.label) {
      delete di.label;
    }
  }
  function setText(element, text) {
    var label = element.label || element;
    var labelTarget = element.labelTarget || element;
    setLabel(label, text, labelTarget !== label);
    ensureInternalLabelDi(element, text);
    return [label, labelTarget];
  }
  function preExecute(ctx) {
    var element = ctx.element, businessObject = element.businessObject, newLabel = ctx.newLabel;
    if (!isLabel(element) && isLabelExternal(element) && !hasExternalLabel(element) && !isEmptyText2(newLabel)) {
      var paddingTop = 7;
      var labelCenter = getExternalLabelMid(element);
      labelCenter = {
        x: labelCenter.x,
        y: labelCenter.y + paddingTop
      };
      modeling.createLabel(element, labelCenter, {
        id: businessObject.id + "_label",
        businessObject,
        di: element.di
      });
    }
  }
  function execute(ctx) {
    ctx.oldLabel = getLabel(ctx.element);
    return setText(ctx.element, ctx.newLabel);
  }
  function revert(ctx) {
    return setText(ctx.element, ctx.oldLabel);
  }
  function postExecute(ctx) {
    var element = ctx.element, label = element.label || element, newLabel = ctx.newLabel, newBounds = ctx.newBounds, hints = ctx.hints || {};
    if (!isLabel(label) && !is(label, "bpmn:TextAnnotation")) {
      return;
    }
    if (isLabel(label) && isEmptyText2(newLabel)) {
      if (hints.removeShape !== false) {
        modeling.removeShape(label, { unsetLabel: false });
      }
      return;
    }
    var text = getLabel(label);
    if (typeof newBounds === "undefined") {
      newBounds = textRenderer.getExternalLabelBounds(label, text);
    }
    if (newBounds) {
      modeling.resizeShape(label, newBounds, NULL_DIMENSIONS2);
    }
  }
  this.preExecute = preExecute;
  this.execute = execute;
  this.revert = revert;
  this.postExecute = postExecute;
}
UpdateLabelHandler.$inject = [
  "modeling",
  "textRenderer",
  "bpmnFactory"
];
function isEmptyText2(label) {
  return !label || !label.trim();
}

// node_modules/bpmn-js/lib/features/modeling/Modeling.js
function Modeling2(eventBus, elementFactory, commandStack, bpmnRules) {
  Modeling.call(this, eventBus, elementFactory, commandStack);
  this._bpmnRules = bpmnRules;
}
e(Modeling2, Modeling);
Modeling2.$inject = [
  "eventBus",
  "elementFactory",
  "commandStack",
  "bpmnRules"
];
Modeling2.prototype.getHandlers = function() {
  var handlers = Modeling.prototype.getHandlers.call(this);
  handlers["element.updateModdleProperties"] = UpdateModdlePropertiesHandler;
  handlers["element.updateProperties"] = UpdatePropertiesHandler;
  handlers["canvas.updateRoot"] = UpdateCanvasRootHandler;
  handlers["lane.add"] = AddLaneHandler;
  handlers["lane.resize"] = ResizeLaneHandler;
  handlers["lane.split"] = SplitLaneHandler;
  handlers["lane.updateRefs"] = UpdateFlowNodeRefsHandler;
  handlers["id.updateClaim"] = IdClaimHandler;
  handlers["element.setColor"] = SetColorHandler;
  handlers["element.updateLabel"] = UpdateLabelHandler;
  return handlers;
};
Modeling2.prototype.updateLabel = function(element, newLabel, newBounds, hints) {
  this._commandStack.execute("element.updateLabel", {
    element,
    newLabel,
    newBounds,
    hints: hints || {}
  });
};
Modeling2.prototype.connect = function(source, target, attrs, hints) {
  var bpmnRules = this._bpmnRules;
  if (!attrs) {
    attrs = bpmnRules.canConnect(source, target);
  }
  if (!attrs) {
    return;
  }
  return this.createConnection(source, target, attrs, source.parent, hints);
};
Modeling2.prototype.updateModdleProperties = function(element, moddleElement, properties) {
  this._commandStack.execute("element.updateModdleProperties", {
    element,
    moddleElement,
    properties
  });
};
Modeling2.prototype.updateProperties = function(element, properties) {
  this._commandStack.execute("element.updateProperties", {
    element,
    properties
  });
};
Modeling2.prototype.resizeLane = function(laneShape, newBounds, balanced) {
  this._commandStack.execute("lane.resize", {
    shape: laneShape,
    newBounds,
    balanced
  });
};
Modeling2.prototype.addLane = function(targetLaneShape, location) {
  var context = {
    shape: targetLaneShape,
    location
  };
  this._commandStack.execute("lane.add", context);
  return context.newLane;
};
Modeling2.prototype.splitLane = function(targetLane, count) {
  this._commandStack.execute("lane.split", {
    shape: targetLane,
    count
  });
};
Modeling2.prototype.makeCollaboration = function() {
  var collaborationElement = this._create("root", {
    type: "bpmn:Collaboration"
  });
  var context = {
    newRoot: collaborationElement
  };
  this._commandStack.execute("canvas.updateRoot", context);
  return collaborationElement;
};
Modeling2.prototype.updateLaneRefs = function(flowNodeShapes, laneShapes) {
  this._commandStack.execute("lane.updateRefs", {
    flowNodeShapes,
    laneShapes
  });
};
Modeling2.prototype.makeProcess = function() {
  var processElement = this._create("root", {
    type: "bpmn:Process"
  });
  var context = {
    newRoot: processElement
  };
  this._commandStack.execute("canvas.updateRoot", context);
};
Modeling2.prototype.claimId = function(id, moddleElement) {
  this._commandStack.execute("id.updateClaim", {
    id,
    element: moddleElement,
    claiming: true
  });
};
Modeling2.prototype.unclaimId = function(id, moddleElement) {
  this._commandStack.execute("id.updateClaim", {
    id,
    element: moddleElement
  });
};
Modeling2.prototype.setColor = function(elements, colors) {
  if (!elements.length) {
    elements = [elements];
  }
  this._commandStack.execute("element.setColor", {
    elements,
    colors
  });
};

// node_modules/bpmn-js/lib/features/modeling/BpmnLayouter.js
var import_min_dash130 = __toESM(require_dist());

// node_modules/diagram-js/lib/layout/BaseLayouter.js
function BaseLayouter() {
}
BaseLayouter.prototype.layoutConnection = function(connection, hints) {
  hints = hints || {};
  return [
    hints.connectionStart || getMid(hints.source || connection.source),
    hints.connectionEnd || getMid(hints.target || connection.target)
  ];
};

// node_modules/diagram-js/lib/layout/ManhattanLayout.js
var import_min_dash129 = __toESM(require_dist());
var MIN_SEGMENT_LENGTH = 20;
var POINT_ORIENTATION_PADDING = 5;
var round11 = Math.round;
var INTERSECTION_THRESHOLD2 = 20;
var ORIENTATION_THRESHOLD = {
  "h:h": 20,
  "v:v": 20,
  "h:v": -10,
  "v:h": -10
};
function needsTurn(orientation, startDirection) {
  return !{
    t: /top/,
    r: /right/,
    b: /bottom/,
    l: /left/,
    h: /./,
    v: /./
  }[startDirection].test(orientation);
}
function canLayoutStraight(direction, targetOrientation) {
  return {
    t: /top/,
    r: /right/,
    b: /bottom/,
    l: /left/,
    h: /left|right/,
    v: /top|bottom/
  }[direction].test(targetOrientation);
}
function getSegmentBendpoints(a6, b5, directions2) {
  var orientation = getOrientation(b5, a6, POINT_ORIENTATION_PADDING);
  var startDirection = directions2.split(":")[0];
  var xmid = round11((b5.x - a6.x) / 2 + a6.x), ymid = round11((b5.y - a6.y) / 2 + a6.y);
  var segmentEnd, segmentDirections;
  var layoutStraight = canLayoutStraight(startDirection, orientation), layoutHorizontal = /h|r|l/.test(startDirection), layoutTurn = false;
  var turnNextDirections = false;
  if (layoutStraight) {
    segmentEnd = layoutHorizontal ? { x: xmid, y: a6.y } : { x: a6.x, y: ymid };
    segmentDirections = layoutHorizontal ? "h:h" : "v:v";
  } else {
    layoutTurn = needsTurn(orientation, startDirection);
    segmentDirections = layoutHorizontal ? "h:v" : "v:h";
    if (layoutTurn) {
      if (layoutHorizontal) {
        turnNextDirections = ymid === a6.y;
        segmentEnd = {
          x: a6.x + MIN_SEGMENT_LENGTH * (/l/.test(startDirection) ? -1 : 1),
          y: turnNextDirections ? ymid + MIN_SEGMENT_LENGTH : ymid
        };
      } else {
        turnNextDirections = xmid === a6.x;
        segmentEnd = {
          x: turnNextDirections ? xmid + MIN_SEGMENT_LENGTH : xmid,
          y: a6.y + MIN_SEGMENT_LENGTH * (/t/.test(startDirection) ? -1 : 1)
        };
      }
    } else {
      segmentEnd = {
        x: xmid,
        y: ymid
      };
    }
  }
  return {
    waypoints: getBendpoints(a6, segmentEnd, segmentDirections).concat(segmentEnd),
    directions: segmentDirections,
    turnNextDirections
  };
}
function getStartSegment(a6, b5, directions2) {
  return getSegmentBendpoints(a6, b5, directions2);
}
function getEndSegment(a6, b5, directions2) {
  var invertedSegment = getSegmentBendpoints(b5, a6, invertDirections(directions2));
  return {
    waypoints: invertedSegment.waypoints.slice().reverse(),
    directions: invertDirections(invertedSegment.directions),
    turnNextDirections: invertedSegment.turnNextDirections
  };
}
function getMidSegment(startSegment, endSegment) {
  var startDirection = startSegment.directions.split(":")[1], endDirection = endSegment.directions.split(":")[0];
  if (startSegment.turnNextDirections) {
    startDirection = startDirection == "h" ? "v" : "h";
  }
  if (endSegment.turnNextDirections) {
    endDirection = endDirection == "h" ? "v" : "h";
  }
  var directions2 = startDirection + ":" + endDirection;
  var bendpoints = getBendpoints(startSegment.waypoints[startSegment.waypoints.length - 1], endSegment.waypoints[0], directions2);
  return {
    waypoints: bendpoints,
    directions: directions2
  };
}
function invertDirections(directions2) {
  return directions2.split(":").reverse().join(":");
}
function getSimpleBendpoints(a6, b5, directions2) {
  var xmid = round11((b5.x - a6.x) / 2 + a6.x), ymid = round11((b5.y - a6.y) / 2 + a6.y);
  if (directions2 === "h:v") {
    return [{ x: b5.x, y: a6.y }];
  }
  if (directions2 === "v:h") {
    return [{ x: a6.x, y: b5.y }];
  }
  if (directions2 === "h:h") {
    return [
      { x: xmid, y: a6.y },
      { x: xmid, y: b5.y }
    ];
  }
  if (directions2 === "v:v") {
    return [
      { x: a6.x, y: ymid },
      { x: b5.x, y: ymid }
    ];
  }
  throw new Error("invalid directions: can only handle varians of [hv]:[hv]");
}
function getBendpoints(a6, b5, directions2) {
  directions2 = directions2 || "h:h";
  if (!isValidDirections(directions2)) {
    throw new Error("unknown directions: <" + directions2 + ">: must be specified as <start>:<end> with start/end in { h,v,t,r,b,l }");
  }
  if (isExplicitDirections(directions2)) {
    var startSegment = getStartSegment(a6, b5, directions2), endSegment = getEndSegment(a6, b5, directions2), midSegment = getMidSegment(startSegment, endSegment);
    return [].concat(startSegment.waypoints, midSegment.waypoints, endSegment.waypoints);
  }
  return getSimpleBendpoints(a6, b5, directions2);
}
function connectPoints(a6, b5, directions2) {
  var points = getBendpoints(a6, b5, directions2);
  points.unshift(a6);
  points.push(b5);
  return withoutRedundantPoints(points);
}
function connectRectangles(source, target, start, end, hints) {
  var preferredLayouts = hints && hints.preferredLayouts || [];
  var preferredLayout = (0, import_min_dash129.without)(preferredLayouts, "straight")[0] || "h:h";
  var threshold = ORIENTATION_THRESHOLD[preferredLayout] || 0;
  var orientation = getOrientation(source, target, threshold);
  var directions2 = getDirections(orientation, preferredLayout);
  start = start || getMid(source);
  end = end || getMid(target);
  var directionSplit = directions2.split(":");
  var startDocking = getDockingPoint(start, source, directionSplit[0], invertOrientation(orientation)), endDocking = getDockingPoint(end, target, directionSplit[1], orientation);
  return connectPoints(startDocking, endDocking, directions2);
}
function repairConnection(source, target, start, end, waypoints, hints) {
  if ((0, import_min_dash129.isArray)(start)) {
    waypoints = start;
    hints = end;
    start = getMid(source);
    end = getMid(target);
  }
  hints = (0, import_min_dash129.assign)({ preferredLayouts: [] }, hints);
  waypoints = waypoints || [];
  var preferredLayouts = hints.preferredLayouts, preferStraight = preferredLayouts.indexOf("straight") !== -1, repairedWaypoints;
  repairedWaypoints = preferStraight && tryLayoutStraight(source, target, start, end, hints);
  if (repairedWaypoints) {
    return repairedWaypoints;
  }
  repairedWaypoints = hints.connectionEnd && tryRepairConnectionEnd(target, source, end, waypoints);
  if (repairedWaypoints) {
    return repairedWaypoints;
  }
  repairedWaypoints = hints.connectionStart && tryRepairConnectionStart(source, target, start, waypoints);
  if (repairedWaypoints) {
    return repairedWaypoints;
  }
  if (!hints.connectionStart && !hints.connectionEnd && waypoints && waypoints.length) {
    return waypoints;
  }
  return connectRectangles(source, target, start, end, hints);
}
function inRange(a6, start, end) {
  return a6 >= start && a6 <= end;
}
function isInRange(axis, a6, b5) {
  var size2 = {
    x: "width",
    y: "height"
  };
  return inRange(a6[axis], b5[axis], b5[axis] + b5[size2[axis]]);
}
function tryLayoutStraight(source, target, start, end, hints) {
  var axis = {}, primaryAxis, orientation;
  orientation = getOrientation(source, target);
  if (!/^(top|bottom|left|right)$/.test(orientation)) {
    return null;
  }
  if (/top|bottom/.test(orientation)) {
    primaryAxis = "x";
  }
  if (/left|right/.test(orientation)) {
    primaryAxis = "y";
  }
  if (hints.preserveDocking === "target") {
    if (!isInRange(primaryAxis, end, source)) {
      return null;
    }
    axis[primaryAxis] = end[primaryAxis];
    return [
      {
        x: axis.x !== void 0 ? axis.x : start.x,
        y: axis.y !== void 0 ? axis.y : start.y,
        original: {
          x: axis.x !== void 0 ? axis.x : start.x,
          y: axis.y !== void 0 ? axis.y : start.y
        }
      },
      {
        x: end.x,
        y: end.y
      }
    ];
  } else {
    if (!isInRange(primaryAxis, start, target)) {
      return null;
    }
    axis[primaryAxis] = start[primaryAxis];
    return [
      {
        x: start.x,
        y: start.y
      },
      {
        x: axis.x !== void 0 ? axis.x : end.x,
        y: axis.y !== void 0 ? axis.y : end.y,
        original: {
          x: axis.x !== void 0 ? axis.x : end.x,
          y: axis.y !== void 0 ? axis.y : end.y
        }
      }
    ];
  }
}
function tryRepairConnectionStart(moved, other, newDocking, points) {
  return _tryRepairConnectionSide(moved, other, newDocking, points);
}
function tryRepairConnectionEnd(moved, other, newDocking, points) {
  var waypoints = points.slice().reverse();
  waypoints = _tryRepairConnectionSide(moved, other, newDocking, waypoints);
  return waypoints ? waypoints.reverse() : null;
}
function _tryRepairConnectionSide(moved, other, newDocking, points) {
  function needsRelayout(points2) {
    if (points2.length < 3) {
      return true;
    }
    if (points2.length > 4) {
      return false;
    }
    return !!(0, import_min_dash129.find)(points2, function(p6, idx) {
      var q3 = points2[idx - 1];
      return q3 && pointDistance(p6, q3) < 3;
    });
  }
  function repairBendpoint(candidate, oldPeer, newPeer) {
    var alignment = pointsAligned(oldPeer, candidate);
    switch (alignment) {
      case "v":
        return { x: newPeer.x, y: candidate.y };
      case "h":
        return { x: candidate.x, y: newPeer.y };
    }
    return { x: candidate.x, y: candidate.y };
  }
  function removeOverlapping(points2, a6, b5) {
    var i6;
    for (i6 = points2.length - 2; i6 !== 0; i6--) {
      if (pointInRect(points2[i6], a6, INTERSECTION_THRESHOLD2) || pointInRect(points2[i6], b5, INTERSECTION_THRESHOLD2)) {
        return points2.slice(i6);
      }
    }
    return points2;
  }
  if (needsRelayout(points)) {
    return null;
  }
  var oldDocking = points[0], newPoints = points.slice(), slicedPoints;
  newPoints[0] = newDocking;
  newPoints[1] = repairBendpoint(newPoints[1], oldDocking, newDocking);
  slicedPoints = removeOverlapping(newPoints, moved, other);
  if (slicedPoints !== newPoints) {
    newPoints = _tryRepairConnectionSide(moved, other, newDocking, slicedPoints);
  }
  if (newPoints && pointsAligned(newPoints)) {
    return null;
  }
  return newPoints;
}
function getDirections(orientation, defaultLayout) {
  if (isExplicitDirections(defaultLayout)) {
    return defaultLayout;
  }
  switch (orientation) {
    case "intersect":
      return "t:t";
    case "top":
    case "bottom":
      return "v:v";
    case "left":
    case "right":
      return "h:h";
    default:
      return defaultLayout;
  }
}
function isValidDirections(directions2) {
  return directions2 && /^h|v|t|r|b|l:h|v|t|r|b|l$/.test(directions2);
}
function isExplicitDirections(directions2) {
  return directions2 && /t|r|b|l/.test(directions2);
}
function invertOrientation(orientation) {
  return {
    "top": "bottom",
    "bottom": "top",
    "left": "right",
    "right": "left",
    "top-left": "bottom-right",
    "bottom-right": "top-left",
    "top-right": "bottom-left",
    "bottom-left": "top-right"
  }[orientation];
}
function getDockingPoint(point, rectangle, dockingDirection, targetOrientation) {
  if (dockingDirection === "h") {
    dockingDirection = /left/.test(targetOrientation) ? "l" : "r";
  }
  if (dockingDirection === "v") {
    dockingDirection = /top/.test(targetOrientation) ? "t" : "b";
  }
  if (dockingDirection === "t") {
    return { original: point, x: point.x, y: rectangle.y };
  }
  if (dockingDirection === "r") {
    return { original: point, x: rectangle.x + rectangle.width, y: point.y };
  }
  if (dockingDirection === "b") {
    return { original: point, x: point.x, y: rectangle.y + rectangle.height };
  }
  if (dockingDirection === "l") {
    return { original: point, x: rectangle.x, y: point.y };
  }
  throw new Error("unexpected dockingDirection: <" + dockingDirection + ">");
}
function withoutRedundantPoints(waypoints) {
  return waypoints.reduce(function(points, p6, idx) {
    var previous = points[points.length - 1], next = waypoints[idx + 1];
    if (!pointsOnLine(previous, next, p6, 0)) {
      points.push(p6);
    }
    return points;
  }, []);
}

// node_modules/bpmn-js/lib/features/modeling/BpmnLayouter.js
var ATTACH_ORIENTATION_PADDING = -10;
var BOUNDARY_TO_HOST_THRESHOLD = 40;
var oppositeOrientationMapping = {
  "top": "bottom",
  "top-right": "bottom-left",
  "top-left": "bottom-right",
  "right": "left",
  "bottom": "top",
  "bottom-right": "top-left",
  "bottom-left": "top-right",
  "left": "right"
};
var orientationDirectionMapping = {
  top: "t",
  right: "r",
  bottom: "b",
  left: "l"
};
function BpmnLayouter() {
}
e(BpmnLayouter, BaseLayouter);
BpmnLayouter.prototype.layoutConnection = function(connection, hints) {
  if (!hints) {
    hints = {};
  }
  var source = hints.source || connection.source, target = hints.target || connection.target, waypoints = hints.waypoints || connection.waypoints, connectionStart = hints.connectionStart, connectionEnd = hints.connectionEnd;
  var manhattanOptions, updatedWaypoints;
  if (!connectionStart) {
    connectionStart = getConnectionDocking(waypoints && waypoints[0], source);
  }
  if (!connectionEnd) {
    connectionEnd = getConnectionDocking(waypoints && waypoints[waypoints.length - 1], target);
  }
  if (is(connection, "bpmn:Association") || is(connection, "bpmn:DataAssociation")) {
    if (waypoints && !isCompensationAssociation(source, target)) {
      return [].concat([connectionStart], waypoints.slice(1, -1), [connectionEnd]);
    }
  }
  if (is(connection, "bpmn:MessageFlow")) {
    manhattanOptions = getMessageFlowManhattanOptions(source, target);
  } else if (is(connection, "bpmn:SequenceFlow") || isCompensationAssociation(source, target)) {
    if (source === target) {
      manhattanOptions = {
        preferredLayouts: getLoopPreferredLayout(source, connection)
      };
    } else if (is(source, "bpmn:BoundaryEvent")) {
      manhattanOptions = {
        preferredLayouts: getBoundaryEventPreferredLayouts(source, target, connectionEnd)
      };
    } else if (isExpandedSubProcess2(source) || isExpandedSubProcess2(target)) {
      manhattanOptions = getSubProcessManhattanOptions(source);
    } else if (is(source, "bpmn:Gateway")) {
      manhattanOptions = {
        preferredLayouts: ["v:h"]
      };
    } else if (is(target, "bpmn:Gateway")) {
      manhattanOptions = {
        preferredLayouts: ["h:v"]
      };
    } else {
      manhattanOptions = {
        preferredLayouts: ["h:h"]
      };
    }
  }
  if (manhattanOptions) {
    manhattanOptions = (0, import_min_dash130.assign)(manhattanOptions, hints);
    updatedWaypoints = withoutRedundantPoints(repairConnection(source, target, connectionStart, connectionEnd, waypoints, manhattanOptions));
  }
  return updatedWaypoints || [connectionStart, connectionEnd];
};
function getAttachOrientation(attachedElement) {
  var hostElement = attachedElement.host;
  return getOrientation(getMid(attachedElement), hostElement, ATTACH_ORIENTATION_PADDING);
}
function getMessageFlowManhattanOptions(source, target) {
  return {
    preferredLayouts: ["straight", "v:v"],
    preserveDocking: getMessageFlowPreserveDocking(source, target)
  };
}
function getMessageFlowPreserveDocking(source, target) {
  if (is(target, "bpmn:Participant")) {
    return "source";
  }
  if (is(source, "bpmn:Participant")) {
    return "target";
  }
  if (isExpandedSubProcess2(target)) {
    return "source";
  }
  if (isExpandedSubProcess2(source)) {
    return "target";
  }
  if (is(target, "bpmn:Event")) {
    return "target";
  }
  if (is(source, "bpmn:Event")) {
    return "source";
  }
  return null;
}
function getSubProcessManhattanOptions(source) {
  return {
    preferredLayouts: ["straight", "h:h"],
    preserveDocking: getSubProcessPreserveDocking(source)
  };
}
function getSubProcessPreserveDocking(source) {
  return isExpandedSubProcess2(source) ? "target" : "source";
}
function getConnectionDocking(point, shape) {
  return point ? point.original || point : getMid(shape);
}
function isCompensationAssociation(source, target) {
  return is(target, "bpmn:Activity") && is(source, "bpmn:BoundaryEvent") && target.businessObject.isForCompensation;
}
function isExpandedSubProcess2(element) {
  return is(element, "bpmn:SubProcess") && isExpanded(element);
}
function isSame2(a6, b5) {
  return a6 === b5;
}
function isAnyOrientation(orientation, orientations) {
  return orientations.indexOf(orientation) !== -1;
}
function getHorizontalOrientation(orientation) {
  var matches2 = /right|left/.exec(orientation);
  return matches2 && matches2[0];
}
function getVerticalOrientation(orientation) {
  var matches2 = /top|bottom/.exec(orientation);
  return matches2 && matches2[0];
}
function isOppositeOrientation(a6, b5) {
  return oppositeOrientationMapping[a6] === b5;
}
function isOppositeHorizontalOrientation(a6, b5) {
  var horizontalOrientation = getHorizontalOrientation(a6);
  var oppositeHorizontalOrientation = oppositeOrientationMapping[horizontalOrientation];
  return b5.indexOf(oppositeHorizontalOrientation) !== -1;
}
function isOppositeVerticalOrientation(a6, b5) {
  var verticalOrientation = getVerticalOrientation(a6);
  var oppositeVerticalOrientation = oppositeOrientationMapping[verticalOrientation];
  return b5.indexOf(oppositeVerticalOrientation) !== -1;
}
function isHorizontalOrientation(orientation) {
  return orientation === "right" || orientation === "left";
}
function getLoopPreferredLayout(source, connection) {
  var waypoints = connection.waypoints;
  var orientation = waypoints && waypoints.length && getOrientation(waypoints[0], source);
  if (orientation === "top") {
    return ["t:r"];
  } else if (orientation === "right") {
    return ["r:b"];
  } else if (orientation === "left") {
    return ["l:t"];
  }
  return ["b:l"];
}
function getBoundaryEventPreferredLayouts(source, target, end) {
  var sourceMid = getMid(source), targetMid = getMid(target), attachOrientation = getAttachOrientation(source), sourceLayout, targetLayout;
  var isLoop = isSame2(source.host, target);
  var attachedToSide = isAnyOrientation(attachOrientation, ["top", "right", "bottom", "left"]);
  var targetOrientation = getOrientation(targetMid, sourceMid, {
    x: source.width / 2 + target.width / 2,
    y: source.height / 2 + target.height / 2
  });
  if (isLoop) {
    return getBoundaryEventLoopLayout(attachOrientation, attachedToSide, source, target, end);
  }
  sourceLayout = getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide);
  targetLayout = getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide);
  return [sourceLayout + ":" + targetLayout];
}
function getBoundaryEventLoopLayout(attachOrientation, attachedToSide, source, target, end) {
  var orientation = attachedToSide ? attachOrientation : getVerticalOrientation(attachOrientation), sourceLayout = orientationDirectionMapping[orientation], targetLayout;
  if (attachedToSide) {
    if (isHorizontalOrientation(attachOrientation)) {
      targetLayout = shouldConnectToSameSide("y", source, target, end) ? "h" : "b";
    } else {
      targetLayout = shouldConnectToSameSide("x", source, target, end) ? "v" : "l";
    }
  } else {
    targetLayout = "v";
  }
  return [sourceLayout + ":" + targetLayout];
}
function shouldConnectToSameSide(axis, source, target, end) {
  var threshold = BOUNDARY_TO_HOST_THRESHOLD;
  return !(areCloseOnAxis(axis, end, target, threshold) || areCloseOnAxis(axis, end, {
    x: target.x + target.width,
    y: target.y + target.height
  }, threshold) || areCloseOnAxis(axis, end, getMid(source), threshold));
}
function areCloseOnAxis(axis, a6, b5, threshold) {
  return Math.abs(a6[axis] - b5[axis]) < threshold;
}
function getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide) {
  if (attachedToSide) {
    return orientationDirectionMapping[attachOrientation];
  }
  if (isSame2(getVerticalOrientation(attachOrientation), getVerticalOrientation(targetOrientation)) || isOppositeOrientation(getHorizontalOrientation(attachOrientation), getHorizontalOrientation(targetOrientation))) {
    return orientationDirectionMapping[getVerticalOrientation(attachOrientation)];
  }
  return orientationDirectionMapping[getHorizontalOrientation(attachOrientation)];
}
function getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide) {
  if (attachedToSide) {
    if (isHorizontalOrientation(attachOrientation)) {
      if (isOppositeHorizontalOrientation(attachOrientation, targetOrientation) || isSame2(attachOrientation, targetOrientation)) {
        return "h";
      }
      return "v";
    } else {
      if (isOppositeVerticalOrientation(attachOrientation, targetOrientation) || isSame2(attachOrientation, targetOrientation)) {
        return "v";
      }
      return "h";
    }
  }
  if (isHorizontalOrientation(targetOrientation) || isSame2(getVerticalOrientation(attachOrientation), getVerticalOrientation(targetOrientation)) && getHorizontalOrientation(targetOrientation)) {
    return "h";
  } else {
    return "v";
  }
}

// node_modules/diagram-js/lib/layout/CroppingConnectionDocking.js
var import_min_dash131 = __toESM(require_dist());
function dockingToPoint(docking) {
  return (0, import_min_dash131.assign)({ original: docking.point.original || docking.point }, docking.actual);
}
function CroppingConnectionDocking(elementRegistry, graphicsFactory) {
  this._elementRegistry = elementRegistry;
  this._graphicsFactory = graphicsFactory;
}
CroppingConnectionDocking.$inject = ["elementRegistry", "graphicsFactory"];
CroppingConnectionDocking.prototype.getCroppedWaypoints = function(connection, source, target) {
  source = source || connection.source;
  target = target || connection.target;
  var sourceDocking = this.getDockingPoint(connection, source, true), targetDocking = this.getDockingPoint(connection, target);
  var croppedWaypoints = connection.waypoints.slice(sourceDocking.idx + 1, targetDocking.idx);
  croppedWaypoints.unshift(dockingToPoint(sourceDocking));
  croppedWaypoints.push(dockingToPoint(targetDocking));
  return croppedWaypoints;
};
CroppingConnectionDocking.prototype.getDockingPoint = function(connection, shape, dockStart) {
  var waypoints = connection.waypoints, dockingIdx, dockingPoint, croppedPoint;
  dockingIdx = dockStart ? 0 : waypoints.length - 1;
  dockingPoint = waypoints[dockingIdx];
  croppedPoint = this._getIntersection(shape, connection, dockStart);
  return {
    point: dockingPoint,
    actual: croppedPoint || dockingPoint,
    idx: dockingIdx
  };
};
CroppingConnectionDocking.prototype._getIntersection = function(shape, connection, takeFirst) {
  var shapePath = this._getShapePath(shape), connectionPath = this._getConnectionPath(connection);
  return getElementLineIntersection(shapePath, connectionPath, takeFirst);
};
CroppingConnectionDocking.prototype._getConnectionPath = function(connection) {
  return this._graphicsFactory.getConnectionPath(connection);
};
CroppingConnectionDocking.prototype._getShapePath = function(shape) {
  return this._graphicsFactory.getShapePath(shape);
};
CroppingConnectionDocking.prototype._getGfx = function(element) {
  return this._elementRegistry.getGraphics(element);
};

// node_modules/bpmn-js/lib/features/modeling/index.js
var modeling_default = {
  __init__: [
    "modeling",
    "bpmnUpdater"
  ],
  __depends__: [
    behavior_default3,
    rules_default2,
    di_ordering_default,
    ordering_default,
    replace_default2,
    command_default,
    tooltips_default,
    label_support_default,
    attach_support_default,
    selection_default,
    change_support_default,
    space_tool_default2
  ],
  bpmnFactory: ["type", BpmnFactory],
  bpmnUpdater: ["type", BpmnUpdater],
  elementFactory: ["type", ElementFactory2],
  modeling: ["type", Modeling2],
  layouter: ["type", BpmnLayouter],
  connectionDocking: ["type", CroppingConnectionDocking]
};

// node_modules/diagram-js/lib/features/move/Move.js
var import_min_dash132 = __toESM(require_dist());
var LOW_PRIORITY25 = 500;
var MEDIUM_PRIORITY = 1250;
var HIGH_PRIORITY18 = 1500;
var round12 = Math.round;
function mid3(element) {
  return {
    x: element.x + round12(element.width / 2),
    y: element.y + round12(element.height / 2)
  };
}
function MoveEvents(eventBus, dragging, modeling, selection, rules) {
  function canMove2(shapes, delta2, position, target) {
    return rules.allowed("elements.move", {
      shapes,
      delta: delta2,
      position,
      target
    });
  }
  eventBus.on("shape.move.start", HIGH_PRIORITY18, function(event2) {
    var context = event2.context, shape = event2.shape, shapes = selection.get().slice();
    if (shapes.indexOf(shape) === -1) {
      shapes = [shape];
    }
    shapes = removeNested(shapes);
    (0, import_min_dash132.assign)(context, {
      shapes,
      validatedShapes: shapes,
      shape
    });
  });
  eventBus.on("shape.move.start", MEDIUM_PRIORITY, function(event2) {
    var context = event2.context, validatedShapes = context.validatedShapes, canExecute;
    canExecute = context.canExecute = canMove2(validatedShapes);
    if (!canExecute) {
      return false;
    }
  });
  eventBus.on("shape.move.move", LOW_PRIORITY25, function(event2) {
    var context = event2.context, validatedShapes = context.validatedShapes, hover = event2.hover, delta2 = { x: event2.dx, y: event2.dy }, position = { x: event2.x, y: event2.y }, canExecute;
    canExecute = canMove2(validatedShapes, delta2, position, hover);
    context.delta = delta2;
    context.canExecute = canExecute;
    if (canExecute === null) {
      context.target = null;
      return;
    }
    context.target = hover;
  });
  eventBus.on("shape.move.end", function(event2) {
    var context = event2.context;
    var delta2 = context.delta, canExecute = context.canExecute, isAttach = canExecute === "attach", shapes = context.shapes;
    if (canExecute === false) {
      return false;
    }
    delta2.x = round12(delta2.x);
    delta2.y = round12(delta2.y);
    if (delta2.x === 0 && delta2.y === 0) {
      return;
    }
    modeling.moveElements(shapes, delta2, context.target, {
      primaryShape: context.shape,
      attach: isAttach
    });
  });
  eventBus.on("element.mousedown", function(event2) {
    if (!isPrimaryButton(event2)) {
      return;
    }
    var originalEvent = getOriginal(event2);
    if (!originalEvent) {
      throw new Error("must supply DOM mousedown event");
    }
    return start(originalEvent, event2.element);
  });
  function start(event2, element, activate, context) {
    if ((0, import_min_dash132.isObject)(activate)) {
      context = activate;
      activate = false;
    }
    if (element.waypoints || !element.parent) {
      return;
    }
    if (classes(event2.target).has("djs-hit-no-move")) {
      return;
    }
    var referencePoint = mid3(element);
    dragging.init(event2, referencePoint, "shape.move", {
      cursor: "grabbing",
      autoActivate: activate,
      data: {
        shape: element,
        context: context || {}
      }
    });
    return true;
  }
  this.start = start;
}
MoveEvents.$inject = [
  "eventBus",
  "dragging",
  "modeling",
  "selection",
  "rules"
];
function removeNested(elements) {
  var ids3 = (0, import_min_dash132.groupBy)(elements, "id");
  return (0, import_min_dash132.filter)(elements, function(element) {
    while (element = element.parent) {
      if (ids3[element.id]) {
        return false;
      }
    }
    return true;
  });
}

// node_modules/diagram-js/lib/features/move/MovePreview.js
var import_min_dash133 = __toESM(require_dist());
var LOW_PRIORITY26 = 499;
var MARKER_DRAGGING2 = "djs-dragging";
var MARKER_OK4 = "drop-ok";
var MARKER_NOT_OK4 = "drop-not-ok";
var MARKER_NEW_PARENT2 = "new-parent";
var MARKER_ATTACH3 = "attach-ok";
function MovePreview(eventBus, canvas, styles, previewSupport) {
  function getVisualDragShapes(shapes) {
    var elements = getAllDraggedElements(shapes);
    var filteredElements = removeEdges(elements);
    return filteredElements;
  }
  function getAllDraggedElements(shapes) {
    var allShapes = selfAndAllChildren(shapes, true);
    var allConnections = (0, import_min_dash133.map)(allShapes, function(shape) {
      return (shape.incoming || []).concat(shape.outgoing || []);
    });
    return (0, import_min_dash133.flatten)(allShapes.concat(allConnections));
  }
  function setMarker(element, marker) {
    [MARKER_ATTACH3, MARKER_OK4, MARKER_NOT_OK4, MARKER_NEW_PARENT2].forEach(function(m6) {
      if (m6 === marker) {
        canvas.addMarker(element, m6);
      } else {
        canvas.removeMarker(element, m6);
      }
    });
  }
  function makeDraggable(context, element, addMarker) {
    previewSupport.addDragger(element, context.dragGroup);
    if (addMarker) {
      canvas.addMarker(element, MARKER_DRAGGING2);
    }
    if (context.allDraggedElements) {
      context.allDraggedElements.push(element);
    } else {
      context.allDraggedElements = [element];
    }
  }
  eventBus.on("shape.move.start", LOW_PRIORITY26, function(event2) {
    var context = event2.context, dragShapes = context.shapes, allDraggedElements = context.allDraggedElements;
    var visuallyDraggedShapes = getVisualDragShapes(dragShapes);
    if (!context.dragGroup) {
      var dragGroup = create("g");
      attr(dragGroup, styles.cls("djs-drag-group", ["no-events"]));
      var activeLayer = canvas.getActiveLayer();
      append(activeLayer, dragGroup);
      context.dragGroup = dragGroup;
    }
    visuallyDraggedShapes.forEach(function(shape) {
      previewSupport.addDragger(shape, context.dragGroup);
    });
    if (!allDraggedElements) {
      allDraggedElements = getAllDraggedElements(dragShapes);
    } else {
      allDraggedElements = (0, import_min_dash133.flatten)([
        allDraggedElements,
        getAllDraggedElements(dragShapes)
      ]);
    }
    (0, import_min_dash133.forEach)(allDraggedElements, function(e7) {
      canvas.addMarker(e7, MARKER_DRAGGING2);
    });
    context.allDraggedElements = allDraggedElements;
    context.differentParents = haveDifferentParents(dragShapes);
  });
  eventBus.on("shape.move.move", LOW_PRIORITY26, function(event2) {
    var context = event2.context, dragGroup = context.dragGroup, target = context.target, parent = context.shape.parent, canExecute = context.canExecute;
    if (target) {
      if (canExecute === "attach") {
        setMarker(target, MARKER_ATTACH3);
      } else if (context.canExecute && target && target.id !== parent.id) {
        setMarker(target, MARKER_NEW_PARENT2);
      } else {
        setMarker(target, context.canExecute ? MARKER_OK4 : MARKER_NOT_OK4);
      }
    }
    translate(dragGroup, event2.dx, event2.dy);
  });
  eventBus.on(["shape.move.out", "shape.move.cleanup"], function(event2) {
    var context = event2.context, target = context.target;
    if (target) {
      setMarker(target, null);
    }
  });
  eventBus.on("shape.move.cleanup", function(event2) {
    var context = event2.context, allDraggedElements = context.allDraggedElements, dragGroup = context.dragGroup;
    (0, import_min_dash133.forEach)(allDraggedElements, function(e7) {
      canvas.removeMarker(e7, MARKER_DRAGGING2);
    });
    if (dragGroup) {
      remove(dragGroup);
    }
  });
  this.makeDraggable = makeDraggable;
}
MovePreview.$inject = [
  "eventBus",
  "canvas",
  "styles",
  "previewSupport"
];
function removeEdges(elements) {
  var filteredElements = (0, import_min_dash133.filter)(elements, function(element) {
    if (!isConnection14(element)) {
      return true;
    } else {
      return (0, import_min_dash133.find)(elements, (0, import_min_dash133.matchPattern)({ id: element.source.id })) && (0, import_min_dash133.find)(elements, (0, import_min_dash133.matchPattern)({ id: element.target.id }));
    }
  });
  return filteredElements;
}
function haveDifferentParents(elements) {
  return (0, import_min_dash133.size)((0, import_min_dash133.groupBy)(elements, function(e7) {
    return e7.parent && e7.parent.id;
  })) !== 1;
}
function isConnection14(element) {
  return element.waypoints;
}

// node_modules/diagram-js/lib/features/move/index.js
var move_default = {
  __depends__: [
    interaction_events_default,
    selection_default,
    outline_default,
    rules_default,
    dragging_default,
    preview_support_default
  ],
  __init__: [
    "move",
    "movePreview"
  ],
  move: ["type", MoveEvents],
  movePreview: ["type", MovePreview]
};

// node_modules/diagram-js/lib/features/palette/Palette.js
var import_min_dash134 = __toESM(require_dist());
var TOGGLE_SELECTOR = ".djs-palette-toggle";
var ENTRY_SELECTOR = ".entry";
var ELEMENT_SELECTOR = TOGGLE_SELECTOR + ", " + ENTRY_SELECTOR;
var PALETTE_PREFIX = "djs-palette-";
var PALETTE_SHOWN_CLS = "shown";
var PALETTE_OPEN_CLS = "open";
var PALETTE_TWO_COLUMN_CLS = "two-column";
var DEFAULT_PRIORITY6 = 1e3;
function Palette(eventBus, canvas) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  var self2 = this;
  eventBus.on("tool-manager.update", function(event2) {
    var tool = event2.tool;
    self2.updateToolHighlight(tool);
  });
  eventBus.on("i18n.changed", function() {
    self2._update();
  });
  eventBus.on("diagram.init", function() {
    self2._diagramInitialized = true;
    self2._rebuild();
  });
}
Palette.$inject = ["eventBus", "canvas"];
Palette.prototype.registerProvider = function(priority, provider) {
  if (!provider) {
    provider = priority;
    priority = DEFAULT_PRIORITY6;
  }
  this._eventBus.on("palette.getProviders", priority, function(event2) {
    event2.providers.push(provider);
  });
  this._rebuild();
};
Palette.prototype.getEntries = function() {
  var providers = this._getProviders();
  return providers.reduce(addPaletteEntries, {});
};
Palette.prototype._rebuild = function() {
  if (!this._diagramInitialized) {
    return;
  }
  var providers = this._getProviders();
  if (!providers.length) {
    return;
  }
  if (!this._container) {
    this._init();
  }
  this._update();
};
Palette.prototype._init = function() {
  var self2 = this;
  var eventBus = this._eventBus;
  var parentContainer = this._getParentContainer();
  var container = this._container = domify$1(Palette.HTML_MARKUP);
  parentContainer.appendChild(container);
  classes2(parentContainer).add(PALETTE_PREFIX + PALETTE_SHOWN_CLS);
  delegate.bind(container, ELEMENT_SELECTOR, "click", function(event2) {
    var target = event2.delegateTarget;
    if (matches(target, TOGGLE_SELECTOR)) {
      return self2.toggle();
    }
    self2.trigger("click", event2);
  });
  event.bind(container, "mousedown", function(event2) {
    event2.stopPropagation();
  });
  delegate.bind(container, ENTRY_SELECTOR, "dragstart", function(event2) {
    self2.trigger("dragstart", event2);
  });
  eventBus.on("canvas.resized", this._layoutChanged, this);
  eventBus.fire("palette.create", {
    container
  });
};
Palette.prototype._getProviders = function(id) {
  var event2 = this._eventBus.createEvent({
    type: "palette.getProviders",
    providers: []
  });
  this._eventBus.fire(event2);
  return event2.providers;
};
Palette.prototype._toggleState = function(state) {
  state = state || {};
  var parent = this._getParentContainer(), container = this._container;
  var eventBus = this._eventBus;
  var twoColumn;
  var cls = classes2(container), parentCls = classes2(parent);
  if ("twoColumn" in state) {
    twoColumn = state.twoColumn;
  } else {
    twoColumn = this._needsCollapse(parent.clientHeight, this._entries || {});
  }
  cls.toggle(PALETTE_TWO_COLUMN_CLS, twoColumn);
  parentCls.toggle(PALETTE_PREFIX + PALETTE_TWO_COLUMN_CLS, twoColumn);
  if ("open" in state) {
    cls.toggle(PALETTE_OPEN_CLS, state.open);
    parentCls.toggle(PALETTE_PREFIX + PALETTE_OPEN_CLS, state.open);
  }
  eventBus.fire("palette.changed", {
    twoColumn,
    open: this.isOpen()
  });
};
Palette.prototype._update = function() {
  var entriesContainer = query(".djs-palette-entries", this._container), entries = this._entries = this.getEntries();
  clear2(entriesContainer);
  (0, import_min_dash134.forEach)(entries, function(entry, id) {
    var grouping = entry.group || "default";
    var container = query("[data-group=" + (0, import_css.default)(grouping) + "]", entriesContainer);
    if (!container) {
      container = domify$1('<div class="group"></div>');
      attr2(container, "data-group", grouping);
      entriesContainer.appendChild(container);
    }
    var html = entry.html || (entry.separator ? '<hr class="separator" />' : '<div class="entry" draggable="true"></div>');
    var control = domify$1(html);
    container.appendChild(control);
    if (!entry.separator) {
      attr2(control, "data-action", id);
      if (entry.title) {
        attr2(control, "title", entry.title);
      }
      if (entry.className) {
        addClasses2(control, entry.className);
      }
      if (entry.imageUrl) {
        var image = domify$1("<img>");
        attr2(image, "src", entry.imageUrl);
        control.appendChild(image);
      }
    }
  });
  this.open();
};
Palette.prototype.trigger = function(action, event2, autoActivate) {
  var entries = this._entries, entry, handler, originalEvent, button = event2.delegateTarget || event2.target;
  if (!button) {
    return event2.preventDefault();
  }
  entry = entries[attr2(button, "data-action")];
  if (!entry) {
    return;
  }
  handler = entry.action;
  originalEvent = event2.originalEvent || event2;
  if ((0, import_min_dash134.isFunction)(handler)) {
    if (action === "click") {
      handler(originalEvent, autoActivate);
    }
  } else {
    if (handler[action]) {
      handler[action](originalEvent, autoActivate);
    }
  }
  event2.preventDefault();
};
Palette.prototype._layoutChanged = function() {
  this._toggleState({});
};
Palette.prototype._needsCollapse = function(availableHeight, entries) {
  var margin = 20 + 10 + 20;
  var entriesHeight = Object.keys(entries).length * 46;
  return availableHeight < entriesHeight + margin;
};
Palette.prototype.close = function() {
  this._toggleState({
    open: false,
    twoColumn: false
  });
};
Palette.prototype.open = function() {
  this._toggleState({ open: true });
};
Palette.prototype.toggle = function(open3) {
  if (this.isOpen()) {
    this.close();
  } else {
    this.open();
  }
};
Palette.prototype.isActiveTool = function(tool) {
  return tool && this._activeTool === tool;
};
Palette.prototype.updateToolHighlight = function(name3) {
  var entriesContainer, toolsContainer;
  if (!this._toolsContainer) {
    entriesContainer = query(".djs-palette-entries", this._container);
    this._toolsContainer = query("[data-group=tools]", entriesContainer);
  }
  toolsContainer = this._toolsContainer;
  (0, import_min_dash134.forEach)(toolsContainer.children, function(tool) {
    var actionName = tool.getAttribute("data-action");
    if (!actionName) {
      return;
    }
    var toolClasses = classes2(tool);
    actionName = actionName.replace("-tool", "");
    if (toolClasses.contains("entry") && actionName === name3) {
      toolClasses.add("highlighted-entry");
    } else {
      toolClasses.remove("highlighted-entry");
    }
  });
};
Palette.prototype.isOpen = function() {
  return classes2(this._container).has(PALETTE_OPEN_CLS);
};
Palette.prototype._getParentContainer = function() {
  return this._canvas.getContainer();
};
Palette.HTML_MARKUP = '<div class="djs-palette"><div class="djs-palette-entries"></div><div class="djs-palette-toggle"></div></div>';
function addClasses2(element, classNames) {
  var classes3 = classes2(element);
  var actualClassNames = (0, import_min_dash134.isArray)(classNames) ? classNames : classNames.split(/\s+/g);
  actualClassNames.forEach(function(cls) {
    classes3.add(cls);
  });
}
function addPaletteEntries(entries, provider) {
  var entriesOrUpdater = provider.getPaletteEntries();
  if ((0, import_min_dash134.isFunction)(entriesOrUpdater)) {
    return entriesOrUpdater(entries);
  }
  (0, import_min_dash134.forEach)(entriesOrUpdater, function(entry, id) {
    entries[id] = entry;
  });
  return entries;
}

// node_modules/diagram-js/lib/features/palette/index.js
var palette_default = {
  __init__: ["palette"],
  palette: ["type", Palette]
};

// node_modules/diagram-js/lib/features/lasso-tool/LassoTool.js
var import_min_dash135 = __toESM(require_dist());
var LASSO_TOOL_CURSOR = "crosshair";
function LassoTool(eventBus, canvas, dragging, elementRegistry, selection, toolManager, mouse) {
  this._selection = selection;
  this._dragging = dragging;
  this._mouse = mouse;
  var self2 = this;
  var visuals = {
    create: function(context) {
      var container = canvas.getActiveLayer(), frame;
      frame = context.frame = create("rect");
      attr(frame, {
        class: "djs-lasso-overlay",
        width: 1,
        height: 1,
        x: 0,
        y: 0
      });
      append(container, frame);
    },
    update: function(context) {
      var frame = context.frame, bbox = context.bbox;
      attr(frame, {
        x: bbox.x,
        y: bbox.y,
        width: bbox.width,
        height: bbox.height
      });
    },
    remove: function(context) {
      if (context.frame) {
        remove(context.frame);
      }
    }
  };
  toolManager.registerTool("lasso", {
    tool: "lasso.selection",
    dragging: "lasso"
  });
  eventBus.on("lasso.selection.end", function(event2) {
    var target = event2.originalEvent.target;
    if (!event2.hover && !(target instanceof SVGElement)) {
      return;
    }
    eventBus.once("lasso.selection.ended", function() {
      self2.activateLasso(event2.originalEvent, true);
    });
  });
  eventBus.on("lasso.end", function(event2) {
    var bbox = toBBox(event2);
    var elements = elementRegistry.filter(function(element) {
      return element;
    });
    self2.select(elements, bbox);
  });
  eventBus.on("lasso.start", function(event2) {
    var context = event2.context;
    context.bbox = toBBox(event2);
    visuals.create(context);
  });
  eventBus.on("lasso.move", function(event2) {
    var context = event2.context;
    context.bbox = toBBox(event2);
    visuals.update(context);
  });
  eventBus.on("lasso.cleanup", function(event2) {
    var context = event2.context;
    visuals.remove(context);
  });
  eventBus.on("element.mousedown", 1500, function(event2) {
    if (!hasSecondaryModifier(event2)) {
      return;
    }
    self2.activateLasso(event2.originalEvent);
    return true;
  });
}
LassoTool.$inject = [
  "eventBus",
  "canvas",
  "dragging",
  "elementRegistry",
  "selection",
  "toolManager",
  "mouse"
];
LassoTool.prototype.activateLasso = function(event2, autoActivate) {
  this._dragging.init(event2, "lasso", {
    autoActivate,
    cursor: LASSO_TOOL_CURSOR,
    data: {
      context: {}
    }
  });
};
LassoTool.prototype.activateSelection = function(event2, autoActivate) {
  this._dragging.init(event2, "lasso.selection", {
    trapClick: false,
    autoActivate,
    cursor: LASSO_TOOL_CURSOR,
    data: {
      context: {}
    }
  });
};
LassoTool.prototype.select = function(elements, bbox) {
  var selectedElements = getEnclosedElements(elements, bbox);
  this._selection.select((0, import_min_dash135.values)(selectedElements));
};
LassoTool.prototype.toggle = function() {
  if (this.isActive()) {
    return this._dragging.cancel();
  }
  var mouseEvent = this._mouse.getLastMoveEvent();
  this.activateSelection(mouseEvent, !!mouseEvent);
};
LassoTool.prototype.isActive = function() {
  var context = this._dragging.context();
  return context && /^lasso/.test(context.prefix);
};
function toBBox(event2) {
  var start = {
    x: event2.x - event2.dx,
    y: event2.y - event2.dy
  };
  var end = {
    x: event2.x,
    y: event2.y
  };
  var bbox;
  if (start.x <= end.x && start.y < end.y || start.x < end.x && start.y <= end.y) {
    bbox = {
      x: start.x,
      y: start.y,
      width: end.x - start.x,
      height: end.y - start.y
    };
  } else if (start.x >= end.x && start.y < end.y || start.x > end.x && start.y <= end.y) {
    bbox = {
      x: end.x,
      y: start.y,
      width: start.x - end.x,
      height: end.y - start.y
    };
  } else if (start.x <= end.x && start.y > end.y || start.x < end.x && start.y >= end.y) {
    bbox = {
      x: start.x,
      y: end.y,
      width: end.x - start.x,
      height: start.y - end.y
    };
  } else if (start.x >= end.x && start.y > end.y || start.x > end.x && start.y >= end.y) {
    bbox = {
      x: end.x,
      y: end.y,
      width: start.x - end.x,
      height: start.y - end.y
    };
  } else {
    bbox = {
      x: end.x,
      y: end.y,
      width: 0,
      height: 0
    };
  }
  return bbox;
}

// node_modules/diagram-js/lib/features/lasso-tool/index.js
var lasso_tool_default = {
  __depends__: [
    tool_manager_default,
    mouse_default
  ],
  __init__: ["lassoTool"],
  lassoTool: ["type", LassoTool]
};

// node_modules/diagram-js/lib/features/hand-tool/HandTool.js
var HIGH_PRIORITY19 = 1500;
var HAND_CURSOR = "grab";
function HandTool(eventBus, canvas, dragging, injector, toolManager, mouse) {
  this._dragging = dragging;
  this._mouse = mouse;
  var self2 = this, keyboard = injector.get("keyboard", false);
  toolManager.registerTool("hand", {
    tool: "hand",
    dragging: "hand.move"
  });
  eventBus.on("element.mousedown", HIGH_PRIORITY19, function(event2) {
    if (!hasPrimaryModifier(event2)) {
      return;
    }
    self2.activateMove(event2.originalEvent, true);
    return false;
  });
  keyboard && keyboard.addListener(HIGH_PRIORITY19, function(e7) {
    if (!isSpace(e7.keyEvent) || self2.isActive()) {
      return;
    }
    var mouseEvent = self2._mouse.getLastMoveEvent();
    self2.activateMove(mouseEvent, !!mouseEvent);
  }, "keyboard.keydown");
  keyboard && keyboard.addListener(HIGH_PRIORITY19, function(e7) {
    if (!isSpace(e7.keyEvent) || !self2.isActive()) {
      return;
    }
    self2.toggle();
  }, "keyboard.keyup");
  eventBus.on("hand.end", function(event2) {
    var target = event2.originalEvent.target;
    if (!event2.hover && !(target instanceof SVGElement)) {
      return false;
    }
    eventBus.once("hand.ended", function() {
      self2.activateMove(event2.originalEvent, { reactivate: true });
    });
  });
  eventBus.on("hand.move.move", function(event2) {
    var scale = canvas.viewbox().scale;
    canvas.scroll({
      dx: event2.dx * scale,
      dy: event2.dy * scale
    });
  });
  eventBus.on("hand.move.end", function(event2) {
    var context = event2.context, reactivate = context.reactivate;
    if (!hasPrimaryModifier(event2) && reactivate) {
      eventBus.once("hand.move.ended", function(event3) {
        self2.activateHand(event3.originalEvent, true, true);
      });
    }
    return false;
  });
}
HandTool.$inject = [
  "eventBus",
  "canvas",
  "dragging",
  "injector",
  "toolManager",
  "mouse"
];
HandTool.prototype.activateMove = function(event2, autoActivate, context) {
  if (typeof autoActivate === "object") {
    context = autoActivate;
    autoActivate = false;
  }
  this._dragging.init(event2, "hand.move", {
    autoActivate,
    cursor: HAND_CURSOR,
    data: {
      context: context || {}
    }
  });
};
HandTool.prototype.activateHand = function(event2, autoActivate, reactivate) {
  this._dragging.init(event2, "hand", {
    trapClick: false,
    autoActivate,
    cursor: HAND_CURSOR,
    data: {
      context: {
        reactivate
      }
    }
  });
};
HandTool.prototype.toggle = function() {
  if (this.isActive()) {
    return this._dragging.cancel();
  }
  var mouseEvent = this._mouse.getLastMoveEvent();
  this.activateHand(mouseEvent, !!mouseEvent);
};
HandTool.prototype.isActive = function() {
  var context = this._dragging.context();
  if (context) {
    return /^(hand|hand\.move)$/.test(context.prefix);
  }
  return false;
};
function isSpace(keyEvent) {
  return isKey("Space", keyEvent);
}

// node_modules/diagram-js/lib/features/hand-tool/index.js
var hand_tool_default = {
  __depends__: [
    tool_manager_default,
    mouse_default
  ],
  __init__: ["handTool"],
  handTool: ["type", HandTool]
};

// node_modules/diagram-js/lib/features/global-connect/GlobalConnect.js
var MARKER_OK5 = "connect-ok";
var MARKER_NOT_OK5 = "connect-not-ok";
function GlobalConnect(eventBus, dragging, connect, canvas, toolManager, rules, mouse) {
  var self2 = this;
  this._dragging = dragging;
  this._rules = rules;
  this._mouse = mouse;
  toolManager.registerTool("global-connect", {
    tool: "global-connect",
    dragging: "global-connect.drag"
  });
  eventBus.on("global-connect.hover", function(event2) {
    var context = event2.context, startTarget = event2.hover;
    var canStartConnect = context.canStartConnect = self2.canStartConnect(startTarget);
    if (canStartConnect === null) {
      return;
    }
    context.startTarget = startTarget;
    canvas.addMarker(startTarget, canStartConnect ? MARKER_OK5 : MARKER_NOT_OK5);
  });
  eventBus.on(["global-connect.out", "global-connect.cleanup"], function(event2) {
    var startTarget = event2.context.startTarget, canStartConnect = event2.context.canStartConnect;
    if (startTarget) {
      canvas.removeMarker(startTarget, canStartConnect ? MARKER_OK5 : MARKER_NOT_OK5);
    }
  });
  eventBus.on(["global-connect.ended"], function(event2) {
    var context = event2.context, startTarget = context.startTarget, startPosition = {
      x: event2.x,
      y: event2.y
    };
    var canStartConnect = self2.canStartConnect(startTarget);
    if (!canStartConnect) {
      return;
    }
    eventBus.once("element.out", function() {
      eventBus.once(["connect.ended", "connect.canceled"], function() {
        eventBus.fire("global-connect.drag.ended");
      });
      connect.start(null, startTarget, startPosition);
    });
    return false;
  });
}
GlobalConnect.$inject = [
  "eventBus",
  "dragging",
  "connect",
  "canvas",
  "toolManager",
  "rules",
  "mouse"
];
GlobalConnect.prototype.start = function(event2, autoActivate) {
  this._dragging.init(event2, "global-connect", {
    autoActivate,
    trapClick: false,
    data: {
      context: {}
    }
  });
};
GlobalConnect.prototype.toggle = function() {
  if (this.isActive()) {
    return this._dragging.cancel();
  }
  var mouseEvent = this._mouse.getLastMoveEvent();
  return this.start(mouseEvent, !!mouseEvent);
};
GlobalConnect.prototype.isActive = function() {
  var context = this._dragging.context();
  return context && /^global-connect/.test(context.prefix);
};
GlobalConnect.prototype.canStartConnect = function(startTarget) {
  return this._rules.allowed("connection.start", { source: startTarget });
};

// node_modules/diagram-js/lib/features/global-connect/index.js
var global_connect_default = {
  __depends__: [
    connect_default,
    rules_default,
    dragging_default,
    tool_manager_default,
    mouse_default
  ],
  globalConnect: ["type", GlobalConnect]
};

// node_modules/bpmn-js/lib/features/palette/PaletteProvider.js
var import_min_dash136 = __toESM(require_dist());
function PaletteProvider(palette, create3, elementFactory, spaceTool, lassoTool, handTool, globalConnect, translate3) {
  this._palette = palette;
  this._create = create3;
  this._elementFactory = elementFactory;
  this._spaceTool = spaceTool;
  this._lassoTool = lassoTool;
  this._handTool = handTool;
  this._globalConnect = globalConnect;
  this._translate = translate3;
  palette.registerProvider(this);
}
PaletteProvider.$inject = [
  "palette",
  "create",
  "elementFactory",
  "spaceTool",
  "lassoTool",
  "handTool",
  "globalConnect",
  "translate"
];
PaletteProvider.prototype.getPaletteEntries = function(element) {
  var actions = {}, create3 = this._create, elementFactory = this._elementFactory, spaceTool = this._spaceTool, lassoTool = this._lassoTool, handTool = this._handTool, globalConnect = this._globalConnect, translate3 = this._translate;
  function createAction(type, group, className, title, options2) {
    function createListener(event2) {
      var shape = elementFactory.createShape((0, import_min_dash136.assign)({ type }, options2));
      if (options2) {
        var di = getDi(shape);
        di.isExpanded = options2.isExpanded;
      }
      create3.start(event2, shape);
    }
    var shortType = type.replace(/^bpmn:/, "");
    return {
      group,
      className,
      title: title || translate3("Create {type}", { type: shortType }),
      action: {
        dragstart: createListener,
        click: createListener
      }
    };
  }
  function createSubprocess(event2) {
    var subProcess = elementFactory.createShape({
      type: "bpmn:SubProcess",
      x: 0,
      y: 0,
      isExpanded: true
    });
    var startEvent = elementFactory.createShape({
      type: "bpmn:StartEvent",
      x: 40,
      y: 82,
      parent: subProcess
    });
    create3.start(event2, [subProcess, startEvent], {
      hints: {
        autoSelect: [subProcess]
      }
    });
  }
  function createParticipant(event2) {
    create3.start(event2, elementFactory.createParticipantShape());
  }
  (0, import_min_dash136.assign)(actions, {
    "hand-tool": {
      group: "tools",
      className: "bpmn-icon-hand-tool",
      title: translate3("Activate the hand tool"),
      action: {
        click: function(event2) {
          handTool.activateHand(event2);
        }
      }
    },
    "lasso-tool": {
      group: "tools",
      className: "bpmn-icon-lasso-tool",
      title: translate3("Activate the lasso tool"),
      action: {
        click: function(event2) {
          lassoTool.activateSelection(event2);
        }
      }
    },
    "space-tool": {
      group: "tools",
      className: "bpmn-icon-space-tool",
      title: translate3("Activate the create/remove space tool"),
      action: {
        click: function(event2) {
          spaceTool.activateSelection(event2);
        }
      }
    },
    "global-connect-tool": {
      group: "tools",
      className: "bpmn-icon-connection-multi",
      title: translate3("Activate the global connect tool"),
      action: {
        click: function(event2) {
          globalConnect.start(event2);
        }
      }
    },
    "tool-separator": {
      group: "tools",
      separator: true
    },
    "create.start-event": createAction("bpmn:StartEvent", "event", "bpmn-icon-start-event-none", translate3("Create StartEvent")),
    "create.intermediate-event": createAction("bpmn:IntermediateThrowEvent", "event", "bpmn-icon-intermediate-event-none", translate3("Create Intermediate/Boundary Event")),
    "create.end-event": createAction("bpmn:EndEvent", "event", "bpmn-icon-end-event-none", translate3("Create EndEvent")),
    "create.exclusive-gateway": createAction("bpmn:ExclusiveGateway", "gateway", "bpmn-icon-gateway-none", translate3("Create Gateway")),
    "create.task": createAction("bpmn:Task", "activity", "bpmn-icon-task", translate3("Create Task")),
    "create.data-object": createAction("bpmn:DataObjectReference", "data-object", "bpmn-icon-data-object", translate3("Create DataObjectReference")),
    "create.data-store": createAction("bpmn:DataStoreReference", "data-store", "bpmn-icon-data-store", translate3("Create DataStoreReference")),
    "create.subprocess-expanded": {
      group: "activity",
      className: "bpmn-icon-subprocess-expanded",
      title: translate3("Create expanded SubProcess"),
      action: {
        dragstart: createSubprocess,
        click: createSubprocess
      }
    },
    "create.participant-expanded": {
      group: "collaboration",
      className: "bpmn-icon-participant",
      title: translate3("Create Pool/Participant"),
      action: {
        dragstart: createParticipant,
        click: createParticipant
      }
    },
    "create.group": createAction("bpmn:Group", "artifact", "bpmn-icon-group", translate3("Create Group"))
  });
  return actions;
};

// node_modules/bpmn-js/lib/features/palette/index.js
var palette_default2 = {
  __depends__: [
    palette_default,
    create_default,
    space_tool_default2,
    lasso_tool_default,
    hand_tool_default,
    global_connect_default,
    translate_default
  ],
  __init__: ["paletteProvider"],
  paletteProvider: ["type", PaletteProvider]
};

// node_modules/bpmn-js/lib/features/replace-preview/BpmnReplacePreview.js
var import_css2 = __toESM(require_css_escape());
var import_min_dash137 = __toESM(require_dist());
var LOW_PRIORITY27 = 250;
function BpmnReplacePreview(eventBus, elementRegistry, elementFactory, canvas, previewSupport) {
  CommandInterceptor.call(this, eventBus);
  function replaceVisual(context) {
    var replacements = context.canExecute.replacements;
    (0, import_min_dash137.forEach)(replacements, function(replacement) {
      var id = replacement.oldElementId;
      var newElement = {
        type: replacement.newElementType
      };
      if (context.visualReplacements[id]) {
        return;
      }
      var element = elementRegistry.get(id);
      (0, import_min_dash137.assign)(newElement, { x: element.x, y: element.y });
      var tempShape = elementFactory.createShape(newElement);
      canvas.addShape(tempShape, element.parent);
      var gfx = query('[data-element-id="' + (0, import_css2.default)(element.id) + '"]', context.dragGroup);
      if (gfx) {
        attr(gfx, { display: "none" });
      }
      var dragger = previewSupport.addDragger(tempShape, context.dragGroup);
      context.visualReplacements[id] = dragger;
      canvas.removeShape(tempShape);
    });
  }
  function restoreVisual(context) {
    var visualReplacements = context.visualReplacements;
    (0, import_min_dash137.forEach)(visualReplacements, function(dragger, id) {
      var originalGfx = query('[data-element-id="' + (0, import_css2.default)(id) + '"]', context.dragGroup);
      if (originalGfx) {
        attr(originalGfx, { display: "inline" });
      }
      dragger.remove();
      if (visualReplacements[id]) {
        delete visualReplacements[id];
      }
    });
  }
  eventBus.on("shape.move.move", LOW_PRIORITY27, function(event2) {
    var context = event2.context, canExecute = context.canExecute;
    if (!context.visualReplacements) {
      context.visualReplacements = {};
    }
    if (canExecute && canExecute.replacements) {
      replaceVisual(context);
    } else {
      restoreVisual(context);
    }
  });
}
BpmnReplacePreview.$inject = [
  "eventBus",
  "elementRegistry",
  "elementFactory",
  "canvas",
  "previewSupport"
];
e(BpmnReplacePreview, CommandInterceptor);

// node_modules/bpmn-js/lib/features/replace-preview/index.js
var replace_preview_default = {
  __depends__: [
    preview_support_default
  ],
  __init__: ["bpmnReplacePreview"],
  bpmnReplacePreview: ["type", BpmnReplacePreview]
};

// node_modules/bpmn-js/lib/features/snapping/BpmnConnectSnapping.js
var import_min_dash138 = __toESM(require_dist());
var HIGHER_PRIORITY3 = 1250;
var BOUNDARY_TO_HOST_THRESHOLD2 = 40;
var TARGET_BOUNDS_PADDING = 20;
var TASK_BOUNDS_PADDING = 10;
var TARGET_CENTER_PADDING = 20;
var AXES = ["x", "y"];
var abs7 = Math.abs;
function BpmnConnectSnapping(eventBus) {
  eventBus.on([
    "connect.hover",
    "connect.move",
    "connect.end"
  ], HIGHER_PRIORITY3, function(event2) {
    var context = event2.context, canExecute = context.canExecute, start = context.start, hover = context.hover, source = context.source, target = context.target;
    if (event2.originalEvent && isCmd(event2.originalEvent)) {
      return;
    }
    if (!context.initialConnectionStart) {
      context.initialConnectionStart = context.connectionStart;
    }
    if (canExecute && hover) {
      snapToShape(event2, hover, getTargetBoundsPadding(hover));
    }
    if (hover && isAnyType(canExecute, [
      "bpmn:Association",
      "bpmn:DataInputAssociation",
      "bpmn:DataOutputAssociation",
      "bpmn:SequenceFlow"
    ])) {
      context.connectionStart = mid(start);
      if (isAny(hover, ["bpmn:Event", "bpmn:Gateway"])) {
        snapToPosition(event2, mid(hover));
      }
      if (isAny(hover, ["bpmn:Task", "bpmn:SubProcess"])) {
        snapToTargetMid(event2, hover);
      }
      if (is(source, "bpmn:BoundaryEvent") && target === source.host) {
        snapBoundaryEventLoop(event2);
      }
    } else if (isType(canExecute, "bpmn:MessageFlow")) {
      if (is(start, "bpmn:Event")) {
        context.connectionStart = mid(start);
      }
      if (is(hover, "bpmn:Event")) {
        snapToPosition(event2, mid(hover));
      }
    } else {
      context.connectionStart = context.initialConnectionStart;
    }
  });
}
BpmnConnectSnapping.$inject = ["eventBus"];
function snapToShape(event2, target, padding) {
  AXES.forEach(function(axis) {
    var dimensionForAxis = getDimensionForAxis(axis, target);
    if (event2[axis] < target[axis] + padding) {
      setSnapped(event2, axis, target[axis] + padding);
    } else if (event2[axis] > target[axis] + dimensionForAxis - padding) {
      setSnapped(event2, axis, target[axis] + dimensionForAxis - padding);
    }
  });
}
function snapToTargetMid(event2, target) {
  var targetMid = mid(target);
  AXES.forEach(function(axis) {
    if (isMid(event2, target, axis)) {
      setSnapped(event2, axis, targetMid[axis]);
    }
  });
}
function snapBoundaryEventLoop(event2) {
  var context = event2.context, source = context.source, target = context.target;
  if (isReverse3(context)) {
    return;
  }
  var sourceMid = mid(source), orientation = getOrientation(sourceMid, target, -10), axes = [];
  if (/top|bottom/.test(orientation)) {
    axes.push("x");
  }
  if (/left|right/.test(orientation)) {
    axes.push("y");
  }
  axes.forEach(function(axis) {
    var coordinate = event2[axis], newCoordinate;
    if (abs7(coordinate - sourceMid[axis]) < BOUNDARY_TO_HOST_THRESHOLD2) {
      if (coordinate > sourceMid[axis]) {
        newCoordinate = sourceMid[axis] + BOUNDARY_TO_HOST_THRESHOLD2;
      } else {
        newCoordinate = sourceMid[axis] - BOUNDARY_TO_HOST_THRESHOLD2;
      }
      setSnapped(event2, axis, newCoordinate);
    }
  });
}
function snapToPosition(event2, position) {
  setSnapped(event2, "x", position.x);
  setSnapped(event2, "y", position.y);
}
function isType(attrs, type) {
  return attrs && attrs.type === type;
}
function isAnyType(attrs, types3) {
  return (0, import_min_dash138.some)(types3, function(type) {
    return isType(attrs, type);
  });
}
function getDimensionForAxis(axis, element) {
  return axis === "x" ? element.width : element.height;
}
function getTargetBoundsPadding(target) {
  if (is(target, "bpmn:Task")) {
    return TASK_BOUNDS_PADDING;
  } else {
    return TARGET_BOUNDS_PADDING;
  }
}
function isMid(event2, target, axis) {
  return event2[axis] > target[axis] + TARGET_CENTER_PADDING && event2[axis] < target[axis] + getDimensionForAxis(axis, target) - TARGET_CENTER_PADDING;
}
function isReverse3(context) {
  var hover = context.hover, source = context.source;
  return hover && source && hover === source;
}

// node_modules/diagram-js/lib/features/snapping/SnapContext.js
var import_min_dash139 = __toESM(require_dist());
function SnapContext() {
  this._targets = {};
  this._snapOrigins = {};
  this._snapLocations = [];
  this._defaultSnaps = {};
}
SnapContext.prototype.getSnapOrigin = function(snapLocation) {
  return this._snapOrigins[snapLocation];
};
SnapContext.prototype.setSnapOrigin = function(snapLocation, initialValue) {
  this._snapOrigins[snapLocation] = initialValue;
  if (this._snapLocations.indexOf(snapLocation) === -1) {
    this._snapLocations.push(snapLocation);
  }
};
SnapContext.prototype.addDefaultSnap = function(type, point) {
  var snapValues = this._defaultSnaps[type];
  if (!snapValues) {
    snapValues = this._defaultSnaps[type] = [];
  }
  snapValues.push(point);
};
SnapContext.prototype.getSnapLocations = function() {
  return this._snapLocations;
};
SnapContext.prototype.setSnapLocations = function(snapLocations) {
  this._snapLocations = snapLocations;
};
SnapContext.prototype.pointsForTarget = function(target) {
  var targetId = target.id || target;
  var snapPoints = this._targets[targetId];
  if (!snapPoints) {
    snapPoints = this._targets[targetId] = new SnapPoints();
    snapPoints.initDefaults(this._defaultSnaps);
  }
  return snapPoints;
};
function SnapPoints(defaultSnaps) {
  this._snapValues = {};
}
SnapPoints.prototype.add = function(snapLocation, point) {
  var snapValues = this._snapValues[snapLocation];
  if (!snapValues) {
    snapValues = this._snapValues[snapLocation] = { x: [], y: [] };
  }
  if (snapValues.x.indexOf(point.x) === -1) {
    snapValues.x.push(point.x);
  }
  if (snapValues.y.indexOf(point.y) === -1) {
    snapValues.y.push(point.y);
  }
};
SnapPoints.prototype.snap = function(point, snapLocation, axis, tolerance) {
  var snappingValues = this._snapValues[snapLocation];
  return snappingValues && snapTo(point[axis], snappingValues[axis], tolerance);
};
SnapPoints.prototype.initDefaults = function(defaultSnaps) {
  var self2 = this;
  (0, import_min_dash139.forEach)(defaultSnaps || {}, function(snapPoints, snapLocation) {
    (0, import_min_dash139.forEach)(snapPoints, function(point) {
      self2.add(snapLocation, point);
    });
  });
};

// node_modules/diagram-js/lib/features/snapping/CreateMoveSnapping.js
var import_min_dash140 = __toESM(require_dist());
var HIGHER_PRIORITY4 = 1250;
function CreateMoveSnapping(elementRegistry, eventBus, snapping) {
  var self2 = this;
  this._elementRegistry = elementRegistry;
  eventBus.on([
    "create.start",
    "shape.move.start"
  ], function(event2) {
    self2.initSnap(event2);
  });
  eventBus.on([
    "create.move",
    "create.end",
    "shape.move.move",
    "shape.move.end"
  ], HIGHER_PRIORITY4, function(event2) {
    var context = event2.context, shape = context.shape, snapContext = context.snapContext, target = context.target;
    if (event2.originalEvent && isCmd(event2.originalEvent)) {
      return;
    }
    if (isSnapped(event2) || !target) {
      return;
    }
    var snapPoints = snapContext.pointsForTarget(target);
    if (!snapPoints.initialized) {
      snapPoints = self2.addSnapTargetPoints(snapPoints, shape, target);
      snapPoints.initialized = true;
    }
    snapping.snap(event2, snapPoints);
  });
  eventBus.on([
    "create.cleanup",
    "shape.move.cleanup"
  ], function() {
    snapping.hide();
  });
}
CreateMoveSnapping.$inject = [
  "elementRegistry",
  "eventBus",
  "snapping"
];
CreateMoveSnapping.prototype.initSnap = function(event2) {
  var elementRegistry = this._elementRegistry;
  var context = event2.context, shape = context.shape, snapContext = context.snapContext;
  if (!snapContext) {
    snapContext = context.snapContext = new SnapContext();
  }
  var shapeMid;
  if (elementRegistry.get(shape.id)) {
    shapeMid = mid(shape, event2);
  } else {
    shapeMid = {
      x: event2.x + mid(shape).x,
      y: event2.y + mid(shape).y
    };
  }
  var shapeTopLeft = {
    x: shapeMid.x - shape.width / 2,
    y: shapeMid.y - shape.height / 2
  }, shapeBottomRight = {
    x: shapeMid.x + shape.width / 2,
    y: shapeMid.y + shape.height / 2
  };
  snapContext.setSnapOrigin("mid", {
    x: shapeMid.x - event2.x,
    y: shapeMid.y - event2.y
  });
  if (isLabel6(shape)) {
    return snapContext;
  }
  snapContext.setSnapOrigin("top-left", {
    x: shapeTopLeft.x - event2.x,
    y: shapeTopLeft.y - event2.y
  });
  snapContext.setSnapOrigin("bottom-right", {
    x: shapeBottomRight.x - event2.x,
    y: shapeBottomRight.y - event2.y
  });
  return snapContext;
};
CreateMoveSnapping.prototype.addSnapTargetPoints = function(snapPoints, shape, target) {
  var snapTargets = this.getSnapTargets(shape, target);
  (0, import_min_dash140.forEach)(snapTargets, function(snapTarget) {
    if (isLabel6(snapTarget)) {
      if (isLabel6(shape)) {
        snapPoints.add("mid", mid(snapTarget));
      }
      return;
    }
    if (isConnection15(snapTarget)) {
      if (snapTarget.waypoints.length < 3) {
        return;
      }
      var waypoints = snapTarget.waypoints.slice(1, -1);
      (0, import_min_dash140.forEach)(waypoints, function(waypoint) {
        snapPoints.add("mid", waypoint);
      });
      return;
    }
    snapPoints.add("mid", mid(snapTarget));
  });
  if (!(0, import_min_dash140.isNumber)(shape.x) || !(0, import_min_dash140.isNumber)(shape.y)) {
    return snapPoints;
  }
  if (this._elementRegistry.get(shape.id)) {
    snapPoints.add("mid", mid(shape));
  }
  return snapPoints;
};
CreateMoveSnapping.prototype.getSnapTargets = function(shape, target) {
  return getChildren2(target).filter(function(child) {
    return !isHidden(child);
  });
};
function isConnection15(element) {
  return !!element.waypoints;
}
function isHidden(element) {
  return !!element.hidden;
}
function isLabel6(element) {
  return !!element.labelTarget;
}

// node_modules/bpmn-js/lib/features/snapping/BpmnCreateMoveSnapping.js
var import_min_dash141 = __toESM(require_dist());
var HIGH_PRIORITY20 = 1500;
function BpmnCreateMoveSnapping(eventBus, injector) {
  injector.invoke(CreateMoveSnapping, this);
  eventBus.on(["create.move", "create.end"], HIGH_PRIORITY20, setSnappedIfConstrained);
  eventBus.on([
    "create.move",
    "create.end",
    "shape.move.move",
    "shape.move.end"
  ], HIGH_PRIORITY20, function(event2) {
    var context = event2.context, canExecute = context.canExecute, target = context.target;
    var canAttach2 = canExecute && (canExecute === "attach" || canExecute.attach);
    if (canAttach2 && !isSnapped(event2)) {
      snapBoundaryEvent(event2, target);
    }
  });
}
e(BpmnCreateMoveSnapping, CreateMoveSnapping);
BpmnCreateMoveSnapping.$inject = [
  "eventBus",
  "injector"
];
BpmnCreateMoveSnapping.prototype.initSnap = function(event2) {
  var snapContext = CreateMoveSnapping.prototype.initSnap.call(this, event2);
  var shape = event2.shape;
  var isMove = !!this._elementRegistry.get(shape.id);
  (0, import_min_dash141.forEach)(shape.outgoing, function(connection) {
    var docking = connection.waypoints[0];
    docking = docking.original || docking;
    snapContext.setSnapOrigin(connection.id + "-docking", getDockingSnapOrigin(docking, isMove, event2));
  });
  (0, import_min_dash141.forEach)(shape.incoming, function(connection) {
    var docking = connection.waypoints[connection.waypoints.length - 1];
    docking = docking.original || docking;
    snapContext.setSnapOrigin(connection.id + "-docking", getDockingSnapOrigin(docking, isMove, event2));
  });
  if (is(shape, "bpmn:Participant")) {
    snapContext.setSnapLocations(["top-left", "bottom-right", "mid"]);
  }
  return snapContext;
};
BpmnCreateMoveSnapping.prototype.addSnapTargetPoints = function(snapPoints, shape, target) {
  CreateMoveSnapping.prototype.addSnapTargetPoints.call(this, snapPoints, shape, target);
  var snapTargets = this.getSnapTargets(shape, target);
  (0, import_min_dash141.forEach)(snapTargets, function(snapTarget) {
    if (isContainer(snapTarget) || areAll([shape, snapTarget], "bpmn:TextAnnotation")) {
      snapPoints.add("top-left", topLeft(snapTarget));
      snapPoints.add("bottom-right", bottomRight(snapTarget));
    }
  });
  var elementRegistry = this._elementRegistry;
  (0, import_min_dash141.forEach)(shape.incoming, function(connection) {
    if (elementRegistry.get(shape.id)) {
      if (!includes9(snapTargets, connection.source)) {
        snapPoints.add("mid", getMid(connection.source));
      }
      var docking = connection.waypoints[0];
      snapPoints.add(connection.id + "-docking", docking.original || docking);
    }
  });
  (0, import_min_dash141.forEach)(shape.outgoing, function(connection) {
    if (elementRegistry.get(shape.id)) {
      if (!includes9(snapTargets, connection.target)) {
        snapPoints.add("mid", getMid(connection.target));
      }
      var docking = connection.waypoints[connection.waypoints.length - 1];
      snapPoints.add(connection.id + "-docking", docking.original || docking);
    }
  });
  if (is(target, "bpmn:SequenceFlow")) {
    snapPoints = this.addSnapTargetPoints(snapPoints, shape, target.parent);
  }
  return snapPoints;
};
BpmnCreateMoveSnapping.prototype.getSnapTargets = function(shape, target) {
  return CreateMoveSnapping.prototype.getSnapTargets.call(this, shape, target).filter(function(snapTarget) {
    return !is(snapTarget, "bpmn:Lane");
  });
};
function snapBoundaryEvent(event2, target) {
  var targetTRBL = asTRBL(target);
  var direction = getBoundaryAttachment(event2, target);
  var context = event2.context, shape = context.shape;
  var offset;
  if (shape.parent) {
    offset = { x: 0, y: 0 };
  } else {
    offset = getMid(shape);
  }
  if (/top/.test(direction)) {
    setSnapped(event2, "y", targetTRBL.top - offset.y);
  } else if (/bottom/.test(direction)) {
    setSnapped(event2, "y", targetTRBL.bottom - offset.y);
  }
  if (/left/.test(direction)) {
    setSnapped(event2, "x", targetTRBL.left - offset.x);
  } else if (/right/.test(direction)) {
    setSnapped(event2, "x", targetTRBL.right - offset.x);
  }
}
function areAll(elements, type) {
  return elements.every(function(el) {
    return is(el, type);
  });
}
function isContainer(element) {
  if (is(element, "bpmn:SubProcess") && isExpanded(element)) {
    return true;
  }
  return is(element, "bpmn:Participant");
}
function setSnappedIfConstrained(event2) {
  var context = event2.context, createConstraints = context.createConstraints;
  if (!createConstraints) {
    return;
  }
  var top = createConstraints.top, right = createConstraints.right, bottom = createConstraints.bottom, left = createConstraints.left;
  if (left && left >= event2.x || right && right <= event2.x) {
    setSnapped(event2, "x", event2.x);
  }
  if (top && top >= event2.y || bottom && bottom <= event2.y) {
    setSnapped(event2, "y", event2.y);
  }
}
function includes9(array, value) {
  return array.indexOf(value) !== -1;
}
function getDockingSnapOrigin(docking, isMove, event2) {
  return isMove ? {
    x: docking.x - event2.x,
    y: docking.y - event2.y
  } : {
    x: docking.x,
    y: docking.y
  };
}

// node_modules/diagram-js/lib/features/snapping/ResizeSnapping.js
var import_min_dash142 = __toESM(require_dist());
var HIGHER_PRIORITY5 = 1250;
function ResizeSnapping(eventBus, snapping) {
  var self2 = this;
  eventBus.on(["resize.start"], function(event2) {
    self2.initSnap(event2);
  });
  eventBus.on([
    "resize.move",
    "resize.end"
  ], HIGHER_PRIORITY5, function(event2) {
    var context = event2.context, shape = context.shape, parent = shape.parent, direction = context.direction, snapContext = context.snapContext;
    if (event2.originalEvent && isCmd(event2.originalEvent)) {
      return;
    }
    if (isSnapped(event2)) {
      return;
    }
    var snapPoints = snapContext.pointsForTarget(parent);
    if (!snapPoints.initialized) {
      snapPoints = self2.addSnapTargetPoints(snapPoints, shape, parent, direction);
      snapPoints.initialized = true;
    }
    if (isHorizontal4(direction)) {
      setSnapped(event2, "x", event2.x);
    }
    if (isVertical(direction)) {
      setSnapped(event2, "y", event2.y);
    }
    snapping.snap(event2, snapPoints);
  });
  eventBus.on(["resize.cleanup"], function() {
    snapping.hide();
  });
}
ResizeSnapping.prototype.initSnap = function(event2) {
  var context = event2.context, shape = context.shape, direction = context.direction, snapContext = context.snapContext;
  if (!snapContext) {
    snapContext = context.snapContext = new SnapContext();
  }
  var snapOrigin = getSnapOrigin(shape, direction);
  snapContext.setSnapOrigin("corner", {
    x: snapOrigin.x - event2.x,
    y: snapOrigin.y - event2.y
  });
  return snapContext;
};
ResizeSnapping.prototype.addSnapTargetPoints = function(snapPoints, shape, target, direction) {
  var snapTargets = this.getSnapTargets(shape, target);
  (0, import_min_dash142.forEach)(snapTargets, function(snapTarget) {
    snapPoints.add("corner", bottomRight(snapTarget));
    snapPoints.add("corner", topLeft(snapTarget));
  });
  snapPoints.add("corner", getSnapOrigin(shape, direction));
  return snapPoints;
};
ResizeSnapping.$inject = [
  "eventBus",
  "snapping"
];
ResizeSnapping.prototype.getSnapTargets = function(shape, target) {
  return getChildren2(target).filter(function(child) {
    return !isAttached(child, shape) && !isConnection16(child) && !isHidden2(child) && !isLabel7(child);
  });
};
function getSnapOrigin(shape, direction) {
  var mid4 = getMid(shape), trbl = asTRBL(shape);
  var snapOrigin = {
    x: mid4.x,
    y: mid4.y
  };
  if (direction.indexOf("n") !== -1) {
    snapOrigin.y = trbl.top;
  } else if (direction.indexOf("s") !== -1) {
    snapOrigin.y = trbl.bottom;
  }
  if (direction.indexOf("e") !== -1) {
    snapOrigin.x = trbl.right;
  } else if (direction.indexOf("w") !== -1) {
    snapOrigin.x = trbl.left;
  }
  return snapOrigin;
}
function isAttached(element, host) {
  return element.host === host;
}
function isConnection16(element) {
  return !!element.waypoints;
}
function isHidden2(element) {
  return !!element.hidden;
}
function isLabel7(element) {
  return !!element.labelTarget;
}
function isHorizontal4(direction) {
  return direction === "n" || direction === "s";
}
function isVertical(direction) {
  return direction === "e" || direction === "w";
}

// node_modules/diagram-js/lib/features/snapping/Snapping.js
var import_min_dash143 = __toESM(require_dist());
var SNAP_TOLERANCE = 7;
var SNAP_LINE_HIDE_DELAY = 1e3;
function Snapping(canvas) {
  this._canvas = canvas;
  this._asyncHide = (0, import_min_dash143.debounce)((0, import_min_dash143.bind)(this.hide, this), SNAP_LINE_HIDE_DELAY);
}
Snapping.$inject = ["canvas"];
Snapping.prototype.snap = function(event2, snapPoints) {
  var context = event2.context, snapContext = context.snapContext, snapLocations = snapContext.getSnapLocations();
  var snapping = {
    x: isSnapped(event2, "x"),
    y: isSnapped(event2, "y")
  };
  (0, import_min_dash143.forEach)(snapLocations, function(location) {
    var snapOrigin = snapContext.getSnapOrigin(location);
    var snapCurrent = {
      x: event2.x + snapOrigin.x,
      y: event2.y + snapOrigin.y
    };
    (0, import_min_dash143.forEach)(["x", "y"], function(axis) {
      var locationSnapping;
      if (!snapping[axis]) {
        locationSnapping = snapPoints.snap(snapCurrent, location, axis, SNAP_TOLERANCE);
        if (locationSnapping !== void 0) {
          snapping[axis] = {
            value: locationSnapping,
            originValue: locationSnapping - snapOrigin[axis]
          };
        }
      }
    });
    if (snapping.x && snapping.y) {
      return false;
    }
  });
  this.showSnapLine("vertical", snapping.x && snapping.x.value);
  this.showSnapLine("horizontal", snapping.y && snapping.y.value);
  (0, import_min_dash143.forEach)(["x", "y"], function(axis) {
    var axisSnapping = snapping[axis];
    if ((0, import_min_dash143.isObject)(axisSnapping)) {
      setSnapped(event2, axis, axisSnapping.originValue);
    }
  });
};
Snapping.prototype._createLine = function(orientation) {
  var root = this._canvas.getLayer("snap");
  var line = create("path");
  attr(line, { d: "M0,0 L0,0" });
  classes(line).add("djs-snap-line");
  append(root, line);
  return {
    update: function(position) {
      if (!(0, import_min_dash143.isNumber)(position)) {
        attr(line, { display: "none" });
      } else {
        if (orientation === "horizontal") {
          attr(line, {
            d: "M-100000," + position + " L+100000," + position,
            display: ""
          });
        } else {
          attr(line, {
            d: "M " + position + ",-100000 L " + position + ", +100000",
            display: ""
          });
        }
      }
    }
  };
};
Snapping.prototype._createSnapLines = function() {
  this._snapLines = {
    horizontal: this._createLine("horizontal"),
    vertical: this._createLine("vertical")
  };
};
Snapping.prototype.showSnapLine = function(orientation, position) {
  var line = this.getSnapLine(orientation);
  if (line) {
    line.update(position);
  }
  this._asyncHide();
};
Snapping.prototype.getSnapLine = function(orientation) {
  if (!this._snapLines) {
    this._createSnapLines();
  }
  return this._snapLines[orientation];
};
Snapping.prototype.hide = function() {
  (0, import_min_dash143.forEach)(this._snapLines, function(snapLine) {
    snapLine.update();
  });
};

// node_modules/diagram-js/lib/features/snapping/index.js
var snapping_default = {
  __init__: [
    "createMoveSnapping",
    "resizeSnapping",
    "snapping"
  ],
  createMoveSnapping: ["type", CreateMoveSnapping],
  resizeSnapping: ["type", ResizeSnapping],
  snapping: ["type", Snapping]
};

// node_modules/bpmn-js/lib/features/snapping/index.js
var snapping_default2 = {
  __depends__: [snapping_default],
  __init__: [
    "connectSnapping",
    "createMoveSnapping"
  ],
  connectSnapping: ["type", BpmnConnectSnapping],
  createMoveSnapping: ["type", BpmnCreateMoveSnapping]
};

// node_modules/diagram-js/lib/features/search-pad/SearchPad.js
function SearchPad(canvas, eventBus, overlays, selection) {
  this._open = false;
  this._results = [];
  this._eventMaps = [];
  this._canvas = canvas;
  this._eventBus = eventBus;
  this._overlays = overlays;
  this._selection = selection;
  this._container = domify$1(SearchPad.BOX_HTML);
  this._searchInput = query(SearchPad.INPUT_SELECTOR, this._container);
  this._resultsContainer = query(SearchPad.RESULTS_CONTAINER_SELECTOR, this._container);
  this._canvas.getContainer().appendChild(this._container);
  eventBus.on(["canvas.destroy", "diagram.destroy"], this.close, this);
}
SearchPad.$inject = [
  "canvas",
  "eventBus",
  "overlays",
  "selection"
];
SearchPad.prototype._bindEvents = function() {
  var self2 = this;
  function listen(el, selector, type, fn2) {
    self2._eventMaps.push({
      el,
      type,
      listener: delegate.bind(el, selector, type, fn2)
    });
  }
  listen(document, "html", "click", function(e7) {
    self2.close();
  });
  listen(this._container, SearchPad.INPUT_SELECTOR, "click", function(e7) {
    e7.stopPropagation();
    e7.delegateTarget.focus();
  });
  listen(this._container, SearchPad.RESULT_SELECTOR, "mouseover", function(e7) {
    e7.stopPropagation();
    self2._scrollToNode(e7.delegateTarget);
    self2._preselect(e7.delegateTarget);
  });
  listen(this._container, SearchPad.RESULT_SELECTOR, "click", function(e7) {
    e7.stopPropagation();
    self2._select(e7.delegateTarget);
  });
  listen(this._container, SearchPad.INPUT_SELECTOR, "keydown", function(e7) {
    if (isKey("ArrowUp", e7)) {
      e7.preventDefault();
    }
    if (isKey("ArrowDown", e7)) {
      e7.preventDefault();
    }
  });
  listen(this._container, SearchPad.INPUT_SELECTOR, "keyup", function(e7) {
    if (isKey("Escape", e7)) {
      return self2.close();
    }
    if (isKey("Enter", e7)) {
      var selected = self2._getCurrentResult();
      return selected ? self2._select(selected) : self2.close();
    }
    if (isKey("ArrowUp", e7)) {
      return self2._scrollToDirection(true);
    }
    if (isKey("ArrowDown", e7)) {
      return self2._scrollToDirection();
    }
    if (isKey(["ArrowLeft", "ArrowRight"], e7)) {
      return;
    }
    self2._search(e7.delegateTarget.value);
  });
};
SearchPad.prototype._unbindEvents = function() {
  this._eventMaps.forEach(function(m6) {
    delegate.unbind(m6.el, m6.type, m6.listener);
  });
};
SearchPad.prototype._search = function(pattern) {
  var self2 = this;
  this._clearResults();
  if (!pattern || pattern === "") {
    return;
  }
  var searchResults = this._searchProvider.find(pattern);
  if (!searchResults.length) {
    return;
  }
  searchResults.forEach(function(result) {
    var id = result.element.id;
    var node3 = self2._createResultNode(result, id);
    self2._results[id] = {
      element: result.element,
      node: node3
    };
  });
  var node2 = query(SearchPad.RESULT_SELECTOR, this._resultsContainer);
  this._scrollToNode(node2);
  this._preselect(node2);
};
SearchPad.prototype._scrollToDirection = function(previous) {
  var selected = this._getCurrentResult();
  if (!selected) {
    return;
  }
  var node2 = previous ? selected.previousElementSibling : selected.nextElementSibling;
  if (node2) {
    this._scrollToNode(node2);
    this._preselect(node2);
  }
};
SearchPad.prototype._scrollToNode = function(node2) {
  if (!node2 || node2 === this._getCurrentResult()) {
    return;
  }
  var nodeOffset = node2.offsetTop;
  var containerScroll = this._resultsContainer.scrollTop;
  var bottomScroll = nodeOffset - this._resultsContainer.clientHeight + node2.clientHeight;
  if (nodeOffset < containerScroll) {
    this._resultsContainer.scrollTop = nodeOffset;
  } else if (containerScroll < bottomScroll) {
    this._resultsContainer.scrollTop = bottomScroll;
  }
};
SearchPad.prototype._clearResults = function() {
  clear2(this._resultsContainer);
  this._results = [];
  this._resetOverlay();
  this._eventBus.fire("searchPad.cleared");
};
SearchPad.prototype._getCurrentResult = function() {
  return query(SearchPad.RESULT_SELECTED_SELECTOR, this._resultsContainer);
};
SearchPad.prototype._createResultNode = function(result, id) {
  var node2 = domify$1(SearchPad.RESULT_HTML);
  if (result.primaryTokens.length > 0) {
    createInnerTextNode(node2, result.primaryTokens, SearchPad.RESULT_PRIMARY_HTML);
  }
  createInnerTextNode(node2, result.secondaryTokens, SearchPad.RESULT_SECONDARY_HTML);
  attr2(node2, SearchPad.RESULT_ID_ATTRIBUTE, id);
  this._resultsContainer.appendChild(node2);
  return node2;
};
SearchPad.prototype.registerProvider = function(provider) {
  this._searchProvider = provider;
};
SearchPad.prototype.open = function() {
  if (!this._searchProvider) {
    throw new Error("no search provider registered");
  }
  if (this.isOpen()) {
    return;
  }
  this._bindEvents();
  this._open = true;
  classes2(this._container).add("open");
  this._searchInput.focus();
  this._eventBus.fire("searchPad.opened");
};
SearchPad.prototype.close = function() {
  if (!this.isOpen()) {
    return;
  }
  this._unbindEvents();
  this._open = false;
  classes2(this._container).remove("open");
  this._clearResults();
  this._searchInput.value = "";
  this._searchInput.blur();
  this._resetOverlay();
  this._eventBus.fire("searchPad.closed");
};
SearchPad.prototype.toggle = function() {
  this.isOpen() ? this.close() : this.open();
};
SearchPad.prototype.isOpen = function() {
  return this._open;
};
SearchPad.prototype._preselect = function(node2) {
  var selectedNode = this._getCurrentResult();
  if (node2 === selectedNode) {
    return;
  }
  if (selectedNode) {
    classes2(selectedNode).remove(SearchPad.RESULT_SELECTED_CLASS);
  }
  var id = attr2(node2, SearchPad.RESULT_ID_ATTRIBUTE);
  var element = this._results[id].element;
  classes2(node2).add(SearchPad.RESULT_SELECTED_CLASS);
  this._resetOverlay(element);
  this._canvas.scrollToElement(element, { top: 400 });
  this._selection.select(element);
  this._eventBus.fire("searchPad.preselected", element);
};
SearchPad.prototype._select = function(node2) {
  var id = attr2(node2, SearchPad.RESULT_ID_ATTRIBUTE);
  var element = this._results[id].element;
  this.close();
  this._resetOverlay();
  this._canvas.scrollToElement(element, { top: 400 });
  this._selection.select(element);
  this._eventBus.fire("searchPad.selected", element);
};
SearchPad.prototype._resetOverlay = function(element) {
  if (this._overlayId) {
    this._overlays.remove(this._overlayId);
  }
  if (element) {
    var box = getBBox(element);
    var overlay = constructOverlay(box);
    this._overlayId = this._overlays.add(element, overlay);
  }
};
function constructOverlay(box) {
  var offset = 6;
  var w6 = box.width + offset * 2;
  var h5 = box.height + offset * 2;
  var styles = {
    width: w6 + "px",
    height: h5 + "px"
  };
  var html = domify$1('<div class="' + SearchPad.OVERLAY_CLASS + '"></div>');
  assign(html, styles);
  return {
    position: {
      bottom: h5 - offset,
      right: w6 - offset
    },
    show: true,
    html
  };
}
function createInnerTextNode(parentNode, tokens, template) {
  var text = createHtmlText(tokens);
  var childNode = domify$1(template);
  childNode.innerHTML = text;
  parentNode.appendChild(childNode);
}
function createHtmlText(tokens) {
  var htmlText = "";
  tokens.forEach(function(t6) {
    if (t6.matched) {
      htmlText += '<strong class="' + SearchPad.RESULT_HIGHLIGHT_CLASS + '">' + escapeHTML(t6.matched) + "</strong>";
    } else {
      htmlText += escapeHTML(t6.normal);
    }
  });
  return htmlText !== "" ? htmlText : null;
}
SearchPad.CONTAINER_SELECTOR = ".djs-search-container";
SearchPad.INPUT_SELECTOR = ".djs-search-input input";
SearchPad.RESULTS_CONTAINER_SELECTOR = ".djs-search-results";
SearchPad.RESULT_SELECTOR = ".djs-search-result";
SearchPad.RESULT_SELECTED_CLASS = "djs-search-result-selected";
SearchPad.RESULT_SELECTED_SELECTOR = "." + SearchPad.RESULT_SELECTED_CLASS;
SearchPad.RESULT_ID_ATTRIBUTE = "data-result-id";
SearchPad.RESULT_HIGHLIGHT_CLASS = "djs-search-highlight";
SearchPad.OVERLAY_CLASS = "djs-search-overlay";
SearchPad.BOX_HTML = '<div class="djs-search-container djs-draggable djs-scrollable"><div class="djs-search-input"><input type="text"/></div><div class="djs-search-results"></div></div>';
SearchPad.RESULT_HTML = '<div class="djs-search-result"></div>';
SearchPad.RESULT_PRIMARY_HTML = '<div class="djs-search-result-primary"></div>';
SearchPad.RESULT_SECONDARY_HTML = '<p class="djs-search-result-secondary"></p>';

// node_modules/diagram-js/lib/features/search-pad/index.js
var search_pad_default = {
  __depends__: [
    overlays_default,
    selection_default
  ],
  searchPad: ["type", SearchPad]
};

// node_modules/bpmn-js/lib/features/search/BpmnSearchProvider.js
var import_min_dash144 = __toESM(require_dist());
function BpmnSearchProvider(elementRegistry, searchPad, canvas) {
  this._elementRegistry = elementRegistry;
  this._canvas = canvas;
  searchPad.registerProvider(this);
}
BpmnSearchProvider.$inject = [
  "elementRegistry",
  "searchPad",
  "canvas"
];
BpmnSearchProvider.prototype.find = function(pattern) {
  var rootElement = this._canvas.getRootElement();
  var elements = this._elementRegistry.filter(function(element) {
    if (element.labelTarget) {
      return false;
    }
    return true;
  });
  elements = (0, import_min_dash144.filter)(elements, function(element) {
    return element !== rootElement;
  });
  elements = (0, import_min_dash144.map)(elements, function(element) {
    return {
      primaryTokens: matchAndSplit(getLabel(element), pattern),
      secondaryTokens: matchAndSplit(element.id, pattern),
      element
    };
  });
  elements = (0, import_min_dash144.filter)(elements, function(element) {
    return hasMatched(element.primaryTokens) || hasMatched(element.secondaryTokens);
  });
  elements = (0, import_min_dash144.sortBy)(elements, function(element) {
    return getLabel(element.element) + element.element.id;
  });
  return elements;
};
function hasMatched(tokens) {
  var matched = (0, import_min_dash144.filter)(tokens, function(t6) {
    return !!t6.matched;
  });
  return matched.length > 0;
}
function matchAndSplit(text, pattern) {
  var tokens = [], originalText = text;
  if (!text) {
    return tokens;
  }
  text = text.toLowerCase();
  pattern = pattern.toLowerCase();
  var i6 = text.indexOf(pattern);
  if (i6 > -1) {
    if (i6 !== 0) {
      tokens.push({
        normal: originalText.substr(0, i6)
      });
    }
    tokens.push({
      matched: originalText.substr(i6, pattern.length)
    });
    if (pattern.length + i6 < text.length) {
      tokens.push({
        normal: originalText.substr(pattern.length + i6, text.length)
      });
    }
  } else {
    tokens.push({
      normal: originalText
    });
  }
  return tokens;
}

// node_modules/bpmn-js/lib/features/search/index.js
var search_default = {
  __depends__: [
    search_pad_default
  ],
  __init__: ["bpmnSearch"],
  bpmnSearch: ["type", BpmnSearchProvider]
};

// node_modules/bpmn-js/lib/Modeler.js
var initialDiagram = '<?xml version="1.0" encoding="UTF-8"?><bpmn:definitions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:bpmn="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:dc="http://www.omg.org/spec/DD/20100524/DC" targetNamespace="http://bpmn.io/schema/bpmn" id="Definitions_1"><bpmn:process id="Process_1" isExecutable="false"><bpmn:startEvent id="StartEvent_1"/></bpmn:process><bpmndi:BPMNDiagram id="BPMNDiagram_1"><bpmndi:BPMNPlane id="BPMNPlane_1" bpmnElement="Process_1"><bpmndi:BPMNShape id="_BPMNShape_StartEvent_2" bpmnElement="StartEvent_1"><dc:Bounds height="36.0" width="36.0" x="173.0" y="102.0"/></bpmndi:BPMNShape></bpmndi:BPMNPlane></bpmndi:BPMNDiagram></bpmn:definitions>';
function Modeler(options2) {
  BaseModeler.call(this, options2);
}
e(Modeler, BaseModeler);
Modeler.Viewer = Viewer;
Modeler.NavigatedViewer = NavigatedViewer;
Modeler.prototype.createDiagram = wrapForCompatibility(function createDiagram() {
  return this.importXML(initialDiagram);
});
Modeler.prototype._interactionModules = [
  keyboard_move_default,
  movecanvas_default,
  touch_default2,
  zoomscroll_default
];
Modeler.prototype._modelingModules = [
  align_elements_default2,
  auto_place_default2,
  auto_scroll_default,
  auto_resize_default,
  bendpoints_default,
  connect_default,
  connection_preview_default,
  context_pad_default2,
  copy_paste_default2,
  create_default,
  distribute_elements_default2,
  editor_actions_default2,
  grid_snapping_default2,
  interaction_events_default2,
  keyboard_default2,
  keyboard_move_selection_default,
  label_editing_default,
  modeling_default,
  move_default,
  palette_default2,
  replace_preview_default,
  resize_default,
  snapping_default2,
  search_default
];
Modeler.prototype._modules = [].concat(Viewer.prototype._modules, Modeler.prototype._interactionModules, Modeler.prototype._modelingModules);

// node_modules/@bpmn-io/properties-panel/preact/dist/preact.module.js
var n3;
var l3;
var u3;
var i3;
var t4;
var o3;
var r4 = {};
var f3 = [];
var e4 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
function c3(n5, l6) {
  for (var u5 in l6)
    n5[u5] = l6[u5];
  return n5;
}
function s3(n5) {
  var l6 = n5.parentNode;
  l6 && l6.removeChild(n5);
}
function a3(n5, l6, u5) {
  var i6, t6, o7, r6 = arguments, f5 = {};
  for (o7 in l6)
    o7 == "key" ? i6 = l6[o7] : o7 == "ref" ? t6 = l6[o7] : f5[o7] = l6[o7];
  if (arguments.length > 3)
    for (u5 = [u5], o7 = 3; o7 < arguments.length; o7++)
      u5.push(r6[o7]);
  if (u5 != null && (f5.children = u5), typeof n5 == "function" && n5.defaultProps != null)
    for (o7 in n5.defaultProps)
      f5[o7] === void 0 && (f5[o7] = n5.defaultProps[o7]);
  return v3(n5, f5, i6, t6, null);
}
function v3(l6, u5, i6, t6, o7) {
  var r6 = { type: l6, props: u5, key: i6, ref: t6, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: o7 == null ? ++n3.__v : o7 };
  return n3.vnode != null && n3.vnode(r6), r6;
}
function h3() {
  return { current: null };
}
function y2(n5) {
  return n5.children;
}
function p3(n5, l6) {
  this.props = n5, this.context = l6;
}
function d3(n5, l6) {
  if (l6 == null)
    return n5.__ ? d3(n5.__, n5.__.__k.indexOf(n5) + 1) : null;
  for (var u5; l6 < n5.__k.length; l6++)
    if ((u5 = n5.__k[l6]) != null && u5.__e != null)
      return u5.__e;
  return typeof n5.type == "function" ? d3(n5) : null;
}
function _3(n5) {
  var l6, u5;
  if ((n5 = n5.__) != null && n5.__c != null) {
    for (n5.__e = n5.__c.base = null, l6 = 0; l6 < n5.__k.length; l6++)
      if ((u5 = n5.__k[l6]) != null && u5.__e != null) {
        n5.__e = n5.__c.base = u5.__e;
        break;
      }
    return _3(n5);
  }
}
function k3(l6) {
  (!l6.__d && (l6.__d = true) && u3.push(l6) && !b3.__r++ || t4 !== n3.debounceRendering) && ((t4 = n3.debounceRendering) || i3)(b3);
}
function b3() {
  for (var n5; b3.__r = u3.length; )
    n5 = u3.sort(function(n6, l6) {
      return n6.__v.__b - l6.__v.__b;
    }), u3 = [], n5.some(function(n6) {
      var l6, u5, i6, t6, o7, r6;
      n6.__d && (o7 = (t6 = (l6 = n6).__v).__e, (r6 = l6.__P) && (u5 = [], (i6 = c3({}, t6)).__v = t6.__v + 1, I2(r6, t6, i6, l6.__n, r6.ownerSVGElement !== void 0, t6.__h != null ? [o7] : null, u5, o7 == null ? d3(t6) : o7, t6.__h), T3(u5, t6), t6.__e != o7 && _3(t6)));
    });
}
function m4(n5, l6, u5, i6, t6, o7, e7, c5, s5, a6) {
  var h5, p6, _5, k6, b5, m6, w6, A5 = i6 && i6.__k || f3, P4 = A5.length;
  for (u5.__k = [], h5 = 0; h5 < l6.length; h5++)
    if ((k6 = u5.__k[h5] = (k6 = l6[h5]) == null || typeof k6 == "boolean" ? null : typeof k6 == "string" || typeof k6 == "number" || typeof k6 == "bigint" ? v3(null, k6, null, null, k6) : Array.isArray(k6) ? v3(y2, { children: k6 }, null, null, null) : k6.__b > 0 ? v3(k6.type, k6.props, k6.key, null, k6.__v) : k6) != null) {
      if (k6.__ = u5, k6.__b = u5.__b + 1, (_5 = A5[h5]) === null || _5 && k6.key == _5.key && k6.type === _5.type)
        A5[h5] = void 0;
      else
        for (p6 = 0; p6 < P4; p6++) {
          if ((_5 = A5[p6]) && k6.key == _5.key && k6.type === _5.type) {
            A5[p6] = void 0;
            break;
          }
          _5 = null;
        }
      I2(n5, k6, _5 = _5 || r4, t6, o7, e7, c5, s5, a6), b5 = k6.__e, (p6 = k6.ref) && _5.ref != p6 && (w6 || (w6 = []), _5.ref && w6.push(_5.ref, null, k6), w6.push(p6, k6.__c || b5, k6)), b5 != null ? (m6 == null && (m6 = b5), typeof k6.type == "function" && k6.__k != null && k6.__k === _5.__k ? k6.__d = s5 = g3(k6, s5, n5) : s5 = x(n5, k6, _5, A5, b5, s5), a6 || u5.type !== "option" ? typeof u5.type == "function" && (u5.__d = s5) : n5.value = "") : s5 && _5.__e == s5 && s5.parentNode != n5 && (s5 = d3(_5));
    }
  for (u5.__e = m6, h5 = P4; h5--; )
    A5[h5] != null && (typeof u5.type == "function" && A5[h5].__e != null && A5[h5].__e == u5.__d && (u5.__d = d3(i6, h5 + 1)), L2(A5[h5], A5[h5]));
  if (w6)
    for (h5 = 0; h5 < w6.length; h5++)
      z3(w6[h5], w6[++h5], w6[++h5]);
}
function g3(n5, l6, u5) {
  var i6, t6;
  for (i6 = 0; i6 < n5.__k.length; i6++)
    (t6 = n5.__k[i6]) && (t6.__ = n5, l6 = typeof t6.type == "function" ? g3(t6, l6, u5) : x(u5, t6, t6, n5.__k, t6.__e, l6));
  return l6;
}
function w3(n5, l6) {
  return l6 = l6 || [], n5 == null || typeof n5 == "boolean" || (Array.isArray(n5) ? n5.some(function(n6) {
    w3(n6, l6);
  }) : l6.push(n5)), l6;
}
function x(n5, l6, u5, i6, t6, o7) {
  var r6, f5, e7;
  if (l6.__d !== void 0)
    r6 = l6.__d, l6.__d = void 0;
  else if (u5 == null || t6 != o7 || t6.parentNode == null)
    n:
      if (o7 == null || o7.parentNode !== n5)
        n5.appendChild(t6), r6 = null;
      else {
        for (f5 = o7, e7 = 0; (f5 = f5.nextSibling) && e7 < i6.length; e7 += 2)
          if (f5 == t6)
            break n;
        n5.insertBefore(t6, o7), r6 = o7;
      }
  return r6 !== void 0 ? r6 : t6.nextSibling;
}
function A2(n5, l6, u5, i6, t6) {
  var o7;
  for (o7 in u5)
    o7 === "children" || o7 === "key" || o7 in l6 || C2(n5, o7, null, u5[o7], i6);
  for (o7 in l6)
    t6 && typeof l6[o7] != "function" || o7 === "children" || o7 === "key" || o7 === "value" || o7 === "checked" || u5[o7] === l6[o7] || C2(n5, o7, l6[o7], u5[o7], i6);
}
function P2(n5, l6, u5) {
  l6[0] === "-" ? n5.setProperty(l6, u5) : n5[l6] = u5 == null ? "" : typeof u5 != "number" || e4.test(l6) ? u5 : u5 + "px";
}
function C2(n5, l6, u5, i6, t6) {
  var o7;
  n:
    if (l6 === "style")
      if (typeof u5 == "string")
        n5.style.cssText = u5;
      else {
        if (typeof i6 == "string" && (n5.style.cssText = i6 = ""), i6)
          for (l6 in i6)
            u5 && l6 in u5 || P2(n5.style, l6, "");
        if (u5)
          for (l6 in u5)
            i6 && u5[l6] === i6[l6] || P2(n5.style, l6, u5[l6]);
      }
    else if (l6[0] === "o" && l6[1] === "n")
      o7 = l6 !== (l6 = l6.replace(/Capture$/, "")), l6 = l6.toLowerCase() in n5 ? l6.toLowerCase().slice(2) : l6.slice(2), n5.l || (n5.l = {}), n5.l[l6 + o7] = u5, u5 ? i6 || n5.addEventListener(l6, o7 ? H2 : $2, o7) : n5.removeEventListener(l6, o7 ? H2 : $2, o7);
    else if (l6 !== "dangerouslySetInnerHTML") {
      if (t6)
        l6 = l6.replace(/xlink[H:h]/, "h").replace(/sName$/, "s");
      else if (l6 !== "href" && l6 !== "list" && l6 !== "form" && l6 !== "tabIndex" && l6 !== "download" && l6 in n5)
        try {
          n5[l6] = u5 == null ? "" : u5;
          break n;
        } catch (n6) {
        }
      typeof u5 == "function" || (u5 != null && (u5 !== false || l6[0] === "a" && l6[1] === "r") ? n5.setAttribute(l6, u5) : n5.removeAttribute(l6));
    }
}
function $2(l6) {
  this.l[l6.type + false](n3.event ? n3.event(l6) : l6);
}
function H2(l6) {
  this.l[l6.type + true](n3.event ? n3.event(l6) : l6);
}
function I2(l6, u5, i6, t6, o7, r6, f5, e7, s5) {
  var a6, v5, h5, d5, _5, k6, b5, g6, w6, x4, A5, P4 = u5.type;
  if (u5.constructor !== void 0)
    return null;
  i6.__h != null && (s5 = i6.__h, e7 = u5.__e = i6.__e, u5.__h = null, r6 = [e7]), (a6 = n3.__b) && a6(u5);
  try {
    n:
      if (typeof P4 == "function") {
        if (g6 = u5.props, w6 = (a6 = P4.contextType) && t6[a6.__c], x4 = a6 ? w6 ? w6.props.value : a6.__ : t6, i6.__c ? b5 = (v5 = u5.__c = i6.__c).__ = v5.__E : ("prototype" in P4 && P4.prototype.render ? u5.__c = v5 = new P4(g6, x4) : (u5.__c = v5 = new p3(g6, x4), v5.constructor = P4, v5.render = M2), w6 && w6.sub(v5), v5.props = g6, v5.state || (v5.state = {}), v5.context = x4, v5.__n = t6, h5 = v5.__d = true, v5.__h = []), v5.__s == null && (v5.__s = v5.state), P4.getDerivedStateFromProps != null && (v5.__s == v5.state && (v5.__s = c3({}, v5.__s)), c3(v5.__s, P4.getDerivedStateFromProps(g6, v5.__s))), d5 = v5.props, _5 = v5.state, h5)
          P4.getDerivedStateFromProps == null && v5.componentWillMount != null && v5.componentWillMount(), v5.componentDidMount != null && v5.__h.push(v5.componentDidMount);
        else {
          if (P4.getDerivedStateFromProps == null && g6 !== d5 && v5.componentWillReceiveProps != null && v5.componentWillReceiveProps(g6, x4), !v5.__e && v5.shouldComponentUpdate != null && v5.shouldComponentUpdate(g6, v5.__s, x4) === false || u5.__v === i6.__v) {
            v5.props = g6, v5.state = v5.__s, u5.__v !== i6.__v && (v5.__d = false), v5.__v = u5, u5.__e = i6.__e, u5.__k = i6.__k, u5.__k.forEach(function(n5) {
              n5 && (n5.__ = u5);
            }), v5.__h.length && f5.push(v5);
            break n;
          }
          v5.componentWillUpdate != null && v5.componentWillUpdate(g6, v5.__s, x4), v5.componentDidUpdate != null && v5.__h.push(function() {
            v5.componentDidUpdate(d5, _5, k6);
          });
        }
        v5.context = x4, v5.props = g6, v5.state = v5.__s, (a6 = n3.__r) && a6(u5), v5.__d = false, v5.__v = u5, v5.__P = l6, a6 = v5.render(v5.props, v5.state, v5.context), v5.state = v5.__s, v5.getChildContext != null && (t6 = c3(c3({}, t6), v5.getChildContext())), h5 || v5.getSnapshotBeforeUpdate == null || (k6 = v5.getSnapshotBeforeUpdate(d5, _5)), A5 = a6 != null && a6.type === y2 && a6.key == null ? a6.props.children : a6, m4(l6, Array.isArray(A5) ? A5 : [A5], u5, i6, t6, o7, r6, f5, e7, s5), v5.base = u5.__e, u5.__h = null, v5.__h.length && f5.push(v5), b5 && (v5.__E = v5.__ = null), v5.__e = false;
      } else
        r6 == null && u5.__v === i6.__v ? (u5.__k = i6.__k, u5.__e = i6.__e) : u5.__e = j3(i6.__e, u5, i6, t6, o7, r6, f5, s5);
    (a6 = n3.diffed) && a6(u5);
  } catch (l7) {
    u5.__v = null, (s5 || r6 != null) && (u5.__e = e7, u5.__h = !!s5, r6[r6.indexOf(e7)] = null), n3.__e(l7, u5, i6);
  }
}
function T3(l6, u5) {
  n3.__c && n3.__c(u5, l6), l6.some(function(u6) {
    try {
      l6 = u6.__h, u6.__h = [], l6.some(function(n5) {
        n5.call(u6);
      });
    } catch (l7) {
      n3.__e(l7, u6.__v);
    }
  });
}
function j3(n5, l6, u5, i6, t6, o7, e7, c5) {
  var a6, v5, h5, y4, p6 = u5.props, d5 = l6.props, _5 = l6.type, k6 = 0;
  if (_5 === "svg" && (t6 = true), o7 != null) {
    for (; k6 < o7.length; k6++)
      if ((a6 = o7[k6]) && (a6 === n5 || (_5 ? a6.localName == _5 : a6.nodeType == 3))) {
        n5 = a6, o7[k6] = null;
        break;
      }
  }
  if (n5 == null) {
    if (_5 === null)
      return document.createTextNode(d5);
    n5 = t6 ? document.createElementNS("http://www.w3.org/2000/svg", _5) : document.createElement(_5, d5.is && d5), o7 = null, c5 = false;
  }
  if (_5 === null)
    p6 === d5 || c5 && n5.data === d5 || (n5.data = d5);
  else {
    if (o7 = o7 && f3.slice.call(n5.childNodes), v5 = (p6 = u5.props || r4).dangerouslySetInnerHTML, h5 = d5.dangerouslySetInnerHTML, !c5) {
      if (o7 != null)
        for (p6 = {}, y4 = 0; y4 < n5.attributes.length; y4++)
          p6[n5.attributes[y4].name] = n5.attributes[y4].value;
      (h5 || v5) && (h5 && (v5 && h5.__html == v5.__html || h5.__html === n5.innerHTML) || (n5.innerHTML = h5 && h5.__html || ""));
    }
    if (A2(n5, d5, p6, t6, c5), h5)
      l6.__k = [];
    else if (k6 = l6.props.children, m4(n5, Array.isArray(k6) ? k6 : [k6], l6, u5, i6, t6 && _5 !== "foreignObject", o7, e7, n5.firstChild, c5), o7 != null)
      for (k6 = o7.length; k6--; )
        o7[k6] != null && s3(o7[k6]);
    c5 || ("value" in d5 && (k6 = d5.value) !== void 0 && (k6 !== n5.value || _5 === "progress" && !k6) && C2(n5, "value", k6, p6.value, false), "checked" in d5 && (k6 = d5.checked) !== void 0 && k6 !== n5.checked && C2(n5, "checked", k6, p6.checked, false));
  }
  return n5;
}
function z3(l6, u5, i6) {
  try {
    typeof l6 == "function" ? l6(u5) : l6.current = u5;
  } catch (l7) {
    n3.__e(l7, i6);
  }
}
function L2(l6, u5, i6) {
  var t6, o7, r6;
  if (n3.unmount && n3.unmount(l6), (t6 = l6.ref) && (t6.current && t6.current !== l6.__e || z3(t6, null, u5)), i6 || typeof l6.type == "function" || (i6 = (o7 = l6.__e) != null), l6.__e = l6.__d = void 0, (t6 = l6.__c) != null) {
    if (t6.componentWillUnmount)
      try {
        t6.componentWillUnmount();
      } catch (l7) {
        n3.__e(l7, u5);
      }
    t6.base = t6.__P = null;
  }
  if (t6 = l6.__k)
    for (r6 = 0; r6 < t6.length; r6++)
      t6[r6] && L2(t6[r6], u5, i6);
  o7 != null && s3(o7);
}
function M2(n5, l6, u5) {
  return this.constructor(n5, u5);
}
function N2(l6, u5, i6) {
  var t6, o7, e7;
  n3.__ && n3.__(l6, u5), o7 = (t6 = typeof i6 == "function") ? null : i6 && i6.__k || u5.__k, e7 = [], I2(u5, l6 = (!t6 && i6 || u5).__k = a3(y2, null, [l6]), o7 || r4, r4, u5.ownerSVGElement !== void 0, !t6 && i6 ? [i6] : o7 ? null : u5.firstChild ? f3.slice.call(u5.childNodes) : null, e7, !t6 && i6 ? i6 : o7 ? o7.__e : u5.firstChild, t6), T3(e7, l6);
}
function O2(n5, l6) {
  N2(n5, l6, O2);
}
function S(n5, l6, u5) {
  var i6, t6, o7, r6 = arguments, f5 = c3({}, n5.props);
  for (o7 in l6)
    o7 == "key" ? i6 = l6[o7] : o7 == "ref" ? t6 = l6[o7] : f5[o7] = l6[o7];
  if (arguments.length > 3)
    for (u5 = [u5], o7 = 3; o7 < arguments.length; o7++)
      u5.push(r6[o7]);
  return u5 != null && (f5.children = u5), v3(n5.type, f5, i6 || n5.key, t6 || n5.ref, null);
}
function q(n5, l6) {
  var u5 = { __c: l6 = "__cC" + o3++, __: n5, Consumer: function(n6, l7) {
    return n6.children(l7);
  }, Provider: function(n6) {
    var u6, i6;
    return this.getChildContext || (u6 = [], (i6 = {})[l6] = this, this.getChildContext = function() {
      return i6;
    }, this.shouldComponentUpdate = function(n7) {
      this.props.value !== n7.value && u6.some(k3);
    }, this.sub = function(n7) {
      u6.push(n7);
      var l7 = n7.componentWillUnmount;
      n7.componentWillUnmount = function() {
        u6.splice(u6.indexOf(n7), 1), l7 && l7.call(n7);
      };
    }), n6.children;
  } };
  return u5.Provider.__ = u5.Consumer.contextType = u5;
}
n3 = { __e: function(n5, l6) {
  for (var u5, i6, t6; l6 = l6.__; )
    if ((u5 = l6.__c) && !u5.__)
      try {
        if ((i6 = u5.constructor) && i6.getDerivedStateFromError != null && (u5.setState(i6.getDerivedStateFromError(n5)), t6 = u5.__d), u5.componentDidCatch != null && (u5.componentDidCatch(n5), t6 = u5.__d), t6)
          return u5.__E = u5;
      } catch (l7) {
        n5 = l7;
      }
  throw n5;
}, __v: 0 }, l3 = function(n5) {
  return n5 != null && n5.constructor === void 0;
}, p3.prototype.setState = function(n5, l6) {
  var u5;
  u5 = this.__s != null && this.__s !== this.state ? this.__s : this.__s = c3({}, this.state), typeof n5 == "function" && (n5 = n5(c3({}, u5), this.props)), n5 && c3(u5, n5), n5 != null && this.__v && (l6 && this.__h.push(l6), k3(this));
}, p3.prototype.forceUpdate = function(n5) {
  this.__v && (this.__e = true, n5 && this.__h.push(n5), k3(this));
}, p3.prototype.render = y2, u3 = [], i3 = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, b3.__r = 0, o3 = 0;

// node_modules/@bpmn-io/properties-panel/preact/hooks/dist/hooks.module.js
var t5;
var u4;
var r5;
var o4 = 0;
var i4 = [];
var c4 = n3.__b;
var f4 = n3.__r;
var e5 = n3.diffed;
var a4 = n3.__c;
var v4 = n3.unmount;
function m5(t6, r6) {
  n3.__h && n3.__h(u4, t6, o4 || r6), o4 = 0;
  var i6 = u4.__H || (u4.__H = { __: [], __h: [] });
  return t6 >= i6.__.length && i6.__.push({}), i6.__[t6];
}
function l4(n5) {
  return o4 = 1, p4(w4, n5);
}
function p4(n5, r6, o7) {
  var i6 = m5(t5++, 2);
  return i6.t = n5, i6.__c || (i6.__ = [o7 ? o7(r6) : w4(void 0, r6), function(n6) {
    var t6 = i6.t(i6.__[0], n6);
    i6.__[0] !== t6 && (i6.__ = [t6, i6.__[1]], i6.__c.setState({}));
  }], i6.__c = u4), i6.__;
}
function y3(r6, o7) {
  var i6 = m5(t5++, 3);
  !n3.__s && k4(i6.__H, o7) && (i6.__ = r6, i6.__H = o7, u4.__H.__h.push(i6));
}
function h4(r6, o7) {
  var i6 = m5(t5++, 4);
  !n3.__s && k4(i6.__H, o7) && (i6.__ = r6, i6.__H = o7, u4.__h.push(i6));
}
function s4(n5) {
  return o4 = 5, d4(function() {
    return { current: n5 };
  }, []);
}
function _4(n5, t6, u5) {
  o4 = 6, h4(function() {
    typeof n5 == "function" ? n5(t6()) : n5 && (n5.current = t6());
  }, u5 == null ? u5 : u5.concat(n5));
}
function d4(n5, u5) {
  var r6 = m5(t5++, 7);
  return k4(r6.__H, u5) && (r6.__ = n5(), r6.__H = u5, r6.__h = n5), r6.__;
}
function A3(n5, t6) {
  return o4 = 8, d4(function() {
    return n5;
  }, t6);
}
function F2(n5) {
  var r6 = u4.context[n5.__c], o7 = m5(t5++, 9);
  return o7.__c = n5, r6 ? (o7.__ == null && (o7.__ = true, r6.sub(u4)), r6.props.value) : n5.__;
}
function T4(t6, u5) {
  n3.useDebugValue && n3.useDebugValue(u5 ? u5(t6) : t6);
}
function x2() {
  i4.forEach(function(t6) {
    if (t6.__P)
      try {
        t6.__H.__h.forEach(g4), t6.__H.__h.forEach(j4), t6.__H.__h = [];
      } catch (u5) {
        t6.__H.__h = [], n3.__e(u5, t6.__v);
      }
  }), i4 = [];
}
n3.__b = function(n5) {
  u4 = null, c4 && c4(n5);
}, n3.__r = function(n5) {
  f4 && f4(n5), t5 = 0;
  var r6 = (u4 = n5.__c).__H;
  r6 && (r6.__h.forEach(g4), r6.__h.forEach(j4), r6.__h = []);
}, n3.diffed = function(t6) {
  e5 && e5(t6);
  var o7 = t6.__c;
  o7 && o7.__H && o7.__H.__h.length && (i4.push(o7) !== 1 && r5 === n3.requestAnimationFrame || ((r5 = n3.requestAnimationFrame) || function(n5) {
    var t7, u5 = function() {
      clearTimeout(r6), b4 && cancelAnimationFrame(t7), setTimeout(n5);
    }, r6 = setTimeout(u5, 100);
    b4 && (t7 = requestAnimationFrame(u5));
  })(x2)), u4 = void 0;
}, n3.__c = function(t6, u5) {
  u5.some(function(t7) {
    try {
      t7.__h.forEach(g4), t7.__h = t7.__h.filter(function(n5) {
        return !n5.__ || j4(n5);
      });
    } catch (r6) {
      u5.some(function(n5) {
        n5.__h && (n5.__h = []);
      }), u5 = [], n3.__e(r6, t7.__v);
    }
  }), a4 && a4(t6, u5);
}, n3.unmount = function(t6) {
  v4 && v4(t6);
  var u5 = t6.__c;
  if (u5 && u5.__H)
    try {
      u5.__H.__.forEach(g4);
    } catch (t7) {
      n3.__e(t7, u5.__v);
    }
};
var b4 = typeof requestAnimationFrame == "function";
function g4(n5) {
  var t6 = u4;
  typeof n5.__c == "function" && n5.__c(), u4 = t6;
}
function j4(n5) {
  var t6 = u4;
  n5.__c = n5.__(), u4 = t6;
}
function k4(n5, t6) {
  return !n5 || n5.length !== t6.length || t6.some(function(t7, u5) {
    return t7 !== n5[u5];
  });
}
function w4(n5, t6) {
  return typeof t6 == "function" ? t6(n5) : t6;
}

// node_modules/bpmn-js-properties-panel/dist/index.esm.js
var import_min_dash147 = __toESM(require_dist());

// node_modules/@bpmn-io/properties-panel/dist/index.esm.js
var import_min_dash145 = __toESM(require_dist());
var import_classnames = __toESM(require_classnames());

// node_modules/@bpmn-io/properties-panel/preact/compat/dist/compat.module.js
function C3(n5, t6) {
  for (var e7 in t6)
    n5[e7] = t6[e7];
  return n5;
}
function S2(n5, t6) {
  for (var e7 in n5)
    if (e7 !== "__source" && !(e7 in t6))
      return true;
  for (var r6 in t6)
    if (r6 !== "__source" && n5[r6] !== t6[r6])
      return true;
  return false;
}
function E(n5) {
  this.props = n5;
}
function g5(n5, t6) {
  function e7(n6) {
    var e8 = this.props.ref, r7 = e8 == n6.ref;
    return !r7 && e8 && (e8.call ? e8(null) : e8.current = null), t6 ? !t6(this.props, n6) || !r7 : S2(this.props, n6);
  }
  function r6(t7) {
    return this.shouldComponentUpdate = e7, a3(n5, t7);
  }
  return r6.displayName = "Memo(" + (n5.displayName || n5.name) + ")", r6.prototype.isReactComponent = true, r6.__f = true, r6;
}
(E.prototype = new p3()).isPureReactComponent = true, E.prototype.shouldComponentUpdate = function(n5, t6) {
  return S2(this.props, n5) || S2(this.state, t6);
};
var w5 = n3.__b;
n3.__b = function(n5) {
  n5.type && n5.type.__f && n5.ref && (n5.props.ref = n5.ref, n5.ref = null), w5 && w5(n5);
};
var R = typeof Symbol != "undefined" && Symbol.for && Symbol.for("react.forward_ref") || 3911;
function x3(n5) {
  function t6(t7, e7) {
    var r6 = C3({}, t7);
    return delete r6.ref, n5(r6, (e7 = t7.ref || e7) && (typeof e7 != "object" || "current" in e7) ? e7 : null);
  }
  return t6.$$typeof = R, t6.render = t6, t6.prototype.isReactComponent = t6.__f = true, t6.displayName = "ForwardRef(" + (n5.displayName || n5.name) + ")", t6;
}
var N3 = function(n5, t6) {
  return n5 == null ? null : w3(w3(n5).map(t6));
};
var k5 = { map: N3, forEach: N3, count: function(n5) {
  return n5 ? w3(n5).length : 0;
}, only: function(n5) {
  var t6 = w3(n5);
  if (t6.length !== 1)
    throw "Children.only";
  return t6[0];
}, toArray: w3 };
var A4 = n3.__e;
n3.__e = function(n5, t6, e7) {
  if (n5.then) {
    for (var r6, u5 = t6; u5 = u5.__; )
      if ((r6 = u5.__c) && r6.__c)
        return t6.__e == null && (t6.__e = e7.__e, t6.__k = e7.__k), r6.__c(n5, t6);
  }
  A4(n5, t6, e7);
};
var O3 = n3.unmount;
function L3() {
  this.__u = 0, this.t = null, this.__b = null;
}
function U(n5) {
  var t6 = n5.__.__c;
  return t6 && t6.__e && t6.__e(n5);
}
function D(n5) {
  var t6, e7, r6;
  function u5(u6) {
    if (t6 || (t6 = n5()).then(function(n6) {
      e7 = n6.default || n6;
    }, function(n6) {
      r6 = n6;
    }), r6)
      throw r6;
    if (!e7)
      throw t6;
    return a3(e7, u6);
  }
  return u5.displayName = "Lazy", u5.__f = true, u5;
}
function F3() {
  this.u = null, this.o = null;
}
n3.unmount = function(n5) {
  var t6 = n5.__c;
  t6 && t6.__R && t6.__R(), t6 && n5.__h === true && (n5.type = null), O3 && O3(n5);
}, (L3.prototype = new p3()).__c = function(n5, t6) {
  var e7 = t6.__c, r6 = this;
  r6.t == null && (r6.t = []), r6.t.push(e7);
  var u5 = U(r6.__v), o7 = false, i6 = function() {
    o7 || (o7 = true, e7.__R = null, u5 ? u5(l6) : l6());
  };
  e7.__R = i6;
  var l6 = function() {
    if (!--r6.__u) {
      if (r6.state.__e) {
        var n6 = r6.state.__e;
        r6.__v.__k[0] = function n7(t8, e8, r7) {
          return t8 && (t8.__v = null, t8.__k = t8.__k && t8.__k.map(function(t9) {
            return n7(t9, e8, r7);
          }), t8.__c && t8.__c.__P === e8 && (t8.__e && r7.insertBefore(t8.__e, t8.__d), t8.__c.__e = true, t8.__c.__P = r7)), t8;
        }(n6, n6.__c.__P, n6.__c.__O);
      }
      var t7;
      for (r6.setState({ __e: r6.__b = null }); t7 = r6.t.pop(); )
        t7.forceUpdate();
    }
  }, f5 = t6.__h === true;
  r6.__u++ || f5 || r6.setState({ __e: r6.__b = r6.__v.__k[0] }), n5.then(i6, i6);
}, L3.prototype.componentWillUnmount = function() {
  this.t = [];
}, L3.prototype.render = function(n5, t6) {
  if (this.__b) {
    if (this.__v.__k) {
      var e7 = document.createElement("div"), r6 = this.__v.__k[0].__c;
      this.__v.__k[0] = function n6(t7, e8, r7) {
        return t7 && (t7.__c && t7.__c.__H && (t7.__c.__H.__.forEach(function(n7) {
          typeof n7.__c == "function" && n7.__c();
        }), t7.__c.__H = null), (t7 = C3({}, t7)).__c != null && (t7.__c.__P === r7 && (t7.__c.__P = e8), t7.__c = null), t7.__k = t7.__k && t7.__k.map(function(t8) {
          return n6(t8, e8, r7);
        })), t7;
      }(this.__b, e7, r6.__O = r6.__P);
    }
    this.__b = null;
  }
  var u5 = t6.__e && a3(y2, null, n5.fallback);
  return u5 && (u5.__h = null), [a3(y2, null, t6.__e ? null : n5.children), u5];
};
var M3 = function(n5, t6, e7) {
  if (++e7[1] === e7[0] && n5.o.delete(t6), n5.props.revealOrder && (n5.props.revealOrder[0] !== "t" || !n5.o.size))
    for (e7 = n5.u; e7; ) {
      for (; e7.length > 3; )
        e7.pop()();
      if (e7[1] < e7[0])
        break;
      n5.u = e7 = e7[2];
    }
};
function T5(n5) {
  return this.getChildContext = function() {
    return n5.context;
  }, n5.children;
}
function j5(n5) {
  var t6 = this, e7 = n5.i;
  t6.componentWillUnmount = function() {
    N2(null, t6.l), t6.l = null, t6.i = null;
  }, t6.i && t6.i !== e7 && t6.componentWillUnmount(), n5.__v ? (t6.l || (t6.i = e7, t6.l = { nodeType: 1, parentNode: e7, childNodes: [], appendChild: function(n6) {
    this.childNodes.push(n6), t6.i.appendChild(n6);
  }, insertBefore: function(n6, e8) {
    this.childNodes.push(n6), t6.i.appendChild(n6);
  }, removeChild: function(n6) {
    this.childNodes.splice(this.childNodes.indexOf(n6) >>> 1, 1), t6.i.removeChild(n6);
  } }), N2(a3(T5, { context: t6.context }, n5.__v), t6.l)) : t6.l && t6.componentWillUnmount();
}
function I3(n5, t6) {
  return a3(j5, { __v: n5, i: t6 });
}
(F3.prototype = new p3()).__e = function(n5) {
  var t6 = this, e7 = U(t6.__v), r6 = t6.o.get(n5);
  return r6[0]++, function(u5) {
    var o7 = function() {
      t6.props.revealOrder ? (r6.push(u5), M3(t6, n5, r6)) : u5();
    };
    e7 ? e7(o7) : o7();
  };
}, F3.prototype.render = function(n5) {
  this.u = null, this.o = /* @__PURE__ */ new Map();
  var t6 = w3(n5.children);
  n5.revealOrder && n5.revealOrder[0] === "b" && t6.reverse();
  for (var e7 = t6.length; e7--; )
    this.o.set(t6[e7], this.u = [1, 0, this.u]);
  return n5.children;
}, F3.prototype.componentDidUpdate = F3.prototype.componentDidMount = function() {
  var n5 = this;
  this.o.forEach(function(t6, e7) {
    M3(n5, e7, t6);
  });
};
var W = typeof Symbol != "undefined" && Symbol.for && Symbol.for("react.element") || 60103;
var P3 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
var V = function(n5) {
  return (typeof Symbol != "undefined" && typeof Symbol() == "symbol" ? /fil|che|rad/i : /fil|che|ra/i).test(n5);
};
function z4(n5, t6, e7) {
  return t6.__k == null && (t6.textContent = ""), N2(n5, t6), typeof e7 == "function" && e7(), n5 ? n5.__c : null;
}
function B2(n5, t6, e7) {
  return O2(n5, t6), typeof e7 == "function" && e7(), n5 ? n5.__c : null;
}
p3.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(n5) {
  Object.defineProperty(p3.prototype, n5, { configurable: true, get: function() {
    return this["UNSAFE_" + n5];
  }, set: function(t6) {
    Object.defineProperty(this, n5, { configurable: true, writable: true, value: t6 });
  } });
});
var H3 = n3.event;
function Z() {
}
function Y() {
  return this.cancelBubble;
}
function $3() {
  return this.defaultPrevented;
}
n3.event = function(n5) {
  return H3 && (n5 = H3(n5)), n5.persist = Z, n5.isPropagationStopped = Y, n5.isDefaultPrevented = $3, n5.nativeEvent = n5;
};
var q2;
var G = { configurable: true, get: function() {
  return this.class;
} };
var J = n3.vnode;
n3.vnode = function(n5) {
  var t6 = n5.type, e7 = n5.props, r6 = e7;
  if (typeof t6 == "string") {
    for (var u5 in r6 = {}, e7) {
      var o7 = e7[u5];
      u5 === "value" && "defaultValue" in e7 && o7 == null || (u5 === "defaultValue" && "value" in e7 && e7.value == null ? u5 = "value" : u5 === "download" && o7 === true ? o7 = "" : /ondoubleclick/i.test(u5) ? u5 = "ondblclick" : /^onchange(textarea|input)/i.test(u5 + t6) && !V(e7.type) ? u5 = "oninput" : /^on(Ani|Tra|Tou|BeforeInp)/.test(u5) ? u5 = u5.toLowerCase() : P3.test(u5) ? u5 = u5.replace(/[A-Z0-9]/, "-$&").toLowerCase() : o7 === null && (o7 = void 0), r6[u5] = o7);
    }
    t6 == "select" && r6.multiple && Array.isArray(r6.value) && (r6.value = w3(e7.children).forEach(function(n6) {
      n6.props.selected = r6.value.indexOf(n6.props.value) != -1;
    })), t6 == "select" && r6.defaultValue != null && (r6.value = w3(e7.children).forEach(function(n6) {
      n6.props.selected = r6.multiple ? r6.defaultValue.indexOf(n6.props.value) != -1 : r6.defaultValue == n6.props.value;
    })), n5.props = r6;
  }
  t6 && e7.class != e7.className && (G.enumerable = "className" in e7, e7.className != null && (r6.class = e7.className), Object.defineProperty(r6, "className", G)), n5.$$typeof = W, J && J(n5);
};
var K = n3.__r;
n3.__r = function(n5) {
  K && K(n5), q2 = n5.__c;
};
var Q = { ReactCurrentDispatcher: { current: { readContext: function(n5) {
  return q2.__n[n5.__c].props.value;
} } } };
var on = typeof performance == "object" && typeof performance.now == "function" ? performance.now.bind(performance) : function() {
  return Date.now();
};
function fn(n5) {
  return a3.bind(null, n5);
}
function cn(n5) {
  return !!n5 && n5.$$typeof === W;
}
function an(n5) {
  return cn(n5) ? S.apply(null, arguments) : n5;
}
function sn(n5) {
  return !!n5.__k && (N2(null, n5), true);
}
function hn(n5) {
  return n5 && (n5.base || n5.nodeType === 1 && n5) || null;
}
var pn = function(n5, t6) {
  return n5(t6);
};
var compat_module_default = { useState: l4, useReducer: p4, useEffect: y3, useLayoutEffect: h4, useRef: s4, useImperativeHandle: _4, useMemo: d4, useCallback: A3, useContext: F2, useDebugValue: T4, version: "16.8.0", Children: k5, render: z4, hydrate: B2, unmountComponentAtNode: sn, createPortal: I3, createElement: a3, createContext: q, createFactory: fn, cloneElement: an, createRef: h3, Fragment: y2, isValidElement: cn, findDOMNode: hn, Component: p3, PureComponent: E, memo: g5, forwardRef: x3, unstable_batchedUpdates: pn, StrictMode: y2, Suspense: L3, SuspenseList: F3, lazy: D, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: Q };

// node_modules/@bpmn-io/properties-panel/preact/jsx-runtime/dist/jsxRuntime.module.js
function o5(_5, o7, e7, n5, t6) {
  var f5 = {};
  for (var l6 in o7)
    l6 != "ref" && (f5[l6] = o7[l6]);
  var s5, u5, a6 = { type: _5, props: f5, key: e7, ref: o7 && o7.ref, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: ++n3.__v, __source: n5, __self: t6 };
  if (typeof _5 == "function" && (s5 = _5.defaultProps))
    for (u5 in s5)
      f5[u5] === void 0 && (f5[u5] = s5[u5]);
  return n3.vnode && n3.vnode(a6), a6;
}

// node_modules/@bpmn-io/feel-editor/dist/index.es.js
var import_autocomplete2 = require("@codemirror/autocomplete");
var import_commands = require("@codemirror/commands");
var import_language3 = require("@codemirror/language");
var import_lint = require("@codemirror/lint");
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");

// node_modules/lezer-feel/dist/index.es.js
var import_lr = require("@lezer/lr");
var import_highlight = require("@lezer/highlight");
var propertyIdentifier = 119;
var identifier = 120;
var nameIdentifier = 121;
var insertSemi = 122;
var expression0 = 126;
var ForExpression = 4;
var forExpressionStart = 129;
var ForInExpression = 7;
var Name = 8;
var Identifier = 9;
var AdditionalIdentifier = 10;
var forExpressionBodyStart = 137;
var IfExpression = 18;
var ifExpressionStart = 138;
var QuantifiedExpression = 22;
var quantifiedExpressionStart = 139;
var QuantifiedInExpression = 26;
var PositiveUnaryTest = 36;
var ArithmeticExpression = 40;
var arithmeticPlusStart = 143;
var arithmeticTimesStart = 144;
var arithmeticExpStart = 145;
var arithmeticUnaryStart = 146;
var VariableName = 47;
var PathExpression = 67;
var pathExpressionStart = 151;
var FilterExpression = 69;
var filterExpressionStart = 152;
var FunctionInvocation = 71;
var functionInvocationStart = 153;
var ParameterName = 75;
var nil = 158;
var NumericLiteral = 78;
var StringLiteral = 79;
var BooleanLiteral = 80;
var FunctionDefinition = 89;
var functionDefinitionStart = 165;
var Context2 = 96;
var contextStart = 167;
var ContextEntry = 97;
var PropertyName = 99;
var PropertyIdentifier = 100;
var LOG_PARSE = typeof process != "undefined" && process.env && /\bfparse(:dbg)?\b/.test(process.env.LOG);
var LOG_PARSE_DEBUG = typeof process != "undefined" && process.env && /\bfparse:dbg\b/.test(process.env.LOG);
var LOG_VARS = typeof process != "undefined" && process.env && /\bcontext\b/.test(process.env.LOG);
var spaceChars = [
  9,
  11,
  12,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
];
var newlineChars = chars("\n\r");
var additionalNameChars = chars("'./-+*");
function chars(str) {
  return Array.from(str).map((s5) => s5.charCodeAt(0));
}
function isStartChar(ch) {
  return ch === 63 || ch === 95 || ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 161 && !isPartChar(ch) && !isSpace2(ch);
}
function isAdditional(ch) {
  return additionalNameChars.includes(ch);
}
function isPartChar(ch) {
  return ch >= 48 && ch <= 57 || ch === 183 || ch >= 768 && ch <= 879 || ch >= 8255 && ch <= 8256;
}
function isSpace2(ch) {
  return spaceChars.includes(ch);
}
function indent(str, spaces) {
  return spaces.concat(str.split(/\n/g).join("\n" + spaces));
}
function parseAdditionalSymbol(input, offset = 0) {
  const next = input.peek(offset);
  if (isAdditional(next)) {
    return {
      offset: 1,
      token: String.fromCharCode(next)
    };
  }
  return null;
}
function parseIdentifier(input, offset = 0, namePart = false) {
  for (let inside = false, chars2 = [], i6 = 0; ; i6++) {
    const next = input.peek(offset + i6);
    if (isStartChar(next) || (inside || namePart) && isPartChar(next)) {
      if (!inside) {
        inside = true;
      }
      chars2.push(next);
    } else {
      if (chars2.length) {
        return {
          token: String.fromCharCode(...chars2),
          offset: i6
        };
      }
      return null;
    }
  }
}
function parseSpaces(input, offset) {
  for (let inside = false, i6 = 0; ; i6++) {
    let next = input.peek(offset + i6);
    if (isSpace2(next)) {
      if (!inside) {
        inside = true;
      }
    } else {
      if (inside) {
        return {
          token: " ",
          offset: i6
        };
      }
      return null;
    }
  }
}
function parseName2(input, variables2) {
  const contextKeys = variables2.contextKeys();
  const start = variables2.tokens;
  for (let i6 = 0, tokens = [], nextMatch = null; ; ) {
    const namePart = start.length + tokens.length > 0;
    const maybeSpace = tokens.length > 0;
    const match = parseIdentifier(input, i6, namePart) || namePart && parseAdditionalSymbol(input, i6) || maybeSpace && parseSpaces(input, i6);
    if (!match) {
      return nextMatch;
    }
    const {
      token,
      offset
    } = match;
    i6 += offset;
    if (token === " ") {
      continue;
    }
    tokens = [...tokens, token];
    const name3 = [...start, ...tokens].join(" ");
    if (contextKeys.some((el) => el === name3)) {
      const token2 = tokens[0];
      nextMatch = {
        token: token2,
        offset: token2.length,
        term: nameIdentifier
      };
    }
    if (dateTimeIdentifiers.some((el) => el === name3)) {
      const token2 = tokens[0];
      nextMatch = {
        token: token2,
        offset: token2.length,
        term: identifier
      };
    }
    if (!contextKeys.some((el) => el.startsWith(name3)) && !dateTimeIdentifiers.some((el) => el.startsWith(name3))) {
      return nextMatch;
    }
  }
}
var identifiersMap = {
  [identifier]: "identifier",
  [nameIdentifier]: "nameIdentifier"
};
var identifiers = new import_lr.ExternalTokenizer((input, stack) => {
  LOG_PARSE_DEBUG && console.log("%s: T <identifier | nameIdentifier>", input.pos);
  const nameMatch = parseName2(input, stack.context);
  const start = stack.context.tokens;
  const match = nameMatch || parseIdentifier(input, 0, start.length > 0);
  if (match) {
    input.advance(match.offset);
    input.acceptToken(nameMatch ? nameMatch.term : identifier);
    LOG_PARSE && console.log("%s: MATCH <%s> <%s>", input.pos, nameMatch ? identifiersMap[nameMatch.term] : "identifier", match.token);
  }
}, { contextual: true });
var propertyIdentifiers = new import_lr.ExternalTokenizer((input, stack) => {
  LOG_PARSE_DEBUG && console.log("%s: T <propertyIdentifier>", input.pos);
  const start = stack.context.tokens;
  const match = parseIdentifier(input, 0, start.length > 0);
  if (match) {
    input.advance(match.offset);
    input.acceptToken(propertyIdentifier);
    LOG_PARSE && console.log("%s: MATCH <propertyIdentifier> <%s>", input.pos, match.token);
  }
});
var insertSemicolon = new import_lr.ExternalTokenizer((input, stack) => {
  LOG_PARSE_DEBUG && console.log("%s: T <insertSemi>", input.pos);
  let offset;
  let insert = false;
  for (offset = 0; ; offset++) {
    const char = input.peek(offset);
    if (spaceChars.includes(char)) {
      continue;
    }
    if (newlineChars.includes(char)) {
      insert = true;
    }
    break;
  }
  if (insert) {
    const identifier2 = parseIdentifier(input, offset + 1);
    const spaces = parseSpaces(input, offset + 1);
    if (spaces || identifier2 && /^(then|else|return|satisfies)$/.test(identifier2.token)) {
      return;
    }
    LOG_PARSE && console.log("%s: MATCH <insertSemi>", input.pos);
    input.acceptToken(insertSemi);
  }
});
var prefixedContextStarts = {
  [functionInvocationStart]: "FunctionInvocation",
  [filterExpressionStart]: "FilterExpression",
  [pathExpressionStart]: "PathExpression"
};
var contextStarts = {
  [contextStart]: "Context",
  [functionDefinitionStart]: "FunctionDefinition",
  [forExpressionStart]: "ForExpression",
  [ifExpressionStart]: "IfExpression",
  [quantifiedExpressionStart]: "QuantifiedExpression"
};
var contextEnds = {
  [Context2]: "Context",
  [FunctionDefinition]: "FunctionDefinition",
  [ForExpression]: "ForExpression",
  [IfExpression]: "IfExpression",
  [QuantifiedExpression]: "QuantifiedExpression",
  [PathExpression]: "PathExpression",
  [FunctionInvocation]: "FunctionInvocation",
  [FilterExpression]: "FilterExpression",
  [ArithmeticExpression]: "ArithmeticExpression"
};
var ValueProducer = class {
  constructor(fn2) {
    this.fn = fn2;
  }
  get(variables2) {
    return this.fn(variables2);
  }
  static of(fn2) {
    return new ValueProducer(fn2);
  }
};
var dateTimeLiterals = {
  "date and time": 1,
  "date": 1,
  "time": 1,
  "duration": 1
};
var dateTimeIdentifiers = Object.keys(dateTimeLiterals);
var Variables = class {
  constructor({
    name: name3 = "Expressions",
    tokens = [],
    children = [],
    parent = null,
    context = {},
    value,
    raw
  } = {}) {
    this.name = name3;
    this.tokens = tokens;
    this.children = children;
    this.parent = parent;
    this.context = context;
    this.value = value;
    this.raw = raw;
  }
  enterScope(name3) {
    const childScope = this.of({
      name: name3,
      parent: this
    });
    LOG_VARS && console.log("[%s] enter", childScope.path, childScope.context);
    return childScope;
  }
  exitScope(str) {
    if (!this.parent) {
      LOG_VARS && console.log("[%s] NO exit %o\n%s", this.path, this.context, indent(str, "  "));
      return this;
    }
    LOG_VARS && console.log("[%s] exit %o\n%s", this.path, this.context, indent(str, "  "));
    return this.parent.pushChild(this);
  }
  token(part) {
    LOG_VARS && console.log("[%s] token <%s> + <%s>", this.path, this.tokens.join(" "), part);
    return this.assign({
      tokens: [...this.tokens, part]
    });
  }
  literal(value) {
    LOG_VARS && console.log("[%s] literal %o", this.path, value);
    return this.pushChild(this.of({
      name: "Literal",
      value
    }));
  }
  computedValue() {
    for (let scope = this; ; scope = scope.children.slice(-1)[0]) {
      if (!scope) {
        return null;
      }
      if (scope.value) {
        return scope.value;
      }
    }
  }
  contextKeys() {
    return Object.keys(this.context).map(normalizeContextKey);
  }
  get path() {
    var _a, _b;
    return ((_b = (_a = this.parent) == null ? void 0 : _a.path) == null ? void 0 : _b.concat(" > ", this.name)) || this.name;
  }
  get(variable) {
    const names = [variable, variable && normalizeContextKey(variable)];
    const contextKey = Object.keys(this.context).find((key) => names.includes(normalizeContextKey(key)));
    if (typeof contextKey === "undefined") {
      return void 0;
    }
    const val = this.context[contextKey];
    if (val instanceof ValueProducer) {
      return val.get(this);
    } else {
      return val;
    }
  }
  resolveName() {
    const variable = this.tokens.join(" ");
    const tokens = [];
    const parentScope = this.assign({
      tokens
    });
    const variableScope = this.of({
      name: "VariableName",
      parent: parentScope,
      value: this.get(variable),
      raw: variable
    });
    LOG_VARS && console.log("[%s] resolve name <%s=%s>", variableScope.path, variable, this.get(variable));
    return parentScope.pushChild(variableScope);
  }
  pushChild(child) {
    if (!child) {
      return this;
    }
    const parent = this.assign({
      children: [...this.children, child]
    });
    child.parent = parent;
    return parent;
  }
  pushChildren(children) {
    let parent = this;
    for (const child of children) {
      parent = parent.pushChild(child);
    }
    return parent;
  }
  declareName() {
    if (this.tokens.length === 0) {
      throw Error("no tokens to declare name");
    }
    const variableName = this.tokens.join(" ");
    LOG_VARS && console.log("[%s] declareName <%s>", this.path, variableName);
    return this.assign({
      tokens: []
    }).pushChild(this.of({
      name: "Name",
      value: variableName
    }));
  }
  define(name3, value) {
    if (typeof name3 !== "string") {
      LOG_VARS && console.log("[%s] no define <%s=%s>", this.path, name3, value);
      return this;
    }
    LOG_VARS && console.log("[%s] define <%s=%s>", this.path, name3, value);
    const context = {
      ...this.context,
      [name3]: value
    };
    return this.assign({
      context
    });
  }
  assign(options2 = {}) {
    return Variables.of({
      ...this,
      ...options2
    });
  }
  of(options2 = {}) {
    const defaultOptions = {
      context: this.context,
      parent: this.parent
    };
    return Variables.of({
      ...defaultOptions,
      ...options2
    });
  }
  static of(options2) {
    const {
      name: name3,
      tokens = [],
      children = [],
      parent = null,
      context = {},
      value,
      raw
    } = options2;
    return new Variables({
      name: name3,
      tokens: [...tokens],
      children: [...children],
      context: {
        ...context
      },
      parent,
      value,
      raw
    });
  }
};
function normalizeContextKey(name3) {
  return name3.replace(/\s*([./\-'+*])\s*/g, " $1 ").replace(/\s{2,}/g, " ").trim();
}
function wrap(variables2, scopeName, code) {
  const parts = variables2.children.filter((c5) => c5.name !== scopeName);
  const children = variables2.children.filter((c5) => c5.name === scopeName);
  const namePart = parts[0];
  const valuePart = parts[Math.max(1, parts.length - 1)];
  const name3 = namePart.computedValue();
  const value = (valuePart == null ? void 0 : valuePart.computedValue()) || null;
  return variables2.assign({
    children
  }).enterScope(scopeName).pushChildren(parts).exitScope(code).define(name3, value);
}
function trackVariables(context = {}) {
  const start = Variables.of({
    context
  });
  return new import_lr.ContextTracker({
    start,
    reduce(variables2, term, stack, input) {
      if (term === Context2) {
        variables2 = variables2.assign({
          value: variables2.context
        });
      }
      if (term === IfExpression) {
        const [thenPart, elsePart] = variables2.children.slice(-2);
        variables2 = variables2.assign({
          value: {
            ...thenPart == null ? void 0 : thenPart.computedValue(),
            ...elsePart == null ? void 0 : elsePart.computedValue()
          }
        });
      }
      if (term === FilterExpression) {
        const [sourcePart, _5] = variables2.children.slice(-2);
        variables2 = variables2.assign({
          value: sourcePart == null ? void 0 : sourcePart.computedValue()
        });
      }
      if (term === FunctionInvocation) {
        const [
          name3,
          ...args
        ] = variables2.children;
        if ((name3 == null ? void 0 : name3.raw) === "get value") {
          variables2 = getContextValue(variables2, args);
        }
      }
      const start2 = contextStarts[term];
      if (start2) {
        return variables2.enterScope(start2);
      }
      const prefixedStart = prefixedContextStarts[term];
      if (prefixedStart) {
        const children = variables2.children.slice(0, -1);
        const lastChild = variables2.children.slice(-1)[0];
        return variables2.assign({
          children
        }).enterScope(prefixedStart).pushChild(lastChild).assign({
          context: {
            ...variables2.context,
            ...lastChild == null ? void 0 : lastChild.computedValue()
          }
        });
      }
      const code = input.read(input.pos, stack.pos);
      const end = contextEnds[term];
      if (end) {
        return variables2.exitScope(code);
      }
      if (term === ContextEntry) {
        return wrap(variables2, "ContextEntry", code);
      }
      if (term === ForInExpression || term === QuantifiedInExpression) {
        return wrap(variables2, "InExpression", code);
      }
      if (term === forExpressionBodyStart) {
        return variables2.define("partial", ValueProducer.of((variables3) => {
          var _a;
          return (_a = variables3.children[variables3.children.length - 1]) == null ? void 0 : _a.computedValue();
        }));
      }
      if (term === ParameterName) {
        const [left] = variables2.children.slice(-1);
        const name3 = left.computedValue();
        return variables2.define(name3, 1);
      }
      if (term === arithmeticPlusStart || term === arithmeticTimesStart || term === arithmeticExpStart) {
        const children = variables2.children.slice(0, -1);
        const lastChild = variables2.children.slice(-1)[0];
        return variables2.assign({
          children
        }).enterScope("ArithmeticExpression").pushChild(lastChild);
      }
      if (term === arithmeticUnaryStart) {
        return variables2.enterScope("ArithmeticExpression");
      }
      if (term === Identifier || term === AdditionalIdentifier || term === PropertyIdentifier) {
        return variables2.token(code);
      }
      if (term === StringLiteral) {
        return variables2.literal(code.replace(/^"|"$/g, ""));
      }
      if (term === BooleanLiteral) {
        return variables2.literal(code === "true" ? true : false);
      }
      if (term === NumericLiteral) {
        return variables2.literal(parseFloat(code));
      }
      if (term === nil) {
        return variables2.literal(null);
      }
      if (term === VariableName) {
        return variables2.resolveName();
      }
      if (term === Name || term === PropertyName) {
        return variables2.declareName();
      }
      if (term === expression0 || term === PositiveUnaryTest) {
        if (variables2.tokens.length > 0) {
          throw new Error("uncleared name");
        }
      }
      if (term === expression0) {
        let parent = variables2;
        while (parent.parent) {
          parent = parent.exitScope(code);
        }
        return parent;
      }
      return variables2;
    }
  });
}
var variableTracker = trackVariables({});
function getContextValue(variables2, args) {
  if (!args.length) {
    return variables2.assign({
      value: null
    });
  }
  if (args[0].name === "Name") {
    args = extractNamedArgs(args, ["m", "key"]);
  }
  if (args.length !== 2) {
    return variables2.assign({
      value: null
    });
  }
  const [
    context,
    key
  ] = args;
  const keyValue = key == null ? void 0 : key.computedValue();
  const contextValue = context == null ? void 0 : context.computedValue();
  if (!contextValue || typeof contextValue !== "object" || typeof keyValue !== "string") {
    return variables2.assign({
      value: null
    });
  }
  return variables2.assign({
    value: [normalizeContextKey(keyValue), keyValue].reduce((value, keyValue2) => {
      if (keyValue2 in contextValue) {
        return contextValue[keyValue2];
      }
      return value;
    }, null)
  });
}
function extractNamedArgs(args, argNames) {
  const context = {};
  for (let i6 = 0; i6 < args.length; i6 += 2) {
    const [name3, value] = args.slice(i6, i6 + 2);
    context[name3.value] = value;
  }
  return argNames.map((name3) => context[name3]);
}
var feelHighlighting = (0, import_highlight.styleTags)({
  StringLiteral: import_highlight.tags.string,
  NumericLiteral: import_highlight.tags.number,
  BooleanLiteral: import_highlight.tags.bool,
  "AtLiteral!": import_highlight.tags.special(import_highlight.tags.string),
  CompareOp: import_highlight.tags.compareOperator,
  ArithOp: import_highlight.tags.arithmeticOperator,
  "for if then else some every satisfies between return": import_highlight.tags.controlKeyword,
  "in instance of and or": import_highlight.tags.operatorKeyword,
  function: import_highlight.tags.definitionKeyword,
  as: import_highlight.tags.keyword,
  "Type/...": import_highlight.tags.typeName,
  Wildcard: import_highlight.tags.special,
  null: import_highlight.tags.null,
  LineComment: import_highlight.tags.lineComment,
  BlockComment: import_highlight.tags.blockComment,
  'VariableName! "?"': import_highlight.tags.variableName,
  "DateTimeConstructor! SpecialFunctionName!": import_highlight.tags.function(import_highlight.tags.special(import_highlight.tags.variableName)),
  "List Interval": import_highlight.tags.list,
  Context: import_highlight.tags.definition(import_highlight.tags.literal),
  "Name!": import_highlight.tags.definition(import_highlight.tags.variableName),
  "Key/Name! ContextEntryType/Name!": import_highlight.tags.definition(import_highlight.tags.propertyName),
  "PathExpression/VariableName!": import_highlight.tags.function(import_highlight.tags.propertyName),
  "FormalParameter/ParameterName!": import_highlight.tags.function(import_highlight.tags.definition(import_highlight.tags.variableName)),
  "( )": import_highlight.tags.paren,
  "[ ]": import_highlight.tags.squareBracket,
  "{ }": import_highlight.tags.brace,
  ".": import_highlight.tags.derefOperator,
  ", ;": import_highlight.tags.separator,
  "..": import_highlight.tags.punctuation
});
var spec_identifier = { __proto__: null, for: 10, in: 30, return: 34, if: 38, then: 40, else: 42, some: 46, every: 48, satisfies: 55, or: 58, and: 62, between: 70, instance: 86, of: 89, days: 99, time: 101, duration: 103, years: 105, months: 107, date: 109, list: 115, context: 121, function: 128, null: 154, true: 324, false: 324, "?": 168, external: 184, not: 207 };
var parser = import_lr.LRParser.deserialize({
  version: 14,
  states: "!%SO`QYOOO$gQYOOOOQU'#Ce'#CeO$qQYO'#C`O%zQ^O'#FOOOQQ'#Fd'#FdO'dQYO'#FdO`QYO'#DUOOQU'#Em'#EmO)QQ^O'#D]OOQO'#Fk'#FkO,PQWO'#DuOOQU'#D|'#D|OOQU'#D}'#D}OOQU'#EO'#EOO,UOWO'#ERO,PQWO'#EPOOQU'#EP'#EPOOQU'#Fq'#FqOOQU'#Fo'#FoOOQU'#ET'#ETO,ZQYO'#EVOOQU'#FQ'#FQO-oQ^O'#FQO/RQYO'#EWO/]QWO'#EXOOQP'#Fy'#FyO/bQXO'#E`OOQU'#Fv'#FvOOQU'#FP'#FPOOQQ'#Eh'#EhQ`QYOOOOQQ'#FR'#FROOQQ'#F['#F[O,ZQYO'#CnOOQQ'#F]'#F]O$qQYO'#CrO/mQYO'#DvOOQU'#Fp'#FpO/rQYO'#EQOOQO'#EQ'#EQO,ZQYO'#EUO`QYO'#ETOOQO'#Fw'#FwO1UQYO'#DQO1lQWO'#F`OOQO'#DS'#DSO1wQYO'#FdQOQWOOO2OQWOOO2rQYO'#CdO3PQYO'#FTOOQQ'#Cc'#CcO3UQYO'#FSOOQQ'#Cb'#CbO3^QYO,58zO`QYO,59hOOQQ'#Fa'#FaOOQQ'#Fb'#FbOOQQ'#Fc'#FcO`QYO,59pO`QYO,59pO`QYO,59pOOQQ'#Fi'#FiO$qQYO,5:]OOQQ'#Fj'#FjO,ZQYO,5:_OOQQ,5;j,5;jO`QYO,59dO`QYO,59fO,ZQYO,59hO4|QYO,59hO5TQYO,59rOOQU,5:h,5:hO5YQ^O,59pOOQU-E8k-E8kO8XQYO'#FlOOQU,5:a,5:aOOQU,5:m,5:mOOQU,5:k,5:kO8cQYO,5:qOOQU,5;l,5;lO:nQYO,5:pO:xQWO,5:rO:}QYO,5:sOOQP'#Ed'#EdO;qQXO'#EcOOQO'#Eb'#EbO;xQWO'#EaO;}QWO'#FzO<VQWO,5:zOOQQ-E8f-E8fO=]QYO,59YO3PQYO'#F_OOQQ'#Cv'#CvO=dQYO'#F^OOQQ'#Cu'#CuO=lQYO,59^O=qQYO,5:bO=vQYO,5:lO9jQYO,5:pO={Q^O,5:oO,ZQYO'#ElO?eQWO,5;zO,ZQYOOOOQR'#Cf'#CfOOQQ'#Ei'#EiO@[QYO,59OO,ZQYO,5;oOOQQ'#FW'#FWO$qQYO'#EjO@lQYO,5;nO`QYO1G.fOOQQ'#FZ'#FZO@tQ^O1G/SOCZQ^O1G/[OEpQ^O1G/[OJlQ^O1G/[OOQU1G/w1G/wOKYQYO1G/yOMgQ^O1G/OO!!TQ^O1G/QO!#cQYO1G/SO,ZQYO1G/SOOQU1G/S1G/SO!#jQYO1G/^O!$UQ^O'#CdO!%hQYO'#FnOOQO'#Dy'#DyO!%rQWO'#DxO!%wQWO'#FmOOQO'#Dw'#DwOOQO'#Dz'#DzO!&PQWO,5<WOOQU1G0]1G0]O,ZQYO1G0[O,ZQYO'#ErO!&UQWO,5<YOOQU1G0^1G0^O!&aQWO'#EZO!&lQWO'#FxOOQO'#EY'#EYO!&tQWO1G0_OOQP'#Et'#EtO!&yQXO,5:}O,ZQYO,5:{O!'QQXO'#EuO!'YQWO,5<fOOQU1G0f1G0fO!'bQYO1G.tO,ZQYO,5;yO$qQYO'#EkO!)OQYO,5;xO`QYO1G.xO!)WQYO1G/|OOQO1G0W1G0WOOQO,5;W,5;WOOQO-E8j-E8jO!)]QWOOOOQQ-E8g-E8gO!)bQYO'#ClOOQQ1G1Z1G1ZOOQQ,5;U,5;UOOQQ-E8h-E8hO!)oQ^O7+$QOOQU7+%e7+%eO`QYO7+$nO!+XQYO,5:qO!+`QWO7+$nO!+eQ^O'#D[OOQU'#DZ'#DZO!.dQYO'#D^O!.iQYO'#D^O!.nQYO'#D^O!.sQ`O'#DfO!.xQ`O'#DiO!.}Q`O'#DmOOQU7+$x7+$xO,ZQYO,5:dO$qQYO'#EqO!/SQWO,5<XOOQU1G1r1G1rO!0YQYO7+%vO!0gQYO,5;^OOQO-E8p-E8pO!#jQYO,5:uO$qQYO'#EsO!0tQWO,5<dO!0|QYO7+%yOOQP-E8r-E8rO!1TQYO1G0gOOQO,5;a,5;aOOQO-E8s-E8sO!3tQ^O7+$`O!3{QYO1G1eOOQQ,5;V,5;VOOQQ-E8i-E8iO!4VQ^O7+$dOOQO7+%h7+%hO,ZQYO,59WO!5oQ^O<<HYOOQU<<HY<<HYO$qQYO'#EnO!8UQ^O,59vO!;TQYO,59xO!;YQYO,59xO!;_QYO,59xO!;dQYO,5:QO$qQYO,5:TO!<OQbO,5:XO!<VQYO1G0OOOQO,5;],5;]OOQO-E8o-E8oO!<aQ^O<<IbOOQU<<Ib<<IbOOQO1G0a1G0aOOQO,5;_,5;_OOQO-E8q-E8qO!?`Q^O'#E]OOQU<<Ie<<IeO`QYO<<IeO`QYO<<GzO!@xQYO1G.rOOQU,5;Y,5;YOOQU-E8l-E8lO!ASQYO1G/dOOQU1G/d1G/dO!AXQbO'#D]O!AjQ`O'#D[O!AuQ`O1G/lO!AzQWO'#DlO!BPQ`O'#FeOOQO'#Dk'#DkO!BXQ`O1G/oOOQO'#Dp'#DpO!B^Q`O'#FgOOQO'#Do'#DoO!BfQ`O1G/sOOQUAN?PAN?PO!BkQ^OAN=fOOQU7+%O7+%OO!DTQ`O,59vOOQU7+%W7+%WO!;dQYO,5:WO$qQYO'#EoO!D`Q`O,5<POOQU7+%Z7+%ZO!;dQYO'#EpO!DhQ`O,5<RO!DpQ`O7+%_OOQO1G/r1G/rOOQO,5;Z,5;ZOOQO-E8m-E8mOOQO,5;[,5;[OOQO-E8n-E8nO!#jQYO<<HyOOQUAN>eAN>eO!DuQ^O'#FQO,ZQYO'#ETO,ZQYO,59hO,ZQYO,59pO,ZQYO,59pO,ZQYO,59pO,ZQYO,59dO,ZQYO,59fO!FyQYO,59hO!GQQYO,5:oO,ZQYO1G.fO!GqQYO1G/SO!I_QYO1G/[O!J{QYO1G/[O!MvQYO1G/OO# kQYO1G/QO# {QYO1G.tO,ZQYO1G.xO##iQYO7+$QO,ZQYO7+$nO#$YQYO7+%yO#&QQYO7+$`O#&XQYO7+$`O#&`Q^O7+$`O#&gQYO7+$dO#'WQYO<<HYO$qQYO'#EnO#(tQYO'#E]O,ZQYO<<IeO,ZQYO<<GzO#)eQYOAN=fO!;dQYO<<HyO,ZQYO'#DUO#*UQ^O'#DQO3^QYO,58zO#+nQYO,59YO#+uQYO,59^O#+zQYO1G/SO#,RQWO1G0_O!'bQYO1G.tO#,WQ`O7+%_O# {QYO1G.tO$qQYO'#C`O,ZQYO'#CnO$qQYO'#CrO,ZQYO,59hO:}QYO,5:sO#,]QYO,59YO#,dQ`O1G/sO#,iQYO,59YO#,pQWO'#EXO,ZQYO'#CnO!'bQYO'#ETO!'bQYO,59hO!'bQYO,59pO!'bQYO,59pO!'bQYO,59pO!'bQYO,59dO!'bQYO,59fO#.`QYO,59hO#/hQ^O,5:oO!'bQYO1G.fO#1TQ^O1G/SO#1[Q^O1G/[O#1cQ^O1G/[O#1jQ^O1G/OO#2QQ^O1G/QO!'bQYO1G.xO#2eQ^O7+$QO!'bQYO7+$nO#4QQYO7+%yO#4XQ^O7+$dO#5tQ^O<<HYO!<OQbO,5:XO#5{Q^O'#E]O!'bQYO<<IeP!'bQYO<<GzP#7hQ^OAN=fO#8kQ^O'#DQO,ZQYO'#CnO!'bQYO'#DUO3^QYO,58zO#:WQYO,59^O#:]QYO1G/SO#:dQWO1G0_O#:iQ`O'#DmO# {QYO'#ETO# {QYO,59hO# {QYO,59pO# {QYO,59pO# {QYO,59pO# {QYO,59dO# {QYO,59fO#<XQYO,59hO#=aQYO,5:oO# {QYO1G.fO#>TQYO1G/SO#>[QYO1G/[O#>cQYO1G/[O#>jQYO1G/OO#?QQYO1G/QO# {QYO1G.xO#?eQYO7+$QO# {QYO7+$nO#@XQYO7+%yO#@`QYO7+$dO#ASQYO<<HYO#AZQYO'#E]O# {QYO<<IeP# {QYO<<GzP#A}QYOAN=fO# {QYO'#DUO3^QYO,58zO#CQQYO,59^O#CVQYO1G/SO#C^QWO1G0_O$qQYO'#C`O$qQYO'#CrO,ZQYO,59hO:}QYO,5:sO#CcQWO'#EXO$qQYO'#C`O$qQYO'#CrO#ChQYO'#DQO,ZQYO,59hO:}QYO,5:sO#DRQWO'#EX",
  stateData: "#DW~O#pOS#qOSPOSQOS~OTpOZUO[TOcqOgsOhsOrzOueO!SxO!TxO!UuO!WwO!b{O!fyO!hhO!ovO!vfO#RjO#lQO#mQO$f[O$g]O$h^O$i_O~OTpO[TOcqOgsOhsOr&lOueO!SxO!TxO!UuO!WwO!b{O!fyO!hhO!ovO!vfO#RjO#lQO#mQO$f[O$g]O$h^O$i_O~OZ!PO#Z!RO~P!|O#lQO#mQO~OZ!ZO[!ZO]![O^![O_!iOm!fOo!gOq!YOr!YOs!hOy!]O{!jO!h!cO#x!aOu$_X~O#n!eO$o!eOT#rXc#rXg#rXh#rX!S#rX!T#rX!U#rX!W#rX!b#rX!f#rX!o#rX!v#rX#R#rX#j#rX#l#rX#m#rX$f#rX$g#rX$h#rX$i#rX~P$yO$f!kOT$WXZ$WX[$WXc$WXg$WXh$WXr$WXu$WX!S$WX!T$WX!U$WX!W$WX!b$WX!f$WX!h$WX!o$WX!v$WX#R$WX#l$WX#m$WX$g$WX$h$WX$i$WX~O#lQO#mQOT!PXZ!PX[!PX]!PX^!PX_!PXc!PXg!PXh!PXm!PXo!PXq!PXr!PXs!PXu!PXy!PX{!PX!S!PX!T!PX!U!PX!W!PX!b!PX!f!PX!h!PX!o!PX!v!PX#R!PX#j!PX#n!PX#x!PX$f!PX$g!PX$h!PX$i!PX$o!PX#|!PXw!PX#{!PXd!PXa!PX#Q!PXe!PXk!PX~Ou!nO~O$g]O~OZUO~P!|O#n!sOZ#tX[#tX]#tX^#tX_#tXm#tXo#tXq#tXr#tXs#tXu#tXy#tX{#tX!f#tX!h#tX#j#tX#x#tXe#tX~OT#tXc#tXg#tXh#tX!S#tX!T#tX!U#tX!W#tX!b#tX!o#tX!v#tX#R#tX#l#tX#m#tX#n#tX$f#tX$g#tX$h#tX$i#tX$o#tX~P,bOZUO!f$bP~P!|Ou!vO~O#k!wO$g]O#Q$nP~Oo#UO~Oo#VOu!tX~OZ!ZO[!ZO]![O^![Oy!]O{!jO!h!cO#x!aOu$_X#jtX#|tXwtX#{tX!ftXdtXatX#QtXktX~O_&sOm&qOo&rOq&mOr&mOs'jO~P/zO#|#YO#j$SXw$SX~O#j#YX~P'dOu#[O~OZ#]O[#]O]#]O^#]O#lQO#mQO#x#]O#y#]O$YWX~O_WXwWX#|WX~P2TO_#aO~O#|#bOa#vX~Oa#eO~OTpOZUO[TOcqOgsOhsOrzO!SxO!TxO!UuO!WwO!b{O!fyO!hhO!ovO!vfO#RjO#lQO#mQO$f[O$g]O$h^O$i_O~Ou#oO~P3cO|#qO~O{!jO!h!cO#x!aOTxaZxa[xa]xa^xa_xacxagxahxamxaoxaqxarxasxau$_Xyxa!Sxa!Txa!Uxa!Wxa!bxa!fxa!oxa!vxa#Rxa#jxa#lxa#mxa#nxa$fxa$gxa$hxa$ixa$oxa#|xawxa#{xadxaaxa#Qxaexakxa~OZUOw$bP~P!|OZ!ZO[!ZO]![O^![O_&sOm&qOo&rOq&mOr&mOs'jOw#zOy!]O{!jO!h!cO#x!aO#{#{Ou$_X~OZ!ZO[!ZO]![O^![O_&sOm&qOo&rOq&mOr&mOs'jOy!]O{!jO!h!cO#x!aO#{#{Ou$_X~O#|#|O!f$bX~P9jO!f$OO~O#lQO#mQOw$lP~OZ#]O[#]O]#]O^#]O#k!wO#x#]O#y#]O~O$Y#VX~P;YO$Y$VO~O#|$WO#Q$nX~O#Q$YO~OZ!ZO[!ZO]![O^![O_&sOm&qOo&rOq&mOr&mOs'jOy!]O{!jO!h!cO#x!aOu$_X~Od$ZO~P<[O#|$]Ok$QX~Ok$_O~O!V$`O~O!S$aO~OT!wac!wag!wah!wa!S!wa!T!wa!U!wa!W!wa!b!wa!f!wa!o!wa!v!wa#R!wa#j!wa#l!wa#m!wa#n!wa$f!wa$g!wa$h!wa$i!wa$o!wa~P$yO#|#YO#j$Saw$Sa~OZ#]O[#]O]#]O^#]O#lQO#mQO#x#]O#y#]O~O_Wa$YWawWa#|Wa~P?pO#|#bOa#va~OZ!ZO[!ZO]![O^![Oy!]O{!jO!h!cO#x!aOTpi_picpigpihpimpiopiqpirpispiu$_X!Spi!Tpi!Upi!Wpi!bpi!fpi!opi!vpi#Rpi#jpi#lpi#mpi#npi$fpi$gpi$hpi$ipi$opi~O]![O^![Oy!]O{!jO!h!cO#x!aOTxiZxi[xi_xicxigxihximxioxiqxirxisxiu$_X!Sxi!Txi!Uxi!Wxi!bxi!fxi!oxi!vxi#Rxi#jxi#lxi#mxi#nxi$fxi$gxi$hxi$ixi$oxi~Oy!]O{!jO!h!cO#x!aOTxiZxi[xi]xi^xi_xicxigxihximxioxiqxirxisxiu$_X!Sxi!Txi!Uxi!Wxi!bxi!fxi!oxi!vxi#Rxi#jxi#lxi#mxi#nxi$fxi$gxi$hxi$ixi$oxi~O{!jO!h!cO#x!aOTxiZxi[xi]xi^xi_xicxigxihximxioxiqxirxisxiu$_X!Sxi!Txi!Uxi!Wxi!bxi!fxi!oxi!vxi#Rxi#jxi#lxi#mxi#nxi$fxi$gxi$hxi$ixi$oxiexi~Oyxi#|xiwxi#{xidxiaxi#Qxikxi~PHVO!f$kO~P<[OZ!ZO[!ZO]![O^![Oy!]O{!jO!h!cO#x!aOTlicliglihlimliu$_X!Sli!Tli!Uli!Wli!bli!fli!oli!vli#Rli#jli#lli#mli#nli$fli$gli$hli$ili$oli~O_!iOo!gOq!YOr!YOs!hO~PKaOZ!ZO[!ZO]![O^![Oy!]O{!jO!h!cO#x!aOTnicnignihnimnioniu$_X!Sni!Tni!Uni!Wni!bni!fni!oni!vni#Rni#jni#lni#mni#nni$fni$gni$hni$ini$oni~O_!iOq!YOr!YOs!hO~PMzOZ!ZO[!ZO]![O^![O_&sOm&qOq&mOr&mOs'jOy!]O{!jO!h!cO#x!aOu$_X~Oo$lO~P!!eO!R$qO!U$rO!W$sO!Z$tO!^$uO!b$vO#lQO#mQO~OZ#aX[#aX]#aX^#aX_#aXm#aXo#aXq#aXr#aXs#aXu#aXw#aXy#aX{#aX!h#aX#l#aX#m#aX#n#aX#x#aX#|#aX~P2TO#|#|Ow$bX~P<[O$Y$xO~O#|$yOw$aX~Ow${O~O#|#|O!f$baw$ba~O$Y%POw!}X#|!}X~O#|%QOw$lX~Ow%SO~O$Y#Va~P;YO#k!wO$g]O~O#|$WO#Q$na~OTpOZUO[TOcqOgsOhsOr'qOueO!SxO!TxO!UuO!WwO!b{O!fyO!hhO!ovO!vfO#RjO#lQO#mQO$f[O$g]O$h^O$i_O~O#|$]Ok$Qa~O!T%^O~Ow!QO~O#{%_Oa`X#|`X~P<[OTSqcSqgSqhSq!SSq!TSq!USq!WSq!bSq!fSq!oSq!vSq#RSq#jSq#lSq#mSq#nSq$fSq$gSq$hSq$iSq$oSq~P$yO#|tX~P8cOw%aO~O#x%bOT!OXZ!OX[!OX]!OX^!OX_!OXc!OXg!OXh!OXm!OXo!OXq!OXr!OXs!OXu!OXy!OX{!OX!S!OX!T!OX!U!OX!W!OX!b!OX!f!OX!h!OX!o!OX!v!OX#R!OX#j!OX#l!OX#m!OX#n!OX$f!OX$g!OX$h!OX$i!OX$o!OX#|!OXw!OX#{!OXd!OXa!OX#Q!OXe!OXk!OX~Oo%dO~Oo%eO~Oo%fO~O![%gO~O![%hO~O![%iO~O#|$yOw$aa~OZ!ZO[!ZO]![O^![O_&sOm&qOo&rOq&mOr&mOs'jOy!]O{!jO#x!aOu$_X~Ow%nO!f%nO!h%mO~P!/[O!f#fa#|#faw#fa~P<[O#|%QOw$la~O#O%tO~P`O#Q#Ti#|#Ti~P<[OZ!ZO[!ZO]![O^![O_'xOm'vOo'wOq'rOr'rOs)]Oy!]O{!jO!h!cO#x!aOTbqcbqgbqhbqu$_X!Sbq!Tbq!Ubq!Wbq!bbq!fbq!obq!vbq#Rbq#jbq#lbq#mbq#nbq$fbq$gbq$hbq$ibq$obq~Oe%uO~P!1_Ok$Ri#|$Ri~P<[OTfqcfqgfqhfq!Sfq!Tfq!Ufq!Wfq!bfq!ffq!ofq!vfq#Rfq#jfq#lfq#mfq#nfq$ffq$gfq$hfq$ifq$ofq~P$yOZ!ZO[!ZO]![O^![Oy!]O{!jO!h!cO#x!aOTpy_pycpygpyhpympyopyqpyrpyspyu$_X!Spy!Tpy!Upy!Wpy!bpy!fpy!opy!vpy#Rpy#jpy#lpy#mpy#npy$fpy$gpy$hpy$ipy$opy~O#x%bOT!OaZ!Oa[!Oa]!Oa^!Oa_!Oac!Oag!Oah!Oam!Oao!Oaq!Oar!Oas!Oau!Oay!Oa{!Oa!S!Oa!T!Oa!U!Oa!W!Oa!b!Oa!f!Oa!h!Oa!o!Oa!v!Oa#R!Oa#j!Oa#l!Oa#m!Oa#n!Oa$f!Oa$g!Oa$h!Oa$i!Oa$o!Oa#|!Oaw!Oa#{!Oad!Oaa!Oa#Q!Oae!Oak!Oa~O!S%yO~O!V%yO~O!S%zO~O!R$qO!U$rO!W$sO!Z$tO!^$uO!b(dO#lQO#mQO~O!X$ZP~P!;dOw!li#|!li~P<[OT$^XZ$^X[$^X]!xy^!xy_!xyc$^Xg$^Xh$^Xm!xyo!xyq!xyr$^Xs!xyu$^Xy!xy{!xy!S$^X!T$^X!U$^X!W$^X!b$^X!f$^X!h$^X!o$^X!v$^X#R$^X#j!xy#l$^X#m$^X#n!xy#x!xy$f$^X$g$^X$h$^X$i$^X$o!xy#|!xyw!xy#{!xyd!xya!xy#Q!xye!xyk!xy~OT#PXc#PXg#PXh#PX!S#PX!T#PX!U#PX!W#PX!b#PX!f#PX!o#PX!v#PX#R#PX#j#PX#l#PX#m#PX#n#PX$f#PX$g#PX$h#PX$i#PX$o#PX~P$yOa`i#|`i~P<[O!T&YO~O#lQO#mQO!X!PX#x!PX#|!PX~O#x'VO!X!OX#|!OX~O!X&[O~O$Y&]O~O#|&^O!X$XX~O!X&`O~O#|&aO!X$ZX~O!X&cO~OTb!Rcb!Rgb!Rhb!R!Sb!R!Tb!R!Ub!R!Wb!R!bb!R!fb!R!ob!R!vb!R#Rb!R#jb!R#lb!R#mb!R#nb!R$fb!R$gb!R$hb!R$ib!R$ob!R~P$yO#x'VO!X!Oa#|!Oa~O#|&^O!X$Xa~O#|&aO!X$Za~O$[&iO~O#|#tXw#tX#{#tXd#tXa#tX#Q#tXk#tX~P,bOTpOZUO[TOcqOgsOhsOr&lO!SxO!TxO!UuO!WwO!b{O!fyO!hhO!ovO!vfO#RjO#lQO#mQO$f[O$g]O$h^O$i_O~Ou#oO~P!E`O#j!wa#|!waw!wa#{!wa!f!wad!waa!wa#Q!wak!wa~P<[OZ!ZO[!ZO]![O^![Oy!]O{!jO!h!cO#x!aO_pimpiopiqpirpispiu$_X#jpi#|piwpi#{pi!fpidpiapi#Qpikpi~O]![O^![Oy!]O{!jO!h!cO#x!aOZxi[xi_ximxioxiqxirxisxiu$_X#jxi#|xiwxi#{xi!fxidxiaxi#Qxikxi~Oy!]O{!jO!h!cO#x!aOZxi[xi]xi^xi_ximxioxiqxirxisxiu$_X#jxi#|xiwxi#{xi!fxidxiaxi#Qxikxi~OZ!ZO[!ZO]![O^![Oy!]O{!jO!h!cO#x!aOmliu$_X#jli#|liwli#{li!flidliali#Qlikli~O_&sOo&rOq&mOr&mOs'jO~P!LiOZ!ZO[!ZO]![O^![Oy!]O{!jO!h!cO#x!aOmnioniu$_X#jni#|niwni#{ni!fnidniani#Qnikni~O_&sOq&mOr&mOs'jO~P!NZOTpOZUO[TOcqOgsOhsOr(eOueO!SxO!TxO!UuO!WwO!b{O!fyO!hhO!ovO!vfO#RjO#lQO#mQO$f[O$g]O$h^O$i_O~O#jSq#|SqwSq#{Sq!fSqdSqaSq#QSqkSq~P<[OZUO#O'XO~P!|OZ!ZO[!ZO]![O^![O_(lOm(jOo(kOq(fOr(fOs)VOy!]O{!jO!h!cO#x!aOu$_X#jbq#|bqwbq#{bq!fbqdbqabq#Qbqkbq~Oe'YO~P#$dOebq~P#$dOebq~P!1_O#jfq#|fqwfq#{fq!ffqdfqafq#Qfqkfq~P<[OZ!ZO[!ZO]![O^![Oy!]O{!jO!h!cO#x!aO_pympyopyqpyrpyspyu$_X#jpy#|pywpy#{py!fpydpyapy#Qpykpy~O#j#PX#|#PXw#PX#{#PX!f#PXd#PXa#PX#Q#PXk#PX~P<[O#jb!R#|b!Rwb!R#{b!R!fb!Rdb!Rab!R#Qb!Rkb!R~P<[OTtXctXgtXhtX!StX!TtX!UtX!WtX!btX!ftX!otX!vtX#RtX#jtX#ltX#mtX#ntX$ftX$gtX$htX$itX$otX~P$yOd&{O~P<[Ok&|O~Oo'OO~P!!eOw'PO~O$['[O~Od'dO~P<[O!X'eO~Od'fO~P<[Ou'kO~OTpOZUO[TOcqOgsOhsOr'qO!SxO!TxO!UuO!WwO!b{O!fyO!hhO!ovO!vfO#RjO#lQO#mQO$f[O$g]O$h^O$i_O~Ou#oO~P#,uOZ!ZO[!ZO]![O^![O_'xOm'vOo'wOq'rOr'rOs)]Oy!]O{!jO!h!cO#x!aOu$_X~OT!wac!wae!wag!wah!wa!S!wa!T!wa!U!wa!W!wa!b!wa!f!wa!o!wa!v!wa#R!wa#j!wa#l!wa#m!wa#n!wa$f!wa$g!wa$h!wa$i!wa$o!wa~P#.gOepi~P@tOexi~PCZOexi~PEpO_'xOo'wOq'rOr'rOs)]Oeli~PKaO_'xOq'rOr'rOs)]Oeni~PMzOTSqcSqeSqgSqhSq!SSq!TSq!USq!WSq!bSq!fSq!oSq!vSq#RSq#jSq#lSq#mSq#nSq$fSq$gSq$hSq$iSq$oSq~P#.gO#O(YO~P!'bOTfqcfqefqgfqhfq!Sfq!Tfq!Ufq!Wfq!bfq!ffq!ofq!vfq#Rfq#jfq#lfq#mfq#nfq$ffq$gfq$hfq$ifq$ofq~P#.gOepy~P!5oOT#PXc#PXe#PXg#PXh#PX!S#PX!T#PX!U#PX!W#PX!b#PX!f#PX!o#PX!v#PX#R#PX#j#PX#l#PX#m#PX#n#PX$f#PX$g#PX$h#PX$i#PX$o#PX~P#.gOZ!ZO[!ZO]![O^![O_'xOm'vOo'wOq'rOr'rOs)]Oy!]O{!jO!h!cO#x!aOu$_X~Qb!RTtXctXetXgtXhtX!StX!TtX!UtX!WtX!btX!ftX!otX!vtX#RtX#jtX#ltX#mtX#ntX$ftX$gtX$htX$itX$otX~P#.gOk(QO~Oo(SO~P!!eOw(TO~O![(WO~OTpOZUO[TOcqOgsOhsOr(eO!SxO!TxO!UuO!WwO!b{O!fyO!hhO!ovO!vfO#RjO#lQO#mQO$f[O$g]O$h^O$i_O~Ou#oO~P#:nOZ!ZO[!ZO]![O^![O_(lOm(jOo(kOq(fOr(fOs)VOy!]O{!jO!h!cO#x!aOu$_X~Oe!wa#j!wa#|!waw!wa#{!wa!f!wad!waa!wa#Q!wak!wa~P#<`Oepi~P!GqOexi~P!I_Oexi~P!J{O_(lOo(kOq(fOr(fOs)VOeli~P!LiO_(lOq(fOr(fOs)VOeni~P!NZOeSq#jSq#|SqwSq#{Sq!fSqdSqaSq#QSqkSq~P#<`O#O({O~P# {Oefq#jfq#|fqwfq#{fq!ffqdfqafq#Qfqkfq~P#<`Oepy~P#'WOe#PX#j#PX#|#PXw#PX#{#PX!f#PXd#PXa#PX#Q#PXk#PX~P#<`OZ!ZO[!ZO]![O^![O_(lOm(jOo(kOq(fOr(fOs)VOy!]O{!jO!h!cO#x!aOu$_X~Qb!Rk(tO~Oo(vO~P!!eOw(wO~Ou)WO~O_(lOm(jOo(kOq(fOr(fOs)VOetX~P/zOu)^O~O",
  goto: "!7p$oPPPP$pP&p&|'V'r*mPPPPP*vP$pPPP$pPP*y+VP$pP$pP$pPPP+`P+nP$pP$pPP+w,^,i,^PPPPPPP,^PP,^P/P/S,^P/Y/`$pP$pP$p/g1g1j1p1gP1{3{1{1{6S8SP$p:S$p<S<S>S>`P>iPP<S>u>{6O?PP?XP?[?b?i?o?u?{B_BiBoBuB{CSCYC`PPPPPPPPCfCjHvJvL|MSPPMZPPMaMm! s!#y!$P!$W!$]!%y!'k!)a!+gP!+jP!+n!-`!/Q!1Q!1W!1Z$p!1a!1aPPPPHv!3a!5g!5m!7m${fOPVehoryz!Y!^!_!`!d!f!g!h!i!n#Y#[#`#d#o#{#|$V$Z$[$_$l$x%S%_%t%u&l&m&n&o&p&q&r&s&u&{&|'O'P'X'Y']'d'f'h'j'p'q'r's't'u'v'w'x'z(Q(S(T(Y(Z(^(_(e(f(g(h(i(j(k(l(n(t(v(w({(|)O)V)]Q!XRQ'_'gQ(`)YR)P)TW!VR'g)T)YR$h#bY!TR#b'g)T)YY#Pt$]'i)U)Z^#t!n!v$y%Q'k)W)^T&O%h&^%fWOPVXehoryz!Y!^!_!`!b!d!f!g!h!i#Y#[#`#d#o#q#{#|$V$Z$[$_$l$x%P%S%_%b%g%i%t%u%{&]&a&i&l&m&n&o&p&q&r&s&u&{&|'O'P'V'X'Y'[']'d'f'h'j'p'q'r's't'u'v'w'x'z(Q(S(T(W(Y(Z(^(_(e(f(g(h(i(j(k(l(n(t(v(w({(|)O)V)]t!SRt!v#b$]$y%Q%h&^'g'i'k)T)U)W)Y)Z)^U#^!S#_#rR#r!nU#^!S#_#rT$T!x$UR$g#`Q#TtQ'a'iQ(a)ZR)Q)UW#Rt'i)U)ZR%Z$]U}P#[#oW#p!i&s'x(lR$b#YQ!QPQ$d#[R$n#oQ$w#qQ%o%PQ%}%gU&S%i&a(WQ&d&]T&j&i'[c$p#q%P%g%i&]&a&i'[(W!fgOVoz!Y!^!_!`!f!g!i#d$Z$_$l%S%t%u'd'q'r's't'u'v'w'x'z(Q(S(T(Y(Z(_Q#j!bU$o#q%P&iS%w%b'V[%|%g%i&]&a'[(W#e&kPehry!d!h!n#Y#[#`#o#{#|$V$[$x%_&l&m&n&o&p&q&r&s&u&{&|'O'P'X'Y']'f'h'j'p(^(e(f(g(h(i(j(k(l(n(t(v(w({(|)O)V)]R&R%hQ&P%hR&e&^Q&V%iR'm(WS&T%i(WR&g&a${YOPVehoryz!Y!^!_!`!d!f!g!h!i!n#Y#[#`#d#o#{#|$V$Z$[$_$l$x%S%_%t%u&l&m&n&o&p&q&r&s&u&{&|'O'P'X'Y']'d'f'h'j'p'q'r's't'u'v'w'x'z(Q(S(T(Y(Z(^(_(e(f(g(h(i(j(k(l(n(t(v(w({(|)O)V)]R#y!nQ#v!nR%k$yS#u!n$yZ$P!v%Q'k)W)^${bOPVehoryz!Y!^!_!`!d!f!g!h!i!n#Y#[#`#d#o#{#|$V$Z$[$_$l$x%S%_%t%u&l&m&n&o&p&q&r&s&u&{&|'O'P'X'Y']'d'f'h'j'p'q'r's't'u'v'w'x'z(Q(S(T(Y(Z(^(_(e(f(g(h(i(j(k(l(n(t(v(w({(|)O)V)]$zbOPVehoryz!Y!^!_!`!d!f!g!h!i!n#Y#[#`#d#o#{#|$V$Z$[$_$l$x%S%_%t%u&l&m&n&o&p&q&r&s&u&{&|'O'P'X'Y']'d'f'h'j'p'q'r's't'u'v'w'x'z(Q(S(T(Y(Z(^(_(e(f(g(h(i(j(k(l(n(t(v(w({(|)O)V)]Q!p_T!yk$W${`OPVehoryz!Y!^!_!`!d!f!g!h!i!n#Y#[#`#d#o#{#|$V$Z$[$_$l$x%S%_%t%u&l&m&n&o&p&q&r&s&u&{&|'O'P'X'Y']'d'f'h'j'p'q'r's't'u'v'w'x'z(Q(S(T(Y(Z(^(_(e(f(g(h(i(j(k(l(n(t(v(w({(|)O)V)]${aOPVehoryz!Y!^!_!`!d!f!g!h!i!n#Y#[#`#d#o#{#|$V$Z$[$_$l$x%S%_%t%u&l&m&n&o&p&q&r&s&u&{&|'O'P'X'Y']'d'f'h'j'p'q'r's't'u'v'w'x'z(Q(S(T(Y(Z(^(_(e(f(g(h(i(j(k(l(n(t(v(w({(|)O)V)]${dOPVehoryz!Y!^!_!`!d!f!g!h!i!n#Y#[#`#d#o#{#|$V$Z$[$_$l$x%S%_%t%u&l&m&n&o&p&q&r&s&u&{&|'O'P'X'Y']'d'f'h'j'p'q'r's't'u'v'w'x'z(Q(S(T(Y(Z(^(_(e(f(g(h(i(j(k(l(n(t(v(w({(|)O)V)]${lOPVehoryz!Y!^!_!`!d!f!g!h!i!n#Y#[#`#d#o#{#|$V$Z$[$_$l$x%S%_%t%u&l&m&n&o&p&q&r&s&u&{&|'O'P'X'Y']'d'f'h'j'p'q'r's't'u'v'w'x'z(Q(S(T(Y(Z(^(_(e(f(g(h(i(j(k(l(n(t(v(w({(|)O)V)]Q$S!vQ'c'kQ(c)^R)S)WW$Q!v'k)W)^R%p%QW%s%S'P(T(wX&W%t'X(Y({Q!{kR%V$WT!zk$WS!xk$WT$T!x$UR!QPQoOR!}oS#_!S#rR$e#_Q#c!VR$i#cQ$^#RR%[$^Q#Z}R$c#Z%UXOPVehoryz!Y!^!_!`!b!d!f!g!h!i!n#Y#[#`#d#o#q#{#|$V$Z$[$_$l$x%P%S%_%b%t%u&i&l&m&n&o&p&q&r&s&u&{&|'O'P'X'Y']'d'f'h'j'p'q'r's't'u'v'w'x'z(Q(S(T(Y(Z(^(_(e(f(g(h(i(j(k(l(n(t(v(w({(|)O)V)]S!mX%{_%{%g%i&]&a'V'[(WQ%c$oS%x%c&ZR&Z%|Q&_&PR&f&_Q&b&TR&h&bQ$z#vR%l$zS#}!t#sR%O#}Q%R$QR%q%RQ$U!xR%T$UQ$X!{R%W$XTnOoSSOoW|P#Y#[&sW!lV'](_)OQ!reQ!thQ#OrQ#WyQ#XzQ#f!YQ#g!^Q#h!_W#i!`&p'u(iQ#k!dQ#l!fQ#m!gQ#n!hQ#s!nQ$f#`Q$j#dQ$m#oQ$|#{Q$}#|Q%U$VQ%X$ZQ%Y$[Q%]$_Q%`$lQ%j$xS%r%S%tQ%v%_Q&X%uQ&t&lQ&v&mQ&w&nQ&x&oQ&y&qQ&z&rQ&}&uQ'Q&{Q'R'fQ'S'dQ'T&|Q'U'OS'W'P'XQ'Z'YQ'^!iQ'`'hQ'b'jQ'l'pQ'n(^Q'y'qQ'{'rQ'|'sQ'}'tQ(O'vQ(P'wQ(R'zQ(U(QQ(V(SS(X(T(YQ([(ZQ(]'xQ(b)]Q(m(eQ(o(fQ(p(gQ(q(hQ(r(jQ(s(kQ(u(nQ(x(tQ(y(vS(z(w({Q(}(|Q)R)VR)[(l${mOPVehoryz!Y!^!_!`!d!f!g!h!i!n#Y#[#`#d#o#{#|$V$Z$[$_$l$x%S%_%t%u&l&m&n&o&p&q&r&s&u&{&|'O'P'X'Y']'d'f'h'j'p'q'r's't'u'v'w'x'z(Q(S(T(Y(Z(^(_(e(f(g(h(i(j(k(l(n(t(v(w({(|)O)V)]rROVoz!Y!^!_!`!f!g!i#d$_$l%S%t%u!p'gPehry!d!h!n#Y#[#`#o#{#|$V$[$x%_&l&m&n&o&p&q&r&s&u&|'O'P'X'Y']'h'j'p(^)V)]r)T&{'f(e(f(g(h(i(j(k(l(n(t(v(w({(|)Os)Y$Z'd'q'r's't'u'v'w'x'z(Q(S(T(Y(Z(_X!WR'g)T)YZ!UR#b'g)T)YQ#`!TR$[#PQ#d!XQ&u'_Q'z(`R(n)PrrOVoz!Y!^!_!`!f!g!i#d$_$l%S%t%u!p'hPehry!d!h!n#Y#[#`#o#{#|$V$[$x%_&l&m&n&o&p&q&r&s&u&|'O'P'X'Y']'h'j'p(^)V)]r'p$Z'd'q'r's't'u'v'w'x'z(Q(S(T(Y(Z(_s(^&{'f(e(f(g(h(i(j(k(l(n(t(v(w({(|)OrtOVoz!Y!^!_!`!f!g!i#d$_$l%S%t%u!p'iPehry!d!h!n#Y#[#`#o#{#|$V$[$x%_&l&m&n&o&p&q&r&s&u&|'O'P'X'Y']'h'j'p(^)V)]r)U&{'f(e(f(g(h(i(j(k(l(n(t(v(w({(|)Os)Z$Z'd'q'r's't'u'v'w'x'z(Q(S(T(Y(Z(_X#St'i)U)ZZ#Qt$]'i)U)ZV!OP#[#of!^S#X#f#l#m$j%]%`%r&X'^!`&n|!r!t#O#W#k#n#s$f$m$|$}%U%Y%j%v&t&v&y&z&}'T'U'W'Z'`'b'l'n(b)Rh's%X'S'y'{(O(P(R(U(V(X([(]i(g'Q'R(m(o(r(s(u(x(y(z(})[h!_S#X#f#g#l#m$j%]%`%r&X'^!b&o|!r!t#O#W#k#n#s$f$m$|$}%U%Y%j%v&t&v&w&y&z&}'T'U'W'Z'`'b'l'n(b)Rj't%X'S'y'{'|(O(P(R(U(V(X([(]k(h'Q'R(m(o(p(r(s(u(x(y(z(})[j!`S#X#f#g#h#l#m$j%]%`%r&X'^!d&p|!r!t#O#W#k#n#s$f$m$|$}%U%Y%j%v&t&v&w&x&y&z&}'T'U'W'Z'`'b'l'n(b)Rl'u%X'S'y'{'|'}(O(P(R(U(V(X([(]m(i'Q'R(m(o(p(q(r(s(u(x(y(z(})[rVOVoz!Y!^!_!`!f!g!i#d$_$l%S%t%u!p']Pehry!d!h!n#Y#[#`#o#{#|$V$[$x%_&l&m&n&o&p&q&r&s&u&|'O'P'X'Y']'h'j'p(^)V)]r(_$Z'd'q'r's't'u'v'w'x'z(Q(S(T(Y(Z(_s)O&{'f(e(f(g(h(i(j(k(l(n(t(v(w({(|)OR&Q%hT&U%i(W$_!bS|!l!r!t#O#W#X#f#g#h#i#k#l#m#n#s$f$j$m$|$}%U%X%Y%]%`%j%r%v&X&t&v&w&x&y&z&}'Q'R'S'T'U'W'Z'^'`'b'l'n'y'{'|'}(O(P(R(U(V(X([(](b(m(o(p(q(r(s(u(x(y(z(})R)[$_!dS|!l!r!t#O#W#X#f#g#h#i#k#l#m#n#s$f$j$m$|$}%U%X%Y%]%`%j%r%v&X&t&v&w&x&y&z&}'Q'R'S'T'U'W'Z'^'`'b'l'n'y'{'|'}(O(P(R(U(V(X([(](b(m(o(p(q(r(s(u(x(y(z(})R)[${ZOPVehoryz!Y!^!_!`!d!f!g!h!i!n#Y#[#`#d#o#{#|$V$Z$[$_$l$x%S%_%t%u&l&m&n&o&p&q&r&s&u&{&|'O'P'X'Y']'d'f'h'j'p'q'r's't'u'v'w'x'z(Q(S(T(Y(Z(^(_(e(f(g(h(i(j(k(l(n(t(v(w({(|)O)V)]Q!oZR!q`R#w!nQ!uhR#x!n${cOPVehoryz!Y!^!_!`!d!f!g!h!i!n#Y#[#`#d#o#{#|$V$Z$[$_$l$x%S%_%t%u&l&m&n&o&p&q&r&s&u&{&|'O'P'X'Y']'d'f'h'j'p'q'r's't'u'v'w'x'z(Q(S(T(Y(Z(^(_(e(f(g(h(i(j(k(l(n(t(v(w({(|)O)V)]riOVoz!Y!^!_!`!f!g!i#d$_$l%S%t%u!p'oPehry!d!h!n#Y#[#`#o#{#|$V$[$x%_&l&m&n&o&p&q&r&s&u&|'O'P'X'Y']'h'j'p(^)V)]r)X&{'f(e(f(g(h(i(j(k(l(n(t(v(w({(|)Os)_$Z'd'q'r's't'u'v'w'x'z(Q(S(T(Y(Z(_X$R!v'k)W)^${kOPVehoryz!Y!^!_!`!d!f!g!h!i!n#Y#[#`#d#o#{#|$V$Z$[$_$l$x%S%_%t%u&l&m&n&o&p&q&r&s&u&{&|'O'P'X'Y']'d'f'h'j'p'q'r's't'u'v'w'x'z(Q(S(T(Y(Z(^(_(e(f(g(h(i(j(k(l(n(t(v(w({(|)O)V)]R!|k",
  nodeNames: "\u26A0 LineComment BlockComment Expressions ForExpression for InExpressions InExpression Name Identifier Identifier ArithOp ArithOp ArithOp ArithOp in IterationContext return IfExpression if then else QuantifiedExpression some every InExpressions InExpression satisfies Disjunction or Conjunction and Comparison CompareOp CompareOp between PositiveUnaryTest ( PositiveUnaryTests ) ArithmeticExpression ArithOp InstanceOfExpression instance of Type QualifiedName VariableName SpecialType days time duration years months date > ListType list < ContextType context ContextEntryTypes ContextEntryType FunctionType function ArgumentTypes ArgumentType PathExpression ] FilterExpression [ FunctionInvocation SpecialFunctionName NamedParameters NamedParameter ParameterName PositionalParameters null NumericLiteral StringLiteral BooleanLiteral DateTimeLiteral DateTimeConstructor AtLiteral ? SimplePositiveUnaryTest Interval ParenthesizedExpression List FunctionDefinition FormalParameters FormalParameter external FunctionBody } { Context ContextEntry Key Name Identifier UnaryTests Wildcard not",
  maxTerm: 169,
  context: variableTracker,
  nodeProps: [
    ["group", -17, 4, 18, 22, 28, 30, 32, 40, 42, 67, 69, 71, 84, 85, 87, 88, 89, 96, "Expression", 47, "Expression Expression", -5, 77, 78, 79, 80, 81, "Expression Literal"],
    ["closedBy", 37, ")", 70, "]", 95, "}"],
    ["openedBy", 39, "(", 68, "[", 94, "{"]
  ],
  propSources: [feelHighlighting],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 14,
  tokenData: "+l~RuXY#fYZ$ZZ[#f]^$Zpq#fqr$`rs$kwx&cxy&hyz&mz{&r{|'P|}'U}!O'Z!O!P'h!P!Q(Q!Q![){![!]*^!]!^*c!^!_*h!_!`$f!`!a*w!b!c+R!}#O+W#P#Q+]#Q#R&z#o#p+b#q#r+g$f$g#f#BY#BZ#f$IS$I_#f$I|$I}$Z$I}$JO$Z$JT$JU#f$KV$KW#f&FU&FV#f?HT?HU#f~#kY#p~XY#fZ[#fpq#f$f$g#f#BY#BZ#f$IS$I_#f$JT$JU#f$KV$KW#f&FU&FV#f?HT?HU#f~$`O#q~~$cP!_!`$f~$kOq~~$pW$g~OY$kZr$krs%Ys#O$k#O#P%_#P;'S$k;'S;=`&]<%lO$k~%_O$g~~%bRO;'S$k;'S;=`%k;=`O$k~%pX$g~OY$kZr$krs%Ys#O$k#O#P%_#P;'S$k;'S;=`&];=`<%l$k<%lO$k~&`P;=`<%l$k~&hO#y~~&mOu~~&rOw~~&wP^~z{&z~'POy~~'UO[~~'ZO#|~R'`PZP!`!a'cQ'hO$[Q~'mQ#x~!O!P's!Q!['x~'xO#{~~'}P$f~!Q!['x~(VQ]~z{(]!P!Q)d~(`TOz(]z{(o{;'S(];'S;=`)^<%lO(]~(rVOz(]z{(o{!P(]!P!Q)X!Q;'S(];'S;=`)^<%lO(]~)^OQ~~)aP;=`<%l(]~)iSP~OY)dZ;'S)d;'S;=`)u<%lO)d~)xP;=`<%l)d~*QQ$f~!O!P*W!Q![){~*ZP!Q!['x~*cO$Y~~*hO$o~R*oP![QrP!_!`*rP*wOrPR+OP!XQrP!_!`*r~+WO$i~~+]O!h~~+bO!f~~+gO#R~~+lO#Q~",
  tokenizers: [propertyIdentifiers, identifiers, insertSemicolon, 0, 1],
  topRules: { "Expressions": [0, 3], "UnaryTests": [1, 101] },
  dynamicPrecedences: { "30": -1, "71": -1, "73": -1, "126": -1 },
  specialized: [{ term: 120, get: (value) => spec_identifier[value] || -1 }],
  tokenPrec: 0
});

// node_modules/lang-feel/dist/index.js
var import_language = require("@codemirror/language");
var import_autocomplete = require("@codemirror/autocomplete");
var snippets = [
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("function(${params}) ${body}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("for ${var} in ${collection} return ${value}", {
    label: "for",
    detail: "expression",
    type: "keyword"
  }),
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("every ${var} in ${collection} satisfies ${condition}", {
    label: "every",
    detail: "quantified expression",
    type: "keyword"
  }),
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("some ${var} in ${collection} satisfies ${condition}", {
    label: "some",
    detail: "quantified expression",
    type: "keyword"
  }),
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("if ${condition} then ${value}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("if ${condition} then ${value} else ${other value}", {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  })
];
var feelLanguage = /* @__PURE__ */ import_language.LRLanguage.define({
  parser: /* @__PURE__ */ parser.configure({
    props: [
      /* @__PURE__ */ import_language.indentNodeProp.add({
        "Context": /* @__PURE__ */ (0, import_language.delimitedIndent)({
          closing: "}"
        }),
        "List FilterExpression": /* @__PURE__ */ (0, import_language.delimitedIndent)({
          closing: "]"
        }),
        "ParenthesizedExpression FunctionInvocation": /* @__PURE__ */ (0, import_language.delimitedIndent)({
          closing: ")"
        }),
        "ForExpression QuantifiedExpression IfExpression": /* @__PURE__ */ (0, import_language.continuedIndent)({
          except: /^\s*(then|else|return|satisfies)\b/
        }),
        "FunctionDefinition": /* @__PURE__ */ (0, import_language.continuedIndent)({
          except: /^\s*(\(|\))/
        })
      }),
      /* @__PURE__ */ import_language.foldNodeProp.add({
        Context: import_language.foldInside,
        List: import_language.foldInside,
        FunctionDefinition(node2) {
          const last2 = node2.getChild(")");
          if (!last2)
            return null;
          return {
            from: last2.to,
            to: node2.to
          };
        }
      })
    ]
  }),
  languageData: {
    indentOnInput: /^\s*(\)|\}|\]|then|else|return|satisfies)$/,
    commentTokens: {
      line: "//",
      block: {
        open: "/*",
        close: "*/"
      }
    }
  }
});

// node_modules/@bpmn-io/feel-lint/dist/index.esm.js
var import_language2 = require("@codemirror/language");
function lintSyntax(syntaxTree3) {
  const lintMessages = [];
  syntaxTree3.iterate({
    enter: (node2) => {
      if (node2.type.isError) {
        const error4 = node2.toString();
        const match = /\((.*?)\)/.exec(error4);
        const nodeType = match && match[1];
        let message;
        if (nodeType) {
          message = "unexpected " + nodeType;
        } else {
          message = "expression expected";
        }
        lintMessages.push({
          from: node2.from,
          to: node2.to,
          severity: "error",
          message,
          type: "syntaxError"
        });
      }
    }
  });
  return lintMessages;
}
function lintAll(syntaxTree3) {
  const lintMessages = [
    ...lintSyntax(syntaxTree3)
  ];
  return lintMessages;
}
var cmFeelLinter = () => (editorView) => {
  if (editorView.state.doc.length === 0) {
    return [];
  }
  const tree = (0, import_language2.syntaxTree)(editorView.state);
  const messages = lintAll(tree);
  return messages.map((message) => ({
    ...message,
    source: "syntaxError"
  }));
};

// node_modules/@bpmn-io/feel-editor/dist/index.es.js
var import_highlight2 = require("@lezer/highlight");
function isNodeEmpty(node2) {
  return node2.from === node2.to;
}
function isPathExpression(node2) {
  if (!node2) {
    return false;
  }
  if (node2.name === "PathExpression") {
    return true;
  }
  return isPathExpression(node2.parent);
}
var tags2 = [
  {
    name: "not()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>negand</code>: boolean</li>\n</ul>\n</li>\n<li>result: boolean</li>\n</ul>\n<pre><code class="language-feel">not(true)\n// false\n</code></pre>\n'
  },
  {
    name: "is defined()",
    description: '<p>Checks if a given value is defined. A value is defined if it exists, and it is an instance of one of the FEEL data types including <code>null</code>.</p>\n<p>The function can be used to check if a variable or a context entry (e.g. a property of a variable) exists. It allows differentiating between a <code>null</code> variable and a value that doesn&#39;t exist.</p>\n<ul>\n<li>parameters:<ul>\n<li><code>value</code>: any</li>\n</ul>\n</li>\n<li>result: boolean</li>\n</ul>\n<pre><code class="language-feel">is defined(1)\n// true\n\nis defined(null)\n// true\n\nis defined(x)\n// false - if no variable &quot;x&quot; exists\n\nis defined(x.y)\n// false - if no variable &quot;x&quot; exists or it doesn&#39;t have a property &quot;y&quot;\n</code></pre>\n'
  },
  {
    name: "get value()",
    description: '<p>Returns the value of the context entry with the given key.</p>\n<ul>\n<li>parameters:<ul>\n<li><code>context</code>: context</li>\n<li><code>key</code>: string</li>\n</ul>\n</li>\n<li>result: any</li>\n</ul>\n<pre><code class="language-feel">get value({foo: 123}, &quot;foo&quot;)\n// 123\n</code></pre>\n'
  },
  {
    name: "get entries()",
    description: '<p>Returns the entries of the context as a list of key-value-pairs.</p>\n<ul>\n<li>parameters:<ul>\n<li><code>context</code>: context</li>\n</ul>\n</li>\n<li>result: list of context which contains two entries for &quot;key&quot; and &quot;value&quot;</li>\n</ul>\n<pre><code class="language-feel">get entries({foo: 123})\n// [{key: &quot;foo&quot;, value: 123}]\n</code></pre>\n'
  },
  {
    name: "put()",
    description: '<p>Add the given key and value to a context. Returns a new context that includes the entry. It might override an existing entry of the context.</p>\n<p>Returns <code>null</code> if the value is not defined.</p>\n<ul>\n<li>parameters:<ul>\n<li><code>context</code>: context</li>\n<li><code>key</code>: string</li>\n<li><code>value</code>: any</li>\n</ul>\n</li>\n<li>result: context</li>\n</ul>\n<pre><code class="language-feel">put({x:1}, &quot;y&quot;, 2)\n// {x:1, y:2}\n</code></pre>\n'
  },
  {
    name: "put all()",
    description: '<p>Union the given contexts (two or more). Returns a new context that includes all entries of the given contexts. It might override context entries if the keys are equal. The entries are overridden in the same order as the contexts are passed in the method.</p>\n<p>Returns <code>null</code> if one of the values is not a context.</p>\n<ul>\n<li>parameters:<ul>\n<li><code>contexts</code>: contexts as varargs</li>\n</ul>\n</li>\n<li>result: context</li>\n</ul>\n<pre><code class="language-feel">put all({x:1}, {y:2})\n// {x:1, y:2}\n</code></pre>\n'
  },
  {
    name: "date()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>from</code>: string / date-time</li>\n<li>or <code>year</code>, <code>month</code>, <code>day</code>: number</li>\n</ul>\n</li>\n<li>result: date</li>\n</ul>\n<pre><code class="language-feel">date(birthday)\n// date(&quot;2018-04-29&quot;)\n\ndate(date and time(&quot;2012-12-25T11:00:00&quot;))\n// date(&quot;2012-12-25&quot;)\n\ndate(2012, 12, 25)\n// date(&quot;2012-12-25&quot;)\n</code></pre>\n'
  },
  {
    name: "time()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>from</code>: string / date-time</li>\n<li>or <code>hour</code>, <code>minute</code>, <code>second</code>: number<ul>\n<li>(optional) <code>offset</code>: day-time-duration</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>result: time</li>\n</ul>\n<pre><code class="language-feel">time(lunchTime)\n// time(&quot;12:00:00&quot;)\n\ntime(date and time(&quot;2012-12-25T11:00:00&quot;))\n// time(&quot;11:00:00&quot;)\n\ntime(23, 59, 0)\n// time(&quot;23:59:00&quot;)\n\ntime(14, 30, 0, duration(&quot;PT1H&quot;))\n// time(&quot;15:30:00&quot;)\n</code></pre>\n'
  },
  {
    name: "date and time()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>date</code>: date / date-time</li>\n<li><code>time</code>: time</li>\n<li>or <code>from</code>: string</li>\n</ul>\n</li>\n<li>result: date-time</li>\n</ul>\n<pre><code class="language-feel">date and time(date(&quot;2012-12-24&quot;),time(&quot;T23:59:00&quot;))\n// date and time(&quot;2012-12-24T23:59:00&quot;)\n\ndate and time(date and time(&quot;2012-12-25T11:00:00&quot;),time(&quot;T23:59:00&quot;))\n// date and time(&quot;2012-12-25T23:59:00&quot;)\n\ndate and time(birthday)\n// date and time(&quot;2018-04-29T009:30:00&quot;)\n</code></pre>\n'
  },
  {
    name: "duration()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>from</code>: string</li>\n</ul>\n</li>\n<li>result: day-time-duration or year-month-duration</li>\n</ul>\n<pre><code class="language-feel">duration(weekDays)\n// duration(&quot;P5D&quot;)\n\nduration(age)\n// duration(&quot;P32Y&quot;)\n</code></pre>\n'
  },
  {
    name: "years and months duration()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>from</code>: date</li>\n<li><code>to</code>: date</li>\n</ul>\n</li>\n<li>result: year-month-duration</li>\n</ul>\n<pre><code class="language-feel">years and months duration(date(&quot;2011-12-22&quot;), date(&quot;2013-08-24&quot;))\n// duration(&quot;P1Y8M&quot;)\n</code></pre>\n'
  },
  {
    name: "number()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>from</code>: string</li>\n</ul>\n</li>\n<li>result: number</li>\n</ul>\n<pre><code class="language-feel">number(&quot;1500.5&quot;)\n// 1500.5\n</code></pre>\n'
  },
  {
    name: "string()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>from</code>: any</li>\n</ul>\n</li>\n<li>result: string</li>\n</ul>\n<pre><code class="language-feel">string(1.1)\n// &quot;1.1&quot;\n\nstring(date(&quot;2012-12-25&quot;))\n// &quot;2012-12-25&quot;\n</code></pre>\n'
  },
  {
    name: "context()",
    description: '<p>Constructs a context of the given list of key-value pairs. It is the reverse function to <a href="feel-built-in-functions-context.md#get-entries">get entries()</a>.</p>\n<p>Each key-value pair must be a context with two entries: <code>key</code> and <code>value</code>. The entry with name <code>key</code> must have a value of the type <code>string</code>.</p>\n<p>It might override context entries if the keys are equal. The entries are overridden in the same order as the contexts in the given list.</p>\n<p>Returns <code>null</code> if one of the entries is not a context or if a context doesn&#39;t contain the required entries.</p>\n<ul>\n<li>parameters:<ul>\n<li><code>entries</code>: list of contexts</li>\n</ul>\n</li>\n<li>result: context</li>\n</ul>\n<pre><code class="language-feel">context([{&quot;key&quot;:&quot;a&quot;, &quot;value&quot;:1}, {&quot;key&quot;:&quot;b&quot;, &quot;value&quot;:2}])\n// {a:1, b:2}\n</code></pre>\n'
  },
  {
    name: "list contains()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>list</code>: list</li>\n<li><code>element</code>: any</li>\n</ul>\n</li>\n<li>result: boolean</li>\n</ul>\n<pre><code class="language-feel">list contains([1,2,3], 2)\n// true\n</code></pre>\n'
  },
  {
    name: "count()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>list</code>: list</li>\n</ul>\n</li>\n<li>result: number</li>\n</ul>\n<pre><code class="language-feel">count([1,2,3])\n// 3\n</code></pre>\n'
  },
  {
    name: "min()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>list</code>: list of numbers</li>\n<li>or numbers as varargs</li>\n</ul>\n</li>\n<li>result: number</li>\n</ul>\n<pre><code class="language-feel">min([1,2,3])\n// 1\n\nmin(1,2,3)\n// 1\n</code></pre>\n'
  },
  {
    name: "max()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>list</code>: list of numbers</li>\n<li>or numbers as varargs</li>\n</ul>\n</li>\n<li>result: number</li>\n</ul>\n<pre><code class="language-feel">max([1,2,3])\n// 3\n\nmax(1,2,3)\n// 3\n</code></pre>\n'
  },
  {
    name: "sum()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>list</code>: list of numbers</li>\n<li>or numbers as varargs</li>\n</ul>\n</li>\n<li>result: number</li>\n</ul>\n<pre><code class="language-feel">sum([1,2,3])\n// 6\n\nsum(1,2,3)\n// 6\n</code></pre>\n'
  },
  {
    name: "product()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>list</code>: list of numbers</li>\n<li>or numbers as varargs</li>\n</ul>\n</li>\n<li>result: number</li>\n</ul>\n<pre><code class="language-feel">product([2, 3, 4])\n// 24\n\nproduct(2, 3, 4)\n// 24\n</code></pre>\n'
  },
  {
    name: "mean()",
    description: '<p>Returns the arithmetic mean (i.e. average).</p>\n<ul>\n<li>parameters:<ul>\n<li><code>list</code>: list of numbers</li>\n<li>or numbers as varargs</li>\n</ul>\n</li>\n<li>result: number</li>\n</ul>\n<pre><code class="language-feel">mean([1,2,3])\n// 2\n\nmean(1,2,3)\n// 2\n</code></pre>\n'
  },
  {
    name: "median()",
    description: '<p>Returns the median element of the list of numbers.</p>\n<ul>\n<li>parameters:<ul>\n<li><code>list</code>: list of numbers</li>\n<li>or numbers as varargs</li>\n</ul>\n</li>\n<li>result: number</li>\n</ul>\n<pre><code class="language-feel">median(8, 2, 5, 3, 4)\n// 4\n\nmedian([6, 1, 2, 3])\n// 2.5\n</code></pre>\n'
  },
  {
    name: "stddev()",
    description: '<p>Returns the standard deviation.</p>\n<ul>\n<li>parameters:<ul>\n<li><code>list</code>: list of numbers</li>\n<li>or numbers as varargs</li>\n</ul>\n</li>\n<li>result: number</li>\n</ul>\n<pre><code class="language-feel">stddev(2, 4, 7, 5)\n// 2.0816659994661326\n\nstddev([2, 4, 7, 5])\n// 2.0816659994661326\n</code></pre>\n'
  },
  {
    name: "mode()",
    description: '<p>Returns the mode of the list of numbers.</p>\n<ul>\n<li>parameters:<ul>\n<li><code>list</code>: list of numbers</li>\n<li>or numbers as varargs</li>\n</ul>\n</li>\n<li>result: list of numbers</li>\n</ul>\n<pre><code class="language-feel">mode(6, 3, 9, 6, 6)\n// [6]\n\nmode([6, 1, 9, 6, 1])\n// [1, 6]\n</code></pre>\n'
  },
  {
    name: "and()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>list</code>: list of booleans</li>\n<li>or booleans as varargs</li>\n</ul>\n</li>\n<li>result: boolean</li>\n</ul>\n<pre><code class="language-feel">and([true,false])\n// false\n\nand(false,null,true)\n// false\n</code></pre>\n'
  },
  {
    name: "all()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>list</code>: list of booleans</li>\n<li>or booleans as varargs</li>\n</ul>\n</li>\n<li>result: boolean</li>\n</ul>\n<pre><code class="language-feel">and([true,false])\n// false\n\nand(false,null,true)\n// false\n</code></pre>\n'
  },
  {
    name: "or()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>list</code>: list of booleans</li>\n<li>or booleans as varargs</li>\n</ul>\n</li>\n<li>result: boolean</li>\n</ul>\n<pre><code class="language-feel">or([false,true])\n// true\n\nor(false,null,true)\n// true\n</code></pre>\n'
  },
  {
    name: "any()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>list</code>: list of booleans</li>\n<li>or booleans as varargs</li>\n</ul>\n</li>\n<li>result: boolean</li>\n</ul>\n<pre><code class="language-feel">or([false,true])\n// true\n\nor(false,null,true)\n// true\n</code></pre>\n'
  },
  {
    name: "sublist()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>list</code>: list</li>\n<li><code>start position</code>: number</li>\n<li>(optional) <code>length</code>: number</li>\n</ul>\n</li>\n<li>result: list</li>\n</ul>\n<pre><code class="language-feel">sublist([1,2,3], 2)\n// [2,3]\n\nsublist([1,2,3], 1, 2)\n// [1,2]\n</code></pre>\n'
  },
  {
    name: "append()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>list</code>: list</li>\n<li><code>items</code>: elements as varargs</li>\n</ul>\n</li>\n<li>result: list</li>\n</ul>\n<pre><code class="language-feel">append([1], 2, 3)\n// [1,2,3]\n</code></pre>\n'
  },
  {
    name: "concatenate()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>lists</code>: lists as varargs</li>\n</ul>\n</li>\n<li>result: list</li>\n</ul>\n<pre><code class="language-feel">concatenate([1,2],[3])\n// [1,2,3]\n\nconcatenate([1],[2],[3])\n// [1,2,3]\n</code></pre>\n'
  },
  {
    name: "insert before()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>list</code>: list</li>\n<li><code>position</code>: number</li>\n<li><code>newItem</code>: any</li>\n</ul>\n</li>\n<li>result: list</li>\n</ul>\n<pre><code class="language-feel">insert before([1,3],1,2)\n// [1,2,3]\n</code></pre>\n'
  },
  {
    name: "remove()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>list</code>: list</li>\n<li><code>position</code>: number</li>\n</ul>\n</li>\n<li>result: list</li>\n</ul>\n<pre><code class="language-feel">remove([1,2,3], 2)\n// [1,3]\n</code></pre>\n'
  },
  {
    name: "reverse()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>list</code>: list</li>\n</ul>\n</li>\n<li>result: list</li>\n</ul>\n<pre><code class="language-feel">reverse([1,2,3])\n// [3,2,1]\n</code></pre>\n'
  },
  {
    name: "index of()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>list</code>: list</li>\n<li><code>match</code>: any</li>\n</ul>\n</li>\n<li>result: list of numbers</li>\n</ul>\n<pre><code class="language-feel">index of([1,2,3,2],2)\n// [2,4]\n</code></pre>\n'
  },
  {
    name: "union()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>lists</code>: lists as varargs</li>\n</ul>\n</li>\n<li>result: list</li>\n</ul>\n<pre><code class="language-feel">union([1,2],[2,3])\n// [1,2,3]\n</code></pre>\n'
  },
  {
    name: "distinct values()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>list</code>: list</li>\n</ul>\n</li>\n<li>result: list</li>\n</ul>\n<pre><code class="language-feel">distinct values([1,2,3,2,1])\n// [1,2,3]\n</code></pre>\n'
  },
  {
    name: "flatten()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>list</code>: list</li>\n</ul>\n</li>\n<li>result: list</li>\n</ul>\n<pre><code class="language-feel">flatten([[1,2],[[3]], 4])\n// [1,2,3,4]\n</code></pre>\n'
  },
  {
    name: "sort()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>list</code>: list</li>\n<li><code>precedes</code>: function with two arguments and boolean result</li>\n</ul>\n</li>\n<li>result: list</li>\n</ul>\n<pre><code class="language-feel">sort(list: [3,1,4,5,2], precedes: function(x,y) x &lt; y)\n// [1,2,3,4,5]\n</code></pre>\n'
  },
  {
    name: "string join()",
    description: '<p>This joins a list of strings into a single string. This is similar to\nJava&#39;s <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Collectors.html#joining(java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence)">joining</a>\nfunction.</p>\n<p>If an item of the list is <code>null</code>, the item is ignored for the result string. If an item is\nneither a string nor <code>null</code>, the function returns <code>null</code> instead of a string.</p>\n<ul>\n<li>Parameters:<ul>\n<li><code>list</code>: The list of strings to join</li>\n<li><code>delimiter</code>: (Optional) The string used between each element (default: empty string)</li>\n<li><code>prefix</code>: (Optional) The string used at the beginning of the joined result (default:\nempty string)</li>\n<li><code>suffix</code>: (Optional) The string used at the end of the joined result (default: empty\nstring)</li>\n</ul>\n</li>\n<li>Result: The joined list as a string</li>\n</ul>\n<pre><code class="language-feel">string join([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;])\n// &quot;abc&quot;\nstring join([&quot;a&quot;], &quot;X&quot;)\n// &quot;a&quot;\nstring join([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], &quot;, &quot;)\n// &quot;a, b, c&quot;\nstring join([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], &quot;, &quot;, &quot;[&quot;, &quot;]&quot;)\n// &quot;[a, b, c]&quot;\nstring join([&quot;a&quot;,null,&quot;c&quot;])\n// &quot;ac&quot;\nstring join([])\n// &quot;&quot;\n</code></pre>\n'
  },
  {
    name: "decimal()",
    description: '<p>Round the given number at the given scale using the given rounding mode. If no rounding mode is passed in, it uses <code>HALF_EVEN</code> as default.</p>\n<ul>\n<li>parameters:<ul>\n<li><code>n</code>: number</li>\n<li><code>scale</code>: number</li>\n<li>(optional) <code>mode</code>: string - one of <code>UP, DOWN, CEILING, FLOOR, HALF_UP, HALF_DOWN, HALF_EVEN, UNNECESSARY</code> (default: <code>HALF_EVEN</code>)</li>\n</ul>\n</li>\n<li>result: number</li>\n</ul>\n<pre><code class="language-feel">decimal(1/3, 2)\n// .33\n\ndecimal(1.5, 0)\n// 2\n\ndecimal(2.5, 0, &quot;half_up&quot;)\n// 3\n</code></pre>\n'
  },
  {
    name: "floor()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>n</code>: number</li>\n</ul>\n</li>\n<li>result: number</li>\n</ul>\n<pre><code class="language-feel">floor(1.5)\n// 1\n\nfloor(-1.5)\n// -2\n</code></pre>\n'
  },
  {
    name: "ceiling()",
    description: '<p>Round the given number at the given scale using the ceiling rounding mode.</p>\n<ul>\n<li>parameters:<ul>\n<li><code>n</code>: number</li>\n</ul>\n</li>\n<li>result: number</li>\n</ul>\n<pre><code class="language-feel">ceiling(1.5)\n// 2\n\nceiling(-1.5)\n// -1\n</code></pre>\n'
  },
  {
    name: "abs()",
    description: '<p>Returns the absolute value of the given numeric value.</p>\n<ul>\n<li>parameters:<ul>\n<li><code>number</code>: number</li>\n</ul>\n</li>\n<li>result: number</li>\n</ul>\n<pre><code class="language-feel">abs(10)\n// 10\n\nabs(-10)\n// 10\n</code></pre>\n'
  },
  {
    name: "modulo()",
    description: '<p>Returns the remainder of the division of dividend by divisor.</p>\n<ul>\n<li>parameters:<ul>\n<li><code>dividend</code>: number</li>\n<li><code>divisor</code>: number</li>\n</ul>\n</li>\n<li>result: number</li>\n</ul>\n<pre><code class="language-feel">modulo(12, 5)\n// 2\n</code></pre>\n'
  },
  {
    name: "sqrt()",
    description: '<p>Returns the square root.</p>\n<ul>\n<li>parameters:<ul>\n<li><code>number</code>: number</li>\n</ul>\n</li>\n<li>result: number</li>\n</ul>\n<pre><code class="language-feel">sqrt(16)\n// 4\n</code></pre>\n'
  },
  {
    name: "log()",
    description: '<p>Returns the natural logarithm (base e) of the number.</p>\n<ul>\n<li>parameters:<ul>\n<li><code>number</code>: number</li>\n</ul>\n</li>\n<li>result: number</li>\n</ul>\n<pre><code class="language-feel">log(10)\n// 2.302585092994046\n</code></pre>\n'
  },
  {
    name: "exp()",
    description: '<p>Returns the Euler\u2019s number e raised to the power of number .</p>\n<ul>\n<li>parameters:<ul>\n<li><code>number</code>: number</li>\n</ul>\n</li>\n<li>result: number</li>\n</ul>\n<pre><code class="language-feel">exp(5)\n// 148.4131591025766\n</code></pre>\n'
  },
  {
    name: "odd()",
    description: '<p>Returns <code>true</code> if the given numeric value is odd. Otherwise, it returns <code>false</code>.</p>\n<ul>\n<li>parameters:<ul>\n<li><code>number</code>: number</li>\n</ul>\n</li>\n<li>result: boolean</li>\n</ul>\n<pre><code class="language-feel">odd(5)\n// true\n\nodd(2)\n// false\n</code></pre>\n'
  },
  {
    name: "even()",
    description: '<p>Returns <code>true</code> if the given numeric value is even. Otherwise, it returns <code>false</code>.</p>\n<ul>\n<li>parameters:<ul>\n<li><code>number</code>: number</li>\n</ul>\n</li>\n<li>result: boolean</li>\n</ul>\n<pre><code class="language-feel">even(5)\n// false\n\neven(2)\n// true\n</code></pre>\n'
  },
  {
    name: "before()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>point1</code>, <code>point2</code>: any</li>\n<li>or <code>range</code>: range, <code>point</code>: any</li>\n<li>or <code>point</code>: any, <code>range</code>: range</li>\n<li>or <code>range1</code>, <code>range2</code>: range</li>\n</ul>\n</li>\n<li>result: boolean</li>\n</ul>\n<pre><code class="language-feel">before(1, 10)\n// true\n\nbefore(10, 1)\n// false\n\nbefore(1, [2..5])\n// true\n\nbefore([1..5], 10)\n// true\n\nbefore([1..5], [6..10])\n// true\n\nbefore([1..5),[5..10])\n// true\n</code></pre>\n'
  },
  {
    name: "after()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>point1</code>, <code>point2</code>: any</li>\n<li>or <code>range</code>: range, <code>point</code>: any</li>\n<li>or <code>point</code>: any, <code>range</code>: range</li>\n<li>or <code>range1</code>, <code>range2</code>: range</li>\n</ul>\n</li>\n<li>result: boolean</li>\n</ul>\n<pre><code class="language-feel">after(10, 1)\n// true\n\nafter(1, 10)\n// false\n\nafter(12, [2..5])\n// true\n\n([1..5], 10)\n// false\n\nbefore([6..10], [1..5])\n// true\n\nbefore([5..10], [1..5))\n// true\n</code></pre>\n'
  },
  {
    name: "meets()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>range1</code>: range</li>\n<li><code>range2</code>: range</li>\n</ul>\n</li>\n<li>result: boolean</li>\n</ul>\n<pre><code class="language-feel">meets([1..5], [5..10])\n// true\n\nmeets([1..3], [4..6])\n// false\n\nmeets([1..3], [3..5])\n// true\n\nmeets([1..5], (5..8])\n// false\n</code></pre>\n'
  },
  {
    name: "met by()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>range1</code>: range</li>\n<li><code>range2</code>: range</li>\n</ul>\n</li>\n<li>result: boolean</li>\n</ul>\n<pre><code class="language-feel">met by([5..10], [1..5])\n// true\n\nmet by([3..4], [1..2])\n// false\n\nmet by([3..5], [1..3])\n// true\n\nmet by((5..8], [1..5))\n// false\n\nmet by([5..10], [1..5))\n// false\n</code></pre>\n'
  },
  {
    name: "overlaps()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>range1</code>: range</li>\n<li><code>range2</code>: range</li>\n</ul>\n</li>\n<li>result: boolean</li>\n</ul>\n<pre><code class="language-feel">overlaps([5..10], [1..6])\n// true\n\noverlaps((3..7], [1..4])\n// true\n\noverlaps([1..3], (3..6])\n// false\n\noverlaps((5..8], [1..5))\n// false\n\noverlaps([4..10], [1..5))\n// treu\n</code></pre>\n'
  },
  {
    name: "overlaps before()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>range1</code>: range</li>\n<li><code>range2</code>: range</li>\n</ul>\n</li>\n<li>result: boolean</li>\n</ul>\n<pre><code class="language-feel">overlaps before([1..5], [4..10])\n// true\n\noverlaps before([3..4], [1..2])\n// false\n\noverlaps before([1..3], (3..5])\n// false\n\noverlaps before([1..5), (3..8])\n// true\n\noverlaps before([1..5), [5..10])\n// false\n</code></pre>\n'
  },
  {
    name: "overlaps after()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>range1</code>: range</li>\n<li><code>range2</code>: range</li>\n</ul>\n</li>\n<li>result: boolean</li>\n</ul>\n<pre><code class="language-feel">overlaps after([4..10], [1..5])\n// true\n\noverlaps after([3..4], [1..2])\n// false\n\noverlaps after([3..5], [1..3))\n// false\n\noverlaps after((5..8], [1..5))\n// false\n\noverlaps after([4..10], [1..5))\n// true\n</code></pre>\n'
  },
  {
    name: "finishes()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>point</code>: any, <code>range</code>: range</li>\n<li>or <code>range1</code>, <code>range2</code>: range</li>\n</ul>\n</li>\n<li>result: boolean</li>\n</ul>\n<pre><code class="language-feel">finishes(5, [1..5])\n// true\n\nfinishes(10, [1..7])\n// false\n\nfinishes([3..5], [1..5])\n// true\n\nfinishes((1..5], [1..5))\n// false\n\nfinishes([5..10], [1..10))\n// false\n</code></pre>\n'
  },
  {
    name: "finished by()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>range</code>: range, <code>point</code>: any</li>\n<li>or <code>range1</code>, <code>range2</code>: range</li>\n</ul>\n</li>\n<li>result: boolean</li>\n</ul>\n<pre><code class="language-feel">finishes by([5..10], 10)\n// true\n\nfinishes by([3..4], 2)\n// false\n\nfinishes by([3..5], [1..5])\n// true\n\nfinishes by((5..8], [1..5))\n// false\n\nfinishes by([5..10], (1..10))\n// true\n</code></pre>\n'
  },
  {
    name: "includes()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>range</code>: range, <code>point</code>: any</li>\n<li>or <code>range1</code>, <code>range2</code>: range</li>\n</ul>\n</li>\n<li>result: boolean</li>\n</ul>\n<pre><code class="language-feel">includes([5..10], 6)\n// true\n\nincludes([3..4], 5)\n// false\n\nincludes([1..10], [4..6])\n// true\n\nincludes((5..8], [1..5))\n// false\n\nincludes([1..10], [1..5))\n// true\n</code></pre>\n'
  },
  {
    name: "during()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>point</code>: any, <code>range</code>: range</li>\n<li>or <code>range1</code>, <code>range2</code>: range</li>\n</ul>\n</li>\n<li>result: boolean</li>\n</ul>\n<pre><code class="language-feel">during(5, [1..10])\n// true\n\nduring(12, [1..10])\n// false\n\nduring(1, (1..10])\n// false\n\nduring([4..6], [1..10))\n// true\n\nduring((1..5], (1..10])\n// true\n</code></pre>\n'
  },
  {
    name: "starts()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>point</code>: any, <code>range</code>: range</li>\n<li>or <code>range1</code>, <code>range2</code>: range</li>\n</ul>\n</li>\n<li>result: boolean</li>\n</ul>\n<pre><code class="language-feel">starts(1, [1..5])\n// true\n\nstarts(1, (1..8])\n// false\n\nstarts((1..5], [1..5])\n// false\n\nstarts([1..10], [1..10])\n// true\n\nstarts((1..10), (1..10))\n// true\n</code></pre>\n'
  },
  {
    name: "started by()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>range</code>: range, <code>point</code>: any</li>\n<li>or <code>range1</code>, <code>range2</code>: range</li>\n</ul>\n</li>\n<li>result: boolean</li>\n</ul>\n<pre><code class="language-feel">started by([1..10], 1)\n// true\n\nstarted by((1..10], 1)\n// false\n\nstarted by([1..10], [1..5])\n// true\n\nstarted by((1..10], [1..5))\n// false\n\nstarted by([1..10], [1..10))\n// true\n</code></pre>\n'
  },
  {
    name: "coincides()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>point1</code>, <code>point2</code>: any</li>\n<li>or <code>range1</code>, <code>range2</code>: range</li>\n</ul>\n</li>\n<li>result: boolean</li>\n</ul>\n<pre><code class="language-feel">coincides(5, 5)\n// true\n\ncoincides(3, 4)\n// false\n\ncoincides([1..5], [1..5])\n// true\n\ncoincides((1..5], [1..5))\n// false\n\ncoincides([1..5], [2..6])\n// false\n</code></pre>\n'
  },
  {
    name: "substring()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>string</code>: string</li>\n<li><code>start position</code>: number</li>\n<li>(optional) <code>length</code>: number</li>\n</ul>\n</li>\n<li>result: string</li>\n</ul>\n<pre><code class="language-feel">substring(&quot;foobar&quot;,3)\n// &quot;obar&quot;\n\nsubstring(&quot;foobar&quot;,3,3)\n// &quot;oba&quot;\n</code></pre>\n'
  },
  {
    name: "string length()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>string</code>: string</li>\n</ul>\n</li>\n<li>result: number</li>\n</ul>\n<pre><code class="language-feel">string length(&quot;foo&quot;)\n// 3\n</code></pre>\n'
  },
  {
    name: "upper case()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>string</code>: string</li>\n</ul>\n</li>\n<li>result: string</li>\n</ul>\n<pre><code class="language-feel">upper case(&quot;aBc4&quot;)\n// &quot;ABC4&quot;\n</code></pre>\n'
  },
  {
    name: "lower case()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>string</code>: string</li>\n</ul>\n</li>\n<li>result: string</li>\n</ul>\n<pre><code class="language-feel">lower case(&quot;aBc4&quot;)\n// &quot;abc4&quot;\n</code></pre>\n'
  },
  {
    name: "substring before()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>string</code>: string</li>\n<li><code>match</code>: string</li>\n</ul>\n</li>\n<li>result: string</li>\n</ul>\n<pre><code class="language-feel">substring before(&quot;foobar&quot;, &quot;bar&quot;)\n// &quot;foo&quot;\n</code></pre>\n'
  },
  {
    name: "substring after()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>string</code>: string</li>\n<li><code>match</code>: string</li>\n</ul>\n</li>\n<li>result: string</li>\n</ul>\n<pre><code class="language-feel">substring after(&quot;foobar&quot;, &quot;ob&quot;)\n// &quot;ar&quot;\n</code></pre>\n'
  },
  {
    name: "contains()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>string</code>: string</li>\n<li><code>match</code>: string</li>\n</ul>\n</li>\n<li>result: boolean</li>\n</ul>\n<pre><code class="language-feel">contains(&quot;foobar&quot;, &quot;of&quot;)\n// false\n</code></pre>\n'
  },
  {
    name: "starts with()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>input</code>: string</li>\n<li><code>match</code>: string</li>\n</ul>\n</li>\n<li>result: boolean</li>\n</ul>\n<pre><code class="language-feel">starts with(&quot;foobar&quot;, &quot;fo&quot;)\n// true\n</code></pre>\n'
  },
  {
    name: "ends with()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>input</code>: string</li>\n<li><code>match</code>: string</li>\n</ul>\n</li>\n<li>result: boolean</li>\n</ul>\n<pre><code class="language-feel">ends with(&quot;foobar&quot;, &quot;r&quot;)\n// true\n</code></pre>\n'
  },
  {
    name: "matches()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>input</code>: string</li>\n<li><code>pattern</code>: string (regular expression)</li>\n</ul>\n</li>\n<li>result: boolean</li>\n</ul>\n<pre><code class="language-feel">matches(&quot;foobar&quot;, &quot;^fo*bar&quot;)\n// true\n</code></pre>\n'
  },
  {
    name: "replace()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>input</code>: string</li>\n<li><code>pattern</code>: string (regular expression)</li>\n<li><code>replacement</code>: string (e.g. <code>$1</code> returns the first match group)</li>\n<li>(optional) <code>flags</code>: string (&quot;s&quot;, &quot;m&quot;, &quot;i&quot;, &quot;x&quot;)</li>\n</ul>\n</li>\n<li>result: string</li>\n</ul>\n<pre><code class="language-feel">replace(&quot;abcd&quot;, &quot;(ab)|(a)&quot;, &quot;[1=$1][2=$2]&quot;)\n// &quot;[1=ab][2=]cd&quot;\n\nreplace(&quot;0123456789&quot;, &quot;(\\d{3})(\\d{3})(\\d{4})&quot;, &quot;($1) $2-$3&quot;)\n// &quot;(012) 345-6789&quot;\n</code></pre>\n'
  },
  {
    name: "split()",
    description: '<ul>\n<li>parameters:<ul>\n<li><code>string</code>: string</li>\n<li><code>delimiter</code>: string (regular expression)</li>\n</ul>\n</li>\n<li>result: list of strings</li>\n</ul>\n<pre><code class="language-feel">split(&quot;John Doe&quot;, &quot;\\s&quot; )\n// [&quot;John&quot;, &quot;Doe&quot;]\n\nsplit(&quot;a;b;c;;&quot;, &quot;;&quot;)\n// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;, &quot;&quot;]\n</code></pre>\n'
  },
  {
    name: "extract()",
    description: '<p>Returns all matches of the pattern in the given string. Returns an empty list if the pattern doesn&#39;t\nmatch.</p>\n<ul>\n<li>parameters:<ul>\n<li><code>string</code>: string</li>\n<li><code>pattern</code>: string (regular expression)</li>\n</ul>\n</li>\n<li>result: list of strings</li>\n</ul>\n<pre><code class="language-feel">extract(&quot;references are 1234, 1256, 1378&quot;, &quot;12[0-9]*&quot;)\n// [&quot;1234&quot;,&quot;1256&quot;]\n</code></pre>\n'
  },
  {
    name: "now()",
    description: '<p>Returns the current date and time including the timezone.</p>\n<ul>\n<li>parameters: no</li>\n<li>result: date-time with timezone</li>\n</ul>\n<pre><code class="language-feel">now()\n// date and time(&quot;2020-07-31T14:27:30@Europe/Berlin&quot;)\n</code></pre>\n'
  },
  {
    name: "today()",
    description: '<p>Returns the current date.</p>\n<ul>\n<li>parameters: no</li>\n<li>result: date</li>\n</ul>\n<pre><code class="language-feel">today()\n// date(&quot;2020-07-31&quot;)\n</code></pre>\n'
  },
  {
    name: "day of week()",
    description: '<p>Returns the day of the week according to the Gregorian calendar. Note that it always returns the English name of the day.</p>\n<ul>\n<li>parameters:<ul>\n<li><code>date</code>: date/date-time</li>\n</ul>\n</li>\n<li>result: string</li>\n</ul>\n<pre><code class="language-feel">day of week(date(&quot;2019-09-17&quot;))\n// &quot;Tuesday&quot;\n</code></pre>\n'
  },
  {
    name: "day of year()",
    description: '<p>Returns the Gregorian number of the day within the year.</p>\n<ul>\n<li>parameters:<ul>\n<li><code>date</code>: date/date-time</li>\n</ul>\n</li>\n<li>result: number</li>\n</ul>\n<pre><code class="language-feel">day of year(date(&quot;2019-09-17&quot;))\n// 260\n</code></pre>\n'
  },
  {
    name: "week of year()",
    description: '<p>Returns the Gregorian number of the week within the year, according to ISO 8601.</p>\n<ul>\n<li>parameters:<ul>\n<li><code>date</code>: date/date-time</li>\n</ul>\n</li>\n<li>result: number</li>\n</ul>\n<pre><code class="language-feel">week of year(date(&quot;2019-09-17&quot;))\n// 38\n</code></pre>\n'
  },
  {
    name: "month of year()",
    description: '<p>Returns the month of the week according to the Gregorian calendar. Note that it always returns the English name of the month.</p>\n<ul>\n<li>parameters:<ul>\n<li><code>date</code>: date/date-time</li>\n</ul>\n</li>\n<li>result: string</li>\n</ul>\n<pre><code class="language-feel">month of year(date(&quot;2019-09-17&quot;))\n// &quot;September&quot;\n</code></pre>\n'
  },
  {
    name: "abs()",
    description: '<p>Returns the absolute value of a given duration.</p>\n<ul>\n<li>parameters:<ul>\n<li><code>n</code>: days-time-duration/years-months-duration</li>\n</ul>\n</li>\n<li>result: duration</li>\n</ul>\n<pre><code class="language-feel">abs(duration(&quot;-PT5H&quot;))\n// &quot;duration(&quot;PT5H&quot;)&quot;\n\nabs(duration(&quot;PT5H&quot;))\n// &quot;duration(&quot;PT5H&quot;)&quot;\n\nabs(duration(&quot;-P2M&quot;))\n// duration(&quot;P2M&quot;)\n</code></pre>\n'
  }
];
var options = tags2.map((tag) => (0, import_autocomplete2.snippetCompletion)(tag.name.replace("()", "(#{1})"), {
  label: tag.name,
  type: "function",
  info: () => {
    const html = domify$1(`<div class="description">${tag.description}<div>`);
    return html;
  },
  boost: -1
}));
var builtins = (context) => {
  let nodeBefore = (0, import_language3.syntaxTree)(context.state).resolve(context.pos, -1);
  let nextNode = nodeBefore.nextSibling;
  const isInEmptyNode = isNodeEmpty(nodeBefore) || nextNode && nextNode.from === context.pos && isNodeEmpty(nextNode);
  if (isInEmptyNode) {
    return context.explicit ? {
      from: context.pos,
      options
    } : null;
  }
  if (nodeBefore.parent && nodeBefore.parent.name !== "VariableName" || isPathExpression(nodeBefore)) {
    return null;
  }
  return {
    from: nodeBefore.from,
    options
  };
};
var variablesFacet = import_state.Facet.define();
var pathExpression = (context) => {
  const variables2 = context.state.facet(variablesFacet)[0];
  const nodeBefore = (0, import_language3.syntaxTree)(context.state).resolve(context.pos, -1);
  if (!isPathExpression(nodeBefore)) {
    return;
  }
  const expression = findPathExpression(nodeBefore);
  const from = nodeBefore === expression ? context.pos : nodeBefore.from;
  const path = getPath(expression, context);
  let options2 = variables2;
  for (var i6 = 0; i6 < path.length - 1; i6++) {
    var childVar = options2.find((val) => val.name === path[i6].name);
    if (!childVar) {
      return null;
    }
    if (childVar.isList !== "optional" && !!childVar.isList !== path[i6].isList) {
      return;
    }
    options2 = childVar.entries;
  }
  if (!options2)
    return;
  options2 = options2.map((v5) => ({
    label: v5.name,
    type: "variable",
    info: v5.info,
    detail: v5.detail
  }));
  const result = {
    from,
    options: options2
  };
  return result;
};
function findPathExpression(node2) {
  while (node2) {
    if (node2.name === "PathExpression") {
      return node2;
    }
    node2 = node2.parent;
  }
}
function getPath(node2, context) {
  let path = [];
  for (let child = node2.firstChild; child; child = child.nextSibling) {
    if (child.name === "PathExpression") {
      path.push(...getPath(child, context));
    } else if (child.name === "FilterExpression") {
      path.push(...getFilter(child, context));
    } else {
      path.push({
        name: getNodeContent(child, context),
        isList: false
      });
    }
  }
  return path;
}
function getFilter(node2, context) {
  const list = node2.firstChild;
  if (list.name === "PathExpression") {
    const path = getPath(list, context);
    const last2 = path[path.length - 1];
    last2.isList = true;
    return path;
  }
  return [{
    name: getNodeContent(list, context),
    isList: true
  }];
}
function getNodeContent(node2, context) {
  return context.state.sliceDoc(node2.from, node2.to);
}
var variables = (context) => {
  const variables2 = context.state.facet(variablesFacet)[0];
  const options2 = variables2.map((v5) => ({
    label: v5.name,
    type: "variable",
    info: v5.info,
    detail: v5.detail
  }));
  let nodeBefore = (0, import_language3.syntaxTree)(context.state).resolve(context.pos, -1);
  let nextNode = nodeBefore.nextSibling;
  const isInEmptyNode = isNodeEmpty(nodeBefore) || nextNode && nextNode.from === context.pos && isNodeEmpty(nextNode);
  if (isInEmptyNode) {
    return context.explicit ? {
      from: context.pos,
      options: options2
    } : null;
  }
  const result = {
    from: nodeBefore.from,
    options: options2
  };
  if (nodeBefore.parent && nodeBefore.parent.name !== "VariableName" || isPathExpression(nodeBefore)) {
    return null;
  }
  return result;
};
function autocompletion() {
  return [
    (0, import_autocomplete2.autocompletion)({
      override: [
        variables,
        builtins,
        (0, import_autocomplete2.completeFromList)(snippets.map((s5) => ({ ...s5, boost: -1 }))),
        pathExpression
      ]
    })
  ];
}
function language() {
  return new import_language3.LanguageSupport(feelLanguage, []);
}
var linter = [(0, import_lint.linter)(cmFeelLinter())];
var baseTheme = import_view.EditorView.theme({
  "& .cm-content": {
    padding: "0px"
  },
  "& .cm-line": {
    padding: "0px"
  },
  "&.cm-editor.cm-focused": {
    outline: "none"
  },
  "& .cm-completionInfo ul": {
    margin: 0,
    paddingLeft: "15px"
  },
  "& .cm-completionInfo pre": {
    marginBottom: 0,
    whiteSpace: "pre-wrap"
  },
  "& .cm-completionInfo p": {
    marginTop: 0
  },
  "& .cm-completionInfo p:not(:last-of-type)": {
    marginBottom: 0
  }
});
var highlightTheme = import_view.EditorView.baseTheme({
  "& .variableName": {
    color: "#10f"
  },
  "& .number": {
    color: "#164"
  },
  "& .string": {
    color: "#a11"
  },
  "& .bool": {
    color: "#219"
  },
  "& .function": {
    color: "#aa3731",
    fontWeight: "bold"
  },
  "& .control": {
    color: "#708"
  }
});
var syntaxClasses = (0, import_language3.syntaxHighlighting)(import_language3.HighlightStyle.define([
  { tag: import_highlight2.tags.variableName, class: "variableName" },
  { tag: import_highlight2.tags.name, class: "variableName" },
  { tag: import_highlight2.tags.number, class: "number" },
  { tag: import_highlight2.tags.string, class: "string" },
  { tag: import_highlight2.tags.bool, class: "bool" },
  { tag: import_highlight2.tags.function(import_highlight2.tags.variableName), class: "function" },
  { tag: import_highlight2.tags.function(import_highlight2.tags.special(import_highlight2.tags.variableName)), class: "function" },
  { tag: import_highlight2.tags.controlKeyword, class: "control" },
  { tag: import_highlight2.tags.operatorKeyword, class: "control" }
]));
var theme = [baseTheme, highlightTheme, syntaxClasses];
var autocompletionConf = new import_state.Compartment();
function FeelEditor({
  container,
  tooltipContainer,
  onChange = () => {
  },
  onKeyDown = () => {
  },
  onLint = () => {
  },
  readOnly = false,
  value = "",
  variables: variables2 = []
}) {
  const changeHandler = import_view.EditorView.updateListener.of((update) => {
    if (update.docChanged) {
      onChange(update.state.doc.toString());
    }
  });
  const lintHandler = import_view.EditorView.updateListener.of((update) => {
    const diagnosticEffects = update.transactions.flatMap((t6) => t6.effects).filter((effect) => effect.is(import_lint.setDiagnosticsEffect));
    if (!diagnosticEffects.length) {
      return;
    }
    const messages = diagnosticEffects.flatMap((effect) => effect.value);
    onLint(messages);
  });
  const keyHandler = import_view.EditorView.domEventHandlers({
    keydown: onKeyDown
  });
  if (typeof tooltipContainer === "string") {
    tooltipContainer = document.querySelector(tooltipContainer);
  }
  const tooltipLayout = tooltipContainer ? (0, import_view.tooltips)({
    tooltipSpace: function() {
      return tooltipContainer.getBoundingClientRect();
    }
  }) : [];
  const extensions = [
    autocompletionConf.of(variablesFacet.of(variables2)),
    autocompletion(),
    (0, import_language3.bracketMatching)(),
    changeHandler,
    (0, import_autocomplete2.closeBrackets)(),
    (0, import_language3.indentOnInput)(),
    keyHandler,
    import_view.keymap.of([
      ...import_commands.defaultKeymap
    ]),
    language(),
    linter,
    lintHandler,
    tooltipLayout,
    theme
  ];
  if (readOnly) {
    extensions.push(import_view.EditorView.editable.of(false));
  }
  this._cmEditor = new import_view.EditorView({
    state: import_state.EditorState.create({
      doc: value,
      extensions
    }),
    parent: container
  });
  return this;
}
FeelEditor.prototype.setValue = function(value) {
  this._cmEditor.dispatch({
    changes: {
      from: 0,
      to: this._cmEditor.state.doc.length,
      insert: value
    }
  });
};
FeelEditor.prototype.focus = function(position) {
  const cmEditor = this._cmEditor;
  cmEditor.contentDOM.focus();
  cmEditor.focus();
  if (typeof position === "number") {
    const end = cmEditor.state.doc.length;
    cmEditor.dispatch({ selection: { anchor: position <= end ? position : end } });
  }
};
FeelEditor.prototype.getSelection = function() {
  return this._cmEditor.state.selection;
};
FeelEditor.prototype.setVariables = function(variables2) {
  this._cmEditor.dispatch({
    effects: autocompletionConf.reconfigure(variablesFacet.of(variables2))
  });
};

// node_modules/@bpmn-io/properties-panel/dist/index.esm.js
var ArrowIcon = function ArrowIcon2(props) {
  return o5("svg", {
    ...props,
    children: o5("path", {
      fillRule: "evenodd",
      d: "m11.657 8-4.95 4.95a1 1 0 0 1-1.414-1.414L8.828 8 5.293 4.464A1 1 0 1 1 6.707 3.05L11.657 8Z"
    })
  });
};
ArrowIcon.defaultProps = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "16",
  height: "16"
};
var CreateIcon = function CreateIcon2(props) {
  return o5("svg", {
    ...props,
    children: o5("path", {
      fillRule: "evenodd",
      d: "M9 13V9h4a1 1 0 0 0 0-2H9V3a1 1 0 1 0-2 0v4H3a1 1 0 1 0 0 2h4v4a1 1 0 0 0 2 0Z"
    })
  });
};
CreateIcon.defaultProps = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "16",
  height: "16"
};
var DeleteIcon = function DeleteIcon2(props) {
  return o5("svg", {
    ...props,
    children: o5("path", {
      fillRule: "evenodd",
      d: "M12 6v7c0 1.1-.4 1.55-1.5 1.55h-5C4.4 14.55 4 14.1 4 13V6h8Zm-1.5 1.5h-5v4.3c0 .66.5 1.2 1.111 1.2H9.39c.611 0 1.111-.54 1.111-1.2V7.5ZM13 3h-2l-1-1H6L5 3H3v1.5h10V3Z"
    })
  });
};
DeleteIcon.defaultProps = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "16",
  height: "16"
};
var ExternalLinkIcon = function ExternalLinkIcon2(props) {
  return o5("svg", {
    ...props,
    children: o5("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M12.637 12.637v-4.72h1.362v4.721c0 .36-.137.676-.411.95-.275.275-.591.412-.95.412H3.362c-.38 0-.703-.132-.967-.396A1.315 1.315 0 0 1 2 12.638V3.362c0-.38.132-.703.396-.967S2.982 2 3.363 2h4.553v1.363H3.363v9.274h9.274ZM14 2H9.28l-.001 1.362h2.408L5.065 9.984l.95.95 6.622-6.622v2.409H14V2Z",
      fill: "#818798"
    })
  });
};
ExternalLinkIcon.defaultProps = {
  width: "16",
  height: "16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
var FeelRequiredIcon = function FeelRequiredIcon2(props) {
  return o5("svg", {
    ...props,
    children: [o5("path", {
      d: "M5.8 7.06V5.95h4.307v1.11H5.8Zm0 3.071v-1.11h4.307v1.11H5.8Z",
      fill: "currentColor"
    }), o5("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M8 3.268A4.732 4.732 0 1 0 12.732 8H14a6 6 0 1 1-6-6v1.268Z",
      fill: "currentColor"
    }), o5("path", {
      d: "m11.28 6.072-.832-.56 1.016-1.224L10 3.848l.312-.912 1.392.584L11.632 2h1.032l-.072 1.52 1.392-.584.312.912-1.464.44 1.008 1.224-.832.552-.864-1.296-.864 1.304Z",
      fill: "currentColor"
    })]
  });
};
FeelRequiredIcon.defaultProps = {
  viewBox: "0 0 16 16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
var FeelOptionalIcon = function FeelOptionalIcon2(props) {
  return o5("svg", {
    ...props,
    children: [o5("path", {
      d: "M5.845 7.04V5.93h4.307v1.11H5.845Zm0 3.07V9h4.307v1.11H5.845Z",
      fill: "currentColor"
    }), o5("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M3.286 8a4.714 4.714 0 1 0 9.428 0 4.714 4.714 0 0 0-9.428 0ZM8 2a6 6 0 1 0 0 12A6 6 0 0 0 8 2Z",
      fill: "currentColor"
    })]
  });
};
FeelOptionalIcon.defaultProps = {
  viewBox: "0 0 16 16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
function Header(props) {
  const {
    element,
    headerProvider
  } = props;
  const {
    getElementIcon,
    getDocumentationRef,
    getElementLabel,
    getTypeLabel
  } = headerProvider;
  const label = getElementLabel(element);
  const type = getTypeLabel(element);
  const documentationRef = getDocumentationRef && getDocumentationRef(element);
  const ElementIcon = getElementIcon(element);
  return o5("div", {
    class: "bio-properties-panel-header",
    children: [o5("div", {
      class: "bio-properties-panel-header-icon",
      children: ElementIcon && o5(ElementIcon, {
        width: "32",
        height: "32",
        viewBox: "0 0 32 32"
      })
    }), o5("div", {
      class: "bio-properties-panel-header-labels",
      children: [o5("div", {
        title: type,
        class: "bio-properties-panel-header-type",
        children: type
      }), label ? o5("div", {
        title: label,
        class: "bio-properties-panel-header-label",
        children: label
      }) : null]
    }), o5("div", {
      class: "bio-properties-panel-header-actions",
      children: documentationRef ? o5("a", {
        rel: "noopener",
        class: "bio-properties-panel-header-link",
        href: documentationRef,
        title: "Open documentation",
        target: "_blank",
        children: o5(ExternalLinkIcon, {})
      }) : null
    })]
  });
}
var DescriptionContext = q({
  description: {},
  getDescriptionForId: () => {
  }
});
var ErrorsContext = q({
  errors: {}
});
var EventContext = q({
  eventBus: null
});
var LayoutContext = q({
  layout: {},
  setLayout: () => {
  },
  getLayoutForKey: () => {
  },
  setLayoutForKey: () => {
  }
});
function useDescriptionContext(id, element) {
  const {
    getDescriptionForId
  } = F2(DescriptionContext);
  return getDescriptionForId(id, element);
}
function useError(id) {
  const {
    errors
  } = F2(ErrorsContext);
  return errors[id];
}
function useEvent(event2, callback, eventBus) {
  const eventContext = F2(EventContext);
  if (!eventBus) {
    ({
      eventBus
    } = eventContext);
  }
  const didMount = s4(false);
  if (eventBus && !didMount.current) {
    eventBus.on(event2, callback);
  }
  y3(() => {
    if (eventBus && didMount.current) {
      eventBus.on(event2, callback);
    }
    didMount.current = true;
    return () => {
      if (eventBus) {
        eventBus.off(event2, callback);
      }
    };
  }, [callback, event2, eventBus]);
}
var KEY_LENGTH = 6;
function useKeyFactory(dependencies = []) {
  const map14 = d4(() => /* @__PURE__ */ new Map(), dependencies);
  const getKey = (el) => {
    let key = map14.get(el);
    if (!key) {
      key = Math.random().toString().slice(-KEY_LENGTH);
      map14.set(el, key);
    }
    return key;
  };
  return getKey;
}
function useLayoutState(path, defaultValue) {
  const {
    getLayoutForKey,
    setLayoutForKey
  } = F2(LayoutContext);
  const layoutForKey = getLayoutForKey(path, defaultValue);
  const [value, set4] = l4(layoutForKey);
  const setState = (newValue) => {
    set4(newValue);
    setLayoutForKey(path, newValue);
  };
  return [value, setState];
}
function usePrevious(value) {
  const ref = s4();
  y3(() => {
    ref.current = value;
  });
  return ref.current;
}
function useShowEntryEvent(id) {
  const {
    onShow
  } = F2(LayoutContext);
  const ref = s4();
  const focus = s4(false);
  const onShowEntry = A3((event2) => {
    if (event2.id === id) {
      onShow();
      if (!focus.current) {
        focus.current = true;
      }
    }
  }, [id]);
  y3(() => {
    if (focus.current && ref.current) {
      if ((0, import_min_dash145.isFunction)(ref.current.focus)) {
        ref.current.focus();
      }
      if ((0, import_min_dash145.isFunction)(ref.current.select)) {
        ref.current.select();
      }
      focus.current = false;
    }
  });
  useEvent("propertiesPanel.showEntry", onShowEntry);
  return ref;
}
function useStickyIntersectionObserver(ref, scrollContainerSelector, setSticky) {
  y3(() => {
    const Observer = IntersectionObserver;
    if (!Observer) {
      return;
    }
    let observer;
    if (ref.current) {
      const scrollContainer = query(scrollContainerSelector);
      observer = new Observer((entries) => {
        entries.forEach((entry) => {
          if (entry.intersectionRatio < 1) {
            setSticky(true);
          } else if (entry.intersectionRatio === 1) {
            setSticky(false);
          }
        });
      }, {
        root: scrollContainer,
        rootMargin: "0px 0px 999999% 0px",
        threshold: [1]
      });
      observer.observe(ref.current);
    }
    return () => {
      if (ref.current && observer) {
        observer.unobserve(ref.current);
      }
    };
  }, [ref, scrollContainerSelector, setSticky]);
}
function useStaticCallback(callback) {
  const callbackRef = s4(callback);
  callbackRef.current = callback;
  return A3((...args) => callbackRef.current(...args), []);
}
function Group(props) {
  const {
    element,
    entries = [],
    id,
    label,
    shouldOpen = false
  } = props;
  const groupRef = s4(null);
  const [open3, setOpen] = useLayoutState(["groups", id, "open"], shouldOpen);
  const onShow = A3(() => setOpen(true), [setOpen]);
  const toggleOpen = () => setOpen(!open3);
  const [edited, setEdited] = l4(false);
  const [sticky, setSticky] = l4(false);
  y3(() => {
    const hasOneEditedEntry = entries.find((entry) => {
      const {
        id: id2,
        isEdited: isEdited2
      } = entry;
      const entryNode = query(`[data-entry-id="${id2}"]`);
      if (!(0, import_min_dash145.isFunction)(isEdited2) || !entryNode) {
        return false;
      }
      const inputNode = query(".bio-properties-panel-input", entryNode);
      return isEdited2(inputNode);
    });
    setEdited(hasOneEditedEntry);
  }, [entries]);
  useStickyIntersectionObserver(groupRef, "div.bio-properties-panel-scroll-container", setSticky);
  const propertiesPanelContext = {
    ...F2(LayoutContext),
    onShow
  };
  return o5("div", {
    class: "bio-properties-panel-group",
    "data-group-id": "group-" + id,
    ref: groupRef,
    children: [o5("div", {
      class: (0, import_classnames.default)("bio-properties-panel-group-header", edited ? "" : "empty", open3 ? "open" : "", sticky && open3 ? "sticky" : ""),
      onClick: toggleOpen,
      children: [o5("div", {
        title: label,
        class: "bio-properties-panel-group-header-title",
        children: label
      }), o5("div", {
        class: "bio-properties-panel-group-header-buttons",
        children: [edited && o5(DataMarker, {}), o5("button", {
          title: "Toggle section",
          class: "bio-properties-panel-group-header-button bio-properties-panel-arrow",
          children: o5(ArrowIcon, {
            class: open3 ? "bio-properties-panel-arrow-down" : "bio-properties-panel-arrow-right"
          })
        })]
      })]
    }), o5("div", {
      class: (0, import_classnames.default)("bio-properties-panel-group-entries", open3 ? "open" : ""),
      children: o5(LayoutContext.Provider, {
        value: propertiesPanelContext,
        children: entries.map((entry) => {
          const {
            component: Component,
            id: id2
          } = entry;
          return a3(Component, {
            ...entry,
            element,
            key: id2
          });
        })
      })
    })]
  });
}
function DataMarker() {
  return o5("div", {
    title: "Section contains data",
    class: "bio-properties-panel-dot"
  });
}
function Placeholder(props) {
  const {
    text,
    icon: Icon
  } = props;
  return o5("div", {
    class: "bio-properties-panel open",
    children: o5("section", {
      class: "bio-properties-panel-placeholder",
      children: [Icon && o5(Icon, {
        class: "bio-properties-panel-placeholder-icon"
      }), o5("p", {
        class: "bio-properties-panel-placeholder-text",
        children: text
      })]
    })
  });
}
var DEFAULT_LAYOUT = {
  open: true
};
var DEFAULT_DESCRIPTION = {};
function PropertiesPanel(props) {
  const {
    element,
    headerProvider,
    placeholderProvider,
    groups,
    layoutConfig = {},
    layoutChanged,
    descriptionConfig = {},
    descriptionLoaded,
    eventBus
  } = props;
  const [layout, setLayout] = l4(createLayout(layoutConfig));
  y3(() => {
    if (typeof layoutChanged === "function") {
      layoutChanged(layout);
    }
  }, [layout, layoutChanged]);
  const getLayoutForKey = (key, defaultValue) => {
    return (0, import_min_dash145.get)(layout, key, defaultValue);
  };
  const setLayoutForKey = (key, config) => {
    const newLayout = (0, import_min_dash145.assign)({}, layout);
    (0, import_min_dash145.set)(newLayout, key, config);
    setLayout(newLayout);
  };
  const layoutContext = {
    layout,
    setLayout,
    getLayoutForKey,
    setLayoutForKey
  };
  const description = createDescriptionContext(descriptionConfig);
  if (typeof descriptionLoaded === "function") {
    descriptionLoaded(description);
  }
  const getDescriptionForId = (id, element2) => {
    return description[id] && description[id](element2);
  };
  const descriptionContext = {
    description,
    getDescriptionForId
  };
  const [errors, setErrors] = l4({});
  const onSetErrors = ({
    errors: errors2
  }) => setErrors(errors2);
  useEvent("propertiesPanel.setErrors", onSetErrors, eventBus);
  const errorsContext = {
    errors
  };
  const eventContext = {
    eventBus
  };
  const propertiesPanelContext = {
    element
  };
  if (placeholderProvider && !element) {
    return o5(Placeholder, {
      ...placeholderProvider.getEmpty()
    });
  }
  if (placeholderProvider && (0, import_min_dash145.isArray)(element)) {
    return o5(Placeholder, {
      ...placeholderProvider.getMultiple()
    });
  }
  return o5(LayoutContext.Provider, {
    value: propertiesPanelContext,
    children: o5(ErrorsContext.Provider, {
      value: errorsContext,
      children: o5(DescriptionContext.Provider, {
        value: descriptionContext,
        children: o5(LayoutContext.Provider, {
          value: layoutContext,
          children: o5(EventContext.Provider, {
            value: eventContext,
            children: o5("div", {
              class: (0, import_classnames.default)("bio-properties-panel", layout.open ? "open" : ""),
              children: [o5(Header, {
                element,
                headerProvider
              }), o5("div", {
                class: "bio-properties-panel-scroll-container",
                children: groups.map((group) => {
                  const {
                    component: Component = Group,
                    id
                  } = group;
                  return a3(Component, {
                    ...group,
                    key: id,
                    element
                  });
                })
              })]
            })
          })
        })
      })
    })
  });
}
function createLayout(overrides) {
  return {
    ...DEFAULT_LAYOUT,
    ...overrides
  };
}
function createDescriptionContext(overrides) {
  return {
    ...DEFAULT_DESCRIPTION,
    ...overrides
  };
}
function DropdownButton(props) {
  const {
    class: className,
    children,
    menuItems = []
  } = props;
  const dropdownRef = s4(null);
  const menuRef = s4(null);
  const [open3, setOpen] = l4(false);
  const close = () => setOpen(false);
  function onDropdownToggle(event2) {
    if (menuRef.current && menuRef.current.contains(event2.target)) {
      return;
    }
    event2.stopPropagation();
    setOpen((open4) => !open4);
  }
  function onActionClick(event2, action) {
    event2.stopPropagation();
    close();
    action();
  }
  useGlobalClick([dropdownRef.current], () => close());
  return o5("div", {
    class: (0, import_classnames.default)("bio-properties-panel-dropdown-button", {
      open: open3
    }, className),
    onClick: onDropdownToggle,
    ref: dropdownRef,
    children: [children, o5("div", {
      class: "bio-properties-panel-dropdown-button__menu",
      ref: menuRef,
      children: menuItems.map((item, index2) => o5(MenuItem, {
        onClick: onActionClick,
        item
      }, index2))
    })]
  });
}
function MenuItem({
  item,
  onClick
}) {
  if (item.separator) {
    return o5("div", {
      class: "bio-properties-panel-dropdown-button__menu-item bio-properties-panel-dropdown-button__menu-item--separator"
    });
  }
  if (item.action) {
    return o5("button", {
      class: "bio-properties-panel-dropdown-button__menu-item bio-properties-panel-dropdown-button__menu-item--actionable",
      onClick: (event2) => onClick(event2, item.action),
      children: item.entry
    });
  }
  return o5("div", {
    class: "bio-properties-panel-dropdown-button__menu-item",
    children: item.entry
  });
}
function useGlobalClick(ignoredElements, callback) {
  y3(() => {
    function listener(event2) {
      if (ignoredElements.some((element) => element && element.contains(event2.target))) {
        return;
      }
      callback();
    }
    document.addEventListener("click", listener, {
      capture: true
    });
    return () => document.removeEventListener("click", listener, {
      capture: true
    });
  }, [...ignoredElements, callback]);
}
function HeaderButton(props) {
  const {
    children = null,
    class: classname,
    onClick = () => {
    },
    ...otherProps
  } = props;
  return o5("button", {
    ...otherProps,
    onClick,
    class: (0, import_classnames.default)("bio-properties-panel-group-header-button", classname),
    children
  });
}
function CollapsibleEntry(props) {
  const {
    element,
    entries = [],
    id,
    label,
    open: shouldOpen,
    remove: remove5
  } = props;
  const [open3, setOpen] = l4(shouldOpen);
  const toggleOpen = () => setOpen(!open3);
  const {
    onShow
  } = F2(LayoutContext);
  const propertiesPanelContext = {
    ...F2(LayoutContext),
    onShow: A3(() => {
      setOpen(true);
      if ((0, import_min_dash145.isFunction)(onShow)) {
        onShow();
      }
    }, [onShow, setOpen])
  };
  const placeholderLabel = "<empty>";
  return o5("div", {
    "data-entry-id": id,
    class: (0, import_classnames.default)("bio-properties-panel-collapsible-entry", open3 ? "open" : ""),
    children: [o5("div", {
      class: "bio-properties-panel-collapsible-entry-header",
      onClick: toggleOpen,
      children: [o5("div", {
        title: label || placeholderLabel,
        class: (0, import_classnames.default)("bio-properties-panel-collapsible-entry-header-title", !label && "empty"),
        children: label || placeholderLabel
      }), o5("button", {
        title: "Toggle list item",
        class: "bio-properties-panel-arrow  bio-properties-panel-collapsible-entry-arrow",
        children: o5(ArrowIcon, {
          class: open3 ? "bio-properties-panel-arrow-down" : "bio-properties-panel-arrow-right"
        })
      }), remove5 ? o5("button", {
        title: "Delete item",
        class: "bio-properties-panel-remove-entry",
        onClick: remove5,
        children: o5(DeleteIcon, {})
      }) : null]
    }), o5("div", {
      class: (0, import_classnames.default)("bio-properties-panel-collapsible-entry-entries", open3 ? "open" : ""),
      children: o5(LayoutContext.Provider, {
        value: propertiesPanelContext,
        children: entries.map((entry) => {
          const {
            component: Component,
            id: id2
          } = entry;
          return a3(Component, {
            ...entry,
            element,
            key: id2
          });
        })
      })
    })]
  });
}
function ListItem(props) {
  const {
    autoFocusEntry,
    autoOpen
  } = props;
  y3(() => {
    if (autoOpen && autoFocusEntry) {
      const entry = query(`[data-entry-id="${autoFocusEntry}"]`);
      const focusableInput = query(".bio-properties-panel-input", entry);
      if (focusableInput) {
        if ((0, import_min_dash145.isFunction)(focusableInput.select)) {
          focusableInput.select();
        } else if ((0, import_min_dash145.isFunction)(focusableInput.focus)) {
          focusableInput.focus();
        }
      }
    }
  }, [autoOpen, autoFocusEntry]);
  return o5("div", {
    class: "bio-properties-panel-list-item",
    children: o5(CollapsibleEntry, {
      ...props,
      open: autoOpen
    })
  });
}
var noop$2 = () => {
};
function ListGroup(props) {
  const {
    add: add3,
    element,
    id,
    items,
    label,
    shouldOpen = true,
    shouldSort = true
  } = props;
  const groupRef = s4(null);
  const [open3, setOpen] = useLayoutState(["groups", id, "open"], false);
  const [sticky, setSticky] = l4(false);
  const onShow = A3(() => setOpen(true), [setOpen]);
  const [ordering, setOrdering] = l4([]);
  const [newItemAdded, setNewItemAdded] = l4(false);
  const prevItems = usePrevious(items);
  const prevElement = usePrevious(element);
  const elementChanged = element !== prevElement;
  const shouldHandleEffects = !elementChanged && (shouldSort || shouldOpen);
  if (elementChanged) {
    setOrdering(createOrdering(shouldSort ? sortItems(items) : items));
  }
  y3(() => {
    if (!prevItems || !shouldSort) {
      setOrdering(createOrdering(items));
    }
  }, [items, element]);
  y3(() => {
    if (shouldHandleEffects && prevItems && items.length > prevItems.length) {
      let add4 = [];
      items.forEach((item) => {
        if (!ordering.includes(item.id)) {
          add4.push(item.id);
        }
      });
      let newOrdering = ordering;
      if (!open3 && shouldOpen) {
        toggleOpen();
        if (shouldSort) {
          newOrdering = createOrdering(sortItems(items));
        }
      }
      newOrdering = newOrdering.filter((item) => !add4.includes(item));
      if (shouldSort) {
        newOrdering.unshift(...add4);
      } else {
        newOrdering.push(...add4);
      }
      setOrdering(newOrdering);
      setNewItemAdded(true);
    } else {
      setNewItemAdded(false);
    }
  }, [items, open3, shouldHandleEffects]);
  y3(() => {
    if (shouldSort && open3 && !newItemAdded) {
      setOrdering(createOrdering(sortItems(items)));
    }
  }, [open3, shouldSort]);
  y3(() => {
    if (shouldHandleEffects && prevItems && items.length < prevItems.length) {
      let keep = [];
      ordering.forEach((o7) => {
        if (getItem(items, o7)) {
          keep.push(o7);
        }
      });
      setOrdering(keep);
    }
  }, [items, shouldHandleEffects]);
  useStickyIntersectionObserver(groupRef, "div.bio-properties-panel-scroll-container", setSticky);
  const toggleOpen = () => setOpen(!open3);
  const hasItems = !!items.length;
  const propertiesPanelContext = {
    ...F2(LayoutContext),
    onShow
  };
  return o5("div", {
    class: "bio-properties-panel-group",
    "data-group-id": "group-" + id,
    ref: groupRef,
    children: [o5("div", {
      class: (0, import_classnames.default)("bio-properties-panel-group-header", hasItems ? "" : "empty", hasItems && open3 ? "open" : "", sticky && open3 ? "sticky" : ""),
      onClick: hasItems ? toggleOpen : noop$2,
      children: [o5("div", {
        title: label,
        class: "bio-properties-panel-group-header-title",
        children: label
      }), o5("div", {
        class: "bio-properties-panel-group-header-buttons",
        children: [add3 ? o5("button", {
          title: "Create new list item",
          class: "bio-properties-panel-group-header-button bio-properties-panel-add-entry",
          onClick: add3,
          children: [o5(CreateIcon, {}), !hasItems ? o5("span", {
            class: "bio-properties-panel-add-entry-label",
            children: "Create"
          }) : null]
        }) : null, hasItems ? o5("div", {
          title: `List contains ${items.length} item${items.length != 1 ? "s" : ""}`,
          class: "bio-properties-panel-list-badge",
          children: items.length
        }) : null, hasItems ? o5("button", {
          title: "Toggle section",
          class: "bio-properties-panel-group-header-button bio-properties-panel-arrow",
          children: o5(ArrowIcon, {
            class: open3 ? "bio-properties-panel-arrow-down" : "bio-properties-panel-arrow-right"
          })
        }) : null]
      })]
    }), o5("div", {
      class: (0, import_classnames.default)("bio-properties-panel-list", open3 && hasItems ? "open" : ""),
      children: o5(LayoutContext.Provider, {
        value: propertiesPanelContext,
        children: ordering.map((o7, index2) => {
          const item = getItem(items, o7);
          if (!item) {
            return;
          }
          const {
            id: id2
          } = item;
          const autoOpen = newItemAdded && (shouldSort ? index2 === 0 : index2 === ordering.length - 1);
          return a3(ListItem, {
            ...item,
            autoOpen,
            element,
            index: index2,
            key: id2
          });
        })
      })
    })]
  });
}
function sortItems(items) {
  return (0, import_min_dash145.sortBy)(items, (i6) => i6.label.toLowerCase());
}
function getItem(items, id) {
  return (0, import_min_dash145.find)(items, (i6) => i6.id === id);
}
function createOrdering(items) {
  return items.map((i6) => i6.id);
}
function Description(props) {
  const {
    element,
    forId,
    value
  } = props;
  const contextDescription = useDescriptionContext(forId, element);
  const description = value || contextDescription;
  if (description) {
    return o5("div", {
      class: "bio-properties-panel-description",
      children: description
    });
  }
}
function Checkbox(props) {
  const {
    id,
    label,
    onChange,
    disabled,
    value = false,
    onFocus,
    onBlur
  } = props;
  const [localValue, setLocalValue] = l4(value);
  const handleChangeCallback = ({
    target
  }) => {
    onChange(target.checked);
  };
  const handleChange = (e7) => {
    handleChangeCallback(e7);
    setLocalValue(e7.target.value);
  };
  y3(() => {
    if (value === localValue) {
      return;
    }
    setLocalValue(value);
  }, [value]);
  const ref = useShowEntryEvent(id);
  return o5("div", {
    class: "bio-properties-panel-checkbox",
    children: [o5("input", {
      ref,
      id: prefixId$7(id),
      name: id,
      onFocus,
      onBlur,
      type: "checkbox",
      class: "bio-properties-panel-input",
      onChange: handleChange,
      checked: localValue,
      disabled
    }), o5("label", {
      for: prefixId$7(id),
      class: "bio-properties-panel-label",
      children: label
    })]
  });
}
function CheckboxEntry(props) {
  const {
    element,
    id,
    description,
    label,
    getValue: getValue2,
    setValue,
    disabled,
    onFocus,
    onBlur
  } = props;
  const value = getValue2(element);
  const error4 = useError(id);
  return o5("div", {
    class: "bio-properties-panel-entry bio-properties-panel-checkbox-entry",
    "data-entry-id": id,
    children: [o5(Checkbox, {
      disabled,
      id,
      label,
      onChange: setValue,
      onFocus,
      onBlur,
      value
    }, element), error4 && o5("div", {
      class: "bio-properties-panel-error",
      children: error4
    }), o5(Description, {
      forId: id,
      element,
      value: description
    })]
  });
}
function isEdited$7(node2) {
  return node2 && !!node2.checked;
}
function prefixId$7(id) {
  return `bio-properties-panel-${id}`;
}
var useBufferedFocus = function(editor, ref) {
  const [buffer, setBuffer] = l4(void 0);
  ref.current = d4(() => ({
    focus: (offset) => {
      if (editor) {
        editor.focus(offset);
      } else {
        if (typeof offset === "undefined") {
          offset = Infinity;
        }
        setBuffer(offset);
      }
    }
  }), [editor]);
  y3(() => {
    if (typeof buffer !== "undefined" && editor) {
      editor.focus(buffer);
      setBuffer(false);
    }
  }, [editor, buffer]);
};
var CodeEditor = x3((props, ref) => {
  const {
    value,
    onInput,
    onFeelToggle,
    onLint = () => {
    },
    disabled,
    tooltipContainer,
    variables: variables2
  } = props;
  const inputRef = s4();
  const [editor, setEditor] = l4();
  const [localValue, setLocalValue] = l4(value || "");
  useBufferedFocus(editor, ref);
  const handleInput = useStaticCallback((newValue) => {
    onInput(newValue);
    setLocalValue(newValue);
  });
  y3(() => {
    let editor2;
    const onKeyDown = (e7) => {
      if (e7.key !== "Backspace" || !editor2) {
        return;
      }
      const selection = editor2.getSelection();
      const range = selection.ranges[selection.mainIndex];
      if (range.from === 0 && range.to === 0) {
        onFeelToggle();
      }
    };
    editor2 = new FeelEditor({
      container: inputRef.current,
      onChange: handleInput,
      onKeyDown,
      onLint,
      tooltipContainer,
      value: localValue,
      variables: variables2
    });
    setEditor(editor2);
    return () => {
      onLint([]);
      inputRef.current.innerHTML = "";
      setEditor(null);
    };
  }, []);
  y3(() => {
    if (!editor) {
      return;
    }
    if (value === localValue) {
      return;
    }
    editor.setValue(value);
    setLocalValue(value);
  }, [value]);
  y3(() => {
    if (!editor) {
      return;
    }
    editor.setVariables(variables2);
  }, [variables2]);
  const handleClick = () => {
    ref.current.focus();
  };
  return o5("div", {
    class: (0, import_classnames.default)("bio-properties-panel-feel-editor-container", disabled ? "disabled" : null),
    children: o5("div", {
      name: props.name,
      class: (0, import_classnames.default)("bio-properties-panel-input", localValue ? "edited" : null),
      ref: inputRef,
      onClick: handleClick
    })
  });
});
function FeelIndicator(props) {
  const {
    active
  } = props;
  if (!active) {
    return null;
  }
  return o5("span", {
    class: "bio-properties-panel-feel-indicator",
    children: "="
  });
}
var noop$1 = () => {
};
function FeelIcon(props) {
  const {
    label,
    feel = false,
    active,
    disabled = false,
    onClick = noop$1
  } = props;
  const feelRequiredLabel = " must be a FEEL expression";
  const feelOptionalLabel = " can optionally be a FEEL expression";
  const handleClick = (e7) => {
    onClick(e7);
    if (!e7.pointerType) {
      e7.stopPropagation();
    }
  };
  return o5("button", {
    class: (0, import_classnames.default)("bio-properties-panel-feel-icon", active ? "active" : null, feel === "required" ? "required" : "optional"),
    onClick: handleClick,
    disabled: feel === "required" || disabled,
    title: label + (feel === "required" ? feelRequiredLabel : feelOptionalLabel),
    children: feel === "required" ? o5(FeelRequiredIcon, {}) : o5(FeelOptionalIcon, {})
  });
}
var noop = () => {
};
function FeelTextfield(props) {
  const {
    debounce: debounce4,
    id,
    label,
    onInput,
    onError,
    feel,
    value = "",
    disabled = false,
    variables: variables2,
    tooltipContainer,
    OptionalComponent = OptionalFeelInput
  } = props;
  const [localValue, _setLocalValue] = l4(value);
  const editorRef = useShowEntryEvent(id);
  const containerRef = s4();
  const feelActive = localValue.startsWith("=") || feel === "required";
  const feelOnlyValue = localValue.startsWith("=") ? localValue.substring(1) : localValue;
  const [focus, _setFocus] = l4(void 0);
  const setFocus = (offset = 0) => {
    const hasFocus = containerRef.current.contains(document.activeElement);
    const position = hasFocus ? document.activeElement.selectionStart : Infinity;
    _setFocus(position + offset);
  };
  const handleInputCallback = d4(() => {
    return debounce4((newValue) => {
      onInput(newValue);
    });
  }, [onInput, debounce4]);
  const setLocalValue = (newValue) => {
    _setLocalValue(newValue);
    if (!newValue || newValue === "=") {
      handleInputCallback(void 0);
    } else {
      handleInputCallback(newValue);
    }
  };
  const handleFeelToggle = useStaticCallback(() => {
    if (feel === "required") {
      return;
    }
    if (!feelActive) {
      setLocalValue("=" + localValue);
    } else {
      setLocalValue(feelOnlyValue);
    }
  });
  const handleLocalInput = (newValue) => {
    if (feelActive) {
      newValue = "=" + newValue;
    }
    if (newValue === localValue) {
      return;
    }
    setLocalValue(newValue);
    if (!feelActive && newValue.startsWith("=")) {
      setFocus(-1);
    }
  };
  const handleLint = useStaticCallback((lint) => {
    if (!(lint && lint.length)) {
      onError(void 0);
      return;
    }
    const error4 = lint[0];
    const message = `${error4.source}: ${error4.message}`;
    onError(message);
  });
  y3(() => {
    if (typeof focus !== "undefined") {
      editorRef.current.focus(focus);
      _setFocus(void 0);
    }
  }, [focus]);
  y3(() => {
    if (value === localValue) {
      return;
    }
    if (!value) {
      setLocalValue(feelActive ? "=" : "");
      return;
    }
    setLocalValue(value);
  }, [value]);
  y3(() => {
    const copyHandler = (event2) => {
      if (!feelActive) {
        return;
      }
      event2.clipboardData.setData("application/FEEL", event2.clipboardData.getData("text"));
    };
    const pasteHandler = (event2) => {
      if (feelActive) {
        return;
      }
      const data = event2.clipboardData.getData("application/FEEL");
      if (data) {
        setTimeout(() => {
          handleFeelToggle();
          setFocus();
        });
      }
    };
    containerRef.current.addEventListener("copy", copyHandler);
    containerRef.current.addEventListener("cut", copyHandler);
    containerRef.current.addEventListener("paste", pasteHandler);
    return () => {
      containerRef.current.removeEventListener("copy", copyHandler);
      containerRef.current.removeEventListener("cut", copyHandler);
      containerRef.current.removeEventListener("paste", pasteHandler);
    };
  }, [containerRef, feelActive, handleFeelToggle, setFocus]);
  return o5("div", {
    class: "bio-properties-panel-feel-entry",
    children: [o5("label", {
      for: prefixId$6(id),
      class: "bio-properties-panel-label",
      onClick: () => setFocus(),
      children: [label, o5(FeelIcon, {
        label,
        feel,
        onClick: handleFeelToggle,
        active: feelActive
      })]
    }), o5("div", {
      class: "bio-properties-panel-feel-container",
      ref: containerRef,
      children: [o5(FeelIndicator, {
        active: feelActive,
        disabled: feel !== "optional" || disabled,
        onClick: handleFeelToggle
      }), feelActive ? o5(CodeEditor, {
        id: prefixId$6(id),
        name: id,
        onInput: handleLocalInput,
        disabled,
        onFeelToggle: () => {
          handleFeelToggle();
          setFocus(true);
        },
        onLint: handleLint,
        value: feelOnlyValue,
        variables: variables2,
        ref: editorRef,
        tooltipContainer
      }) : o5(OptionalComponent, {
        ...props,
        onInput: handleLocalInput,
        value: localValue,
        ref: editorRef
      })]
    })]
  });
}
var OptionalFeelInput = x3((props, ref) => {
  const {
    id,
    disabled,
    onInput,
    value,
    onFocus,
    onBlur
  } = props;
  const inputRef = s4();
  ref.current = {
    focus: (position) => {
      const input = inputRef.current;
      if (!input) {
        return;
      }
      input.focus();
      if (typeof position === "number") {
        if (position > value.length) {
          position = value.length;
        }
        input.setSelectionRange(position, position);
      }
    }
  };
  return o5("input", {
    id: prefixId$6(id),
    type: "text",
    ref: inputRef,
    name: id,
    spellCheck: "false",
    autoComplete: "off",
    disabled,
    class: "bio-properties-panel-input",
    onInput: (e7) => onInput(e7.target.value),
    onFocus,
    onBlur,
    value: value || ""
  });
});
var OptionalFeelTextArea = x3((props, ref) => {
  const {
    id,
    disabled,
    onInput,
    value,
    onFocus,
    onBlur
  } = props;
  const inputRef = s4();
  ref.current = {
    focus: () => {
      const input = inputRef.current;
      if (!input) {
        return;
      }
      input.focus();
      input.setSelectionRange(0, 0);
    }
  };
  return o5("textarea", {
    id: prefixId$6(id),
    type: "text",
    ref: inputRef,
    name: id,
    spellCheck: "false",
    autoComplete: "off",
    disabled,
    class: "bio-properties-panel-input",
    onInput: (e7) => onInput(e7.target.value),
    onFocus,
    onBlur,
    value: value || "",
    "data-gramm": "false"
  });
});
function FeelEntry(props) {
  const {
    element,
    id,
    description,
    debounce: debounce4,
    disabled,
    feel,
    label,
    getValue: getValue2,
    setValue,
    tooltipContainer,
    validate: validate3,
    show = noop,
    example,
    variables: variables2,
    onFocus,
    onBlur
  } = props;
  const [cachedInvalidValue, setCachedInvalidValue] = l4(null);
  const [validationError, setValidationError] = l4(null);
  const [localError, setLocalError] = l4(null);
  let value = getValue2(element);
  const previousValue = usePrevious(value);
  y3(() => {
    if ((0, import_min_dash145.isFunction)(validate3)) {
      const newValidationError = validate3(value) || null;
      setValidationError(newValidationError);
    }
  }, [value]);
  const onInput = useStaticCallback((newValue) => {
    let newValidationError = null;
    if ((0, import_min_dash145.isFunction)(validate3)) {
      newValidationError = validate3(newValue) || null;
    }
    if (newValidationError) {
      setCachedInvalidValue(newValue);
    } else {
      if (newValue !== value) {
        setValue(newValue);
      }
    }
    setValidationError(newValidationError);
  });
  const onError = A3((err) => {
    setLocalError(err);
  }, []);
  if (previousValue === value && validationError) {
    value = cachedInvalidValue;
  }
  const temporaryError = useError(id);
  const error4 = localError || temporaryError || validationError;
  return o5("div", {
    class: (0, import_classnames.default)(props.class, "bio-properties-panel-entry", error4 ? "has-error" : ""),
    "data-entry-id": id,
    children: [o5(FeelTextfield, {
      debounce: debounce4,
      disabled,
      feel,
      id,
      label,
      onInput,
      onError,
      onFocus,
      onBlur,
      example,
      show,
      value,
      variables: variables2,
      tooltipContainer,
      OptionalComponent: props.OptionalComponent
    }, element), error4 && o5("div", {
      class: "bio-properties-panel-error",
      children: error4
    }), o5(Description, {
      forId: id,
      element,
      value: description
    })]
  });
}
function FeelTextArea(props) {
  return o5(FeelEntry, {
    class: "bio-properties-panel-feel-textarea",
    OptionalComponent: OptionalFeelTextArea,
    ...props
  });
}
function isEdited$6(node2) {
  return node2 && (!!node2.value || node2.classList.contains("edited"));
}
function prefixId$6(id) {
  return `bio-properties-panel-${id}`;
}
function List(props) {
  const {
    id,
    element,
    items = [],
    component,
    label = "<empty>",
    open: shouldOpen,
    onAdd,
    onRemove,
    autoFocusEntry,
    compareFn,
    ...restProps
  } = props;
  const [open3, setOpen] = l4(!!shouldOpen);
  const hasItems = !!items.length;
  const toggleOpen = () => hasItems && setOpen(!open3);
  const opening = !usePrevious(open3) && open3;
  const elementChanged = usePrevious(element) !== element;
  const shouldReset = opening || elementChanged;
  const sortedItems = useSortedItems(items, compareFn, shouldReset);
  const newItems = useNewItems(items, elementChanged);
  y3(() => {
    if (open3 && !hasItems) {
      setOpen(false);
    }
  }, [open3, hasItems]);
  function addItem(event2) {
    event2.stopPropagation();
    onAdd();
    if (!open3) {
      setOpen(true);
    }
  }
  return o5("div", {
    "data-entry-id": id,
    class: (0, import_classnames.default)("bio-properties-panel-entry", "bio-properties-panel-list-entry", hasItems ? "" : "empty", open3 ? "open" : ""),
    children: [o5("div", {
      class: "bio-properties-panel-list-entry-header",
      onClick: toggleOpen,
      children: [o5("div", {
        title: label,
        class: (0, import_classnames.default)("bio-properties-panel-list-entry-header-title", open3 && "open"),
        children: label
      }), o5("div", {
        class: "bio-properties-panel-list-entry-header-buttons",
        children: [o5("button", {
          title: "Create new list item",
          onClick: addItem,
          class: "bio-properties-panel-add-entry",
          children: [o5(CreateIcon, {}), !hasItems ? o5("span", {
            class: "bio-properties-panel-add-entry-label",
            children: "Create"
          }) : null]
        }), hasItems && o5("div", {
          title: `List contains ${items.length} item${items.length != 1 ? "s" : ""}`,
          class: "bio-properties-panel-list-badge",
          children: items.length
        }), hasItems && o5("button", {
          title: "Toggle list item",
          class: "bio-properties-panel-arrow",
          children: o5(ArrowIcon, {
            class: open3 ? "bio-properties-panel-arrow-down" : "bio-properties-panel-arrow-right"
          })
        })]
      })]
    }), hasItems && o5(ItemsList, {
      ...restProps,
      autoFocusEntry,
      component,
      element,
      id,
      items: sortedItems,
      newItems,
      onRemove,
      open: open3
    })]
  });
}
function ItemsList(props) {
  const {
    autoFocusEntry,
    component: Component,
    element,
    id,
    items,
    newItems,
    onRemove,
    open: open3,
    ...restProps
  } = props;
  const getKey = useKeyFactory();
  const newItem = newItems[0];
  y3(() => {
    if (newItem && autoFocusEntry) {
      const entry = query(`[data-entry-id="${id}"]`);
      const selector = typeof autoFocusEntry === "boolean" ? ".bio-properties-panel-input" : autoFocusEntry;
      const focusableInput = query(selector, entry);
      if (focusableInput) {
        if ((0, import_min_dash145.isFunction)(focusableInput.select)) {
          focusableInput.select();
        } else if ((0, import_min_dash145.isFunction)(focusableInput.focus)) {
          focusableInput.focus();
        }
      }
    }
  }, [newItem, autoFocusEntry, id]);
  return o5("ol", {
    class: (0, import_classnames.default)("bio-properties-panel-list-entry-items", open3 ? "open" : ""),
    children: items.map((item, index2) => {
      const key = getKey(item);
      return o5("li", {
        class: "bio-properties-panel-list-entry-item",
        children: [o5(Component, {
          ...restProps,
          element,
          id,
          index: index2,
          item,
          open: item === newItem
        }), onRemove && o5("button", {
          type: "button",
          title: "Delete item",
          class: "bio-properties-panel-remove-entry bio-properties-panel-remove-list-entry",
          onClick: () => onRemove && onRemove(item),
          children: o5(DeleteIcon, {})
        })]
      }, key);
    })
  });
}
function useSortedItems(currentItems, compareFn, shouldReset = false) {
  const itemsRef = s4(currentItems.slice());
  if (shouldReset) {
    itemsRef.current = currentItems.slice();
    if (compareFn) {
      itemsRef.current.sort(compareFn);
    }
  } else {
    const items = itemsRef.current;
    for (const item of currentItems) {
      if (!items.includes(item)) {
        compareFn ? items.unshift(item) : items.push(item);
      }
    }
    itemsRef.current = items.filter((item) => currentItems.includes(item));
  }
  return itemsRef.current;
}
function useNewItems(items = [], shouldReset) {
  const previousItems = usePrevious(items.slice()) || [];
  if (shouldReset) {
    return [];
  }
  return previousItems ? items.filter((item) => !previousItems.includes(item)) : [];
}
function Select(props) {
  const {
    id,
    label,
    onChange,
    options: options2 = [],
    value = "",
    disabled,
    onFocus,
    onBlur
  } = props;
  const ref = useShowEntryEvent(id);
  const [localValue, setLocalValue] = l4(value);
  const handleChangeCallback = ({
    target
  }) => {
    onChange(target.value);
  };
  const handleChange = (e7) => {
    handleChangeCallback(e7);
    setLocalValue(e7.target.value);
  };
  y3(() => {
    if (value === localValue) {
      return;
    }
    setLocalValue(value);
  }, [value]);
  return o5("div", {
    class: "bio-properties-panel-select",
    children: [o5("label", {
      for: prefixId$4(id),
      class: "bio-properties-panel-label",
      children: label
    }), o5("select", {
      ref,
      id: prefixId$4(id),
      name: id,
      class: "bio-properties-panel-input",
      onInput: handleChange,
      onFocus,
      onBlur,
      value: localValue,
      disabled,
      children: options2.map((option, idx) => {
        return o5("option", {
          value: option.value,
          disabled: option.disabled,
          children: option.label
        }, idx);
      })
    })]
  });
}
function SelectEntry(props) {
  const {
    element,
    id,
    description,
    label,
    getValue: getValue2,
    setValue,
    getOptions,
    disabled,
    onFocus,
    onBlur
  } = props;
  const value = getValue2(element);
  const options2 = getOptions(element);
  const error4 = useError(id);
  return o5("div", {
    class: (0, import_classnames.default)("bio-properties-panel-entry", error4 ? "has-error" : ""),
    "data-entry-id": id,
    children: [o5(Select, {
      id,
      label,
      value,
      onChange: setValue,
      onFocus,
      onBlur,
      options: options2,
      disabled
    }, element), error4 && o5("div", {
      class: "bio-properties-panel-error",
      children: error4
    }), o5(Description, {
      forId: id,
      element,
      value: description
    })]
  });
}
function isEdited$4(node2) {
  return node2 && !!node2.value;
}
function prefixId$4(id) {
  return `bio-properties-panel-${id}`;
}
function Simple(props) {
  const {
    debounce: debounce4,
    disabled,
    element,
    getValue: getValue2,
    id,
    onBlur,
    onFocus,
    setValue
  } = props;
  const value = getValue2(element);
  const [localValue, setLocalValue] = l4(value);
  const handleInputCallback = d4(() => {
    return debounce4(({
      target
    }) => setValue(target.value.length ? target.value : void 0));
  }, [setValue, debounce4]);
  const handleInput = (e7) => {
    handleInputCallback(e7);
    setLocalValue(e7.target.value);
  };
  y3(() => {
    if (value === localValue) {
      return;
    }
    setLocalValue(value);
  }, [value]);
  return o5("div", {
    class: "bio-properties-panel-simple",
    children: o5("input", {
      id: prefixId$3(id),
      type: "text",
      name: id,
      spellCheck: "false",
      autoComplete: "off",
      disabled,
      class: "bio-properties-panel-input",
      onInput: handleInput,
      "aria-label": localValue || "<empty>",
      onFocus,
      onBlur,
      value: localValue
    }, element)
  });
}
function prefixId$3(id) {
  return `bio-properties-panel-${id}`;
}
function TextArea(props) {
  const {
    id,
    label,
    rows = 2,
    debounce: debounce4,
    onInput,
    value = "",
    disabled,
    monospace,
    onFocus,
    onBlur
  } = props;
  const [localValue, setLocalValue] = l4(value);
  const ref = useShowEntryEvent(id);
  const handleInputCallback = d4(() => {
    return debounce4(({
      target
    }) => onInput(target.value.length ? target.value : void 0));
  }, [onInput, debounce4]);
  const handleInput = (e7) => {
    handleInputCallback(e7);
    setLocalValue(e7.target.value);
  };
  y3(() => {
    if (value === localValue) {
      return;
    }
    setLocalValue(value);
  }, [value]);
  return o5("div", {
    class: "bio-properties-panel-textarea",
    children: [o5("label", {
      for: prefixId$2(id),
      class: "bio-properties-panel-label",
      children: label
    }), o5("textarea", {
      ref,
      id: prefixId$2(id),
      name: id,
      spellCheck: "false",
      class: (0, import_classnames.default)("bio-properties-panel-input", monospace ? "bio-properties-panel-input-monospace" : ""),
      onInput: handleInput,
      onFocus,
      onBlur,
      rows,
      value: localValue,
      disabled,
      "data-gramm": "false"
    })]
  });
}
function TextAreaEntry(props) {
  const {
    element,
    id,
    description,
    debounce: debounce4,
    label,
    getValue: getValue2,
    setValue,
    rows,
    monospace,
    disabled,
    onFocus,
    onBlur
  } = props;
  const value = getValue2(element);
  const error4 = useError(id);
  return o5("div", {
    class: (0, import_classnames.default)("bio-properties-panel-entry", error4 ? "has-error" : ""),
    "data-entry-id": id,
    children: [o5(TextArea, {
      id,
      label,
      value,
      onInput: setValue,
      onFocus,
      onBlur,
      rows,
      debounce: debounce4,
      monospace,
      disabled
    }, element), error4 && o5("div", {
      class: "bio-properties-panel-error",
      children: error4
    }), o5(Description, {
      forId: id,
      element,
      value: description
    })]
  });
}
function isEdited$2(node2) {
  return node2 && !!node2.value;
}
function prefixId$2(id) {
  return `bio-properties-panel-${id}`;
}
function Textfield(props) {
  const {
    debounce: debounce4,
    disabled = false,
    id,
    label,
    onInput,
    onFocus,
    onBlur,
    value = ""
  } = props;
  const [localValue, setLocalValue] = l4(value || "");
  const ref = useShowEntryEvent(id);
  const handleInputCallback = d4(() => {
    return debounce4(({
      target
    }) => onInput(target.value.length ? target.value : void 0));
  }, [onInput, debounce4]);
  const handleInput = (e7) => {
    handleInputCallback(e7);
    setLocalValue(e7.target.value);
  };
  y3(() => {
    if (value === localValue) {
      return;
    }
    setLocalValue(value);
  }, [value]);
  return o5("div", {
    class: "bio-properties-panel-textfield",
    children: [o5("label", {
      for: prefixId$1(id),
      class: "bio-properties-panel-label",
      children: label
    }), o5("input", {
      ref,
      id: prefixId$1(id),
      type: "text",
      name: id,
      spellCheck: "false",
      autoComplete: "off",
      disabled,
      class: "bio-properties-panel-input",
      onInput: handleInput,
      onFocus,
      onBlur,
      value: localValue
    })]
  });
}
function TextfieldEntry(props) {
  const {
    element,
    id,
    description,
    debounce: debounce4,
    disabled,
    label,
    getValue: getValue2,
    setValue,
    validate: validate3,
    onFocus,
    onBlur
  } = props;
  const [cachedInvalidValue, setCachedInvalidValue] = l4(null);
  const globalError = useError(id);
  const [localError, setLocalError] = l4(null);
  let value = getValue2(element);
  const previousValue = usePrevious(value);
  y3(() => {
    if ((0, import_min_dash145.isFunction)(validate3)) {
      const newValidationError = validate3(value) || null;
      setLocalError(newValidationError);
    }
  }, [value]);
  const onInput = (newValue) => {
    let newValidationError = null;
    if ((0, import_min_dash145.isFunction)(validate3)) {
      newValidationError = validate3(newValue) || null;
    }
    if (newValidationError) {
      setCachedInvalidValue(newValue);
    } else {
      setValue(newValue);
    }
    setLocalError(newValidationError);
  };
  if (previousValue === value && localError) {
    value = cachedInvalidValue;
  }
  const error4 = globalError || localError;
  return o5("div", {
    class: (0, import_classnames.default)("bio-properties-panel-entry", error4 ? "has-error" : ""),
    "data-entry-id": id,
    children: [o5(Textfield, {
      debounce: debounce4,
      disabled,
      id,
      label,
      onInput,
      onFocus,
      onBlur,
      value
    }, element), error4 && o5("div", {
      class: "bio-properties-panel-error",
      children: error4
    }), o5(Description, {
      forId: id,
      element,
      value: description
    })]
  });
}
function isEdited$1(node2) {
  return node2 && !!node2.value;
}
function prefixId$1(id) {
  return `bio-properties-panel-${id}`;
}
function ToggleSwitch(props) {
  const {
    id,
    label,
    onInput,
    value,
    switcherLabel,
    onFocus,
    onBlur
  } = props;
  const [localValue, setLocalValue] = l4(value);
  const handleInputCallback = async () => {
    onInput(!value);
  };
  const handleInput = (e7) => {
    handleInputCallback();
    setLocalValue(e7.target.value);
  };
  y3(() => {
    if (value === localValue) {
      return;
    }
    setLocalValue(value);
  }, [value]);
  return o5("div", {
    class: "bio-properties-panel-toggle-switch",
    children: [o5("label", {
      class: "bio-properties-panel-label",
      for: prefixId(id),
      children: label
    }), o5("div", {
      class: "bio-properties-panel-field-wrapper",
      children: [o5("label", {
        class: "bio-properties-panel-toggle-switch__switcher",
        children: [o5("input", {
          id: prefixId(id),
          class: "bio-properties-panel-input",
          type: "checkbox",
          onFocus,
          onBlur,
          name: id,
          onInput: handleInput,
          checked: !!localValue
        }), o5("span", {
          class: "bio-properties-panel-toggle-switch__slider"
        })]
      }), o5("p", {
        class: "bio-properties-panel-toggle-switch__label",
        children: switcherLabel
      })]
    })]
  });
}
function ToggleSwitchEntry(props) {
  const {
    element,
    id,
    description,
    label,
    switcherLabel,
    getValue: getValue2,
    setValue,
    onFocus,
    onBlur
  } = props;
  const value = getValue2(element);
  return o5("div", {
    class: "bio-properties-panel-entry bio-properties-panel-toggle-switch-entry",
    "data-entry-id": id,
    children: [o5(ToggleSwitch, {
      id,
      label,
      value,
      onInput: setValue,
      onFocus,
      onBlur,
      switcherLabel
    }), o5(Description, {
      forId: id,
      element,
      value: description
    })]
  });
}
function isEdited(node2) {
  return node2 && !!node2.checked;
}
function prefixId(id) {
  return `bio-properties-panel-${id}`;
}
var DEFAULT_DEBOUNCE_TIME = 300;
function debounceInput(debounceDelay) {
  return function _debounceInput(fn2) {
    if (debounceDelay !== false) {
      var debounceTime = (0, import_min_dash145.isNumber)(debounceDelay) ? debounceDelay : DEFAULT_DEBOUNCE_TIME;
      return (0, import_min_dash145.debounce)(fn2, debounceTime);
    } else {
      return fn2;
    }
  };
}
debounceInput.$inject = ["config.debounceInput"];
var index = {
  debounceInput: ["factory", debounceInput]
};

// node_modules/bpmn-js-properties-panel/dist/index.esm.js
var import_zeebe = __toESM(require_zeebe());
var import_array_move = __toESM(require_array_move());
var import_extract_process_variables = __toESM(require_dist2());
var import_semver_compare = __toESM(require_semver_compare());

// node_modules/@bpmn-io/element-templates-validator/dist/index.esm.js
var import_min_dash146 = __toESM(require_dist());
var version$1 = "0.10.1";
var standaloneValidator = { exports: {} };
var equal = { exports: {} };
var fastDeepEqual = function equal2(a6, b5) {
  if (a6 === b5)
    return true;
  if (a6 && b5 && typeof a6 == "object" && typeof b5 == "object") {
    if (a6.constructor !== b5.constructor)
      return false;
    var length2, i6, keys4;
    if (Array.isArray(a6)) {
      length2 = a6.length;
      if (length2 != b5.length)
        return false;
      for (i6 = length2; i6-- !== 0; )
        if (!equal2(a6[i6], b5[i6]))
          return false;
      return true;
    }
    if (a6.constructor === RegExp)
      return a6.source === b5.source && a6.flags === b5.flags;
    if (a6.valueOf !== Object.prototype.valueOf)
      return a6.valueOf() === b5.valueOf();
    if (a6.toString !== Object.prototype.toString)
      return a6.toString() === b5.toString();
    keys4 = Object.keys(a6);
    length2 = keys4.length;
    if (length2 !== Object.keys(b5).length)
      return false;
    for (i6 = length2; i6-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b5, keys4[i6]))
        return false;
    for (i6 = length2; i6-- !== 0; ) {
      var key = keys4[i6];
      if (!equal2(a6[key], b5[key]))
        return false;
    }
    return true;
  }
  return a6 !== a6 && b5 !== b5;
};
(function(module2) {
  module2.exports = fastDeepEqual;
})(equal);
standaloneValidator.exports = validate14$1;
standaloneValidator.exports.default = validate14$1;
var schema17$1 = { "type": "object", "allOf": [{ "required": ["name", "id", "appliesTo", "properties"], "properties": { "name": { "$id": "#/name", "type": "string", "description": "The name of the element template." }, "id": { "$id": "#/id", "type": "string", "description": "The identifier of the element template." }, "description": { "$id": "#/description", "type": "string", "description": "The description of the element template." }, "version": { "$id": "#/version", "type": "integer", "description": "Optional version of the template. If you add a version to a template it will be considered unique based on its ID and version. Two templates can have the same ID if their version is different." }, "isDefault": { "$id": "#/isDefault", "type": "boolean", "description": "Indicates whether the element template is a default template." }, "appliesTo": { "$id": "#/appliesTo", "type": "array", "description": "List of BPMN types the template can be applied to.", "default": [], "items": { "$id": "#/appliesTo/items", "type": "string", "pattern": "^[\\w\\d]+:[\\w\\d]+$", "allOf": [{ "examples": ["bpmn:Task", "bpmn:ServiceTask", "bpmn:SequenceFlow", "bpmn:Process", "bpmn:StartEvent", "bpmn:Gateway"] }], "errorMessage": { "pattern": 'invalid item for "appliesTo", should contain namespaced property, example: "bpmn:Task"' } } }, "elementType": { "$id": "#/elementType", "type": "object", "description": "The BPMN type the element will be transformed into.", "default": {}, "required": ["value"], "properties": { "value": { "$id": "#/elementType/value", "type": "string", "pattern": "^[\\w\\d]+:[\\w\\d]+$", "allOf": [{ "examples": ["bpmn:ServiceTask", "bpmn:UserTask", "bpmn:StartEvent", "bpmn:ExclusiveGateway", "bpmn:ParallelGateway"] }], "errorMessage": { "pattern": 'invalid item for "elementType", should contain namespaced property, example: "bpmn:Task"' } } }, "errorMessage": { "required": { "value": "missing elementType value" } } }, "metadata": { "$id": "#/metadata", "type": "object", "description": "Some custom properties for further configuration.", "default": {} }, "entriesVisible": { "$id": "#/entriesVisible", "type": "boolean", "description": "Select whether non-template entries are visible in the properties panel." }, "groups": { "$id": "#/groups", "type": "array", "description": "Custom fields can be ordered together via groups.", "allOf": [{ "examples": [[{ "id": "group-1", "label": "My Group" }]] }], "items": { "$id": "#/groups/group", "type": "object", "default": {}, "required": ["id", "label"], "properties": { "id": { "$id": "#/groups/group/id", "type": "string", "description": "The id of the custom group" }, "label": { "$id": "#/groups/group/label", "type": "string", "description": "The label of the custom group" } }, "errorMessage": { "required": { "id": 'missing id for group "${0#}"', "label": 'missing label for group "${0#}"' } } } }, "documentationRef": { "$id": "#/documentationRef", "type": "string", "pattern": "^(https|http)://.*", "errorMessage": { "pattern": 'Malformed documentation URL, must match "^(https|http)://.*"' } } }, "errorMessage": { "required": { "name": "missing template name", "id": "missing template id", "appliesTo": "missing appliesTo=[]", "properties": "missing properties=[]" } } }], "properties": { "properties": { "$ref": "#/definitions/properties", "$id": "#/properties" }, "scopes": { "$id": "#/scopes", "type": "array", "description": "Special scoped bindings that allow you to configure nested elements.", "allOf": [{ "examples": [[{ "type": "bpmn:Error", "id": "Error_1", "properties": [{ "value": "error-code", "binding": { "type": "property", "name": "errorCode" } }, { "value": "error-message", "binding": { "type": "property", "name": "camunda:errorMessage" } }, { "value": "error-name", "binding": { "type": "property", "name": "name" } }] }]] }], "items": { "$id": "#/scopes/item", "type": "object", "default": {}, "properties": { "type": { "$id": "#scopes/item/type", "type": "string", "description": "The type of a scope.", "enum": ["camunda:Connector", "bpmn:Error"], "errorMessage": "invalid scope type ${0}; must be any of { camunda:Connector, bpmn:Error }" }, "properties": { "$id": "#/scopes/properties", "description": "List of properties of a scope.", "default": [], "allOf": [{ "$ref": "#/definitions/properties/allOf/0" }, { "$ref": "#/definitions/properties/allOf/1" }] } }, "required": ["type", "properties"], "allOf": [{ "if": { "properties": { "type": { "enum": ["bpmn:Error"] } }, "required": ["type"] }, "then": { "required": ["id"], "errorMessage": "invalid scope ${0/type}, missing id" } }], "errorMessage": { "required": { "type": "invalid scope, missing type", "properties": "invalid scope ${0/type}, missing properties=[]" } } } } } };
var schema18$1 = { "allOf": [{ "type": "array", "description": "List of properties of the element template.", "allOf": [{ "examples": [[{ "label": "Name", "type": "String", "binding": { "type": "property", "name": "name" } }]] }], "items": { "type": "object", "default": {}, "allOf": [{ "if": { "properties": { "type": { "const": "Dropdown" } }, "required": ["type"] }, "then": { "required": ["choices"], "errorMessage": 'must provide choices=[] with "Dropdown" type' } }], "properties": { "id": { "type": "string", "description": "Unique identifier of the property." }, "value": { "$id": "#/properties/property/value", "type": ["string", "boolean"], "description": "The value of a control field." }, "description": { "$id": "#/properties/property/description", "type": "string", "description": "The description of a control field." }, "label": { "$id": "#/properties/property/label", "type": "string", "description": "The label of a control field." }, "type": { "$id": "#/properties/property/type", "type": "string", "description": "The type of a control field." }, "editable": { "$id": "#/properties/property/editable", "type": "boolean", "description": "Indicates whether a control field is editable or not." }, "choices": { "$id": "#/properties/property/choices", "type": "array", "description": "The choices for dropdown fields.", "default": [], "items": { "$id": "#/properties/property/choices/item", "type": "object", "default": {}, "properties": { "name": { "$id": "#/properties/property/choices/item/name", "type": "string", "description": "The name of a choice." }, "value": { "$id": "#/properties/property/choices/item/value", "type": "string", "description": "The value of a choice." } }, "required": ["value", "name"], "errorMessage": { "required": '{ name, value } must be specified for "Dropdown" choices' } } }, "constraints": { "$id": "#/properties/property/constraints", "type": "object", "description": "The validation constraints of a control field.", "allOf": [{ "examples": [{ "notEmpty": true }] }], "properties": { "notEmpty": { "$id": "#/properties/property/constraints/notEmpty", "type": "boolean", "description": "The control field must not be empty." }, "minLength": { "$id": "#/properties/property/constraints/minLength", "type": "number", "description": "The minimal length of a control field value." }, "maxLength": { "$id": "#/properties/property/constraints/maxLength", "type": "number", "description": "The maximal length for a control field value." }, "pattern": { "$id": "#/properties/property/constraints/pattern", "description": "A regular expression pattern for a constraint.", "oneOf": [{ "type": "object", "default": {}, "properties": { "value": { "$id": "#/properties/property/constraints/pattern/value", "type": "string", "description": "The regular expression of a pattern." }, "message": { "$id": "#/properties/property/constraints/pattern/message", "type": "string", "description": "The validation message of a pattern." } } }, { "type": "string" }] } } }, "group": { "$id": "#/properties/property/group", "type": "string", "description": "The custom group of a control field." }, "condition": { "$id": "#/condition", "type": "object", "description": "Condition to activate the binding.", "allOf": [{ "examples": [{ "type": "simple", "property": "httpMethod", "equals": "GET" }, { "type": "simple", "property": "httpMethod", "oneOf": ["POST", "PUT", "DELETE"] }] }], "required": ["property"], "properties": { "type": { "$id": "#/condition/type", "const": "simple", "description": "The type of the condition.", "default": "simple" }, "property": { "$id": "#/condition/property", "type": "string", "description": "The id of the property to check." } }, "oneOf": [{ "properties": { "equals": { "type": ["string", "number", "boolean"] } }, "required": ["equals"] }, { "properties": { "oneOf": { "type": "array", "items": { "type": ["string", "number"] } } }, "required": ["oneOf"] }], "errorMessage": { "required": { "property": "missing property name for condition" } } } } } }, { "$schema": "http://json-schema.org/draft-07/schema", "type": "array", "description": "List of properties of the element template.", "items": { "type": "object", "default": {}, "required": ["binding"], "allOf": [{ "if": { "properties": { "binding": { "properties": { "type": { "const": "property" } }, "required": ["type"] } }, "required": ["binding"] }, "then": { "properties": { "type": { "enum": ["String", "Text", "Hidden", "Dropdown", "Boolean"], "errorMessage": 'invalid property type ${0} for binding type "property"; must be any of { String, Text, Hidden, Dropdown, Boolean }' } } } }, { "if": { "properties": { "binding": { "properties": { "type": { "const": "camunda:executionListener" } }, "required": ["type"] } }, "required": ["binding"] }, "then": { "properties": { "type": { "enum": ["Hidden"], "errorMessage": 'invalid property type ${1/type} for binding type "camunda:executionListener"; must be "Hidden"' } } } }, { "if": { "properties": { "binding": { "properties": { "type": { "enum": ["camunda:property", "camunda:outputParameter", "camunda:in", "camunda:in:businessKey", "camunda:out", "camunda:errorEventDefinition"] } }, "required": ["type"] } }, "required": ["binding"] }, "then": { "properties": { "type": { "enum": ["String", "Hidden", "Dropdown"], "errorMessage": "invalid property type ${0} for binding type ${1/binding/type}; must be any of { String, Hidden, Dropdown }" } } } }, { "if": { "properties": { "binding": { "properties": { "type": { "enum": ["camunda:inputParameter", "camunda:field"] } }, "required": ["type"] } }, "required": ["binding"] }, "then": { "properties": { "type": { "enum": ["String", "Text", "Hidden", "Dropdown"], "errorMessage": "invalid property type ${0} for binding type ${1/binding/type}; must be any of { String, Text, Hidden, Dropdown }" } } } }], "properties": { "binding": { "$id": "#/properties/property/binding", "type": "object", "description": "Specifying how the property is mapped to BPMN or Camunda extension elements and attributes.", "required": ["type"], "allOf": [{ "if": { "properties": { "type": { "enum": ["property", "camunda:property", "camunda:inputParameter", "camunda:field"] } }, "required": ["type"] }, "then": { "required": ["name"], "errorMessage": "property.binding ${0/type} requires name" } }, { "if": { "properties": { "type": { "const": "camunda:outputParameter" } }, "required": ["type"] }, "then": { "required": ["source"], "errorMessage": "property.binding ${0/type} requires source" } }, { "if": { "properties": { "type": { "const": "camunda:in" } }, "required": ["type"] }, "then": { "anyOf": [{ "required": ["variables"] }, { "required": ["target"] }], "errorMessage": "property.binding ${0/type} requires variables, target, or both" } }, { "if": { "properties": { "type": { "const": "camunda:out" } }, "required": ["type"] }, "then": { "oneOf": [{ "required": ["variables"], "not": { "anyOf": [{ "required": ["source"] }, { "required": ["sourceExpression"] }] } }, { "required": ["source"], "not": { "anyOf": [{ "required": ["variables"] }, { "required": ["sourceExpression"] }] } }, { "required": ["sourceExpression"], "not": { "anyOf": [{ "required": ["variables"] }, { "required": ["source"] }] } }, { "required": ["variables", "sourceExpression"], "not": { "required": ["source"] } }, { "required": ["variables", "source"], "not": { "required": ["sourceExpression"] } }], "errorMessage": "property.binding ${0/type} requires one of the following: variables, sourceExpression, source, (sourceExpression and variables), or (source and variables)" } }, { "if": { "properties": { "type": { "const": "camunda:errorEventDefinition" } }, "required": ["type"] }, "then": { "oneOf": [{ "required": ["errorRef"] }], "errorMessage": "property.binding ${0/type} requires errorRef" } }, { "examples": [{ "type": "property", "name": "name" }, { "type": "camunda:property", "name": "property" }, { "type": "camunda:inputParameter", "name": "input" }, { "type": "camunda:outputParameter", "source": "output" }, { "type": "camunda:in", "target": "target" }, { "type": "camunda:in:businessKey" }, { "type": "camunda:out", "source": "output" }, { "type": "camunda:executionListener", "event": "start" }, { "type": "camunda:field", "name": "field" }, { "type": "camunda:errorEventDefinition", "errorRef": "error" }, { "type": "camunda:errorEventDefinition", "errorRef": "error" }] }], "properties": { "type": { "$id": "#/properties/property/binding/type", "type": "string", "enum": ["property", "camunda:property", "camunda:inputParameter", "camunda:outputParameter", "camunda:in", "camunda:out", "camunda:in:businessKey", "camunda:executionListener", "camunda:field", "camunda:errorEventDefinition"], "description": "The type of a property binding.", "errorMessage": "invalid property.binding type ${0}; must be any of { property, camunda:property, camunda:inputParameter, camunda:outputParameter, camunda:in, camunda:out, camunda:in:businessKey, camunda:executionListener, camunda:field, camunda:errorEventDefinition }" }, "name": { "$id": "#/properties/property/binding/name", "type": "string", "description": "The name of a property binding." }, "event": { "$id": "#/properties/property/binding/event", "type": "string", "description": "The event type of a property binding (camunda:executionListener)." }, "scriptFormat": { "$id": "#/properties/property/binding/scriptFormat", "type": "string", "description": "The script format of a property binding (camunda:outputParameter, camunda:inputParameter)." }, "source": { "$id": "#/properties/property/binding/source", "type": "string", "description": "The source value of a property binding (camunda:outputParameter, camunda:out)." }, "target": { "$id": "#/properties/property/binding/target", "type": "string", "description": "The target value of a property binding (camunda:in)." }, "expression": { "$id": "#/properties/property/binding/expression", "type": "boolean", "description": "Indicates whether the control field value is an expression (camunda:in, camunda:field)." }, "variables": { "$id": "#/properties/property/binding/variables", "type": "string", "enum": ["all", "local"], "description": "The variable mapping of a property binding (camunda:in)." }, "sourceExpression": { "$id": "#/properties/property/binding/sourceExpression", "type": "string", "description": "The string containing the expression for the source attribute (camunda:out)." } } } }, "errorMessage": { "required": 'missing binding for property "${0#}"' } } }] };
var schema19 = { "type": "array", "description": "List of properties of the element template.", "allOf": [{ "examples": [[{ "label": "Name", "type": "String", "binding": { "type": "property", "name": "name" } }]] }], "items": { "type": "object", "default": {}, "allOf": [{ "if": { "properties": { "type": { "const": "Dropdown" } }, "required": ["type"] }, "then": { "required": ["choices"], "errorMessage": 'must provide choices=[] with "Dropdown" type' } }], "properties": { "id": { "type": "string", "description": "Unique identifier of the property." }, "value": { "$id": "#/properties/property/value", "type": ["string", "boolean"], "description": "The value of a control field." }, "description": { "$id": "#/properties/property/description", "type": "string", "description": "The description of a control field." }, "label": { "$id": "#/properties/property/label", "type": "string", "description": "The label of a control field." }, "type": { "$id": "#/properties/property/type", "type": "string", "description": "The type of a control field." }, "editable": { "$id": "#/properties/property/editable", "type": "boolean", "description": "Indicates whether a control field is editable or not." }, "choices": { "$id": "#/properties/property/choices", "type": "array", "description": "The choices for dropdown fields.", "default": [], "items": { "$id": "#/properties/property/choices/item", "type": "object", "default": {}, "properties": { "name": { "$id": "#/properties/property/choices/item/name", "type": "string", "description": "The name of a choice." }, "value": { "$id": "#/properties/property/choices/item/value", "type": "string", "description": "The value of a choice." } }, "required": ["value", "name"], "errorMessage": { "required": '{ name, value } must be specified for "Dropdown" choices' } } }, "constraints": { "$id": "#/properties/property/constraints", "type": "object", "description": "The validation constraints of a control field.", "allOf": [{ "examples": [{ "notEmpty": true }] }], "properties": { "notEmpty": { "$id": "#/properties/property/constraints/notEmpty", "type": "boolean", "description": "The control field must not be empty." }, "minLength": { "$id": "#/properties/property/constraints/minLength", "type": "number", "description": "The minimal length of a control field value." }, "maxLength": { "$id": "#/properties/property/constraints/maxLength", "type": "number", "description": "The maximal length for a control field value." }, "pattern": { "$id": "#/properties/property/constraints/pattern", "description": "A regular expression pattern for a constraint.", "oneOf": [{ "type": "object", "default": {}, "properties": { "value": { "$id": "#/properties/property/constraints/pattern/value", "type": "string", "description": "The regular expression of a pattern." }, "message": { "$id": "#/properties/property/constraints/pattern/message", "type": "string", "description": "The validation message of a pattern." } } }, { "type": "string" }] } } }, "group": { "$id": "#/properties/property/group", "type": "string", "description": "The custom group of a control field." }, "condition": { "$id": "#/condition", "type": "object", "description": "Condition to activate the binding.", "allOf": [{ "examples": [{ "type": "simple", "property": "httpMethod", "equals": "GET" }, { "type": "simple", "property": "httpMethod", "oneOf": ["POST", "PUT", "DELETE"] }] }], "required": ["property"], "properties": { "type": { "$id": "#/condition/type", "const": "simple", "description": "The type of the condition.", "default": "simple" }, "property": { "$id": "#/condition/property", "type": "string", "description": "The id of the property to check." } }, "oneOf": [{ "properties": { "equals": { "type": ["string", "number", "boolean"] } }, "required": ["equals"] }, { "properties": { "oneOf": { "type": "array", "items": { "type": ["string", "number"] } } }, "required": ["oneOf"] }], "errorMessage": { "required": { "property": "missing property name for condition" } } } } } };
var schema20 = { "$schema": "http://json-schema.org/draft-07/schema", "type": "array", "description": "List of properties of the element template.", "items": { "type": "object", "default": {}, "required": ["binding"], "allOf": [{ "if": { "properties": { "binding": { "properties": { "type": { "const": "property" } }, "required": ["type"] } }, "required": ["binding"] }, "then": { "properties": { "type": { "enum": ["String", "Text", "Hidden", "Dropdown", "Boolean"], "errorMessage": 'invalid property type ${0} for binding type "property"; must be any of { String, Text, Hidden, Dropdown, Boolean }' } } } }, { "if": { "properties": { "binding": { "properties": { "type": { "const": "camunda:executionListener" } }, "required": ["type"] } }, "required": ["binding"] }, "then": { "properties": { "type": { "enum": ["Hidden"], "errorMessage": 'invalid property type ${1/type} for binding type "camunda:executionListener"; must be "Hidden"' } } } }, { "if": { "properties": { "binding": { "properties": { "type": { "enum": ["camunda:property", "camunda:outputParameter", "camunda:in", "camunda:in:businessKey", "camunda:out", "camunda:errorEventDefinition"] } }, "required": ["type"] } }, "required": ["binding"] }, "then": { "properties": { "type": { "enum": ["String", "Hidden", "Dropdown"], "errorMessage": "invalid property type ${0} for binding type ${1/binding/type}; must be any of { String, Hidden, Dropdown }" } } } }, { "if": { "properties": { "binding": { "properties": { "type": { "enum": ["camunda:inputParameter", "camunda:field"] } }, "required": ["type"] } }, "required": ["binding"] }, "then": { "properties": { "type": { "enum": ["String", "Text", "Hidden", "Dropdown"], "errorMessage": "invalid property type ${0} for binding type ${1/binding/type}; must be any of { String, Text, Hidden, Dropdown }" } } } }], "properties": { "binding": { "$id": "#/properties/property/binding", "type": "object", "description": "Specifying how the property is mapped to BPMN or Camunda extension elements and attributes.", "required": ["type"], "allOf": [{ "if": { "properties": { "type": { "enum": ["property", "camunda:property", "camunda:inputParameter", "camunda:field"] } }, "required": ["type"] }, "then": { "required": ["name"], "errorMessage": "property.binding ${0/type} requires name" } }, { "if": { "properties": { "type": { "const": "camunda:outputParameter" } }, "required": ["type"] }, "then": { "required": ["source"], "errorMessage": "property.binding ${0/type} requires source" } }, { "if": { "properties": { "type": { "const": "camunda:in" } }, "required": ["type"] }, "then": { "anyOf": [{ "required": ["variables"] }, { "required": ["target"] }], "errorMessage": "property.binding ${0/type} requires variables, target, or both" } }, { "if": { "properties": { "type": { "const": "camunda:out" } }, "required": ["type"] }, "then": { "oneOf": [{ "required": ["variables"], "not": { "anyOf": [{ "required": ["source"] }, { "required": ["sourceExpression"] }] } }, { "required": ["source"], "not": { "anyOf": [{ "required": ["variables"] }, { "required": ["sourceExpression"] }] } }, { "required": ["sourceExpression"], "not": { "anyOf": [{ "required": ["variables"] }, { "required": ["source"] }] } }, { "required": ["variables", "sourceExpression"], "not": { "required": ["source"] } }, { "required": ["variables", "source"], "not": { "required": ["sourceExpression"] } }], "errorMessage": "property.binding ${0/type} requires one of the following: variables, sourceExpression, source, (sourceExpression and variables), or (source and variables)" } }, { "if": { "properties": { "type": { "const": "camunda:errorEventDefinition" } }, "required": ["type"] }, "then": { "oneOf": [{ "required": ["errorRef"] }], "errorMessage": "property.binding ${0/type} requires errorRef" } }, { "examples": [{ "type": "property", "name": "name" }, { "type": "camunda:property", "name": "property" }, { "type": "camunda:inputParameter", "name": "input" }, { "type": "camunda:outputParameter", "source": "output" }, { "type": "camunda:in", "target": "target" }, { "type": "camunda:in:businessKey" }, { "type": "camunda:out", "source": "output" }, { "type": "camunda:executionListener", "event": "start" }, { "type": "camunda:field", "name": "field" }, { "type": "camunda:errorEventDefinition", "errorRef": "error" }, { "type": "camunda:errorEventDefinition", "errorRef": "error" }] }], "properties": { "type": { "$id": "#/properties/property/binding/type", "type": "string", "enum": ["property", "camunda:property", "camunda:inputParameter", "camunda:outputParameter", "camunda:in", "camunda:out", "camunda:in:businessKey", "camunda:executionListener", "camunda:field", "camunda:errorEventDefinition"], "description": "The type of a property binding.", "errorMessage": "invalid property.binding type ${0}; must be any of { property, camunda:property, camunda:inputParameter, camunda:outputParameter, camunda:in, camunda:out, camunda:in:businessKey, camunda:executionListener, camunda:field, camunda:errorEventDefinition }" }, "name": { "$id": "#/properties/property/binding/name", "type": "string", "description": "The name of a property binding." }, "event": { "$id": "#/properties/property/binding/event", "type": "string", "description": "The event type of a property binding (camunda:executionListener)." }, "scriptFormat": { "$id": "#/properties/property/binding/scriptFormat", "type": "string", "description": "The script format of a property binding (camunda:outputParameter, camunda:inputParameter)." }, "source": { "$id": "#/properties/property/binding/source", "type": "string", "description": "The source value of a property binding (camunda:outputParameter, camunda:out)." }, "target": { "$id": "#/properties/property/binding/target", "type": "string", "description": "The target value of a property binding (camunda:in)." }, "expression": { "$id": "#/properties/property/binding/expression", "type": "boolean", "description": "Indicates whether the control field value is an expression (camunda:in, camunda:field)." }, "variables": { "$id": "#/properties/property/binding/variables", "type": "string", "enum": ["all", "local"], "description": "The variable mapping of a property binding (camunda:in)." }, "sourceExpression": { "$id": "#/properties/property/binding/sourceExpression", "type": "string", "description": "The string containing the expression for the source attribute (camunda:out)." } } } }, "errorMessage": { "required": 'missing binding for property "${0#}"' } } };
var pattern0$1 = new RegExp("^[\\w\\d]+:[\\w\\d]+$", "u");
var pattern2$1 = new RegExp("^(https|http)://.*", "u");
var obj0$1 = { "required": "missingProperty", "dependencies": "property", "dependentRequired": "property" };
var func0$1 = equal.exports;
function validate15$1(data, { dataPath = "", parentData, parentDataProperty, rootData = data } = {}) {
  let vErrors = null;
  let errors = 0;
  if (data && typeof data == "object" && !Array.isArray(data)) {
    if (data.name === void 0) {
      const err0 = { keyword: "required", dataPath, schemaPath: "#/allOf/0/required", params: { missingProperty: "name" }, message: "should have required property 'name'" };
      if (vErrors === null) {
        vErrors = [err0];
      } else {
        vErrors.push(err0);
      }
      errors++;
    }
    if (data.id === void 0) {
      const err1 = { keyword: "required", dataPath, schemaPath: "#/allOf/0/required", params: { missingProperty: "id" }, message: "should have required property 'id'" };
      if (vErrors === null) {
        vErrors = [err1];
      } else {
        vErrors.push(err1);
      }
      errors++;
    }
    if (data.appliesTo === void 0) {
      const err2 = { keyword: "required", dataPath, schemaPath: "#/allOf/0/required", params: { missingProperty: "appliesTo" }, message: "should have required property 'appliesTo'" };
      if (vErrors === null) {
        vErrors = [err2];
      } else {
        vErrors.push(err2);
      }
      errors++;
    }
    if (data.properties === void 0) {
      const err3 = { keyword: "required", dataPath, schemaPath: "#/allOf/0/required", params: { missingProperty: "properties" }, message: "should have required property 'properties'" };
      if (vErrors === null) {
        vErrors = [err3];
      } else {
        vErrors.push(err3);
      }
      errors++;
    }
    if (data.name !== void 0) {
      if (typeof data.name !== "string") {
        const err4 = { keyword: "type", dataPath: dataPath + "/name", schemaPath: "#/allOf/0/properties/name/type", params: { type: "string" }, message: "should be string" };
        if (vErrors === null) {
          vErrors = [err4];
        } else {
          vErrors.push(err4);
        }
        errors++;
      }
    }
    if (data.id !== void 0) {
      if (typeof data.id !== "string") {
        const err5 = { keyword: "type", dataPath: dataPath + "/id", schemaPath: "#/allOf/0/properties/id/type", params: { type: "string" }, message: "should be string" };
        if (vErrors === null) {
          vErrors = [err5];
        } else {
          vErrors.push(err5);
        }
        errors++;
      }
    }
    if (data.description !== void 0) {
      if (typeof data.description !== "string") {
        const err6 = { keyword: "type", dataPath: dataPath + "/description", schemaPath: "#/allOf/0/properties/description/type", params: { type: "string" }, message: "should be string" };
        if (vErrors === null) {
          vErrors = [err6];
        } else {
          vErrors.push(err6);
        }
        errors++;
      }
    }
    if (data.version !== void 0) {
      let data3 = data.version;
      if (!(typeof data3 == "number" && (!(data3 % 1) && !isNaN(data3)))) {
        const err7 = { keyword: "type", dataPath: dataPath + "/version", schemaPath: "#/allOf/0/properties/version/type", params: { type: "integer" }, message: "should be integer" };
        if (vErrors === null) {
          vErrors = [err7];
        } else {
          vErrors.push(err7);
        }
        errors++;
      }
    }
    if (data.isDefault !== void 0) {
      if (typeof data.isDefault !== "boolean") {
        const err8 = { keyword: "type", dataPath: dataPath + "/isDefault", schemaPath: "#/allOf/0/properties/isDefault/type", params: { type: "boolean" }, message: "should be boolean" };
        if (vErrors === null) {
          vErrors = [err8];
        } else {
          vErrors.push(err8);
        }
        errors++;
      }
    }
    if (data.appliesTo !== void 0) {
      let data5 = data.appliesTo;
      if (Array.isArray(data5)) {
        const len0 = data5.length;
        for (let i0 = 0; i0 < len0; i0++) {
          let data6 = data5[i0];
          if (typeof data6 === "string") {
            if (!pattern0$1.test(data6)) {
              const err9 = { keyword: "pattern", dataPath: dataPath + "/appliesTo/" + i0, schemaPath: "#/allOf/0/properties/appliesTo/items/pattern", params: { pattern: "^[\\w\\d]+:[\\w\\d]+$" }, message: 'should match pattern "^[\\w\\d]+:[\\w\\d]+$"' };
              if (vErrors === null) {
                vErrors = [err9];
              } else {
                vErrors.push(err9);
              }
              errors++;
            }
          } else {
            const err10 = { keyword: "type", dataPath: dataPath + "/appliesTo/" + i0, schemaPath: "#/allOf/0/properties/appliesTo/items/type", params: { type: "string" }, message: "should be string" };
            if (vErrors === null) {
              vErrors = [err10];
            } else {
              vErrors.push(err10);
            }
            errors++;
          }
          if (errors > 0) {
            const emErrors0 = { "pattern": [] };
            const templates0 = {};
            for (const err11 of vErrors) {
              if (err11.keyword !== "errorMessage" && !err11.emUsed && err11.dataPath === dataPath + "/appliesTo/" + i0 && err11.keyword in emErrors0 && err11.schemaPath.indexOf("#/allOf/0/properties/appliesTo/items") === 0 && /^\/[^\/]*$/.test(err11.schemaPath.slice(36))) {
                emErrors0[err11.keyword].push(err11);
                err11.emUsed = true;
              }
            }
            for (const key0 in emErrors0) {
              if (emErrors0[key0].length) {
                const err12 = { keyword: "errorMessage", dataPath: dataPath + "/appliesTo/" + i0, schemaPath: "#/allOf/0/properties/appliesTo/items/errorMessage", params: { errors: emErrors0[key0] }, message: key0 in templates0 ? templates0[key0]() : schema17$1.allOf[0].properties.appliesTo.items.errorMessage[key0] };
                if (vErrors === null) {
                  vErrors = [err12];
                } else {
                  vErrors.push(err12);
                }
                errors++;
              }
            }
            const emErrs0 = [];
            for (const err13 of vErrors) {
              if (!err13.emUsed) {
                emErrs0.push(err13);
              }
            }
            vErrors = emErrs0;
            errors = emErrs0.length;
          }
        }
      } else {
        const err14 = { keyword: "type", dataPath: dataPath + "/appliesTo", schemaPath: "#/allOf/0/properties/appliesTo/type", params: { type: "array" }, message: "should be array" };
        if (vErrors === null) {
          vErrors = [err14];
        } else {
          vErrors.push(err14);
        }
        errors++;
      }
    }
    if (data.elementType !== void 0) {
      let data7 = data.elementType;
      if (data7 && typeof data7 == "object" && !Array.isArray(data7)) {
        if (data7.value === void 0) {
          const err15 = { keyword: "required", dataPath: dataPath + "/elementType", schemaPath: "#/allOf/0/properties/elementType/required", params: { missingProperty: "value" }, message: "should have required property 'value'" };
          if (vErrors === null) {
            vErrors = [err15];
          } else {
            vErrors.push(err15);
          }
          errors++;
        }
        if (data7.value !== void 0) {
          let data8 = data7.value;
          if (typeof data8 === "string") {
            if (!pattern0$1.test(data8)) {
              const err16 = { keyword: "pattern", dataPath: dataPath + "/elementType/value", schemaPath: "#/allOf/0/properties/elementType/properties/value/pattern", params: { pattern: "^[\\w\\d]+:[\\w\\d]+$" }, message: 'should match pattern "^[\\w\\d]+:[\\w\\d]+$"' };
              if (vErrors === null) {
                vErrors = [err16];
              } else {
                vErrors.push(err16);
              }
              errors++;
            }
          } else {
            const err17 = { keyword: "type", dataPath: dataPath + "/elementType/value", schemaPath: "#/allOf/0/properties/elementType/properties/value/type", params: { type: "string" }, message: "should be string" };
            if (vErrors === null) {
              vErrors = [err17];
            } else {
              vErrors.push(err17);
            }
            errors++;
          }
          if (errors > 0) {
            const emErrors1 = { "pattern": [] };
            const templates1 = {};
            for (const err18 of vErrors) {
              if (err18.keyword !== "errorMessage" && !err18.emUsed && err18.dataPath === dataPath + "/elementType/value" && err18.keyword in emErrors1 && err18.schemaPath.indexOf("#/allOf/0/properties/elementType/properties/value") === 0 && /^\/[^\/]*$/.test(err18.schemaPath.slice(49))) {
                emErrors1[err18.keyword].push(err18);
                err18.emUsed = true;
              }
            }
            for (const key1 in emErrors1) {
              if (emErrors1[key1].length) {
                const err19 = { keyword: "errorMessage", dataPath: dataPath + "/elementType/value", schemaPath: "#/allOf/0/properties/elementType/properties/value/errorMessage", params: { errors: emErrors1[key1] }, message: key1 in templates1 ? templates1[key1]() : schema17$1.allOf[0].properties.elementType.properties.value.errorMessage[key1] };
                if (vErrors === null) {
                  vErrors = [err19];
                } else {
                  vErrors.push(err19);
                }
                errors++;
              }
            }
            const emErrs1 = [];
            for (const err20 of vErrors) {
              if (!err20.emUsed) {
                emErrs1.push(err20);
              }
            }
            vErrors = emErrs1;
            errors = emErrs1.length;
          }
        }
      } else {
        const err21 = { keyword: "type", dataPath: dataPath + "/elementType", schemaPath: "#/allOf/0/properties/elementType/type", params: { type: "object" }, message: "should be object" };
        if (vErrors === null) {
          vErrors = [err21];
        } else {
          vErrors.push(err21);
        }
        errors++;
      }
      if (errors > 0) {
        const emErrors2 = { "required": { "value": [] } };
        const templates2 = { required: {} };
        let emPropParams0;
        let emParamsErrors0;
        for (const err22 of vErrors) {
          if (err22.keyword !== "errorMessage" && !err22.emUsed && err22.dataPath === dataPath + "/elementType" && err22.keyword in emErrors2 && err22.schemaPath.indexOf("#/allOf/0/properties/elementType") === 0 && /^\/[^\/]*$/.test(err22.schemaPath.slice(32))) {
            emPropParams0 = obj0$1[err22.keyword];
            emParamsErrors0 = emErrors2[err22.keyword][err22.params[emPropParams0]];
            if (emParamsErrors0) {
              emParamsErrors0.push(err22);
              err22.emUsed = true;
            }
          }
        }
        for (const key2 in emErrors2) {
          for (const keyProp0 in emErrors2[key2]) {
            emParamsErrors0 = emErrors2[key2][keyProp0];
            if (emParamsErrors0.length) {
              const tmpl0 = templates2[key2] && templates2[key2][keyProp0];
              const err23 = { keyword: "errorMessage", dataPath: dataPath + "/elementType", schemaPath: "#/allOf/0/properties/elementType/errorMessage", params: { errors: emParamsErrors0 }, message: tmpl0 ? tmpl0() : schema17$1.allOf[0].properties.elementType.errorMessage[key2][keyProp0] };
              if (vErrors === null) {
                vErrors = [err23];
              } else {
                vErrors.push(err23);
              }
              errors++;
            }
          }
        }
        const emErrs2 = [];
        for (const err24 of vErrors) {
          if (!err24.emUsed) {
            emErrs2.push(err24);
          }
        }
        vErrors = emErrs2;
        errors = emErrs2.length;
      }
    }
    if (data.metadata !== void 0) {
      let data9 = data.metadata;
      if (!(data9 && typeof data9 == "object" && !Array.isArray(data9))) {
        const err25 = { keyword: "type", dataPath: dataPath + "/metadata", schemaPath: "#/allOf/0/properties/metadata/type", params: { type: "object" }, message: "should be object" };
        if (vErrors === null) {
          vErrors = [err25];
        } else {
          vErrors.push(err25);
        }
        errors++;
      }
    }
    if (data.entriesVisible !== void 0) {
      if (typeof data.entriesVisible !== "boolean") {
        const err26 = { keyword: "type", dataPath: dataPath + "/entriesVisible", schemaPath: "#/allOf/0/properties/entriesVisible/type", params: { type: "boolean" }, message: "should be boolean" };
        if (vErrors === null) {
          vErrors = [err26];
        } else {
          vErrors.push(err26);
        }
        errors++;
      }
    }
    if (data.groups !== void 0) {
      let data11 = data.groups;
      if (Array.isArray(data11)) {
        const len1 = data11.length;
        for (let i1 = 0; i1 < len1; i1++) {
          let data12 = data11[i1];
          if (data12 && typeof data12 == "object" && !Array.isArray(data12)) {
            if (data12.id === void 0) {
              const err27 = { keyword: "required", dataPath: dataPath + "/groups/" + i1, schemaPath: "#/allOf/0/properties/groups/items/required", params: { missingProperty: "id" }, message: "should have required property 'id'" };
              if (vErrors === null) {
                vErrors = [err27];
              } else {
                vErrors.push(err27);
              }
              errors++;
            }
            if (data12.label === void 0) {
              const err28 = { keyword: "required", dataPath: dataPath + "/groups/" + i1, schemaPath: "#/allOf/0/properties/groups/items/required", params: { missingProperty: "label" }, message: "should have required property 'label'" };
              if (vErrors === null) {
                vErrors = [err28];
              } else {
                vErrors.push(err28);
              }
              errors++;
            }
            if (data12.id !== void 0) {
              if (typeof data12.id !== "string") {
                const err29 = { keyword: "type", dataPath: dataPath + "/groups/" + i1 + "/id", schemaPath: "#/allOf/0/properties/groups/items/properties/id/type", params: { type: "string" }, message: "should be string" };
                if (vErrors === null) {
                  vErrors = [err29];
                } else {
                  vErrors.push(err29);
                }
                errors++;
              }
            }
            if (data12.label !== void 0) {
              if (typeof data12.label !== "string") {
                const err30 = { keyword: "type", dataPath: dataPath + "/groups/" + i1 + "/label", schemaPath: "#/allOf/0/properties/groups/items/properties/label/type", params: { type: "string" }, message: "should be string" };
                if (vErrors === null) {
                  vErrors = [err30];
                } else {
                  vErrors.push(err30);
                }
                errors++;
              }
            }
          } else {
            const err31 = { keyword: "type", dataPath: dataPath + "/groups/" + i1, schemaPath: "#/allOf/0/properties/groups/items/type", params: { type: "object" }, message: "should be object" };
            if (vErrors === null) {
              vErrors = [err31];
            } else {
              vErrors.push(err31);
            }
            errors++;
          }
          if (errors > 0) {
            const emErrors3 = { "required": { "id": [], "label": [] } };
            const templates3 = { required: { id: function() {
              return 'missing id for group "' + JSON.stringify(i1) + '"';
            }, label: function() {
              return 'missing label for group "' + JSON.stringify(i1) + '"';
            } } };
            let emPropParams1;
            let emParamsErrors1;
            for (const err32 of vErrors) {
              if (err32.keyword !== "errorMessage" && !err32.emUsed && err32.dataPath === dataPath + "/groups/" + i1 && err32.keyword in emErrors3 && err32.schemaPath.indexOf("#/allOf/0/properties/groups/items") === 0 && /^\/[^\/]*$/.test(err32.schemaPath.slice(33))) {
                emPropParams1 = obj0$1[err32.keyword];
                emParamsErrors1 = emErrors3[err32.keyword][err32.params[emPropParams1]];
                if (emParamsErrors1) {
                  emParamsErrors1.push(err32);
                  err32.emUsed = true;
                }
              }
            }
            for (const key3 in emErrors3) {
              for (const keyProp1 in emErrors3[key3]) {
                emParamsErrors1 = emErrors3[key3][keyProp1];
                if (emParamsErrors1.length) {
                  const tmpl1 = templates3[key3] && templates3[key3][keyProp1];
                  const err33 = { keyword: "errorMessage", dataPath: dataPath + "/groups/" + i1, schemaPath: "#/allOf/0/properties/groups/items/errorMessage", params: { errors: emParamsErrors1 }, message: tmpl1 ? tmpl1() : schema17$1.allOf[0].properties.groups.items.errorMessage[key3][keyProp1] };
                  if (vErrors === null) {
                    vErrors = [err33];
                  } else {
                    vErrors.push(err33);
                  }
                  errors++;
                }
              }
            }
            const emErrs3 = [];
            for (const err34 of vErrors) {
              if (!err34.emUsed) {
                emErrs3.push(err34);
              }
            }
            vErrors = emErrs3;
            errors = emErrs3.length;
          }
        }
      } else {
        const err35 = { keyword: "type", dataPath: dataPath + "/groups", schemaPath: "#/allOf/0/properties/groups/type", params: { type: "array" }, message: "should be array" };
        if (vErrors === null) {
          vErrors = [err35];
        } else {
          vErrors.push(err35);
        }
        errors++;
      }
    }
    if (data.documentationRef !== void 0) {
      let data15 = data.documentationRef;
      if (typeof data15 === "string") {
        if (!pattern2$1.test(data15)) {
          const err36 = { keyword: "pattern", dataPath: dataPath + "/documentationRef", schemaPath: "#/allOf/0/properties/documentationRef/pattern", params: { pattern: "^(https|http)://.*" }, message: 'should match pattern "^(https|http)://.*"' };
          if (vErrors === null) {
            vErrors = [err36];
          } else {
            vErrors.push(err36);
          }
          errors++;
        }
      } else {
        const err37 = { keyword: "type", dataPath: dataPath + "/documentationRef", schemaPath: "#/allOf/0/properties/documentationRef/type", params: { type: "string" }, message: "should be string" };
        if (vErrors === null) {
          vErrors = [err37];
        } else {
          vErrors.push(err37);
        }
        errors++;
      }
      if (errors > 0) {
        const emErrors4 = { "pattern": [] };
        const templates4 = {};
        for (const err38 of vErrors) {
          if (err38.keyword !== "errorMessage" && !err38.emUsed && err38.dataPath === dataPath + "/documentationRef" && err38.keyword in emErrors4 && err38.schemaPath.indexOf("#/allOf/0/properties/documentationRef") === 0 && /^\/[^\/]*$/.test(err38.schemaPath.slice(37))) {
            emErrors4[err38.keyword].push(err38);
            err38.emUsed = true;
          }
        }
        for (const key4 in emErrors4) {
          if (emErrors4[key4].length) {
            const err39 = { keyword: "errorMessage", dataPath: dataPath + "/documentationRef", schemaPath: "#/allOf/0/properties/documentationRef/errorMessage", params: { errors: emErrors4[key4] }, message: key4 in templates4 ? templates4[key4]() : schema17$1.allOf[0].properties.documentationRef.errorMessage[key4] };
            if (vErrors === null) {
              vErrors = [err39];
            } else {
              vErrors.push(err39);
            }
            errors++;
          }
        }
        const emErrs4 = [];
        for (const err40 of vErrors) {
          if (!err40.emUsed) {
            emErrs4.push(err40);
          }
        }
        vErrors = emErrs4;
        errors = emErrs4.length;
      }
    }
  }
  if (errors > 0) {
    const emErrors5 = { "required": { "name": [], "id": [], "appliesTo": [], "properties": [] } };
    const templates5 = { required: {} };
    let emPropParams2;
    let emParamsErrors2;
    for (const err41 of vErrors) {
      if (err41.keyword !== "errorMessage" && !err41.emUsed && err41.dataPath === dataPath && err41.keyword in emErrors5 && err41.schemaPath.indexOf("#/allOf/0") === 0 && /^\/[^\/]*$/.test(err41.schemaPath.slice(9))) {
        emPropParams2 = obj0$1[err41.keyword];
        emParamsErrors2 = emErrors5[err41.keyword][err41.params[emPropParams2]];
        if (emParamsErrors2) {
          emParamsErrors2.push(err41);
          err41.emUsed = true;
        }
      }
    }
    for (const key5 in emErrors5) {
      for (const keyProp2 in emErrors5[key5]) {
        emParamsErrors2 = emErrors5[key5][keyProp2];
        if (emParamsErrors2.length) {
          const tmpl2 = templates5[key5] && templates5[key5][keyProp2];
          const err42 = { keyword: "errorMessage", dataPath, schemaPath: "#/allOf/0/errorMessage", params: { errors: emParamsErrors2 }, message: tmpl2 ? tmpl2() : schema17$1.allOf[0].errorMessage[key5][keyProp2] };
          if (vErrors === null) {
            vErrors = [err42];
          } else {
            vErrors.push(err42);
          }
          errors++;
        }
      }
    }
    const emErrs5 = [];
    for (const err43 of vErrors) {
      if (!err43.emUsed) {
        emErrs5.push(err43);
      }
    }
    vErrors = emErrs5;
    errors = emErrs5.length;
  }
  if (data && typeof data == "object" && !Array.isArray(data)) {
    if (data.properties !== void 0) {
      let data16 = data.properties;
      if (Array.isArray(data16)) {
        const len2 = data16.length;
        for (let i22 = 0; i22 < len2; i22++) {
          let data17 = data16[i22];
          const _errs41 = errors;
          let valid18 = true;
          const _errs42 = errors;
          if (data17 && typeof data17 == "object" && !Array.isArray(data17)) {
            if (data17.type === void 0 && "type") {
              const err44 = {};
              if (vErrors === null) {
                vErrors = [err44];
              } else {
                vErrors.push(err44);
              }
              errors++;
            } else {
              if (data17.type !== void 0) {
                if (!func0$1(data17.type, "Dropdown")) {
                  const err45 = {};
                  if (vErrors === null) {
                    vErrors = [err45];
                  } else {
                    vErrors.push(err45);
                  }
                  errors++;
                }
              }
            }
          }
          var _valid0 = _errs42 === errors;
          errors = _errs41;
          if (vErrors !== null) {
            if (_errs41) {
              vErrors.length = _errs41;
            } else {
              vErrors = null;
            }
          }
          if (_valid0) {
            const _errs44 = errors;
            if (data17 && typeof data17 == "object" && !Array.isArray(data17)) {
              if (data17.choices === void 0) {
                const err46 = { keyword: "required", dataPath: dataPath + "/properties/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/allOf/0/then/required", params: { missingProperty: "choices" }, message: "should have required property 'choices'" };
                if (vErrors === null) {
                  vErrors = [err46];
                } else {
                  vErrors.push(err46);
                }
                errors++;
              }
            }
            if (errors > 0) {
              const emErrs6 = [];
              for (const err47 of vErrors) {
                if (err47.keyword !== "errorMessage" && !err47.emUsed && (err47.dataPath === dataPath + "/properties/" + i22 || err47.dataPath.indexOf(dataPath + "/properties/" + i22) === 0 && err47.dataPath[dataPath + "/properties/" + i22.length] === "/") && err47.schemaPath.indexOf("#/definitions/properties/allOf/0/items/allOf/0/then") === 0 && err47.schemaPath["#/definitions/properties/allOf/0/items/allOf/0/then".length] === "/") {
                  emErrs6.push(err47);
                  err47.emUsed = true;
                }
              }
              if (emErrs6.length) {
                const err48 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/allOf/0/then/errorMessage", params: { errors: emErrs6 }, message: 'must provide choices=[] with "Dropdown" type' };
                if (vErrors === null) {
                  vErrors = [err48];
                } else {
                  vErrors.push(err48);
                }
                errors++;
              }
              const emErrs7 = [];
              for (const err49 of vErrors) {
                if (!err49.emUsed) {
                  emErrs7.push(err49);
                }
              }
              vErrors = emErrs7;
              errors = emErrs7.length;
            }
            var _valid0 = _errs44 === errors;
            valid18 = _valid0;
          }
          if (!valid18) {
            const err50 = { keyword: "if", dataPath: dataPath + "/properties/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/allOf/0/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
            if (vErrors === null) {
              vErrors = [err50];
            } else {
              vErrors.push(err50);
            }
            errors++;
          }
          if (data17 && typeof data17 == "object" && !Array.isArray(data17)) {
            if (data17.id !== void 0) {
              if (typeof data17.id !== "string") {
                const err51 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/id", schemaPath: "#/definitions/properties/allOf/0/items/properties/id/type", params: { type: "string" }, message: "should be string" };
                if (vErrors === null) {
                  vErrors = [err51];
                } else {
                  vErrors.push(err51);
                }
                errors++;
              }
            }
            if (data17.value !== void 0) {
              let data20 = data17.value;
              if (typeof data20 !== "string" && typeof data20 !== "boolean") {
                const err52 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/value", schemaPath: "#/definitions/properties/allOf/0/items/properties/value/type", params: { type: schema18$1.allOf[0].items.properties.value.type }, message: "should be string,boolean" };
                if (vErrors === null) {
                  vErrors = [err52];
                } else {
                  vErrors.push(err52);
                }
                errors++;
              }
            }
            if (data17.description !== void 0) {
              if (typeof data17.description !== "string") {
                const err53 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/description", schemaPath: "#/definitions/properties/allOf/0/items/properties/description/type", params: { type: "string" }, message: "should be string" };
                if (vErrors === null) {
                  vErrors = [err53];
                } else {
                  vErrors.push(err53);
                }
                errors++;
              }
            }
            if (data17.label !== void 0) {
              if (typeof data17.label !== "string") {
                const err54 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/label", schemaPath: "#/definitions/properties/allOf/0/items/properties/label/type", params: { type: "string" }, message: "should be string" };
                if (vErrors === null) {
                  vErrors = [err54];
                } else {
                  vErrors.push(err54);
                }
                errors++;
              }
            }
            if (data17.type !== void 0) {
              if (typeof data17.type !== "string") {
                const err55 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/type", schemaPath: "#/definitions/properties/allOf/0/items/properties/type/type", params: { type: "string" }, message: "should be string" };
                if (vErrors === null) {
                  vErrors = [err55];
                } else {
                  vErrors.push(err55);
                }
                errors++;
              }
            }
            if (data17.editable !== void 0) {
              if (typeof data17.editable !== "boolean") {
                const err56 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/editable", schemaPath: "#/definitions/properties/allOf/0/items/properties/editable/type", params: { type: "boolean" }, message: "should be boolean" };
                if (vErrors === null) {
                  vErrors = [err56];
                } else {
                  vErrors.push(err56);
                }
                errors++;
              }
            }
            if (data17.choices !== void 0) {
              let data25 = data17.choices;
              if (Array.isArray(data25)) {
                const len3 = data25.length;
                for (let i32 = 0; i32 < len3; i32++) {
                  let data26 = data25[i32];
                  if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
                    if (data26.value === void 0) {
                      const err57 = { keyword: "required", dataPath: dataPath + "/properties/" + i22 + "/choices/" + i32, schemaPath: "#/definitions/properties/allOf/0/items/properties/choices/items/required", params: { missingProperty: "value" }, message: "should have required property 'value'" };
                      if (vErrors === null) {
                        vErrors = [err57];
                      } else {
                        vErrors.push(err57);
                      }
                      errors++;
                    }
                    if (data26.name === void 0) {
                      const err58 = { keyword: "required", dataPath: dataPath + "/properties/" + i22 + "/choices/" + i32, schemaPath: "#/definitions/properties/allOf/0/items/properties/choices/items/required", params: { missingProperty: "name" }, message: "should have required property 'name'" };
                      if (vErrors === null) {
                        vErrors = [err58];
                      } else {
                        vErrors.push(err58);
                      }
                      errors++;
                    }
                    if (data26.name !== void 0) {
                      if (typeof data26.name !== "string") {
                        const err59 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/choices/" + i32 + "/name", schemaPath: "#/definitions/properties/allOf/0/items/properties/choices/items/properties/name/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err59];
                        } else {
                          vErrors.push(err59);
                        }
                        errors++;
                      }
                    }
                    if (data26.value !== void 0) {
                      if (typeof data26.value !== "string") {
                        const err60 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/choices/" + i32 + "/value", schemaPath: "#/definitions/properties/allOf/0/items/properties/choices/items/properties/value/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err60];
                        } else {
                          vErrors.push(err60);
                        }
                        errors++;
                      }
                    }
                  } else {
                    const err61 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/choices/" + i32, schemaPath: "#/definitions/properties/allOf/0/items/properties/choices/items/type", params: { type: "object" }, message: "should be object" };
                    if (vErrors === null) {
                      vErrors = [err61];
                    } else {
                      vErrors.push(err61);
                    }
                    errors++;
                  }
                  if (errors > 0) {
                    const emErrors6 = { "required": [] };
                    const templates6 = {};
                    for (const err62 of vErrors) {
                      if (err62.keyword !== "errorMessage" && !err62.emUsed && err62.dataPath === dataPath + "/properties/" + i22 + "/choices/" + i32 && err62.keyword in emErrors6 && err62.schemaPath.indexOf("#/definitions/properties/allOf/0/items/properties/choices/items") === 0 && /^\/[^\/]*$/.test(err62.schemaPath.slice(63))) {
                        emErrors6[err62.keyword].push(err62);
                        err62.emUsed = true;
                      }
                    }
                    for (const key6 in emErrors6) {
                      if (emErrors6[key6].length) {
                        const err63 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i22 + "/choices/" + i32, schemaPath: "#/definitions/properties/allOf/0/items/properties/choices/items/errorMessage", params: { errors: emErrors6[key6] }, message: key6 in templates6 ? templates6[key6]() : schema18$1.allOf[0].items.properties.choices.items.errorMessage[key6] };
                        if (vErrors === null) {
                          vErrors = [err63];
                        } else {
                          vErrors.push(err63);
                        }
                        errors++;
                      }
                    }
                    const emErrs8 = [];
                    for (const err64 of vErrors) {
                      if (!err64.emUsed) {
                        emErrs8.push(err64);
                      }
                    }
                    vErrors = emErrs8;
                    errors = emErrs8.length;
                  }
                }
              } else {
                const err65 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/choices", schemaPath: "#/definitions/properties/allOf/0/items/properties/choices/type", params: { type: "array" }, message: "should be array" };
                if (vErrors === null) {
                  vErrors = [err65];
                } else {
                  vErrors.push(err65);
                }
                errors++;
              }
            }
            if (data17.constraints !== void 0) {
              let data29 = data17.constraints;
              if (data29 && typeof data29 == "object" && !Array.isArray(data29)) {
                if (data29.notEmpty !== void 0) {
                  if (typeof data29.notEmpty !== "boolean") {
                    const err66 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/constraints/notEmpty", schemaPath: "#/definitions/properties/allOf/0/items/properties/constraints/properties/notEmpty/type", params: { type: "boolean" }, message: "should be boolean" };
                    if (vErrors === null) {
                      vErrors = [err66];
                    } else {
                      vErrors.push(err66);
                    }
                    errors++;
                  }
                }
                if (data29.minLength !== void 0) {
                  if (!(typeof data29.minLength == "number")) {
                    const err67 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/constraints/minLength", schemaPath: "#/definitions/properties/allOf/0/items/properties/constraints/properties/minLength/type", params: { type: "number" }, message: "should be number" };
                    if (vErrors === null) {
                      vErrors = [err67];
                    } else {
                      vErrors.push(err67);
                    }
                    errors++;
                  }
                }
                if (data29.maxLength !== void 0) {
                  if (!(typeof data29.maxLength == "number")) {
                    const err68 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/constraints/maxLength", schemaPath: "#/definitions/properties/allOf/0/items/properties/constraints/properties/maxLength/type", params: { type: "number" }, message: "should be number" };
                    if (vErrors === null) {
                      vErrors = [err68];
                    } else {
                      vErrors.push(err68);
                    }
                    errors++;
                  }
                }
                if (data29.pattern !== void 0) {
                  let data33 = data29.pattern;
                  const _errs74 = errors;
                  let valid26 = false;
                  let passing0 = null;
                  const _errs75 = errors;
                  if (data33 && typeof data33 == "object" && !Array.isArray(data33)) {
                    if (data33.value !== void 0) {
                      if (typeof data33.value !== "string") {
                        const err69 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/constraints/pattern/value", schemaPath: "#/definitions/properties/allOf/0/items/properties/constraints/properties/pattern/oneOf/0/properties/value/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err69];
                        } else {
                          vErrors.push(err69);
                        }
                        errors++;
                      }
                    }
                    if (data33.message !== void 0) {
                      if (typeof data33.message !== "string") {
                        const err70 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/constraints/pattern/message", schemaPath: "#/definitions/properties/allOf/0/items/properties/constraints/properties/pattern/oneOf/0/properties/message/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err70];
                        } else {
                          vErrors.push(err70);
                        }
                        errors++;
                      }
                    }
                  } else {
                    const err71 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/constraints/pattern", schemaPath: "#/definitions/properties/allOf/0/items/properties/constraints/properties/pattern/oneOf/0/type", params: { type: "object" }, message: "should be object" };
                    if (vErrors === null) {
                      vErrors = [err71];
                    } else {
                      vErrors.push(err71);
                    }
                    errors++;
                  }
                  var _valid1 = _errs75 === errors;
                  if (_valid1) {
                    valid26 = true;
                    passing0 = 0;
                  }
                  const _errs81 = errors;
                  if (typeof data33 !== "string") {
                    const err72 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/constraints/pattern", schemaPath: "#/definitions/properties/allOf/0/items/properties/constraints/properties/pattern/oneOf/1/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err72];
                    } else {
                      vErrors.push(err72);
                    }
                    errors++;
                  }
                  var _valid1 = _errs81 === errors;
                  if (_valid1 && valid26) {
                    valid26 = false;
                    passing0 = [passing0, 1];
                  } else {
                    if (_valid1) {
                      valid26 = true;
                      passing0 = 1;
                    }
                  }
                  if (!valid26) {
                    const err73 = { keyword: "oneOf", dataPath: dataPath + "/properties/" + i22 + "/constraints/pattern", schemaPath: "#/definitions/properties/allOf/0/items/properties/constraints/properties/pattern/oneOf", params: { passingSchemas: passing0 }, message: "should match exactly one schema in oneOf" };
                    if (vErrors === null) {
                      vErrors = [err73];
                    } else {
                      vErrors.push(err73);
                    }
                    errors++;
                  } else {
                    errors = _errs74;
                    if (vErrors !== null) {
                      if (_errs74) {
                        vErrors.length = _errs74;
                      } else {
                        vErrors = null;
                      }
                    }
                  }
                }
              } else {
                const err74 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/constraints", schemaPath: "#/definitions/properties/allOf/0/items/properties/constraints/type", params: { type: "object" }, message: "should be object" };
                if (vErrors === null) {
                  vErrors = [err74];
                } else {
                  vErrors.push(err74);
                }
                errors++;
              }
            }
            if (data17.group !== void 0) {
              if (typeof data17.group !== "string") {
                const err75 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/group", schemaPath: "#/definitions/properties/allOf/0/items/properties/group/type", params: { type: "string" }, message: "should be string" };
                if (vErrors === null) {
                  vErrors = [err75];
                } else {
                  vErrors.push(err75);
                }
                errors++;
              }
            }
            if (data17.condition !== void 0) {
              let data37 = data17.condition;
              const _errs87 = errors;
              let valid28 = false;
              let passing1 = null;
              const _errs88 = errors;
              if (data37 && typeof data37 == "object" && !Array.isArray(data37)) {
                if (data37.equals === void 0) {
                  const err76 = { keyword: "required", dataPath: dataPath + "/properties/" + i22 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/oneOf/0/required", params: { missingProperty: "equals" }, message: "should have required property 'equals'" };
                  if (vErrors === null) {
                    vErrors = [err76];
                  } else {
                    vErrors.push(err76);
                  }
                  errors++;
                }
                if (data37.equals !== void 0) {
                  let data38 = data37.equals;
                  if (typeof data38 !== "string" && !(typeof data38 == "number") && typeof data38 !== "boolean") {
                    const err77 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/condition/equals", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/oneOf/0/properties/equals/type", params: { type: schema18$1.allOf[0].items.properties.condition.oneOf[0].properties.equals.type }, message: "should be string,number,boolean" };
                    if (vErrors === null) {
                      vErrors = [err77];
                    } else {
                      vErrors.push(err77);
                    }
                    errors++;
                  }
                }
              }
              var _valid2 = _errs88 === errors;
              if (_valid2) {
                valid28 = true;
                passing1 = 0;
              }
              const _errs91 = errors;
              if (data37 && typeof data37 == "object" && !Array.isArray(data37)) {
                if (data37.oneOf === void 0) {
                  const err78 = { keyword: "required", dataPath: dataPath + "/properties/" + i22 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/oneOf/1/required", params: { missingProperty: "oneOf" }, message: "should have required property 'oneOf'" };
                  if (vErrors === null) {
                    vErrors = [err78];
                  } else {
                    vErrors.push(err78);
                  }
                  errors++;
                }
                if (data37.oneOf !== void 0) {
                  let data39 = data37.oneOf;
                  if (Array.isArray(data39)) {
                    const len4 = data39.length;
                    for (let i42 = 0; i42 < len4; i42++) {
                      let data40 = data39[i42];
                      if (typeof data40 !== "string" && !(typeof data40 == "number")) {
                        const err79 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/condition/oneOf/" + i42, schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/oneOf/1/properties/oneOf/items/type", params: { type: schema18$1.allOf[0].items.properties.condition.oneOf[1].properties.oneOf.items.type }, message: "should be string,number" };
                        if (vErrors === null) {
                          vErrors = [err79];
                        } else {
                          vErrors.push(err79);
                        }
                        errors++;
                      }
                    }
                  } else {
                    const err80 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/condition/oneOf", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/oneOf/1/properties/oneOf/type", params: { type: "array" }, message: "should be array" };
                    if (vErrors === null) {
                      vErrors = [err80];
                    } else {
                      vErrors.push(err80);
                    }
                    errors++;
                  }
                }
              }
              var _valid2 = _errs91 === errors;
              if (_valid2 && valid28) {
                valid28 = false;
                passing1 = [passing1, 1];
              } else {
                if (_valid2) {
                  valid28 = true;
                  passing1 = 1;
                }
              }
              if (!valid28) {
                const err81 = { keyword: "oneOf", dataPath: dataPath + "/properties/" + i22 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/oneOf", params: { passingSchemas: passing1 }, message: "should match exactly one schema in oneOf" };
                if (vErrors === null) {
                  vErrors = [err81];
                } else {
                  vErrors.push(err81);
                }
                errors++;
              } else {
                errors = _errs87;
                if (vErrors !== null) {
                  if (_errs87) {
                    vErrors.length = _errs87;
                  } else {
                    vErrors = null;
                  }
                }
              }
              if (data37 && typeof data37 == "object" && !Array.isArray(data37)) {
                if (data37.property === void 0) {
                  const err82 = { keyword: "required", dataPath: dataPath + "/properties/" + i22 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/required", params: { missingProperty: "property" }, message: "should have required property 'property'" };
                  if (vErrors === null) {
                    vErrors = [err82];
                  } else {
                    vErrors.push(err82);
                  }
                  errors++;
                }
                if (data37.type !== void 0) {
                  if (!func0$1(data37.type, "simple")) {
                    const err83 = { keyword: "const", dataPath: dataPath + "/properties/" + i22 + "/condition/type", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/properties/type/const", params: { allowedValue: "simple" }, message: "should be equal to constant" };
                    if (vErrors === null) {
                      vErrors = [err83];
                    } else {
                      vErrors.push(err83);
                    }
                    errors++;
                  }
                }
                if (data37.property !== void 0) {
                  if (typeof data37.property !== "string") {
                    const err84 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/condition/property", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/properties/property/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err84];
                    } else {
                      vErrors.push(err84);
                    }
                    errors++;
                  }
                }
              } else {
                const err85 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/type", params: { type: "object" }, message: "should be object" };
                if (vErrors === null) {
                  vErrors = [err85];
                } else {
                  vErrors.push(err85);
                }
                errors++;
              }
              if (errors > 0) {
                const emErrors7 = { "required": { "property": [] } };
                const templates7 = { required: {} };
                let emPropParams3;
                let emParamsErrors3;
                for (const err86 of vErrors) {
                  if (err86.keyword !== "errorMessage" && !err86.emUsed && err86.dataPath === dataPath + "/properties/" + i22 + "/condition" && err86.keyword in emErrors7 && err86.schemaPath.indexOf("#/definitions/properties/allOf/0/items/properties/condition") === 0 && /^\/[^\/]*$/.test(err86.schemaPath.slice(59))) {
                    emPropParams3 = obj0$1[err86.keyword];
                    emParamsErrors3 = emErrors7[err86.keyword][err86.params[emPropParams3]];
                    if (emParamsErrors3) {
                      emParamsErrors3.push(err86);
                      err86.emUsed = true;
                    }
                  }
                }
                for (const key7 in emErrors7) {
                  for (const keyProp3 in emErrors7[key7]) {
                    emParamsErrors3 = emErrors7[key7][keyProp3];
                    if (emParamsErrors3.length) {
                      const tmpl3 = templates7[key7] && templates7[key7][keyProp3];
                      const err87 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i22 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/errorMessage", params: { errors: emParamsErrors3 }, message: tmpl3 ? tmpl3() : schema18$1.allOf[0].items.properties.condition.errorMessage[key7][keyProp3] };
                      if (vErrors === null) {
                        vErrors = [err87];
                      } else {
                        vErrors.push(err87);
                      }
                      errors++;
                    }
                  }
                }
                const emErrs9 = [];
                for (const err88 of vErrors) {
                  if (!err88.emUsed) {
                    emErrs9.push(err88);
                  }
                }
                vErrors = emErrs9;
                errors = emErrs9.length;
              }
            }
          } else {
            const err89 = { keyword: "type", dataPath: dataPath + "/properties/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/type", params: { type: "object" }, message: "should be object" };
            if (vErrors === null) {
              vErrors = [err89];
            } else {
              vErrors.push(err89);
            }
            errors++;
          }
        }
      } else {
        const err90 = { keyword: "type", dataPath: dataPath + "/properties", schemaPath: "#/definitions/properties/allOf/0/type", params: { type: "array" }, message: "should be array" };
        if (vErrors === null) {
          vErrors = [err90];
        } else {
          vErrors.push(err90);
        }
        errors++;
      }
      if (Array.isArray(data16)) {
        const len5 = data16.length;
        for (let i52 = 0; i52 < len5; i52++) {
          let data43 = data16[i52];
          const _errs104 = errors;
          let valid38 = true;
          const _errs105 = errors;
          if (data43 && typeof data43 == "object" && !Array.isArray(data43)) {
            if (data43.binding === void 0 && "binding") {
              const err91 = {};
              if (vErrors === null) {
                vErrors = [err91];
              } else {
                vErrors.push(err91);
              }
              errors++;
            } else {
              if (data43.binding !== void 0) {
                let data44 = data43.binding;
                if (data44 && typeof data44 == "object" && !Array.isArray(data44)) {
                  if (data44.type === void 0 && "type") {
                    const err92 = {};
                    if (vErrors === null) {
                      vErrors = [err92];
                    } else {
                      vErrors.push(err92);
                    }
                    errors++;
                  } else {
                    if (data44.type !== void 0) {
                      if (!func0$1(data44.type, "property")) {
                        const err93 = {};
                        if (vErrors === null) {
                          vErrors = [err93];
                        } else {
                          vErrors.push(err93);
                        }
                        errors++;
                      }
                    }
                  }
                }
              }
            }
          }
          var _valid3 = _errs105 === errors;
          errors = _errs104;
          if (vErrors !== null) {
            if (_errs104) {
              vErrors.length = _errs104;
            } else {
              vErrors = null;
            }
          }
          if (_valid3) {
            const _errs108 = errors;
            if (data43 && typeof data43 == "object" && !Array.isArray(data43)) {
              if (data43.type !== void 0) {
                let data46 = data43.type;
                if (!(data46 === "String" || data46 === "Text" || data46 === "Hidden" || data46 === "Dropdown" || data46 === "Boolean")) {
                  const err94 = { keyword: "enum", dataPath: dataPath + "/properties/" + i52 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/0/then/properties/type/enum", params: { allowedValues: schema18$1.allOf[1].items.allOf[0].then.properties.type.enum }, message: "should be equal to one of the allowed values" };
                  if (vErrors === null) {
                    vErrors = [err94];
                  } else {
                    vErrors.push(err94);
                  }
                  errors++;
                }
                if (errors > 0) {
                  const emErrs10 = [];
                  for (const err95 of vErrors) {
                    if (err95.keyword !== "errorMessage" && !err95.emUsed && (err95.dataPath === dataPath + "/properties/" + i52 + "/type" || err95.dataPath.indexOf(dataPath + "/properties/" + i52 + "/type") === 0 && err95.dataPath[dataPath + "/properties/" + i52 + "/type".length] === "/") && err95.schemaPath.indexOf("#/definitions/properties/allOf/1/items/allOf/0/then/properties/type") === 0 && err95.schemaPath["#/definitions/properties/allOf/1/items/allOf/0/then/properties/type".length] === "/") {
                      emErrs10.push(err95);
                      err95.emUsed = true;
                    }
                  }
                  if (emErrs10.length) {
                    const err96 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i52 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/0/then/properties/type/errorMessage", params: { errors: emErrs10 }, message: "invalid property type " + JSON.stringify(data46) + ' for binding type "property"; must be any of { String, Text, Hidden, Dropdown, Boolean }' };
                    if (vErrors === null) {
                      vErrors = [err96];
                    } else {
                      vErrors.push(err96);
                    }
                    errors++;
                  }
                  const emErrs11 = [];
                  for (const err97 of vErrors) {
                    if (!err97.emUsed) {
                      emErrs11.push(err97);
                    }
                  }
                  vErrors = emErrs11;
                  errors = emErrs11.length;
                }
              }
            }
            var _valid3 = _errs108 === errors;
            valid38 = _valid3;
          }
          if (!valid38) {
            const err98 = { keyword: "if", dataPath: dataPath + "/properties/" + i52, schemaPath: "#/definitions/properties/allOf/1/items/allOf/0/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
            if (vErrors === null) {
              vErrors = [err98];
            } else {
              vErrors.push(err98);
            }
            errors++;
          }
          const _errs111 = errors;
          let valid42 = true;
          const _errs112 = errors;
          if (data43 && typeof data43 == "object" && !Array.isArray(data43)) {
            if (data43.binding === void 0 && "binding") {
              const err99 = {};
              if (vErrors === null) {
                vErrors = [err99];
              } else {
                vErrors.push(err99);
              }
              errors++;
            } else {
              if (data43.binding !== void 0) {
                let data47 = data43.binding;
                if (data47 && typeof data47 == "object" && !Array.isArray(data47)) {
                  if (data47.type === void 0 && "type") {
                    const err100 = {};
                    if (vErrors === null) {
                      vErrors = [err100];
                    } else {
                      vErrors.push(err100);
                    }
                    errors++;
                  } else {
                    if (data47.type !== void 0) {
                      if (!func0$1(data47.type, "camunda:executionListener")) {
                        const err101 = {};
                        if (vErrors === null) {
                          vErrors = [err101];
                        } else {
                          vErrors.push(err101);
                        }
                        errors++;
                      }
                    }
                  }
                }
              }
            }
          }
          var _valid4 = _errs112 === errors;
          errors = _errs111;
          if (vErrors !== null) {
            if (_errs111) {
              vErrors.length = _errs111;
            } else {
              vErrors = null;
            }
          }
          if (_valid4) {
            const _errs115 = errors;
            if (data43 && typeof data43 == "object" && !Array.isArray(data43)) {
              if (data43.type !== void 0) {
                if (!(data43.type === "Hidden")) {
                  const err102 = { keyword: "enum", dataPath: dataPath + "/properties/" + i52 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/1/then/properties/type/enum", params: { allowedValues: schema18$1.allOf[1].items.allOf[1].then.properties.type.enum }, message: "should be equal to one of the allowed values" };
                  if (vErrors === null) {
                    vErrors = [err102];
                  } else {
                    vErrors.push(err102);
                  }
                  errors++;
                }
                if (errors > 0) {
                  const emErrs12 = [];
                  for (const err103 of vErrors) {
                    if (err103.keyword !== "errorMessage" && !err103.emUsed && (err103.dataPath === dataPath + "/properties/" + i52 + "/type" || err103.dataPath.indexOf(dataPath + "/properties/" + i52 + "/type") === 0 && err103.dataPath[dataPath + "/properties/" + i52 + "/type".length] === "/") && err103.schemaPath.indexOf("#/definitions/properties/allOf/1/items/allOf/1/then/properties/type") === 0 && err103.schemaPath["#/definitions/properties/allOf/1/items/allOf/1/then/properties/type".length] === "/") {
                      emErrs12.push(err103);
                      err103.emUsed = true;
                    }
                  }
                  if (emErrs12.length) {
                    const err104 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i52 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/1/then/properties/type/errorMessage", params: { errors: emErrs12 }, message: "invalid property type " + JSON.stringify(data43 && data43.type) + ' for binding type "camunda:executionListener"; must be "Hidden"' };
                    if (vErrors === null) {
                      vErrors = [err104];
                    } else {
                      vErrors.push(err104);
                    }
                    errors++;
                  }
                  const emErrs13 = [];
                  for (const err105 of vErrors) {
                    if (!err105.emUsed) {
                      emErrs13.push(err105);
                    }
                  }
                  vErrors = emErrs13;
                  errors = emErrs13.length;
                }
              }
            }
            var _valid4 = _errs115 === errors;
            valid42 = _valid4;
          }
          if (!valid42) {
            const err106 = { keyword: "if", dataPath: dataPath + "/properties/" + i52, schemaPath: "#/definitions/properties/allOf/1/items/allOf/1/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
            if (vErrors === null) {
              vErrors = [err106];
            } else {
              vErrors.push(err106);
            }
            errors++;
          }
          const _errs118 = errors;
          let valid46 = true;
          const _errs119 = errors;
          if (data43 && typeof data43 == "object" && !Array.isArray(data43)) {
            if (data43.binding === void 0 && "binding") {
              const err107 = {};
              if (vErrors === null) {
                vErrors = [err107];
              } else {
                vErrors.push(err107);
              }
              errors++;
            } else {
              if (data43.binding !== void 0) {
                let data50 = data43.binding;
                if (data50 && typeof data50 == "object" && !Array.isArray(data50)) {
                  if (data50.type === void 0 && "type") {
                    const err108 = {};
                    if (vErrors === null) {
                      vErrors = [err108];
                    } else {
                      vErrors.push(err108);
                    }
                    errors++;
                  } else {
                    if (data50.type !== void 0) {
                      let data51 = data50.type;
                      if (!(data51 === "camunda:property" || data51 === "camunda:outputParameter" || data51 === "camunda:in" || data51 === "camunda:in:businessKey" || data51 === "camunda:out" || data51 === "camunda:errorEventDefinition")) {
                        const err109 = {};
                        if (vErrors === null) {
                          vErrors = [err109];
                        } else {
                          vErrors.push(err109);
                        }
                        errors++;
                      }
                    }
                  }
                }
              }
            }
          }
          var _valid5 = _errs119 === errors;
          errors = _errs118;
          if (vErrors !== null) {
            if (_errs118) {
              vErrors.length = _errs118;
            } else {
              vErrors = null;
            }
          }
          if (_valid5) {
            const _errs122 = errors;
            if (data43 && typeof data43 == "object" && !Array.isArray(data43)) {
              if (data43.type !== void 0) {
                let data52 = data43.type;
                if (!(data52 === "String" || data52 === "Hidden" || data52 === "Dropdown")) {
                  const err110 = { keyword: "enum", dataPath: dataPath + "/properties/" + i52 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/2/then/properties/type/enum", params: { allowedValues: schema18$1.allOf[1].items.allOf[2].then.properties.type.enum }, message: "should be equal to one of the allowed values" };
                  if (vErrors === null) {
                    vErrors = [err110];
                  } else {
                    vErrors.push(err110);
                  }
                  errors++;
                }
                if (errors > 0) {
                  const emErrs14 = [];
                  for (const err111 of vErrors) {
                    if (err111.keyword !== "errorMessage" && !err111.emUsed && (err111.dataPath === dataPath + "/properties/" + i52 + "/type" || err111.dataPath.indexOf(dataPath + "/properties/" + i52 + "/type") === 0 && err111.dataPath[dataPath + "/properties/" + i52 + "/type".length] === "/") && err111.schemaPath.indexOf("#/definitions/properties/allOf/1/items/allOf/2/then/properties/type") === 0 && err111.schemaPath["#/definitions/properties/allOf/1/items/allOf/2/then/properties/type".length] === "/") {
                      emErrs14.push(err111);
                      err111.emUsed = true;
                    }
                  }
                  if (emErrs14.length) {
                    const err112 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i52 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/2/then/properties/type/errorMessage", params: { errors: emErrs14 }, message: "invalid property type " + JSON.stringify(data52) + " for binding type " + JSON.stringify(data43 && data43.binding && data43.binding.type) + "; must be any of { String, Hidden, Dropdown }" };
                    if (vErrors === null) {
                      vErrors = [err112];
                    } else {
                      vErrors.push(err112);
                    }
                    errors++;
                  }
                  const emErrs15 = [];
                  for (const err113 of vErrors) {
                    if (!err113.emUsed) {
                      emErrs15.push(err113);
                    }
                  }
                  vErrors = emErrs15;
                  errors = emErrs15.length;
                }
              }
            }
            var _valid5 = _errs122 === errors;
            valid46 = _valid5;
          }
          if (!valid46) {
            const err114 = { keyword: "if", dataPath: dataPath + "/properties/" + i52, schemaPath: "#/definitions/properties/allOf/1/items/allOf/2/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
            if (vErrors === null) {
              vErrors = [err114];
            } else {
              vErrors.push(err114);
            }
            errors++;
          }
          const _errs125 = errors;
          let valid50 = true;
          const _errs126 = errors;
          if (data43 && typeof data43 == "object" && !Array.isArray(data43)) {
            if (data43.binding === void 0 && "binding") {
              const err115 = {};
              if (vErrors === null) {
                vErrors = [err115];
              } else {
                vErrors.push(err115);
              }
              errors++;
            } else {
              if (data43.binding !== void 0) {
                let data53 = data43.binding;
                if (data53 && typeof data53 == "object" && !Array.isArray(data53)) {
                  if (data53.type === void 0 && "type") {
                    const err116 = {};
                    if (vErrors === null) {
                      vErrors = [err116];
                    } else {
                      vErrors.push(err116);
                    }
                    errors++;
                  } else {
                    if (data53.type !== void 0) {
                      let data54 = data53.type;
                      if (!(data54 === "camunda:inputParameter" || data54 === "camunda:field")) {
                        const err117 = {};
                        if (vErrors === null) {
                          vErrors = [err117];
                        } else {
                          vErrors.push(err117);
                        }
                        errors++;
                      }
                    }
                  }
                }
              }
            }
          }
          var _valid6 = _errs126 === errors;
          errors = _errs125;
          if (vErrors !== null) {
            if (_errs125) {
              vErrors.length = _errs125;
            } else {
              vErrors = null;
            }
          }
          if (_valid6) {
            const _errs129 = errors;
            if (data43 && typeof data43 == "object" && !Array.isArray(data43)) {
              if (data43.type !== void 0) {
                let data55 = data43.type;
                if (!(data55 === "String" || data55 === "Text" || data55 === "Hidden" || data55 === "Dropdown")) {
                  const err118 = { keyword: "enum", dataPath: dataPath + "/properties/" + i52 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/3/then/properties/type/enum", params: { allowedValues: schema18$1.allOf[1].items.allOf[3].then.properties.type.enum }, message: "should be equal to one of the allowed values" };
                  if (vErrors === null) {
                    vErrors = [err118];
                  } else {
                    vErrors.push(err118);
                  }
                  errors++;
                }
                if (errors > 0) {
                  const emErrs16 = [];
                  for (const err119 of vErrors) {
                    if (err119.keyword !== "errorMessage" && !err119.emUsed && (err119.dataPath === dataPath + "/properties/" + i52 + "/type" || err119.dataPath.indexOf(dataPath + "/properties/" + i52 + "/type") === 0 && err119.dataPath[dataPath + "/properties/" + i52 + "/type".length] === "/") && err119.schemaPath.indexOf("#/definitions/properties/allOf/1/items/allOf/3/then/properties/type") === 0 && err119.schemaPath["#/definitions/properties/allOf/1/items/allOf/3/then/properties/type".length] === "/") {
                      emErrs16.push(err119);
                      err119.emUsed = true;
                    }
                  }
                  if (emErrs16.length) {
                    const err120 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i52 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/3/then/properties/type/errorMessage", params: { errors: emErrs16 }, message: "invalid property type " + JSON.stringify(data55) + " for binding type " + JSON.stringify(data43 && data43.binding && data43.binding.type) + "; must be any of { String, Text, Hidden, Dropdown }" };
                    if (vErrors === null) {
                      vErrors = [err120];
                    } else {
                      vErrors.push(err120);
                    }
                    errors++;
                  }
                  const emErrs17 = [];
                  for (const err121 of vErrors) {
                    if (!err121.emUsed) {
                      emErrs17.push(err121);
                    }
                  }
                  vErrors = emErrs17;
                  errors = emErrs17.length;
                }
              }
            }
            var _valid6 = _errs129 === errors;
            valid50 = _valid6;
          }
          if (!valid50) {
            const err122 = { keyword: "if", dataPath: dataPath + "/properties/" + i52, schemaPath: "#/definitions/properties/allOf/1/items/allOf/3/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
            if (vErrors === null) {
              vErrors = [err122];
            } else {
              vErrors.push(err122);
            }
            errors++;
          }
          if (data43 && typeof data43 == "object" && !Array.isArray(data43)) {
            if (data43.binding === void 0) {
              const err123 = { keyword: "required", dataPath: dataPath + "/properties/" + i52, schemaPath: "#/definitions/properties/allOf/1/items/required", params: { missingProperty: "binding" }, message: "should have required property 'binding'" };
              if (vErrors === null) {
                vErrors = [err123];
              } else {
                vErrors.push(err123);
              }
              errors++;
            }
            if (data43.binding !== void 0) {
              let data56 = data43.binding;
              const _errs134 = errors;
              let valid56 = true;
              const _errs135 = errors;
              if (data56 && typeof data56 == "object" && !Array.isArray(data56)) {
                if (data56.type === void 0 && "type") {
                  const err124 = {};
                  if (vErrors === null) {
                    vErrors = [err124];
                  } else {
                    vErrors.push(err124);
                  }
                  errors++;
                } else {
                  if (data56.type !== void 0) {
                    let data57 = data56.type;
                    if (!(data57 === "property" || data57 === "camunda:property" || data57 === "camunda:inputParameter" || data57 === "camunda:field")) {
                      const err125 = {};
                      if (vErrors === null) {
                        vErrors = [err125];
                      } else {
                        vErrors.push(err125);
                      }
                      errors++;
                    }
                  }
                }
              }
              var _valid7 = _errs135 === errors;
              errors = _errs134;
              if (vErrors !== null) {
                if (_errs134) {
                  vErrors.length = _errs134;
                } else {
                  vErrors = null;
                }
              }
              if (_valid7) {
                const _errs137 = errors;
                if (data56 && typeof data56 == "object" && !Array.isArray(data56)) {
                  if (data56.name === void 0) {
                    const err126 = { keyword: "required", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/0/then/required", params: { missingProperty: "name" }, message: "should have required property 'name'" };
                    if (vErrors === null) {
                      vErrors = [err126];
                    } else {
                      vErrors.push(err126);
                    }
                    errors++;
                  }
                }
                if (errors > 0) {
                  const emErrs18 = [];
                  for (const err127 of vErrors) {
                    if (err127.keyword !== "errorMessage" && !err127.emUsed && (err127.dataPath === dataPath + "/properties/" + i52 + "/binding" || err127.dataPath.indexOf(dataPath + "/properties/" + i52 + "/binding") === 0 && err127.dataPath[dataPath + "/properties/" + i52 + "/binding".length] === "/") && err127.schemaPath.indexOf("#/definitions/properties/allOf/1/items/properties/binding/allOf/0/then") === 0 && err127.schemaPath["#/definitions/properties/allOf/1/items/properties/binding/allOf/0/then".length] === "/") {
                      emErrs18.push(err127);
                      err127.emUsed = true;
                    }
                  }
                  if (emErrs18.length) {
                    const err128 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/0/then/errorMessage", params: { errors: emErrs18 }, message: "property.binding " + JSON.stringify(data56 && data56.type) + " requires name" };
                    if (vErrors === null) {
                      vErrors = [err128];
                    } else {
                      vErrors.push(err128);
                    }
                    errors++;
                  }
                  const emErrs19 = [];
                  for (const err129 of vErrors) {
                    if (!err129.emUsed) {
                      emErrs19.push(err129);
                    }
                  }
                  vErrors = emErrs19;
                  errors = emErrs19.length;
                }
                var _valid7 = _errs137 === errors;
                valid56 = _valid7;
              }
              if (!valid56) {
                const err130 = { keyword: "if", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/0/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                if (vErrors === null) {
                  vErrors = [err130];
                } else {
                  vErrors.push(err130);
                }
                errors++;
              }
              const _errs139 = errors;
              let valid58 = true;
              const _errs140 = errors;
              if (data56 && typeof data56 == "object" && !Array.isArray(data56)) {
                if (data56.type === void 0 && "type") {
                  const err131 = {};
                  if (vErrors === null) {
                    vErrors = [err131];
                  } else {
                    vErrors.push(err131);
                  }
                  errors++;
                } else {
                  if (data56.type !== void 0) {
                    if (!func0$1(data56.type, "camunda:outputParameter")) {
                      const err132 = {};
                      if (vErrors === null) {
                        vErrors = [err132];
                      } else {
                        vErrors.push(err132);
                      }
                      errors++;
                    }
                  }
                }
              }
              var _valid8 = _errs140 === errors;
              errors = _errs139;
              if (vErrors !== null) {
                if (_errs139) {
                  vErrors.length = _errs139;
                } else {
                  vErrors = null;
                }
              }
              if (_valid8) {
                const _errs142 = errors;
                if (data56 && typeof data56 == "object" && !Array.isArray(data56)) {
                  if (data56.source === void 0) {
                    const err133 = { keyword: "required", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/1/then/required", params: { missingProperty: "source" }, message: "should have required property 'source'" };
                    if (vErrors === null) {
                      vErrors = [err133];
                    } else {
                      vErrors.push(err133);
                    }
                    errors++;
                  }
                }
                if (errors > 0) {
                  const emErrs20 = [];
                  for (const err134 of vErrors) {
                    if (err134.keyword !== "errorMessage" && !err134.emUsed && (err134.dataPath === dataPath + "/properties/" + i52 + "/binding" || err134.dataPath.indexOf(dataPath + "/properties/" + i52 + "/binding") === 0 && err134.dataPath[dataPath + "/properties/" + i52 + "/binding".length] === "/") && err134.schemaPath.indexOf("#/definitions/properties/allOf/1/items/properties/binding/allOf/1/then") === 0 && err134.schemaPath["#/definitions/properties/allOf/1/items/properties/binding/allOf/1/then".length] === "/") {
                      emErrs20.push(err134);
                      err134.emUsed = true;
                    }
                  }
                  if (emErrs20.length) {
                    const err135 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/1/then/errorMessage", params: { errors: emErrs20 }, message: "property.binding " + JSON.stringify(data56 && data56.type) + " requires source" };
                    if (vErrors === null) {
                      vErrors = [err135];
                    } else {
                      vErrors.push(err135);
                    }
                    errors++;
                  }
                  const emErrs21 = [];
                  for (const err136 of vErrors) {
                    if (!err136.emUsed) {
                      emErrs21.push(err136);
                    }
                  }
                  vErrors = emErrs21;
                  errors = emErrs21.length;
                }
                var _valid8 = _errs142 === errors;
                valid58 = _valid8;
              }
              if (!valid58) {
                const err137 = { keyword: "if", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/1/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                if (vErrors === null) {
                  vErrors = [err137];
                } else {
                  vErrors.push(err137);
                }
                errors++;
              }
              const _errs144 = errors;
              let valid60 = true;
              const _errs145 = errors;
              if (data56 && typeof data56 == "object" && !Array.isArray(data56)) {
                if (data56.type === void 0 && "type") {
                  const err138 = {};
                  if (vErrors === null) {
                    vErrors = [err138];
                  } else {
                    vErrors.push(err138);
                  }
                  errors++;
                } else {
                  if (data56.type !== void 0) {
                    if (!func0$1(data56.type, "camunda:in")) {
                      const err139 = {};
                      if (vErrors === null) {
                        vErrors = [err139];
                      } else {
                        vErrors.push(err139);
                      }
                      errors++;
                    }
                  }
                }
              }
              var _valid9 = _errs145 === errors;
              errors = _errs144;
              if (vErrors !== null) {
                if (_errs144) {
                  vErrors.length = _errs144;
                } else {
                  vErrors = null;
                }
              }
              if (_valid9) {
                const _errs147 = errors;
                const _errs148 = errors;
                let valid62 = false;
                const _errs149 = errors;
                if (data56 && typeof data56 == "object" && !Array.isArray(data56)) {
                  if (data56.variables === void 0) {
                    const err140 = { keyword: "required", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/2/then/anyOf/0/required", params: { missingProperty: "variables" }, message: "should have required property 'variables'" };
                    if (vErrors === null) {
                      vErrors = [err140];
                    } else {
                      vErrors.push(err140);
                    }
                    errors++;
                  }
                }
                var _valid10 = _errs149 === errors;
                valid62 = valid62 || _valid10;
                if (!valid62) {
                  const _errs150 = errors;
                  if (data56 && typeof data56 == "object" && !Array.isArray(data56)) {
                    if (data56.target === void 0) {
                      const err141 = { keyword: "required", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/2/then/anyOf/1/required", params: { missingProperty: "target" }, message: "should have required property 'target'" };
                      if (vErrors === null) {
                        vErrors = [err141];
                      } else {
                        vErrors.push(err141);
                      }
                      errors++;
                    }
                  }
                  var _valid10 = _errs150 === errors;
                  valid62 = valid62 || _valid10;
                }
                if (!valid62) {
                  const err142 = { keyword: "anyOf", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/2/then/anyOf", params: {}, message: "should match some schema in anyOf" };
                  if (vErrors === null) {
                    vErrors = [err142];
                  } else {
                    vErrors.push(err142);
                  }
                  errors++;
                } else {
                  errors = _errs148;
                  if (vErrors !== null) {
                    if (_errs148) {
                      vErrors.length = _errs148;
                    } else {
                      vErrors = null;
                    }
                  }
                }
                if (errors > 0) {
                  const emErrs22 = [];
                  for (const err143 of vErrors) {
                    if (err143.keyword !== "errorMessage" && !err143.emUsed && (err143.dataPath === dataPath + "/properties/" + i52 + "/binding" || err143.dataPath.indexOf(dataPath + "/properties/" + i52 + "/binding") === 0 && err143.dataPath[dataPath + "/properties/" + i52 + "/binding".length] === "/") && err143.schemaPath.indexOf("#/definitions/properties/allOf/1/items/properties/binding/allOf/2/then") === 0 && err143.schemaPath["#/definitions/properties/allOf/1/items/properties/binding/allOf/2/then".length] === "/") {
                      emErrs22.push(err143);
                      err143.emUsed = true;
                    }
                  }
                  if (emErrs22.length) {
                    const err144 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/2/then/errorMessage", params: { errors: emErrs22 }, message: "property.binding " + JSON.stringify(data56 && data56.type) + " requires variables, target, or both" };
                    if (vErrors === null) {
                      vErrors = [err144];
                    } else {
                      vErrors.push(err144);
                    }
                    errors++;
                  }
                  const emErrs23 = [];
                  for (const err145 of vErrors) {
                    if (!err145.emUsed) {
                      emErrs23.push(err145);
                    }
                  }
                  vErrors = emErrs23;
                  errors = emErrs23.length;
                }
                var _valid9 = _errs147 === errors;
                valid60 = _valid9;
              }
              if (!valid60) {
                const err146 = { keyword: "if", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/2/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                if (vErrors === null) {
                  vErrors = [err146];
                } else {
                  vErrors.push(err146);
                }
                errors++;
              }
              const _errs152 = errors;
              let valid63 = true;
              const _errs153 = errors;
              if (data56 && typeof data56 == "object" && !Array.isArray(data56)) {
                if (data56.type === void 0 && "type") {
                  const err147 = {};
                  if (vErrors === null) {
                    vErrors = [err147];
                  } else {
                    vErrors.push(err147);
                  }
                  errors++;
                } else {
                  if (data56.type !== void 0) {
                    if (!func0$1(data56.type, "camunda:out")) {
                      const err148 = {};
                      if (vErrors === null) {
                        vErrors = [err148];
                      } else {
                        vErrors.push(err148);
                      }
                      errors++;
                    }
                  }
                }
              }
              var _valid11 = _errs153 === errors;
              errors = _errs152;
              if (vErrors !== null) {
                if (_errs152) {
                  vErrors.length = _errs152;
                } else {
                  vErrors = null;
                }
              }
              if (_valid11) {
                const _errs155 = errors;
                const _errs156 = errors;
                let valid65 = false;
                let passing2 = null;
                const _errs157 = errors;
                const _errs158 = errors;
                const _errs159 = errors;
                const _errs160 = errors;
                let valid67 = false;
                const _errs161 = errors;
                if (data56 && typeof data56 == "object" && !Array.isArray(data56)) {
                  if (data56.source === void 0 && "source") {
                    const err149 = {};
                    if (vErrors === null) {
                      vErrors = [err149];
                    } else {
                      vErrors.push(err149);
                    }
                    errors++;
                  }
                }
                var _valid13 = _errs161 === errors;
                valid67 = valid67 || _valid13;
                if (!valid67) {
                  const _errs162 = errors;
                  if (data56 && typeof data56 == "object" && !Array.isArray(data56)) {
                    if (data56.sourceExpression === void 0 && "sourceExpression") {
                      const err150 = {};
                      if (vErrors === null) {
                        vErrors = [err150];
                      } else {
                        vErrors.push(err150);
                      }
                      errors++;
                    }
                  }
                  var _valid13 = _errs162 === errors;
                  valid67 = valid67 || _valid13;
                }
                if (!valid67) {
                  const err151 = {};
                  if (vErrors === null) {
                    vErrors = [err151];
                  } else {
                    vErrors.push(err151);
                  }
                  errors++;
                } else {
                  errors = _errs160;
                  if (vErrors !== null) {
                    if (_errs160) {
                      vErrors.length = _errs160;
                    } else {
                      vErrors = null;
                    }
                  }
                }
                var valid66 = _errs159 === errors;
                if (!valid66) {
                  errors = _errs158;
                  if (vErrors !== null) {
                    if (_errs158) {
                      vErrors.length = _errs158;
                    } else {
                      vErrors = null;
                    }
                  }
                } else {
                  const err152 = { keyword: "not", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/0/not", params: {}, message: "should NOT be valid" };
                  if (vErrors === null) {
                    vErrors = [err152];
                  } else {
                    vErrors.push(err152);
                  }
                  errors++;
                }
                if (data56 && typeof data56 == "object" && !Array.isArray(data56)) {
                  if (data56.variables === void 0) {
                    const err153 = { keyword: "required", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/0/required", params: { missingProperty: "variables" }, message: "should have required property 'variables'" };
                    if (vErrors === null) {
                      vErrors = [err153];
                    } else {
                      vErrors.push(err153);
                    }
                    errors++;
                  }
                }
                var _valid12 = _errs157 === errors;
                if (_valid12) {
                  valid65 = true;
                  passing2 = 0;
                }
                const _errs163 = errors;
                const _errs164 = errors;
                const _errs165 = errors;
                const _errs166 = errors;
                let valid69 = false;
                const _errs167 = errors;
                if (data56 && typeof data56 == "object" && !Array.isArray(data56)) {
                  if (data56.variables === void 0 && "variables") {
                    const err154 = {};
                    if (vErrors === null) {
                      vErrors = [err154];
                    } else {
                      vErrors.push(err154);
                    }
                    errors++;
                  }
                }
                var _valid14 = _errs167 === errors;
                valid69 = valid69 || _valid14;
                if (!valid69) {
                  const _errs168 = errors;
                  if (data56 && typeof data56 == "object" && !Array.isArray(data56)) {
                    if (data56.sourceExpression === void 0 && "sourceExpression") {
                      const err155 = {};
                      if (vErrors === null) {
                        vErrors = [err155];
                      } else {
                        vErrors.push(err155);
                      }
                      errors++;
                    }
                  }
                  var _valid14 = _errs168 === errors;
                  valid69 = valid69 || _valid14;
                }
                if (!valid69) {
                  const err156 = {};
                  if (vErrors === null) {
                    vErrors = [err156];
                  } else {
                    vErrors.push(err156);
                  }
                  errors++;
                } else {
                  errors = _errs166;
                  if (vErrors !== null) {
                    if (_errs166) {
                      vErrors.length = _errs166;
                    } else {
                      vErrors = null;
                    }
                  }
                }
                var valid68 = _errs165 === errors;
                if (!valid68) {
                  errors = _errs164;
                  if (vErrors !== null) {
                    if (_errs164) {
                      vErrors.length = _errs164;
                    } else {
                      vErrors = null;
                    }
                  }
                } else {
                  const err157 = { keyword: "not", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/1/not", params: {}, message: "should NOT be valid" };
                  if (vErrors === null) {
                    vErrors = [err157];
                  } else {
                    vErrors.push(err157);
                  }
                  errors++;
                }
                if (data56 && typeof data56 == "object" && !Array.isArray(data56)) {
                  if (data56.source === void 0) {
                    const err158 = { keyword: "required", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/1/required", params: { missingProperty: "source" }, message: "should have required property 'source'" };
                    if (vErrors === null) {
                      vErrors = [err158];
                    } else {
                      vErrors.push(err158);
                    }
                    errors++;
                  }
                }
                var _valid12 = _errs163 === errors;
                if (_valid12 && valid65) {
                  valid65 = false;
                  passing2 = [passing2, 1];
                } else {
                  if (_valid12) {
                    valid65 = true;
                    passing2 = 1;
                  }
                  const _errs169 = errors;
                  const _errs170 = errors;
                  const _errs171 = errors;
                  const _errs172 = errors;
                  let valid71 = false;
                  const _errs173 = errors;
                  if (data56 && typeof data56 == "object" && !Array.isArray(data56)) {
                    if (data56.variables === void 0 && "variables") {
                      const err159 = {};
                      if (vErrors === null) {
                        vErrors = [err159];
                      } else {
                        vErrors.push(err159);
                      }
                      errors++;
                    }
                  }
                  var _valid15 = _errs173 === errors;
                  valid71 = valid71 || _valid15;
                  if (!valid71) {
                    const _errs174 = errors;
                    if (data56 && typeof data56 == "object" && !Array.isArray(data56)) {
                      if (data56.source === void 0 && "source") {
                        const err160 = {};
                        if (vErrors === null) {
                          vErrors = [err160];
                        } else {
                          vErrors.push(err160);
                        }
                        errors++;
                      }
                    }
                    var _valid15 = _errs174 === errors;
                    valid71 = valid71 || _valid15;
                  }
                  if (!valid71) {
                    const err161 = {};
                    if (vErrors === null) {
                      vErrors = [err161];
                    } else {
                      vErrors.push(err161);
                    }
                    errors++;
                  } else {
                    errors = _errs172;
                    if (vErrors !== null) {
                      if (_errs172) {
                        vErrors.length = _errs172;
                      } else {
                        vErrors = null;
                      }
                    }
                  }
                  var valid70 = _errs171 === errors;
                  if (!valid70) {
                    errors = _errs170;
                    if (vErrors !== null) {
                      if (_errs170) {
                        vErrors.length = _errs170;
                      } else {
                        vErrors = null;
                      }
                    }
                  } else {
                    const err162 = { keyword: "not", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/2/not", params: {}, message: "should NOT be valid" };
                    if (vErrors === null) {
                      vErrors = [err162];
                    } else {
                      vErrors.push(err162);
                    }
                    errors++;
                  }
                  if (data56 && typeof data56 == "object" && !Array.isArray(data56)) {
                    if (data56.sourceExpression === void 0) {
                      const err163 = { keyword: "required", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/2/required", params: { missingProperty: "sourceExpression" }, message: "should have required property 'sourceExpression'" };
                      if (vErrors === null) {
                        vErrors = [err163];
                      } else {
                        vErrors.push(err163);
                      }
                      errors++;
                    }
                  }
                  var _valid12 = _errs169 === errors;
                  if (_valid12 && valid65) {
                    valid65 = false;
                    passing2 = [passing2, 2];
                  } else {
                    if (_valid12) {
                      valid65 = true;
                      passing2 = 2;
                    }
                    const _errs175 = errors;
                    const _errs176 = errors;
                    const _errs177 = errors;
                    if (data56 && typeof data56 == "object" && !Array.isArray(data56)) {
                      if (data56.source === void 0 && "source") {
                        const err164 = {};
                        if (vErrors === null) {
                          vErrors = [err164];
                        } else {
                          vErrors.push(err164);
                        }
                        errors++;
                      }
                    }
                    var valid72 = _errs177 === errors;
                    if (!valid72) {
                      errors = _errs176;
                      if (vErrors !== null) {
                        if (_errs176) {
                          vErrors.length = _errs176;
                        } else {
                          vErrors = null;
                        }
                      }
                    } else {
                      const err165 = { keyword: "not", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/3/not", params: {}, message: "should NOT be valid" };
                      if (vErrors === null) {
                        vErrors = [err165];
                      } else {
                        vErrors.push(err165);
                      }
                      errors++;
                    }
                    if (data56 && typeof data56 == "object" && !Array.isArray(data56)) {
                      if (data56.variables === void 0) {
                        const err166 = { keyword: "required", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/3/required", params: { missingProperty: "variables" }, message: "should have required property 'variables'" };
                        if (vErrors === null) {
                          vErrors = [err166];
                        } else {
                          vErrors.push(err166);
                        }
                        errors++;
                      }
                      if (data56.sourceExpression === void 0) {
                        const err167 = { keyword: "required", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/3/required", params: { missingProperty: "sourceExpression" }, message: "should have required property 'sourceExpression'" };
                        if (vErrors === null) {
                          vErrors = [err167];
                        } else {
                          vErrors.push(err167);
                        }
                        errors++;
                      }
                    }
                    var _valid12 = _errs175 === errors;
                    if (_valid12 && valid65) {
                      valid65 = false;
                      passing2 = [passing2, 3];
                    } else {
                      if (_valid12) {
                        valid65 = true;
                        passing2 = 3;
                      }
                      const _errs178 = errors;
                      const _errs179 = errors;
                      const _errs180 = errors;
                      if (data56 && typeof data56 == "object" && !Array.isArray(data56)) {
                        if (data56.sourceExpression === void 0 && "sourceExpression") {
                          const err168 = {};
                          if (vErrors === null) {
                            vErrors = [err168];
                          } else {
                            vErrors.push(err168);
                          }
                          errors++;
                        }
                      }
                      var valid73 = _errs180 === errors;
                      if (!valid73) {
                        errors = _errs179;
                        if (vErrors !== null) {
                          if (_errs179) {
                            vErrors.length = _errs179;
                          } else {
                            vErrors = null;
                          }
                        }
                      } else {
                        const err169 = { keyword: "not", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/4/not", params: {}, message: "should NOT be valid" };
                        if (vErrors === null) {
                          vErrors = [err169];
                        } else {
                          vErrors.push(err169);
                        }
                        errors++;
                      }
                      if (data56 && typeof data56 == "object" && !Array.isArray(data56)) {
                        if (data56.variables === void 0) {
                          const err170 = { keyword: "required", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/4/required", params: { missingProperty: "variables" }, message: "should have required property 'variables'" };
                          if (vErrors === null) {
                            vErrors = [err170];
                          } else {
                            vErrors.push(err170);
                          }
                          errors++;
                        }
                        if (data56.source === void 0) {
                          const err171 = { keyword: "required", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/4/required", params: { missingProperty: "source" }, message: "should have required property 'source'" };
                          if (vErrors === null) {
                            vErrors = [err171];
                          } else {
                            vErrors.push(err171);
                          }
                          errors++;
                        }
                      }
                      var _valid12 = _errs178 === errors;
                      if (_valid12 && valid65) {
                        valid65 = false;
                        passing2 = [passing2, 4];
                      } else {
                        if (_valid12) {
                          valid65 = true;
                          passing2 = 4;
                        }
                      }
                    }
                  }
                }
                if (!valid65) {
                  const err172 = { keyword: "oneOf", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf", params: { passingSchemas: passing2 }, message: "should match exactly one schema in oneOf" };
                  if (vErrors === null) {
                    vErrors = [err172];
                  } else {
                    vErrors.push(err172);
                  }
                  errors++;
                } else {
                  errors = _errs156;
                  if (vErrors !== null) {
                    if (_errs156) {
                      vErrors.length = _errs156;
                    } else {
                      vErrors = null;
                    }
                  }
                }
                if (errors > 0) {
                  const emErrs24 = [];
                  for (const err173 of vErrors) {
                    if (err173.keyword !== "errorMessage" && !err173.emUsed && (err173.dataPath === dataPath + "/properties/" + i52 + "/binding" || err173.dataPath.indexOf(dataPath + "/properties/" + i52 + "/binding") === 0 && err173.dataPath[dataPath + "/properties/" + i52 + "/binding".length] === "/") && err173.schemaPath.indexOf("#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then") === 0 && err173.schemaPath["#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then".length] === "/") {
                      emErrs24.push(err173);
                      err173.emUsed = true;
                    }
                  }
                  if (emErrs24.length) {
                    const err174 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/errorMessage", params: { errors: emErrs24 }, message: "property.binding " + JSON.stringify(data56 && data56.type) + " requires one of the following: variables, sourceExpression, source, (sourceExpression and variables), or (source and variables)" };
                    if (vErrors === null) {
                      vErrors = [err174];
                    } else {
                      vErrors.push(err174);
                    }
                    errors++;
                  }
                  const emErrs25 = [];
                  for (const err175 of vErrors) {
                    if (!err175.emUsed) {
                      emErrs25.push(err175);
                    }
                  }
                  vErrors = emErrs25;
                  errors = emErrs25.length;
                }
                var _valid11 = _errs155 === errors;
                valid63 = _valid11;
              }
              if (!valid63) {
                const err176 = { keyword: "if", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                if (vErrors === null) {
                  vErrors = [err176];
                } else {
                  vErrors.push(err176);
                }
                errors++;
              }
              const _errs182 = errors;
              let valid74 = true;
              const _errs183 = errors;
              if (data56 && typeof data56 == "object" && !Array.isArray(data56)) {
                if (data56.type === void 0 && "type") {
                  const err177 = {};
                  if (vErrors === null) {
                    vErrors = [err177];
                  } else {
                    vErrors.push(err177);
                  }
                  errors++;
                } else {
                  if (data56.type !== void 0) {
                    if (!func0$1(data56.type, "camunda:errorEventDefinition")) {
                      const err178 = {};
                      if (vErrors === null) {
                        vErrors = [err178];
                      } else {
                        vErrors.push(err178);
                      }
                      errors++;
                    }
                  }
                }
              }
              var _valid16 = _errs183 === errors;
              errors = _errs182;
              if (vErrors !== null) {
                if (_errs182) {
                  vErrors.length = _errs182;
                } else {
                  vErrors = null;
                }
              }
              if (_valid16) {
                const _errs185 = errors;
                const _errs186 = errors;
                let valid76 = false;
                let passing3 = null;
                const _errs187 = errors;
                if (data56 && typeof data56 == "object" && !Array.isArray(data56)) {
                  if (data56.errorRef === void 0) {
                    const err179 = { keyword: "required", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/4/then/oneOf/0/required", params: { missingProperty: "errorRef" }, message: "should have required property 'errorRef'" };
                    if (vErrors === null) {
                      vErrors = [err179];
                    } else {
                      vErrors.push(err179);
                    }
                    errors++;
                  }
                }
                var _valid17 = _errs187 === errors;
                if (_valid17) {
                  valid76 = true;
                  passing3 = 0;
                }
                if (!valid76) {
                  const err180 = { keyword: "oneOf", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/4/then/oneOf", params: { passingSchemas: passing3 }, message: "should match exactly one schema in oneOf" };
                  if (vErrors === null) {
                    vErrors = [err180];
                  } else {
                    vErrors.push(err180);
                  }
                  errors++;
                } else {
                  errors = _errs186;
                  if (vErrors !== null) {
                    if (_errs186) {
                      vErrors.length = _errs186;
                    } else {
                      vErrors = null;
                    }
                  }
                }
                if (errors > 0) {
                  const emErrs26 = [];
                  for (const err181 of vErrors) {
                    if (err181.keyword !== "errorMessage" && !err181.emUsed && (err181.dataPath === dataPath + "/properties/" + i52 + "/binding" || err181.dataPath.indexOf(dataPath + "/properties/" + i52 + "/binding") === 0 && err181.dataPath[dataPath + "/properties/" + i52 + "/binding".length] === "/") && err181.schemaPath.indexOf("#/definitions/properties/allOf/1/items/properties/binding/allOf/4/then") === 0 && err181.schemaPath["#/definitions/properties/allOf/1/items/properties/binding/allOf/4/then".length] === "/") {
                      emErrs26.push(err181);
                      err181.emUsed = true;
                    }
                  }
                  if (emErrs26.length) {
                    const err182 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/4/then/errorMessage", params: { errors: emErrs26 }, message: "property.binding " + JSON.stringify(data56 && data56.type) + " requires errorRef" };
                    if (vErrors === null) {
                      vErrors = [err182];
                    } else {
                      vErrors.push(err182);
                    }
                    errors++;
                  }
                  const emErrs27 = [];
                  for (const err183 of vErrors) {
                    if (!err183.emUsed) {
                      emErrs27.push(err183);
                    }
                  }
                  vErrors = emErrs27;
                  errors = emErrs27.length;
                }
                var _valid16 = _errs185 === errors;
                valid74 = _valid16;
              }
              if (!valid74) {
                const err184 = { keyword: "if", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/4/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                if (vErrors === null) {
                  vErrors = [err184];
                } else {
                  vErrors.push(err184);
                }
                errors++;
              }
              if (data56 && typeof data56 == "object" && !Array.isArray(data56)) {
                if (data56.type === void 0) {
                  const err185 = { keyword: "required", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/required", params: { missingProperty: "type" }, message: "should have required property 'type'" };
                  if (vErrors === null) {
                    vErrors = [err185];
                  } else {
                    vErrors.push(err185);
                  }
                  errors++;
                }
                if (data56.type !== void 0) {
                  let data62 = data56.type;
                  if (typeof data62 !== "string") {
                    const err186 = { keyword: "type", dataPath: dataPath + "/properties/" + i52 + "/binding/type", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/type/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err186];
                    } else {
                      vErrors.push(err186);
                    }
                    errors++;
                  }
                  if (!(data62 === "property" || data62 === "camunda:property" || data62 === "camunda:inputParameter" || data62 === "camunda:outputParameter" || data62 === "camunda:in" || data62 === "camunda:out" || data62 === "camunda:in:businessKey" || data62 === "camunda:executionListener" || data62 === "camunda:field" || data62 === "camunda:errorEventDefinition")) {
                    const err187 = { keyword: "enum", dataPath: dataPath + "/properties/" + i52 + "/binding/type", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/type/enum", params: { allowedValues: schema18$1.allOf[1].items.properties.binding.properties.type.enum }, message: "should be equal to one of the allowed values" };
                    if (vErrors === null) {
                      vErrors = [err187];
                    } else {
                      vErrors.push(err187);
                    }
                    errors++;
                  }
                  if (errors > 0) {
                    const emErrs28 = [];
                    for (const err188 of vErrors) {
                      if (err188.keyword !== "errorMessage" && !err188.emUsed && (err188.dataPath === dataPath + "/properties/" + i52 + "/binding/type" || err188.dataPath.indexOf(dataPath + "/properties/" + i52 + "/binding/type") === 0 && err188.dataPath[dataPath + "/properties/" + i52 + "/binding/type".length] === "/") && err188.schemaPath.indexOf("#/definitions/properties/allOf/1/items/properties/binding/properties/type") === 0 && err188.schemaPath["#/definitions/properties/allOf/1/items/properties/binding/properties/type".length] === "/") {
                        emErrs28.push(err188);
                        err188.emUsed = true;
                      }
                    }
                    if (emErrs28.length) {
                      const err189 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i52 + "/binding/type", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/type/errorMessage", params: { errors: emErrs28 }, message: "invalid property.binding type " + JSON.stringify(data62) + "; must be any of { property, camunda:property, camunda:inputParameter, camunda:outputParameter, camunda:in, camunda:out, camunda:in:businessKey, camunda:executionListener, camunda:field, camunda:errorEventDefinition }" };
                      if (vErrors === null) {
                        vErrors = [err189];
                      } else {
                        vErrors.push(err189);
                      }
                      errors++;
                    }
                    const emErrs29 = [];
                    for (const err190 of vErrors) {
                      if (!err190.emUsed) {
                        emErrs29.push(err190);
                      }
                    }
                    vErrors = emErrs29;
                    errors = emErrs29.length;
                  }
                }
                if (data56.name !== void 0) {
                  if (typeof data56.name !== "string") {
                    const err191 = { keyword: "type", dataPath: dataPath + "/properties/" + i52 + "/binding/name", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/name/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err191];
                    } else {
                      vErrors.push(err191);
                    }
                    errors++;
                  }
                }
                if (data56.event !== void 0) {
                  if (typeof data56.event !== "string") {
                    const err192 = { keyword: "type", dataPath: dataPath + "/properties/" + i52 + "/binding/event", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/event/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err192];
                    } else {
                      vErrors.push(err192);
                    }
                    errors++;
                  }
                }
                if (data56.scriptFormat !== void 0) {
                  if (typeof data56.scriptFormat !== "string") {
                    const err193 = { keyword: "type", dataPath: dataPath + "/properties/" + i52 + "/binding/scriptFormat", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/scriptFormat/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err193];
                    } else {
                      vErrors.push(err193);
                    }
                    errors++;
                  }
                }
                if (data56.source !== void 0) {
                  if (typeof data56.source !== "string") {
                    const err194 = { keyword: "type", dataPath: dataPath + "/properties/" + i52 + "/binding/source", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/source/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err194];
                    } else {
                      vErrors.push(err194);
                    }
                    errors++;
                  }
                }
                if (data56.target !== void 0) {
                  if (typeof data56.target !== "string") {
                    const err195 = { keyword: "type", dataPath: dataPath + "/properties/" + i52 + "/binding/target", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/target/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err195];
                    } else {
                      vErrors.push(err195);
                    }
                    errors++;
                  }
                }
                if (data56.expression !== void 0) {
                  if (typeof data56.expression !== "boolean") {
                    const err196 = { keyword: "type", dataPath: dataPath + "/properties/" + i52 + "/binding/expression", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/expression/type", params: { type: "boolean" }, message: "should be boolean" };
                    if (vErrors === null) {
                      vErrors = [err196];
                    } else {
                      vErrors.push(err196);
                    }
                    errors++;
                  }
                }
                if (data56.variables !== void 0) {
                  let data69 = data56.variables;
                  if (typeof data69 !== "string") {
                    const err197 = { keyword: "type", dataPath: dataPath + "/properties/" + i52 + "/binding/variables", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/variables/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err197];
                    } else {
                      vErrors.push(err197);
                    }
                    errors++;
                  }
                  if (!(data69 === "all" || data69 === "local")) {
                    const err198 = { keyword: "enum", dataPath: dataPath + "/properties/" + i52 + "/binding/variables", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/variables/enum", params: { allowedValues: schema18$1.allOf[1].items.properties.binding.properties.variables.enum }, message: "should be equal to one of the allowed values" };
                    if (vErrors === null) {
                      vErrors = [err198];
                    } else {
                      vErrors.push(err198);
                    }
                    errors++;
                  }
                }
                if (data56.sourceExpression !== void 0) {
                  if (typeof data56.sourceExpression !== "string") {
                    const err199 = { keyword: "type", dataPath: dataPath + "/properties/" + i52 + "/binding/sourceExpression", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/sourceExpression/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err199];
                    } else {
                      vErrors.push(err199);
                    }
                    errors++;
                  }
                }
              } else {
                const err200 = { keyword: "type", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/type", params: { type: "object" }, message: "should be object" };
                if (vErrors === null) {
                  vErrors = [err200];
                } else {
                  vErrors.push(err200);
                }
                errors++;
              }
            }
          } else {
            const err201 = { keyword: "type", dataPath: dataPath + "/properties/" + i52, schemaPath: "#/definitions/properties/allOf/1/items/type", params: { type: "object" }, message: "should be object" };
            if (vErrors === null) {
              vErrors = [err201];
            } else {
              vErrors.push(err201);
            }
            errors++;
          }
          if (errors > 0) {
            const emErrors8 = { "required": [] };
            const templates8 = { required: function() {
              return 'missing binding for property "' + JSON.stringify(i52) + '"';
            } };
            for (const err202 of vErrors) {
              if (err202.keyword !== "errorMessage" && !err202.emUsed && err202.dataPath === dataPath + "/properties/" + i52 && err202.keyword in emErrors8 && err202.schemaPath.indexOf("#/definitions/properties/allOf/1/items") === 0 && /^\/[^\/]*$/.test(err202.schemaPath.slice(38))) {
                emErrors8[err202.keyword].push(err202);
                err202.emUsed = true;
              }
            }
            for (const key8 in emErrors8) {
              if (emErrors8[key8].length) {
                const err203 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i52, schemaPath: "#/definitions/properties/allOf/1/items/errorMessage", params: { errors: emErrors8[key8] }, message: key8 in templates8 ? templates8[key8]() : schema18$1.allOf[1].items.errorMessage[key8] };
                if (vErrors === null) {
                  vErrors = [err203];
                } else {
                  vErrors.push(err203);
                }
                errors++;
              }
            }
            const emErrs30 = [];
            for (const err204 of vErrors) {
              if (!err204.emUsed) {
                emErrs30.push(err204);
              }
            }
            vErrors = emErrs30;
            errors = emErrs30.length;
          }
        }
      } else {
        const err205 = { keyword: "type", dataPath: dataPath + "/properties", schemaPath: "#/definitions/properties/allOf/1/type", params: { type: "array" }, message: "should be array" };
        if (vErrors === null) {
          vErrors = [err205];
        } else {
          vErrors.push(err205);
        }
        errors++;
      }
    }
    if (data.scopes !== void 0) {
      let data71 = data.scopes;
      if (Array.isArray(data71)) {
        const len6 = data71.length;
        for (let i6 = 0; i6 < len6; i6++) {
          let data72 = data71[i6];
          const _errs211 = errors;
          let valid82 = true;
          const _errs212 = errors;
          if (data72 && typeof data72 == "object" && !Array.isArray(data72)) {
            if (data72.type === void 0 && "type") {
              const err206 = {};
              if (vErrors === null) {
                vErrors = [err206];
              } else {
                vErrors.push(err206);
              }
              errors++;
            } else {
              if (data72.type !== void 0) {
                if (!(data72.type === "bpmn:Error")) {
                  const err207 = {};
                  if (vErrors === null) {
                    vErrors = [err207];
                  } else {
                    vErrors.push(err207);
                  }
                  errors++;
                }
              }
            }
          }
          var _valid18 = _errs212 === errors;
          errors = _errs211;
          if (vErrors !== null) {
            if (_errs211) {
              vErrors.length = _errs211;
            } else {
              vErrors = null;
            }
          }
          if (_valid18) {
            const _errs214 = errors;
            if (data72 && typeof data72 == "object" && !Array.isArray(data72)) {
              if (data72.id === void 0) {
                const err208 = { keyword: "required", dataPath: dataPath + "/scopes/" + i6, schemaPath: "#/properties/scopes/items/allOf/0/then/required", params: { missingProperty: "id" }, message: "should have required property 'id'" };
                if (vErrors === null) {
                  vErrors = [err208];
                } else {
                  vErrors.push(err208);
                }
                errors++;
              }
            }
            if (errors > 0) {
              const emErrs31 = [];
              for (const err209 of vErrors) {
                if (err209.keyword !== "errorMessage" && !err209.emUsed && (err209.dataPath === dataPath + "/scopes/" + i6 || err209.dataPath.indexOf(dataPath + "/scopes/" + i6) === 0 && err209.dataPath[dataPath + "/scopes/" + i6.length] === "/") && err209.schemaPath.indexOf("#/properties/scopes/items/allOf/0/then") === 0 && err209.schemaPath["#/properties/scopes/items/allOf/0/then".length] === "/") {
                  emErrs31.push(err209);
                  err209.emUsed = true;
                }
              }
              if (emErrs31.length) {
                const err210 = { keyword: "errorMessage", dataPath: dataPath + "/scopes/" + i6, schemaPath: "#/properties/scopes/items/allOf/0/then/errorMessage", params: { errors: emErrs31 }, message: "invalid scope " + JSON.stringify(data72 && data72.type) + ", missing id" };
                if (vErrors === null) {
                  vErrors = [err210];
                } else {
                  vErrors.push(err210);
                }
                errors++;
              }
              const emErrs32 = [];
              for (const err211 of vErrors) {
                if (!err211.emUsed) {
                  emErrs32.push(err211);
                }
              }
              vErrors = emErrs32;
              errors = emErrs32.length;
            }
            var _valid18 = _errs214 === errors;
            valid82 = _valid18;
          }
          if (!valid82) {
            const err212 = { keyword: "if", dataPath: dataPath + "/scopes/" + i6, schemaPath: "#/properties/scopes/items/allOf/0/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
            if (vErrors === null) {
              vErrors = [err212];
            } else {
              vErrors.push(err212);
            }
            errors++;
          }
          if (data72 && typeof data72 == "object" && !Array.isArray(data72)) {
            if (data72.type === void 0) {
              const err213 = { keyword: "required", dataPath: dataPath + "/scopes/" + i6, schemaPath: "#/properties/scopes/items/required", params: { missingProperty: "type" }, message: "should have required property 'type'" };
              if (vErrors === null) {
                vErrors = [err213];
              } else {
                vErrors.push(err213);
              }
              errors++;
            }
            if (data72.properties === void 0) {
              const err214 = { keyword: "required", dataPath: dataPath + "/scopes/" + i6, schemaPath: "#/properties/scopes/items/required", params: { missingProperty: "properties" }, message: "should have required property 'properties'" };
              if (vErrors === null) {
                vErrors = [err214];
              } else {
                vErrors.push(err214);
              }
              errors++;
            }
            if (data72.type !== void 0) {
              let data74 = data72.type;
              if (typeof data74 !== "string") {
                const err215 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/type", schemaPath: "#/properties/scopes/items/properties/type/type", params: { type: "string" }, message: "should be string" };
                if (vErrors === null) {
                  vErrors = [err215];
                } else {
                  vErrors.push(err215);
                }
                errors++;
              }
              if (!(data74 === "camunda:Connector" || data74 === "bpmn:Error")) {
                const err216 = { keyword: "enum", dataPath: dataPath + "/scopes/" + i6 + "/type", schemaPath: "#/properties/scopes/items/properties/type/enum", params: { allowedValues: schema17$1.properties.scopes.items.properties.type.enum }, message: "should be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err216];
                } else {
                  vErrors.push(err216);
                }
                errors++;
              }
              if (errors > 0) {
                const emErrs33 = [];
                for (const err217 of vErrors) {
                  if (err217.keyword !== "errorMessage" && !err217.emUsed && (err217.dataPath === dataPath + "/scopes/" + i6 + "/type" || err217.dataPath.indexOf(dataPath + "/scopes/" + i6 + "/type") === 0 && err217.dataPath[dataPath + "/scopes/" + i6 + "/type".length] === "/") && err217.schemaPath.indexOf("#/properties/scopes/items/properties/type") === 0 && err217.schemaPath["#/properties/scopes/items/properties/type".length] === "/") {
                    emErrs33.push(err217);
                    err217.emUsed = true;
                  }
                }
                if (emErrs33.length) {
                  const err218 = { keyword: "errorMessage", dataPath: dataPath + "/scopes/" + i6 + "/type", schemaPath: "#/properties/scopes/items/properties/type/errorMessage", params: { errors: emErrs33 }, message: "invalid scope type " + JSON.stringify(data74) + "; must be any of { camunda:Connector, bpmn:Error }" };
                  if (vErrors === null) {
                    vErrors = [err218];
                  } else {
                    vErrors.push(err218);
                  }
                  errors++;
                }
                const emErrs34 = [];
                for (const err219 of vErrors) {
                  if (!err219.emUsed) {
                    emErrs34.push(err219);
                  }
                }
                vErrors = emErrs34;
                errors = emErrs34.length;
              }
            }
            if (data72.properties !== void 0) {
              let data75 = data72.properties;
              if (Array.isArray(data75)) {
                const len7 = data75.length;
                for (let i7 = 0; i7 < len7; i7++) {
                  let data76 = data75[i7];
                  const _errs224 = errors;
                  let valid91 = true;
                  const _errs225 = errors;
                  if (data76 && typeof data76 == "object" && !Array.isArray(data76)) {
                    if (data76.type === void 0 && "type") {
                      const err220 = {};
                      if (vErrors === null) {
                        vErrors = [err220];
                      } else {
                        vErrors.push(err220);
                      }
                      errors++;
                    } else {
                      if (data76.type !== void 0) {
                        if (!func0$1(data76.type, "Dropdown")) {
                          const err221 = {};
                          if (vErrors === null) {
                            vErrors = [err221];
                          } else {
                            vErrors.push(err221);
                          }
                          errors++;
                        }
                      }
                    }
                  }
                  var _valid19 = _errs225 === errors;
                  errors = _errs224;
                  if (vErrors !== null) {
                    if (_errs224) {
                      vErrors.length = _errs224;
                    } else {
                      vErrors = null;
                    }
                  }
                  if (_valid19) {
                    const _errs227 = errors;
                    if (data76 && typeof data76 == "object" && !Array.isArray(data76)) {
                      if (data76.choices === void 0) {
                        const err222 = { keyword: "required", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7, schemaPath: "#/definitions/properties/allOf/0/items/allOf/0/then/required", params: { missingProperty: "choices" }, message: "should have required property 'choices'" };
                        if (vErrors === null) {
                          vErrors = [err222];
                        } else {
                          vErrors.push(err222);
                        }
                        errors++;
                      }
                    }
                    if (errors > 0) {
                      const emErrs35 = [];
                      for (const err223 of vErrors) {
                        if (err223.keyword !== "errorMessage" && !err223.emUsed && (err223.dataPath === dataPath + "/scopes/" + i6 + "/properties/" + i7 || err223.dataPath.indexOf(dataPath + "/scopes/" + i6 + "/properties/" + i7) === 0 && err223.dataPath[dataPath + "/scopes/" + i6 + "/properties/" + i7.length] === "/") && err223.schemaPath.indexOf("#/definitions/properties/allOf/0/items/allOf/0/then") === 0 && err223.schemaPath["#/definitions/properties/allOf/0/items/allOf/0/then".length] === "/") {
                          emErrs35.push(err223);
                          err223.emUsed = true;
                        }
                      }
                      if (emErrs35.length) {
                        const err224 = { keyword: "errorMessage", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7, schemaPath: "#/definitions/properties/allOf/0/items/allOf/0/then/errorMessage", params: { errors: emErrs35 }, message: 'must provide choices=[] with "Dropdown" type' };
                        if (vErrors === null) {
                          vErrors = [err224];
                        } else {
                          vErrors.push(err224);
                        }
                        errors++;
                      }
                      const emErrs36 = [];
                      for (const err225 of vErrors) {
                        if (!err225.emUsed) {
                          emErrs36.push(err225);
                        }
                      }
                      vErrors = emErrs36;
                      errors = emErrs36.length;
                    }
                    var _valid19 = _errs227 === errors;
                    valid91 = _valid19;
                  }
                  if (!valid91) {
                    const err226 = { keyword: "if", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7, schemaPath: "#/definitions/properties/allOf/0/items/allOf/0/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                    if (vErrors === null) {
                      vErrors = [err226];
                    } else {
                      vErrors.push(err226);
                    }
                    errors++;
                  }
                  if (data76 && typeof data76 == "object" && !Array.isArray(data76)) {
                    if (data76.id !== void 0) {
                      if (typeof data76.id !== "string") {
                        const err227 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/id", schemaPath: "#/definitions/properties/allOf/0/items/properties/id/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err227];
                        } else {
                          vErrors.push(err227);
                        }
                        errors++;
                      }
                    }
                    if (data76.value !== void 0) {
                      let data79 = data76.value;
                      if (typeof data79 !== "string" && typeof data79 !== "boolean") {
                        const err228 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/value", schemaPath: "#/definitions/properties/allOf/0/items/properties/value/type", params: { type: schema19.items.properties.value.type }, message: "should be string,boolean" };
                        if (vErrors === null) {
                          vErrors = [err228];
                        } else {
                          vErrors.push(err228);
                        }
                        errors++;
                      }
                    }
                    if (data76.description !== void 0) {
                      if (typeof data76.description !== "string") {
                        const err229 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/description", schemaPath: "#/definitions/properties/allOf/0/items/properties/description/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err229];
                        } else {
                          vErrors.push(err229);
                        }
                        errors++;
                      }
                    }
                    if (data76.label !== void 0) {
                      if (typeof data76.label !== "string") {
                        const err230 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/label", schemaPath: "#/definitions/properties/allOf/0/items/properties/label/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err230];
                        } else {
                          vErrors.push(err230);
                        }
                        errors++;
                      }
                    }
                    if (data76.type !== void 0) {
                      if (typeof data76.type !== "string") {
                        const err231 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/type", schemaPath: "#/definitions/properties/allOf/0/items/properties/type/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err231];
                        } else {
                          vErrors.push(err231);
                        }
                        errors++;
                      }
                    }
                    if (data76.editable !== void 0) {
                      if (typeof data76.editable !== "boolean") {
                        const err232 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/editable", schemaPath: "#/definitions/properties/allOf/0/items/properties/editable/type", params: { type: "boolean" }, message: "should be boolean" };
                        if (vErrors === null) {
                          vErrors = [err232];
                        } else {
                          vErrors.push(err232);
                        }
                        errors++;
                      }
                    }
                    if (data76.choices !== void 0) {
                      let data84 = data76.choices;
                      if (Array.isArray(data84)) {
                        const len8 = data84.length;
                        for (let i8 = 0; i8 < len8; i8++) {
                          let data85 = data84[i8];
                          if (data85 && typeof data85 == "object" && !Array.isArray(data85)) {
                            if (data85.value === void 0) {
                              const err233 = { keyword: "required", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/choices/" + i8, schemaPath: "#/definitions/properties/allOf/0/items/properties/choices/items/required", params: { missingProperty: "value" }, message: "should have required property 'value'" };
                              if (vErrors === null) {
                                vErrors = [err233];
                              } else {
                                vErrors.push(err233);
                              }
                              errors++;
                            }
                            if (data85.name === void 0) {
                              const err234 = { keyword: "required", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/choices/" + i8, schemaPath: "#/definitions/properties/allOf/0/items/properties/choices/items/required", params: { missingProperty: "name" }, message: "should have required property 'name'" };
                              if (vErrors === null) {
                                vErrors = [err234];
                              } else {
                                vErrors.push(err234);
                              }
                              errors++;
                            }
                            if (data85.name !== void 0) {
                              if (typeof data85.name !== "string") {
                                const err235 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/choices/" + i8 + "/name", schemaPath: "#/definitions/properties/allOf/0/items/properties/choices/items/properties/name/type", params: { type: "string" }, message: "should be string" };
                                if (vErrors === null) {
                                  vErrors = [err235];
                                } else {
                                  vErrors.push(err235);
                                }
                                errors++;
                              }
                            }
                            if (data85.value !== void 0) {
                              if (typeof data85.value !== "string") {
                                const err236 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/choices/" + i8 + "/value", schemaPath: "#/definitions/properties/allOf/0/items/properties/choices/items/properties/value/type", params: { type: "string" }, message: "should be string" };
                                if (vErrors === null) {
                                  vErrors = [err236];
                                } else {
                                  vErrors.push(err236);
                                }
                                errors++;
                              }
                            }
                          } else {
                            const err237 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/choices/" + i8, schemaPath: "#/definitions/properties/allOf/0/items/properties/choices/items/type", params: { type: "object" }, message: "should be object" };
                            if (vErrors === null) {
                              vErrors = [err237];
                            } else {
                              vErrors.push(err237);
                            }
                            errors++;
                          }
                          if (errors > 0) {
                            const emErrors9 = { "required": [] };
                            const templates9 = {};
                            for (const err238 of vErrors) {
                              if (err238.keyword !== "errorMessage" && !err238.emUsed && err238.dataPath === dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/choices/" + i8 && err238.keyword in emErrors9 && err238.schemaPath.indexOf("#/definitions/properties/allOf/0/items/properties/choices/items") === 0 && /^\/[^\/]*$/.test(err238.schemaPath.slice(63))) {
                                emErrors9[err238.keyword].push(err238);
                                err238.emUsed = true;
                              }
                            }
                            for (const key9 in emErrors9) {
                              if (emErrors9[key9].length) {
                                const err239 = { keyword: "errorMessage", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/choices/" + i8, schemaPath: "#/definitions/properties/allOf/0/items/properties/choices/items/errorMessage", params: { errors: emErrors9[key9] }, message: key9 in templates9 ? templates9[key9]() : schema19.items.properties.choices.items.errorMessage[key9] };
                                if (vErrors === null) {
                                  vErrors = [err239];
                                } else {
                                  vErrors.push(err239);
                                }
                                errors++;
                              }
                            }
                            const emErrs37 = [];
                            for (const err240 of vErrors) {
                              if (!err240.emUsed) {
                                emErrs37.push(err240);
                              }
                            }
                            vErrors = emErrs37;
                            errors = emErrs37.length;
                          }
                        }
                      } else {
                        const err241 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/choices", schemaPath: "#/definitions/properties/allOf/0/items/properties/choices/type", params: { type: "array" }, message: "should be array" };
                        if (vErrors === null) {
                          vErrors = [err241];
                        } else {
                          vErrors.push(err241);
                        }
                        errors++;
                      }
                    }
                    if (data76.constraints !== void 0) {
                      let data88 = data76.constraints;
                      if (data88 && typeof data88 == "object" && !Array.isArray(data88)) {
                        if (data88.notEmpty !== void 0) {
                          if (typeof data88.notEmpty !== "boolean") {
                            const err242 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/constraints/notEmpty", schemaPath: "#/definitions/properties/allOf/0/items/properties/constraints/properties/notEmpty/type", params: { type: "boolean" }, message: "should be boolean" };
                            if (vErrors === null) {
                              vErrors = [err242];
                            } else {
                              vErrors.push(err242);
                            }
                            errors++;
                          }
                        }
                        if (data88.minLength !== void 0) {
                          if (!(typeof data88.minLength == "number")) {
                            const err243 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/constraints/minLength", schemaPath: "#/definitions/properties/allOf/0/items/properties/constraints/properties/minLength/type", params: { type: "number" }, message: "should be number" };
                            if (vErrors === null) {
                              vErrors = [err243];
                            } else {
                              vErrors.push(err243);
                            }
                            errors++;
                          }
                        }
                        if (data88.maxLength !== void 0) {
                          if (!(typeof data88.maxLength == "number")) {
                            const err244 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/constraints/maxLength", schemaPath: "#/definitions/properties/allOf/0/items/properties/constraints/properties/maxLength/type", params: { type: "number" }, message: "should be number" };
                            if (vErrors === null) {
                              vErrors = [err244];
                            } else {
                              vErrors.push(err244);
                            }
                            errors++;
                          }
                        }
                        if (data88.pattern !== void 0) {
                          let data92 = data88.pattern;
                          const _errs257 = errors;
                          let valid99 = false;
                          let passing4 = null;
                          const _errs258 = errors;
                          if (data92 && typeof data92 == "object" && !Array.isArray(data92)) {
                            if (data92.value !== void 0) {
                              if (typeof data92.value !== "string") {
                                const err245 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/constraints/pattern/value", schemaPath: "#/definitions/properties/allOf/0/items/properties/constraints/properties/pattern/oneOf/0/properties/value/type", params: { type: "string" }, message: "should be string" };
                                if (vErrors === null) {
                                  vErrors = [err245];
                                } else {
                                  vErrors.push(err245);
                                }
                                errors++;
                              }
                            }
                            if (data92.message !== void 0) {
                              if (typeof data92.message !== "string") {
                                const err246 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/constraints/pattern/message", schemaPath: "#/definitions/properties/allOf/0/items/properties/constraints/properties/pattern/oneOf/0/properties/message/type", params: { type: "string" }, message: "should be string" };
                                if (vErrors === null) {
                                  vErrors = [err246];
                                } else {
                                  vErrors.push(err246);
                                }
                                errors++;
                              }
                            }
                          } else {
                            const err247 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/constraints/pattern", schemaPath: "#/definitions/properties/allOf/0/items/properties/constraints/properties/pattern/oneOf/0/type", params: { type: "object" }, message: "should be object" };
                            if (vErrors === null) {
                              vErrors = [err247];
                            } else {
                              vErrors.push(err247);
                            }
                            errors++;
                          }
                          var _valid20 = _errs258 === errors;
                          if (_valid20) {
                            valid99 = true;
                            passing4 = 0;
                          }
                          const _errs264 = errors;
                          if (typeof data92 !== "string") {
                            const err248 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/constraints/pattern", schemaPath: "#/definitions/properties/allOf/0/items/properties/constraints/properties/pattern/oneOf/1/type", params: { type: "string" }, message: "should be string" };
                            if (vErrors === null) {
                              vErrors = [err248];
                            } else {
                              vErrors.push(err248);
                            }
                            errors++;
                          }
                          var _valid20 = _errs264 === errors;
                          if (_valid20 && valid99) {
                            valid99 = false;
                            passing4 = [passing4, 1];
                          } else {
                            if (_valid20) {
                              valid99 = true;
                              passing4 = 1;
                            }
                          }
                          if (!valid99) {
                            const err249 = { keyword: "oneOf", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/constraints/pattern", schemaPath: "#/definitions/properties/allOf/0/items/properties/constraints/properties/pattern/oneOf", params: { passingSchemas: passing4 }, message: "should match exactly one schema in oneOf" };
                            if (vErrors === null) {
                              vErrors = [err249];
                            } else {
                              vErrors.push(err249);
                            }
                            errors++;
                          } else {
                            errors = _errs257;
                            if (vErrors !== null) {
                              if (_errs257) {
                                vErrors.length = _errs257;
                              } else {
                                vErrors = null;
                              }
                            }
                          }
                        }
                      } else {
                        const err250 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/constraints", schemaPath: "#/definitions/properties/allOf/0/items/properties/constraints/type", params: { type: "object" }, message: "should be object" };
                        if (vErrors === null) {
                          vErrors = [err250];
                        } else {
                          vErrors.push(err250);
                        }
                        errors++;
                      }
                    }
                    if (data76.group !== void 0) {
                      if (typeof data76.group !== "string") {
                        const err251 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/group", schemaPath: "#/definitions/properties/allOf/0/items/properties/group/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err251];
                        } else {
                          vErrors.push(err251);
                        }
                        errors++;
                      }
                    }
                    if (data76.condition !== void 0) {
                      let data96 = data76.condition;
                      const _errs270 = errors;
                      let valid101 = false;
                      let passing5 = null;
                      const _errs271 = errors;
                      if (data96 && typeof data96 == "object" && !Array.isArray(data96)) {
                        if (data96.equals === void 0) {
                          const err252 = { keyword: "required", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/oneOf/0/required", params: { missingProperty: "equals" }, message: "should have required property 'equals'" };
                          if (vErrors === null) {
                            vErrors = [err252];
                          } else {
                            vErrors.push(err252);
                          }
                          errors++;
                        }
                        if (data96.equals !== void 0) {
                          let data97 = data96.equals;
                          if (typeof data97 !== "string" && !(typeof data97 == "number") && typeof data97 !== "boolean") {
                            const err253 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/condition/equals", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/oneOf/0/properties/equals/type", params: { type: schema19.items.properties.condition.oneOf[0].properties.equals.type }, message: "should be string,number,boolean" };
                            if (vErrors === null) {
                              vErrors = [err253];
                            } else {
                              vErrors.push(err253);
                            }
                            errors++;
                          }
                        }
                      }
                      var _valid21 = _errs271 === errors;
                      if (_valid21) {
                        valid101 = true;
                        passing5 = 0;
                      }
                      const _errs274 = errors;
                      if (data96 && typeof data96 == "object" && !Array.isArray(data96)) {
                        if (data96.oneOf === void 0) {
                          const err254 = { keyword: "required", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/oneOf/1/required", params: { missingProperty: "oneOf" }, message: "should have required property 'oneOf'" };
                          if (vErrors === null) {
                            vErrors = [err254];
                          } else {
                            vErrors.push(err254);
                          }
                          errors++;
                        }
                        if (data96.oneOf !== void 0) {
                          let data98 = data96.oneOf;
                          if (Array.isArray(data98)) {
                            const len9 = data98.length;
                            for (let i9 = 0; i9 < len9; i9++) {
                              let data99 = data98[i9];
                              if (typeof data99 !== "string" && !(typeof data99 == "number")) {
                                const err255 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/condition/oneOf/" + i9, schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/oneOf/1/properties/oneOf/items/type", params: { type: schema19.items.properties.condition.oneOf[1].properties.oneOf.items.type }, message: "should be string,number" };
                                if (vErrors === null) {
                                  vErrors = [err255];
                                } else {
                                  vErrors.push(err255);
                                }
                                errors++;
                              }
                            }
                          } else {
                            const err256 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/condition/oneOf", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/oneOf/1/properties/oneOf/type", params: { type: "array" }, message: "should be array" };
                            if (vErrors === null) {
                              vErrors = [err256];
                            } else {
                              vErrors.push(err256);
                            }
                            errors++;
                          }
                        }
                      }
                      var _valid21 = _errs274 === errors;
                      if (_valid21 && valid101) {
                        valid101 = false;
                        passing5 = [passing5, 1];
                      } else {
                        if (_valid21) {
                          valid101 = true;
                          passing5 = 1;
                        }
                      }
                      if (!valid101) {
                        const err257 = { keyword: "oneOf", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/oneOf", params: { passingSchemas: passing5 }, message: "should match exactly one schema in oneOf" };
                        if (vErrors === null) {
                          vErrors = [err257];
                        } else {
                          vErrors.push(err257);
                        }
                        errors++;
                      } else {
                        errors = _errs270;
                        if (vErrors !== null) {
                          if (_errs270) {
                            vErrors.length = _errs270;
                          } else {
                            vErrors = null;
                          }
                        }
                      }
                      if (data96 && typeof data96 == "object" && !Array.isArray(data96)) {
                        if (data96.property === void 0) {
                          const err258 = { keyword: "required", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/required", params: { missingProperty: "property" }, message: "should have required property 'property'" };
                          if (vErrors === null) {
                            vErrors = [err258];
                          } else {
                            vErrors.push(err258);
                          }
                          errors++;
                        }
                        if (data96.type !== void 0) {
                          if (!func0$1(data96.type, "simple")) {
                            const err259 = { keyword: "const", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/condition/type", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/properties/type/const", params: { allowedValue: "simple" }, message: "should be equal to constant" };
                            if (vErrors === null) {
                              vErrors = [err259];
                            } else {
                              vErrors.push(err259);
                            }
                            errors++;
                          }
                        }
                        if (data96.property !== void 0) {
                          if (typeof data96.property !== "string") {
                            const err260 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/condition/property", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/properties/property/type", params: { type: "string" }, message: "should be string" };
                            if (vErrors === null) {
                              vErrors = [err260];
                            } else {
                              vErrors.push(err260);
                            }
                            errors++;
                          }
                        }
                      } else {
                        const err261 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/type", params: { type: "object" }, message: "should be object" };
                        if (vErrors === null) {
                          vErrors = [err261];
                        } else {
                          vErrors.push(err261);
                        }
                        errors++;
                      }
                      if (errors > 0) {
                        const emErrors10 = { "required": { "property": [] } };
                        const templates10 = { required: {} };
                        let emPropParams4;
                        let emParamsErrors4;
                        for (const err262 of vErrors) {
                          if (err262.keyword !== "errorMessage" && !err262.emUsed && err262.dataPath === dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/condition" && err262.keyword in emErrors10 && err262.schemaPath.indexOf("#/definitions/properties/allOf/0/items/properties/condition") === 0 && /^\/[^\/]*$/.test(err262.schemaPath.slice(59))) {
                            emPropParams4 = obj0$1[err262.keyword];
                            emParamsErrors4 = emErrors10[err262.keyword][err262.params[emPropParams4]];
                            if (emParamsErrors4) {
                              emParamsErrors4.push(err262);
                              err262.emUsed = true;
                            }
                          }
                        }
                        for (const key10 in emErrors10) {
                          for (const keyProp4 in emErrors10[key10]) {
                            emParamsErrors4 = emErrors10[key10][keyProp4];
                            if (emParamsErrors4.length) {
                              const tmpl4 = templates10[key10] && templates10[key10][keyProp4];
                              const err263 = { keyword: "errorMessage", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/errorMessage", params: { errors: emParamsErrors4 }, message: tmpl4 ? tmpl4() : schema19.items.properties.condition.errorMessage[key10][keyProp4] };
                              if (vErrors === null) {
                                vErrors = [err263];
                              } else {
                                vErrors.push(err263);
                              }
                              errors++;
                            }
                          }
                        }
                        const emErrs38 = [];
                        for (const err264 of vErrors) {
                          if (!err264.emUsed) {
                            emErrs38.push(err264);
                          }
                        }
                        vErrors = emErrs38;
                        errors = emErrs38.length;
                      }
                    }
                  } else {
                    const err265 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i7, schemaPath: "#/definitions/properties/allOf/0/items/type", params: { type: "object" }, message: "should be object" };
                    if (vErrors === null) {
                      vErrors = [err265];
                    } else {
                      vErrors.push(err265);
                    }
                    errors++;
                  }
                }
              } else {
                const err266 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties", schemaPath: "#/definitions/properties/allOf/0/type", params: { type: "array" }, message: "should be array" };
                if (vErrors === null) {
                  vErrors = [err266];
                } else {
                  vErrors.push(err266);
                }
                errors++;
              }
              if (Array.isArray(data75)) {
                const len10 = data75.length;
                for (let i10 = 0; i10 < len10; i10++) {
                  let data102 = data75[i10];
                  const _errs288 = errors;
                  let valid112 = true;
                  const _errs289 = errors;
                  if (data102 && typeof data102 == "object" && !Array.isArray(data102)) {
                    if (data102.binding === void 0 && "binding") {
                      const err267 = {};
                      if (vErrors === null) {
                        vErrors = [err267];
                      } else {
                        vErrors.push(err267);
                      }
                      errors++;
                    } else {
                      if (data102.binding !== void 0) {
                        let data103 = data102.binding;
                        if (data103 && typeof data103 == "object" && !Array.isArray(data103)) {
                          if (data103.type === void 0 && "type") {
                            const err268 = {};
                            if (vErrors === null) {
                              vErrors = [err268];
                            } else {
                              vErrors.push(err268);
                            }
                            errors++;
                          } else {
                            if (data103.type !== void 0) {
                              if (!func0$1(data103.type, "property")) {
                                const err269 = {};
                                if (vErrors === null) {
                                  vErrors = [err269];
                                } else {
                                  vErrors.push(err269);
                                }
                                errors++;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  var _valid22 = _errs289 === errors;
                  errors = _errs288;
                  if (vErrors !== null) {
                    if (_errs288) {
                      vErrors.length = _errs288;
                    } else {
                      vErrors = null;
                    }
                  }
                  if (_valid22) {
                    const _errs292 = errors;
                    if (data102 && typeof data102 == "object" && !Array.isArray(data102)) {
                      if (data102.type !== void 0) {
                        let data105 = data102.type;
                        if (!(data105 === "String" || data105 === "Text" || data105 === "Hidden" || data105 === "Dropdown" || data105 === "Boolean")) {
                          const err270 = { keyword: "enum", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/0/then/properties/type/enum", params: { allowedValues: schema20.items.allOf[0].then.properties.type.enum }, message: "should be equal to one of the allowed values" };
                          if (vErrors === null) {
                            vErrors = [err270];
                          } else {
                            vErrors.push(err270);
                          }
                          errors++;
                        }
                        if (errors > 0) {
                          const emErrs39 = [];
                          for (const err271 of vErrors) {
                            if (err271.keyword !== "errorMessage" && !err271.emUsed && (err271.dataPath === dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/type" || err271.dataPath.indexOf(dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/type") === 0 && err271.dataPath[dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/type".length] === "/") && err271.schemaPath.indexOf("#/definitions/properties/allOf/1/items/allOf/0/then/properties/type") === 0 && err271.schemaPath["#/definitions/properties/allOf/1/items/allOf/0/then/properties/type".length] === "/") {
                              emErrs39.push(err271);
                              err271.emUsed = true;
                            }
                          }
                          if (emErrs39.length) {
                            const err272 = { keyword: "errorMessage", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/0/then/properties/type/errorMessage", params: { errors: emErrs39 }, message: "invalid property type " + JSON.stringify(data105) + ' for binding type "property"; must be any of { String, Text, Hidden, Dropdown, Boolean }' };
                            if (vErrors === null) {
                              vErrors = [err272];
                            } else {
                              vErrors.push(err272);
                            }
                            errors++;
                          }
                          const emErrs40 = [];
                          for (const err273 of vErrors) {
                            if (!err273.emUsed) {
                              emErrs40.push(err273);
                            }
                          }
                          vErrors = emErrs40;
                          errors = emErrs40.length;
                        }
                      }
                    }
                    var _valid22 = _errs292 === errors;
                    valid112 = _valid22;
                  }
                  if (!valid112) {
                    const err274 = { keyword: "if", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10, schemaPath: "#/definitions/properties/allOf/1/items/allOf/0/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                    if (vErrors === null) {
                      vErrors = [err274];
                    } else {
                      vErrors.push(err274);
                    }
                    errors++;
                  }
                  const _errs295 = errors;
                  let valid116 = true;
                  const _errs296 = errors;
                  if (data102 && typeof data102 == "object" && !Array.isArray(data102)) {
                    if (data102.binding === void 0 && "binding") {
                      const err275 = {};
                      if (vErrors === null) {
                        vErrors = [err275];
                      } else {
                        vErrors.push(err275);
                      }
                      errors++;
                    } else {
                      if (data102.binding !== void 0) {
                        let data106 = data102.binding;
                        if (data106 && typeof data106 == "object" && !Array.isArray(data106)) {
                          if (data106.type === void 0 && "type") {
                            const err276 = {};
                            if (vErrors === null) {
                              vErrors = [err276];
                            } else {
                              vErrors.push(err276);
                            }
                            errors++;
                          } else {
                            if (data106.type !== void 0) {
                              if (!func0$1(data106.type, "camunda:executionListener")) {
                                const err277 = {};
                                if (vErrors === null) {
                                  vErrors = [err277];
                                } else {
                                  vErrors.push(err277);
                                }
                                errors++;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  var _valid23 = _errs296 === errors;
                  errors = _errs295;
                  if (vErrors !== null) {
                    if (_errs295) {
                      vErrors.length = _errs295;
                    } else {
                      vErrors = null;
                    }
                  }
                  if (_valid23) {
                    const _errs299 = errors;
                    if (data102 && typeof data102 == "object" && !Array.isArray(data102)) {
                      if (data102.type !== void 0) {
                        if (!(data102.type === "Hidden")) {
                          const err278 = { keyword: "enum", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/1/then/properties/type/enum", params: { allowedValues: schema20.items.allOf[1].then.properties.type.enum }, message: "should be equal to one of the allowed values" };
                          if (vErrors === null) {
                            vErrors = [err278];
                          } else {
                            vErrors.push(err278);
                          }
                          errors++;
                        }
                        if (errors > 0) {
                          const emErrs41 = [];
                          for (const err279 of vErrors) {
                            if (err279.keyword !== "errorMessage" && !err279.emUsed && (err279.dataPath === dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/type" || err279.dataPath.indexOf(dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/type") === 0 && err279.dataPath[dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/type".length] === "/") && err279.schemaPath.indexOf("#/definitions/properties/allOf/1/items/allOf/1/then/properties/type") === 0 && err279.schemaPath["#/definitions/properties/allOf/1/items/allOf/1/then/properties/type".length] === "/") {
                              emErrs41.push(err279);
                              err279.emUsed = true;
                            }
                          }
                          if (emErrs41.length) {
                            const err280 = { keyword: "errorMessage", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/1/then/properties/type/errorMessage", params: { errors: emErrs41 }, message: "invalid property type " + JSON.stringify(data102 && data102.type) + ' for binding type "camunda:executionListener"; must be "Hidden"' };
                            if (vErrors === null) {
                              vErrors = [err280];
                            } else {
                              vErrors.push(err280);
                            }
                            errors++;
                          }
                          const emErrs42 = [];
                          for (const err281 of vErrors) {
                            if (!err281.emUsed) {
                              emErrs42.push(err281);
                            }
                          }
                          vErrors = emErrs42;
                          errors = emErrs42.length;
                        }
                      }
                    }
                    var _valid23 = _errs299 === errors;
                    valid116 = _valid23;
                  }
                  if (!valid116) {
                    const err282 = { keyword: "if", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10, schemaPath: "#/definitions/properties/allOf/1/items/allOf/1/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                    if (vErrors === null) {
                      vErrors = [err282];
                    } else {
                      vErrors.push(err282);
                    }
                    errors++;
                  }
                  const _errs302 = errors;
                  let valid120 = true;
                  const _errs303 = errors;
                  if (data102 && typeof data102 == "object" && !Array.isArray(data102)) {
                    if (data102.binding === void 0 && "binding") {
                      const err283 = {};
                      if (vErrors === null) {
                        vErrors = [err283];
                      } else {
                        vErrors.push(err283);
                      }
                      errors++;
                    } else {
                      if (data102.binding !== void 0) {
                        let data109 = data102.binding;
                        if (data109 && typeof data109 == "object" && !Array.isArray(data109)) {
                          if (data109.type === void 0 && "type") {
                            const err284 = {};
                            if (vErrors === null) {
                              vErrors = [err284];
                            } else {
                              vErrors.push(err284);
                            }
                            errors++;
                          } else {
                            if (data109.type !== void 0) {
                              let data110 = data109.type;
                              if (!(data110 === "camunda:property" || data110 === "camunda:outputParameter" || data110 === "camunda:in" || data110 === "camunda:in:businessKey" || data110 === "camunda:out" || data110 === "camunda:errorEventDefinition")) {
                                const err285 = {};
                                if (vErrors === null) {
                                  vErrors = [err285];
                                } else {
                                  vErrors.push(err285);
                                }
                                errors++;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  var _valid24 = _errs303 === errors;
                  errors = _errs302;
                  if (vErrors !== null) {
                    if (_errs302) {
                      vErrors.length = _errs302;
                    } else {
                      vErrors = null;
                    }
                  }
                  if (_valid24) {
                    const _errs306 = errors;
                    if (data102 && typeof data102 == "object" && !Array.isArray(data102)) {
                      if (data102.type !== void 0) {
                        let data111 = data102.type;
                        if (!(data111 === "String" || data111 === "Hidden" || data111 === "Dropdown")) {
                          const err286 = { keyword: "enum", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/2/then/properties/type/enum", params: { allowedValues: schema20.items.allOf[2].then.properties.type.enum }, message: "should be equal to one of the allowed values" };
                          if (vErrors === null) {
                            vErrors = [err286];
                          } else {
                            vErrors.push(err286);
                          }
                          errors++;
                        }
                        if (errors > 0) {
                          const emErrs43 = [];
                          for (const err287 of vErrors) {
                            if (err287.keyword !== "errorMessage" && !err287.emUsed && (err287.dataPath === dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/type" || err287.dataPath.indexOf(dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/type") === 0 && err287.dataPath[dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/type".length] === "/") && err287.schemaPath.indexOf("#/definitions/properties/allOf/1/items/allOf/2/then/properties/type") === 0 && err287.schemaPath["#/definitions/properties/allOf/1/items/allOf/2/then/properties/type".length] === "/") {
                              emErrs43.push(err287);
                              err287.emUsed = true;
                            }
                          }
                          if (emErrs43.length) {
                            const err288 = { keyword: "errorMessage", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/2/then/properties/type/errorMessage", params: { errors: emErrs43 }, message: "invalid property type " + JSON.stringify(data111) + " for binding type " + JSON.stringify(data102 && data102.binding && data102.binding.type) + "; must be any of { String, Hidden, Dropdown }" };
                            if (vErrors === null) {
                              vErrors = [err288];
                            } else {
                              vErrors.push(err288);
                            }
                            errors++;
                          }
                          const emErrs44 = [];
                          for (const err289 of vErrors) {
                            if (!err289.emUsed) {
                              emErrs44.push(err289);
                            }
                          }
                          vErrors = emErrs44;
                          errors = emErrs44.length;
                        }
                      }
                    }
                    var _valid24 = _errs306 === errors;
                    valid120 = _valid24;
                  }
                  if (!valid120) {
                    const err290 = { keyword: "if", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10, schemaPath: "#/definitions/properties/allOf/1/items/allOf/2/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                    if (vErrors === null) {
                      vErrors = [err290];
                    } else {
                      vErrors.push(err290);
                    }
                    errors++;
                  }
                  const _errs309 = errors;
                  let valid124 = true;
                  const _errs310 = errors;
                  if (data102 && typeof data102 == "object" && !Array.isArray(data102)) {
                    if (data102.binding === void 0 && "binding") {
                      const err291 = {};
                      if (vErrors === null) {
                        vErrors = [err291];
                      } else {
                        vErrors.push(err291);
                      }
                      errors++;
                    } else {
                      if (data102.binding !== void 0) {
                        let data112 = data102.binding;
                        if (data112 && typeof data112 == "object" && !Array.isArray(data112)) {
                          if (data112.type === void 0 && "type") {
                            const err292 = {};
                            if (vErrors === null) {
                              vErrors = [err292];
                            } else {
                              vErrors.push(err292);
                            }
                            errors++;
                          } else {
                            if (data112.type !== void 0) {
                              let data113 = data112.type;
                              if (!(data113 === "camunda:inputParameter" || data113 === "camunda:field")) {
                                const err293 = {};
                                if (vErrors === null) {
                                  vErrors = [err293];
                                } else {
                                  vErrors.push(err293);
                                }
                                errors++;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  var _valid25 = _errs310 === errors;
                  errors = _errs309;
                  if (vErrors !== null) {
                    if (_errs309) {
                      vErrors.length = _errs309;
                    } else {
                      vErrors = null;
                    }
                  }
                  if (_valid25) {
                    const _errs313 = errors;
                    if (data102 && typeof data102 == "object" && !Array.isArray(data102)) {
                      if (data102.type !== void 0) {
                        let data114 = data102.type;
                        if (!(data114 === "String" || data114 === "Text" || data114 === "Hidden" || data114 === "Dropdown")) {
                          const err294 = { keyword: "enum", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/3/then/properties/type/enum", params: { allowedValues: schema20.items.allOf[3].then.properties.type.enum }, message: "should be equal to one of the allowed values" };
                          if (vErrors === null) {
                            vErrors = [err294];
                          } else {
                            vErrors.push(err294);
                          }
                          errors++;
                        }
                        if (errors > 0) {
                          const emErrs45 = [];
                          for (const err295 of vErrors) {
                            if (err295.keyword !== "errorMessage" && !err295.emUsed && (err295.dataPath === dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/type" || err295.dataPath.indexOf(dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/type") === 0 && err295.dataPath[dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/type".length] === "/") && err295.schemaPath.indexOf("#/definitions/properties/allOf/1/items/allOf/3/then/properties/type") === 0 && err295.schemaPath["#/definitions/properties/allOf/1/items/allOf/3/then/properties/type".length] === "/") {
                              emErrs45.push(err295);
                              err295.emUsed = true;
                            }
                          }
                          if (emErrs45.length) {
                            const err296 = { keyword: "errorMessage", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/3/then/properties/type/errorMessage", params: { errors: emErrs45 }, message: "invalid property type " + JSON.stringify(data114) + " for binding type " + JSON.stringify(data102 && data102.binding && data102.binding.type) + "; must be any of { String, Text, Hidden, Dropdown }" };
                            if (vErrors === null) {
                              vErrors = [err296];
                            } else {
                              vErrors.push(err296);
                            }
                            errors++;
                          }
                          const emErrs46 = [];
                          for (const err297 of vErrors) {
                            if (!err297.emUsed) {
                              emErrs46.push(err297);
                            }
                          }
                          vErrors = emErrs46;
                          errors = emErrs46.length;
                        }
                      }
                    }
                    var _valid25 = _errs313 === errors;
                    valid124 = _valid25;
                  }
                  if (!valid124) {
                    const err298 = { keyword: "if", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10, schemaPath: "#/definitions/properties/allOf/1/items/allOf/3/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                    if (vErrors === null) {
                      vErrors = [err298];
                    } else {
                      vErrors.push(err298);
                    }
                    errors++;
                  }
                  if (data102 && typeof data102 == "object" && !Array.isArray(data102)) {
                    if (data102.binding === void 0) {
                      const err299 = { keyword: "required", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10, schemaPath: "#/definitions/properties/allOf/1/items/required", params: { missingProperty: "binding" }, message: "should have required property 'binding'" };
                      if (vErrors === null) {
                        vErrors = [err299];
                      } else {
                        vErrors.push(err299);
                      }
                      errors++;
                    }
                    if (data102.binding !== void 0) {
                      let data115 = data102.binding;
                      const _errs318 = errors;
                      let valid130 = true;
                      const _errs319 = errors;
                      if (data115 && typeof data115 == "object" && !Array.isArray(data115)) {
                        if (data115.type === void 0 && "type") {
                          const err300 = {};
                          if (vErrors === null) {
                            vErrors = [err300];
                          } else {
                            vErrors.push(err300);
                          }
                          errors++;
                        } else {
                          if (data115.type !== void 0) {
                            let data116 = data115.type;
                            if (!(data116 === "property" || data116 === "camunda:property" || data116 === "camunda:inputParameter" || data116 === "camunda:field")) {
                              const err301 = {};
                              if (vErrors === null) {
                                vErrors = [err301];
                              } else {
                                vErrors.push(err301);
                              }
                              errors++;
                            }
                          }
                        }
                      }
                      var _valid26 = _errs319 === errors;
                      errors = _errs318;
                      if (vErrors !== null) {
                        if (_errs318) {
                          vErrors.length = _errs318;
                        } else {
                          vErrors = null;
                        }
                      }
                      if (_valid26) {
                        const _errs321 = errors;
                        if (data115 && typeof data115 == "object" && !Array.isArray(data115)) {
                          if (data115.name === void 0) {
                            const err302 = { keyword: "required", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/0/then/required", params: { missingProperty: "name" }, message: "should have required property 'name'" };
                            if (vErrors === null) {
                              vErrors = [err302];
                            } else {
                              vErrors.push(err302);
                            }
                            errors++;
                          }
                        }
                        if (errors > 0) {
                          const emErrs47 = [];
                          for (const err303 of vErrors) {
                            if (err303.keyword !== "errorMessage" && !err303.emUsed && (err303.dataPath === dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding" || err303.dataPath.indexOf(dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding") === 0 && err303.dataPath[dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding".length] === "/") && err303.schemaPath.indexOf("#/definitions/properties/allOf/1/items/properties/binding/allOf/0/then") === 0 && err303.schemaPath["#/definitions/properties/allOf/1/items/properties/binding/allOf/0/then".length] === "/") {
                              emErrs47.push(err303);
                              err303.emUsed = true;
                            }
                          }
                          if (emErrs47.length) {
                            const err304 = { keyword: "errorMessage", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/0/then/errorMessage", params: { errors: emErrs47 }, message: "property.binding " + JSON.stringify(data115 && data115.type) + " requires name" };
                            if (vErrors === null) {
                              vErrors = [err304];
                            } else {
                              vErrors.push(err304);
                            }
                            errors++;
                          }
                          const emErrs48 = [];
                          for (const err305 of vErrors) {
                            if (!err305.emUsed) {
                              emErrs48.push(err305);
                            }
                          }
                          vErrors = emErrs48;
                          errors = emErrs48.length;
                        }
                        var _valid26 = _errs321 === errors;
                        valid130 = _valid26;
                      }
                      if (!valid130) {
                        const err306 = { keyword: "if", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/0/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                        if (vErrors === null) {
                          vErrors = [err306];
                        } else {
                          vErrors.push(err306);
                        }
                        errors++;
                      }
                      const _errs323 = errors;
                      let valid132 = true;
                      const _errs324 = errors;
                      if (data115 && typeof data115 == "object" && !Array.isArray(data115)) {
                        if (data115.type === void 0 && "type") {
                          const err307 = {};
                          if (vErrors === null) {
                            vErrors = [err307];
                          } else {
                            vErrors.push(err307);
                          }
                          errors++;
                        } else {
                          if (data115.type !== void 0) {
                            if (!func0$1(data115.type, "camunda:outputParameter")) {
                              const err308 = {};
                              if (vErrors === null) {
                                vErrors = [err308];
                              } else {
                                vErrors.push(err308);
                              }
                              errors++;
                            }
                          }
                        }
                      }
                      var _valid27 = _errs324 === errors;
                      errors = _errs323;
                      if (vErrors !== null) {
                        if (_errs323) {
                          vErrors.length = _errs323;
                        } else {
                          vErrors = null;
                        }
                      }
                      if (_valid27) {
                        const _errs326 = errors;
                        if (data115 && typeof data115 == "object" && !Array.isArray(data115)) {
                          if (data115.source === void 0) {
                            const err309 = { keyword: "required", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/1/then/required", params: { missingProperty: "source" }, message: "should have required property 'source'" };
                            if (vErrors === null) {
                              vErrors = [err309];
                            } else {
                              vErrors.push(err309);
                            }
                            errors++;
                          }
                        }
                        if (errors > 0) {
                          const emErrs49 = [];
                          for (const err310 of vErrors) {
                            if (err310.keyword !== "errorMessage" && !err310.emUsed && (err310.dataPath === dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding" || err310.dataPath.indexOf(dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding") === 0 && err310.dataPath[dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding".length] === "/") && err310.schemaPath.indexOf("#/definitions/properties/allOf/1/items/properties/binding/allOf/1/then") === 0 && err310.schemaPath["#/definitions/properties/allOf/1/items/properties/binding/allOf/1/then".length] === "/") {
                              emErrs49.push(err310);
                              err310.emUsed = true;
                            }
                          }
                          if (emErrs49.length) {
                            const err311 = { keyword: "errorMessage", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/1/then/errorMessage", params: { errors: emErrs49 }, message: "property.binding " + JSON.stringify(data115 && data115.type) + " requires source" };
                            if (vErrors === null) {
                              vErrors = [err311];
                            } else {
                              vErrors.push(err311);
                            }
                            errors++;
                          }
                          const emErrs50 = [];
                          for (const err312 of vErrors) {
                            if (!err312.emUsed) {
                              emErrs50.push(err312);
                            }
                          }
                          vErrors = emErrs50;
                          errors = emErrs50.length;
                        }
                        var _valid27 = _errs326 === errors;
                        valid132 = _valid27;
                      }
                      if (!valid132) {
                        const err313 = { keyword: "if", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/1/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                        if (vErrors === null) {
                          vErrors = [err313];
                        } else {
                          vErrors.push(err313);
                        }
                        errors++;
                      }
                      const _errs328 = errors;
                      let valid134 = true;
                      const _errs329 = errors;
                      if (data115 && typeof data115 == "object" && !Array.isArray(data115)) {
                        if (data115.type === void 0 && "type") {
                          const err314 = {};
                          if (vErrors === null) {
                            vErrors = [err314];
                          } else {
                            vErrors.push(err314);
                          }
                          errors++;
                        } else {
                          if (data115.type !== void 0) {
                            if (!func0$1(data115.type, "camunda:in")) {
                              const err315 = {};
                              if (vErrors === null) {
                                vErrors = [err315];
                              } else {
                                vErrors.push(err315);
                              }
                              errors++;
                            }
                          }
                        }
                      }
                      var _valid28 = _errs329 === errors;
                      errors = _errs328;
                      if (vErrors !== null) {
                        if (_errs328) {
                          vErrors.length = _errs328;
                        } else {
                          vErrors = null;
                        }
                      }
                      if (_valid28) {
                        const _errs331 = errors;
                        const _errs332 = errors;
                        let valid136 = false;
                        const _errs333 = errors;
                        if (data115 && typeof data115 == "object" && !Array.isArray(data115)) {
                          if (data115.variables === void 0) {
                            const err316 = { keyword: "required", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/2/then/anyOf/0/required", params: { missingProperty: "variables" }, message: "should have required property 'variables'" };
                            if (vErrors === null) {
                              vErrors = [err316];
                            } else {
                              vErrors.push(err316);
                            }
                            errors++;
                          }
                        }
                        var _valid29 = _errs333 === errors;
                        valid136 = valid136 || _valid29;
                        if (!valid136) {
                          const _errs334 = errors;
                          if (data115 && typeof data115 == "object" && !Array.isArray(data115)) {
                            if (data115.target === void 0) {
                              const err317 = { keyword: "required", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/2/then/anyOf/1/required", params: { missingProperty: "target" }, message: "should have required property 'target'" };
                              if (vErrors === null) {
                                vErrors = [err317];
                              } else {
                                vErrors.push(err317);
                              }
                              errors++;
                            }
                          }
                          var _valid29 = _errs334 === errors;
                          valid136 = valid136 || _valid29;
                        }
                        if (!valid136) {
                          const err318 = { keyword: "anyOf", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/2/then/anyOf", params: {}, message: "should match some schema in anyOf" };
                          if (vErrors === null) {
                            vErrors = [err318];
                          } else {
                            vErrors.push(err318);
                          }
                          errors++;
                        } else {
                          errors = _errs332;
                          if (vErrors !== null) {
                            if (_errs332) {
                              vErrors.length = _errs332;
                            } else {
                              vErrors = null;
                            }
                          }
                        }
                        if (errors > 0) {
                          const emErrs51 = [];
                          for (const err319 of vErrors) {
                            if (err319.keyword !== "errorMessage" && !err319.emUsed && (err319.dataPath === dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding" || err319.dataPath.indexOf(dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding") === 0 && err319.dataPath[dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding".length] === "/") && err319.schemaPath.indexOf("#/definitions/properties/allOf/1/items/properties/binding/allOf/2/then") === 0 && err319.schemaPath["#/definitions/properties/allOf/1/items/properties/binding/allOf/2/then".length] === "/") {
                              emErrs51.push(err319);
                              err319.emUsed = true;
                            }
                          }
                          if (emErrs51.length) {
                            const err320 = { keyword: "errorMessage", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/2/then/errorMessage", params: { errors: emErrs51 }, message: "property.binding " + JSON.stringify(data115 && data115.type) + " requires variables, target, or both" };
                            if (vErrors === null) {
                              vErrors = [err320];
                            } else {
                              vErrors.push(err320);
                            }
                            errors++;
                          }
                          const emErrs52 = [];
                          for (const err321 of vErrors) {
                            if (!err321.emUsed) {
                              emErrs52.push(err321);
                            }
                          }
                          vErrors = emErrs52;
                          errors = emErrs52.length;
                        }
                        var _valid28 = _errs331 === errors;
                        valid134 = _valid28;
                      }
                      if (!valid134) {
                        const err322 = { keyword: "if", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/2/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                        if (vErrors === null) {
                          vErrors = [err322];
                        } else {
                          vErrors.push(err322);
                        }
                        errors++;
                      }
                      const _errs336 = errors;
                      let valid137 = true;
                      const _errs337 = errors;
                      if (data115 && typeof data115 == "object" && !Array.isArray(data115)) {
                        if (data115.type === void 0 && "type") {
                          const err323 = {};
                          if (vErrors === null) {
                            vErrors = [err323];
                          } else {
                            vErrors.push(err323);
                          }
                          errors++;
                        } else {
                          if (data115.type !== void 0) {
                            if (!func0$1(data115.type, "camunda:out")) {
                              const err324 = {};
                              if (vErrors === null) {
                                vErrors = [err324];
                              } else {
                                vErrors.push(err324);
                              }
                              errors++;
                            }
                          }
                        }
                      }
                      var _valid30 = _errs337 === errors;
                      errors = _errs336;
                      if (vErrors !== null) {
                        if (_errs336) {
                          vErrors.length = _errs336;
                        } else {
                          vErrors = null;
                        }
                      }
                      if (_valid30) {
                        const _errs339 = errors;
                        const _errs340 = errors;
                        let valid139 = false;
                        let passing6 = null;
                        const _errs341 = errors;
                        const _errs342 = errors;
                        const _errs343 = errors;
                        const _errs344 = errors;
                        let valid141 = false;
                        const _errs345 = errors;
                        if (data115 && typeof data115 == "object" && !Array.isArray(data115)) {
                          if (data115.source === void 0 && "source") {
                            const err325 = {};
                            if (vErrors === null) {
                              vErrors = [err325];
                            } else {
                              vErrors.push(err325);
                            }
                            errors++;
                          }
                        }
                        var _valid32 = _errs345 === errors;
                        valid141 = valid141 || _valid32;
                        if (!valid141) {
                          const _errs346 = errors;
                          if (data115 && typeof data115 == "object" && !Array.isArray(data115)) {
                            if (data115.sourceExpression === void 0 && "sourceExpression") {
                              const err326 = {};
                              if (vErrors === null) {
                                vErrors = [err326];
                              } else {
                                vErrors.push(err326);
                              }
                              errors++;
                            }
                          }
                          var _valid32 = _errs346 === errors;
                          valid141 = valid141 || _valid32;
                        }
                        if (!valid141) {
                          const err327 = {};
                          if (vErrors === null) {
                            vErrors = [err327];
                          } else {
                            vErrors.push(err327);
                          }
                          errors++;
                        } else {
                          errors = _errs344;
                          if (vErrors !== null) {
                            if (_errs344) {
                              vErrors.length = _errs344;
                            } else {
                              vErrors = null;
                            }
                          }
                        }
                        var valid140 = _errs343 === errors;
                        if (!valid140) {
                          errors = _errs342;
                          if (vErrors !== null) {
                            if (_errs342) {
                              vErrors.length = _errs342;
                            } else {
                              vErrors = null;
                            }
                          }
                        } else {
                          const err328 = { keyword: "not", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/0/not", params: {}, message: "should NOT be valid" };
                          if (vErrors === null) {
                            vErrors = [err328];
                          } else {
                            vErrors.push(err328);
                          }
                          errors++;
                        }
                        if (data115 && typeof data115 == "object" && !Array.isArray(data115)) {
                          if (data115.variables === void 0) {
                            const err329 = { keyword: "required", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/0/required", params: { missingProperty: "variables" }, message: "should have required property 'variables'" };
                            if (vErrors === null) {
                              vErrors = [err329];
                            } else {
                              vErrors.push(err329);
                            }
                            errors++;
                          }
                        }
                        var _valid31 = _errs341 === errors;
                        if (_valid31) {
                          valid139 = true;
                          passing6 = 0;
                        }
                        const _errs347 = errors;
                        const _errs348 = errors;
                        const _errs349 = errors;
                        const _errs350 = errors;
                        let valid143 = false;
                        const _errs351 = errors;
                        if (data115 && typeof data115 == "object" && !Array.isArray(data115)) {
                          if (data115.variables === void 0 && "variables") {
                            const err330 = {};
                            if (vErrors === null) {
                              vErrors = [err330];
                            } else {
                              vErrors.push(err330);
                            }
                            errors++;
                          }
                        }
                        var _valid33 = _errs351 === errors;
                        valid143 = valid143 || _valid33;
                        if (!valid143) {
                          const _errs352 = errors;
                          if (data115 && typeof data115 == "object" && !Array.isArray(data115)) {
                            if (data115.sourceExpression === void 0 && "sourceExpression") {
                              const err331 = {};
                              if (vErrors === null) {
                                vErrors = [err331];
                              } else {
                                vErrors.push(err331);
                              }
                              errors++;
                            }
                          }
                          var _valid33 = _errs352 === errors;
                          valid143 = valid143 || _valid33;
                        }
                        if (!valid143) {
                          const err332 = {};
                          if (vErrors === null) {
                            vErrors = [err332];
                          } else {
                            vErrors.push(err332);
                          }
                          errors++;
                        } else {
                          errors = _errs350;
                          if (vErrors !== null) {
                            if (_errs350) {
                              vErrors.length = _errs350;
                            } else {
                              vErrors = null;
                            }
                          }
                        }
                        var valid142 = _errs349 === errors;
                        if (!valid142) {
                          errors = _errs348;
                          if (vErrors !== null) {
                            if (_errs348) {
                              vErrors.length = _errs348;
                            } else {
                              vErrors = null;
                            }
                          }
                        } else {
                          const err333 = { keyword: "not", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/1/not", params: {}, message: "should NOT be valid" };
                          if (vErrors === null) {
                            vErrors = [err333];
                          } else {
                            vErrors.push(err333);
                          }
                          errors++;
                        }
                        if (data115 && typeof data115 == "object" && !Array.isArray(data115)) {
                          if (data115.source === void 0) {
                            const err334 = { keyword: "required", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/1/required", params: { missingProperty: "source" }, message: "should have required property 'source'" };
                            if (vErrors === null) {
                              vErrors = [err334];
                            } else {
                              vErrors.push(err334);
                            }
                            errors++;
                          }
                        }
                        var _valid31 = _errs347 === errors;
                        if (_valid31 && valid139) {
                          valid139 = false;
                          passing6 = [passing6, 1];
                        } else {
                          if (_valid31) {
                            valid139 = true;
                            passing6 = 1;
                          }
                          const _errs353 = errors;
                          const _errs354 = errors;
                          const _errs355 = errors;
                          const _errs356 = errors;
                          let valid145 = false;
                          const _errs357 = errors;
                          if (data115 && typeof data115 == "object" && !Array.isArray(data115)) {
                            if (data115.variables === void 0 && "variables") {
                              const err335 = {};
                              if (vErrors === null) {
                                vErrors = [err335];
                              } else {
                                vErrors.push(err335);
                              }
                              errors++;
                            }
                          }
                          var _valid34 = _errs357 === errors;
                          valid145 = valid145 || _valid34;
                          if (!valid145) {
                            const _errs358 = errors;
                            if (data115 && typeof data115 == "object" && !Array.isArray(data115)) {
                              if (data115.source === void 0 && "source") {
                                const err336 = {};
                                if (vErrors === null) {
                                  vErrors = [err336];
                                } else {
                                  vErrors.push(err336);
                                }
                                errors++;
                              }
                            }
                            var _valid34 = _errs358 === errors;
                            valid145 = valid145 || _valid34;
                          }
                          if (!valid145) {
                            const err337 = {};
                            if (vErrors === null) {
                              vErrors = [err337];
                            } else {
                              vErrors.push(err337);
                            }
                            errors++;
                          } else {
                            errors = _errs356;
                            if (vErrors !== null) {
                              if (_errs356) {
                                vErrors.length = _errs356;
                              } else {
                                vErrors = null;
                              }
                            }
                          }
                          var valid144 = _errs355 === errors;
                          if (!valid144) {
                            errors = _errs354;
                            if (vErrors !== null) {
                              if (_errs354) {
                                vErrors.length = _errs354;
                              } else {
                                vErrors = null;
                              }
                            }
                          } else {
                            const err338 = { keyword: "not", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/2/not", params: {}, message: "should NOT be valid" };
                            if (vErrors === null) {
                              vErrors = [err338];
                            } else {
                              vErrors.push(err338);
                            }
                            errors++;
                          }
                          if (data115 && typeof data115 == "object" && !Array.isArray(data115)) {
                            if (data115.sourceExpression === void 0) {
                              const err339 = { keyword: "required", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/2/required", params: { missingProperty: "sourceExpression" }, message: "should have required property 'sourceExpression'" };
                              if (vErrors === null) {
                                vErrors = [err339];
                              } else {
                                vErrors.push(err339);
                              }
                              errors++;
                            }
                          }
                          var _valid31 = _errs353 === errors;
                          if (_valid31 && valid139) {
                            valid139 = false;
                            passing6 = [passing6, 2];
                          } else {
                            if (_valid31) {
                              valid139 = true;
                              passing6 = 2;
                            }
                            const _errs359 = errors;
                            const _errs360 = errors;
                            const _errs361 = errors;
                            if (data115 && typeof data115 == "object" && !Array.isArray(data115)) {
                              if (data115.source === void 0 && "source") {
                                const err340 = {};
                                if (vErrors === null) {
                                  vErrors = [err340];
                                } else {
                                  vErrors.push(err340);
                                }
                                errors++;
                              }
                            }
                            var valid146 = _errs361 === errors;
                            if (!valid146) {
                              errors = _errs360;
                              if (vErrors !== null) {
                                if (_errs360) {
                                  vErrors.length = _errs360;
                                } else {
                                  vErrors = null;
                                }
                              }
                            } else {
                              const err341 = { keyword: "not", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/3/not", params: {}, message: "should NOT be valid" };
                              if (vErrors === null) {
                                vErrors = [err341];
                              } else {
                                vErrors.push(err341);
                              }
                              errors++;
                            }
                            if (data115 && typeof data115 == "object" && !Array.isArray(data115)) {
                              if (data115.variables === void 0) {
                                const err342 = { keyword: "required", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/3/required", params: { missingProperty: "variables" }, message: "should have required property 'variables'" };
                                if (vErrors === null) {
                                  vErrors = [err342];
                                } else {
                                  vErrors.push(err342);
                                }
                                errors++;
                              }
                              if (data115.sourceExpression === void 0) {
                                const err343 = { keyword: "required", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/3/required", params: { missingProperty: "sourceExpression" }, message: "should have required property 'sourceExpression'" };
                                if (vErrors === null) {
                                  vErrors = [err343];
                                } else {
                                  vErrors.push(err343);
                                }
                                errors++;
                              }
                            }
                            var _valid31 = _errs359 === errors;
                            if (_valid31 && valid139) {
                              valid139 = false;
                              passing6 = [passing6, 3];
                            } else {
                              if (_valid31) {
                                valid139 = true;
                                passing6 = 3;
                              }
                              const _errs362 = errors;
                              const _errs363 = errors;
                              const _errs364 = errors;
                              if (data115 && typeof data115 == "object" && !Array.isArray(data115)) {
                                if (data115.sourceExpression === void 0 && "sourceExpression") {
                                  const err344 = {};
                                  if (vErrors === null) {
                                    vErrors = [err344];
                                  } else {
                                    vErrors.push(err344);
                                  }
                                  errors++;
                                }
                              }
                              var valid147 = _errs364 === errors;
                              if (!valid147) {
                                errors = _errs363;
                                if (vErrors !== null) {
                                  if (_errs363) {
                                    vErrors.length = _errs363;
                                  } else {
                                    vErrors = null;
                                  }
                                }
                              } else {
                                const err345 = { keyword: "not", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/4/not", params: {}, message: "should NOT be valid" };
                                if (vErrors === null) {
                                  vErrors = [err345];
                                } else {
                                  vErrors.push(err345);
                                }
                                errors++;
                              }
                              if (data115 && typeof data115 == "object" && !Array.isArray(data115)) {
                                if (data115.variables === void 0) {
                                  const err346 = { keyword: "required", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/4/required", params: { missingProperty: "variables" }, message: "should have required property 'variables'" };
                                  if (vErrors === null) {
                                    vErrors = [err346];
                                  } else {
                                    vErrors.push(err346);
                                  }
                                  errors++;
                                }
                                if (data115.source === void 0) {
                                  const err347 = { keyword: "required", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/4/required", params: { missingProperty: "source" }, message: "should have required property 'source'" };
                                  if (vErrors === null) {
                                    vErrors = [err347];
                                  } else {
                                    vErrors.push(err347);
                                  }
                                  errors++;
                                }
                              }
                              var _valid31 = _errs362 === errors;
                              if (_valid31 && valid139) {
                                valid139 = false;
                                passing6 = [passing6, 4];
                              } else {
                                if (_valid31) {
                                  valid139 = true;
                                  passing6 = 4;
                                }
                              }
                            }
                          }
                        }
                        if (!valid139) {
                          const err348 = { keyword: "oneOf", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf", params: { passingSchemas: passing6 }, message: "should match exactly one schema in oneOf" };
                          if (vErrors === null) {
                            vErrors = [err348];
                          } else {
                            vErrors.push(err348);
                          }
                          errors++;
                        } else {
                          errors = _errs340;
                          if (vErrors !== null) {
                            if (_errs340) {
                              vErrors.length = _errs340;
                            } else {
                              vErrors = null;
                            }
                          }
                        }
                        if (errors > 0) {
                          const emErrs53 = [];
                          for (const err349 of vErrors) {
                            if (err349.keyword !== "errorMessage" && !err349.emUsed && (err349.dataPath === dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding" || err349.dataPath.indexOf(dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding") === 0 && err349.dataPath[dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding".length] === "/") && err349.schemaPath.indexOf("#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then") === 0 && err349.schemaPath["#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then".length] === "/") {
                              emErrs53.push(err349);
                              err349.emUsed = true;
                            }
                          }
                          if (emErrs53.length) {
                            const err350 = { keyword: "errorMessage", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/errorMessage", params: { errors: emErrs53 }, message: "property.binding " + JSON.stringify(data115 && data115.type) + " requires one of the following: variables, sourceExpression, source, (sourceExpression and variables), or (source and variables)" };
                            if (vErrors === null) {
                              vErrors = [err350];
                            } else {
                              vErrors.push(err350);
                            }
                            errors++;
                          }
                          const emErrs54 = [];
                          for (const err351 of vErrors) {
                            if (!err351.emUsed) {
                              emErrs54.push(err351);
                            }
                          }
                          vErrors = emErrs54;
                          errors = emErrs54.length;
                        }
                        var _valid30 = _errs339 === errors;
                        valid137 = _valid30;
                      }
                      if (!valid137) {
                        const err352 = { keyword: "if", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                        if (vErrors === null) {
                          vErrors = [err352];
                        } else {
                          vErrors.push(err352);
                        }
                        errors++;
                      }
                      const _errs366 = errors;
                      let valid148 = true;
                      const _errs367 = errors;
                      if (data115 && typeof data115 == "object" && !Array.isArray(data115)) {
                        if (data115.type === void 0 && "type") {
                          const err353 = {};
                          if (vErrors === null) {
                            vErrors = [err353];
                          } else {
                            vErrors.push(err353);
                          }
                          errors++;
                        } else {
                          if (data115.type !== void 0) {
                            if (!func0$1(data115.type, "camunda:errorEventDefinition")) {
                              const err354 = {};
                              if (vErrors === null) {
                                vErrors = [err354];
                              } else {
                                vErrors.push(err354);
                              }
                              errors++;
                            }
                          }
                        }
                      }
                      var _valid35 = _errs367 === errors;
                      errors = _errs366;
                      if (vErrors !== null) {
                        if (_errs366) {
                          vErrors.length = _errs366;
                        } else {
                          vErrors = null;
                        }
                      }
                      if (_valid35) {
                        const _errs369 = errors;
                        const _errs370 = errors;
                        let valid150 = false;
                        let passing7 = null;
                        const _errs371 = errors;
                        if (data115 && typeof data115 == "object" && !Array.isArray(data115)) {
                          if (data115.errorRef === void 0) {
                            const err355 = { keyword: "required", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/4/then/oneOf/0/required", params: { missingProperty: "errorRef" }, message: "should have required property 'errorRef'" };
                            if (vErrors === null) {
                              vErrors = [err355];
                            } else {
                              vErrors.push(err355);
                            }
                            errors++;
                          }
                        }
                        var _valid36 = _errs371 === errors;
                        if (_valid36) {
                          valid150 = true;
                          passing7 = 0;
                        }
                        if (!valid150) {
                          const err356 = { keyword: "oneOf", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/4/then/oneOf", params: { passingSchemas: passing7 }, message: "should match exactly one schema in oneOf" };
                          if (vErrors === null) {
                            vErrors = [err356];
                          } else {
                            vErrors.push(err356);
                          }
                          errors++;
                        } else {
                          errors = _errs370;
                          if (vErrors !== null) {
                            if (_errs370) {
                              vErrors.length = _errs370;
                            } else {
                              vErrors = null;
                            }
                          }
                        }
                        if (errors > 0) {
                          const emErrs55 = [];
                          for (const err357 of vErrors) {
                            if (err357.keyword !== "errorMessage" && !err357.emUsed && (err357.dataPath === dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding" || err357.dataPath.indexOf(dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding") === 0 && err357.dataPath[dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding".length] === "/") && err357.schemaPath.indexOf("#/definitions/properties/allOf/1/items/properties/binding/allOf/4/then") === 0 && err357.schemaPath["#/definitions/properties/allOf/1/items/properties/binding/allOf/4/then".length] === "/") {
                              emErrs55.push(err357);
                              err357.emUsed = true;
                            }
                          }
                          if (emErrs55.length) {
                            const err358 = { keyword: "errorMessage", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/4/then/errorMessage", params: { errors: emErrs55 }, message: "property.binding " + JSON.stringify(data115 && data115.type) + " requires errorRef" };
                            if (vErrors === null) {
                              vErrors = [err358];
                            } else {
                              vErrors.push(err358);
                            }
                            errors++;
                          }
                          const emErrs56 = [];
                          for (const err359 of vErrors) {
                            if (!err359.emUsed) {
                              emErrs56.push(err359);
                            }
                          }
                          vErrors = emErrs56;
                          errors = emErrs56.length;
                        }
                        var _valid35 = _errs369 === errors;
                        valid148 = _valid35;
                      }
                      if (!valid148) {
                        const err360 = { keyword: "if", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/4/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                        if (vErrors === null) {
                          vErrors = [err360];
                        } else {
                          vErrors.push(err360);
                        }
                        errors++;
                      }
                      if (data115 && typeof data115 == "object" && !Array.isArray(data115)) {
                        if (data115.type === void 0) {
                          const err361 = { keyword: "required", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/required", params: { missingProperty: "type" }, message: "should have required property 'type'" };
                          if (vErrors === null) {
                            vErrors = [err361];
                          } else {
                            vErrors.push(err361);
                          }
                          errors++;
                        }
                        if (data115.type !== void 0) {
                          let data121 = data115.type;
                          if (typeof data121 !== "string") {
                            const err362 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding/type", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/type/type", params: { type: "string" }, message: "should be string" };
                            if (vErrors === null) {
                              vErrors = [err362];
                            } else {
                              vErrors.push(err362);
                            }
                            errors++;
                          }
                          if (!(data121 === "property" || data121 === "camunda:property" || data121 === "camunda:inputParameter" || data121 === "camunda:outputParameter" || data121 === "camunda:in" || data121 === "camunda:out" || data121 === "camunda:in:businessKey" || data121 === "camunda:executionListener" || data121 === "camunda:field" || data121 === "camunda:errorEventDefinition")) {
                            const err363 = { keyword: "enum", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding/type", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/type/enum", params: { allowedValues: schema20.items.properties.binding.properties.type.enum }, message: "should be equal to one of the allowed values" };
                            if (vErrors === null) {
                              vErrors = [err363];
                            } else {
                              vErrors.push(err363);
                            }
                            errors++;
                          }
                          if (errors > 0) {
                            const emErrs57 = [];
                            for (const err364 of vErrors) {
                              if (err364.keyword !== "errorMessage" && !err364.emUsed && (err364.dataPath === dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding/type" || err364.dataPath.indexOf(dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding/type") === 0 && err364.dataPath[dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding/type".length] === "/") && err364.schemaPath.indexOf("#/definitions/properties/allOf/1/items/properties/binding/properties/type") === 0 && err364.schemaPath["#/definitions/properties/allOf/1/items/properties/binding/properties/type".length] === "/") {
                                emErrs57.push(err364);
                                err364.emUsed = true;
                              }
                            }
                            if (emErrs57.length) {
                              const err365 = { keyword: "errorMessage", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding/type", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/type/errorMessage", params: { errors: emErrs57 }, message: "invalid property.binding type " + JSON.stringify(data121) + "; must be any of { property, camunda:property, camunda:inputParameter, camunda:outputParameter, camunda:in, camunda:out, camunda:in:businessKey, camunda:executionListener, camunda:field, camunda:errorEventDefinition }" };
                              if (vErrors === null) {
                                vErrors = [err365];
                              } else {
                                vErrors.push(err365);
                              }
                              errors++;
                            }
                            const emErrs58 = [];
                            for (const err366 of vErrors) {
                              if (!err366.emUsed) {
                                emErrs58.push(err366);
                              }
                            }
                            vErrors = emErrs58;
                            errors = emErrs58.length;
                          }
                        }
                        if (data115.name !== void 0) {
                          if (typeof data115.name !== "string") {
                            const err367 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding/name", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/name/type", params: { type: "string" }, message: "should be string" };
                            if (vErrors === null) {
                              vErrors = [err367];
                            } else {
                              vErrors.push(err367);
                            }
                            errors++;
                          }
                        }
                        if (data115.event !== void 0) {
                          if (typeof data115.event !== "string") {
                            const err368 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding/event", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/event/type", params: { type: "string" }, message: "should be string" };
                            if (vErrors === null) {
                              vErrors = [err368];
                            } else {
                              vErrors.push(err368);
                            }
                            errors++;
                          }
                        }
                        if (data115.scriptFormat !== void 0) {
                          if (typeof data115.scriptFormat !== "string") {
                            const err369 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding/scriptFormat", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/scriptFormat/type", params: { type: "string" }, message: "should be string" };
                            if (vErrors === null) {
                              vErrors = [err369];
                            } else {
                              vErrors.push(err369);
                            }
                            errors++;
                          }
                        }
                        if (data115.source !== void 0) {
                          if (typeof data115.source !== "string") {
                            const err370 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding/source", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/source/type", params: { type: "string" }, message: "should be string" };
                            if (vErrors === null) {
                              vErrors = [err370];
                            } else {
                              vErrors.push(err370);
                            }
                            errors++;
                          }
                        }
                        if (data115.target !== void 0) {
                          if (typeof data115.target !== "string") {
                            const err371 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding/target", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/target/type", params: { type: "string" }, message: "should be string" };
                            if (vErrors === null) {
                              vErrors = [err371];
                            } else {
                              vErrors.push(err371);
                            }
                            errors++;
                          }
                        }
                        if (data115.expression !== void 0) {
                          if (typeof data115.expression !== "boolean") {
                            const err372 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding/expression", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/expression/type", params: { type: "boolean" }, message: "should be boolean" };
                            if (vErrors === null) {
                              vErrors = [err372];
                            } else {
                              vErrors.push(err372);
                            }
                            errors++;
                          }
                        }
                        if (data115.variables !== void 0) {
                          let data128 = data115.variables;
                          if (typeof data128 !== "string") {
                            const err373 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding/variables", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/variables/type", params: { type: "string" }, message: "should be string" };
                            if (vErrors === null) {
                              vErrors = [err373];
                            } else {
                              vErrors.push(err373);
                            }
                            errors++;
                          }
                          if (!(data128 === "all" || data128 === "local")) {
                            const err374 = { keyword: "enum", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding/variables", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/variables/enum", params: { allowedValues: schema20.items.properties.binding.properties.variables.enum }, message: "should be equal to one of the allowed values" };
                            if (vErrors === null) {
                              vErrors = [err374];
                            } else {
                              vErrors.push(err374);
                            }
                            errors++;
                          }
                        }
                        if (data115.sourceExpression !== void 0) {
                          if (typeof data115.sourceExpression !== "string") {
                            const err375 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding/sourceExpression", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/sourceExpression/type", params: { type: "string" }, message: "should be string" };
                            if (vErrors === null) {
                              vErrors = [err375];
                            } else {
                              vErrors.push(err375);
                            }
                            errors++;
                          }
                        }
                      } else {
                        const err376 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/type", params: { type: "object" }, message: "should be object" };
                        if (vErrors === null) {
                          vErrors = [err376];
                        } else {
                          vErrors.push(err376);
                        }
                        errors++;
                      }
                    }
                  } else {
                    const err377 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10, schemaPath: "#/definitions/properties/allOf/1/items/type", params: { type: "object" }, message: "should be object" };
                    if (vErrors === null) {
                      vErrors = [err377];
                    } else {
                      vErrors.push(err377);
                    }
                    errors++;
                  }
                  if (errors > 0) {
                    const emErrors11 = { "required": [] };
                    const templates11 = { required: function() {
                      return 'missing binding for property "' + JSON.stringify(i10) + '"';
                    } };
                    for (const err378 of vErrors) {
                      if (err378.keyword !== "errorMessage" && !err378.emUsed && err378.dataPath === dataPath + "/scopes/" + i6 + "/properties/" + i10 && err378.keyword in emErrors11 && err378.schemaPath.indexOf("#/definitions/properties/allOf/1/items") === 0 && /^\/[^\/]*$/.test(err378.schemaPath.slice(38))) {
                        emErrors11[err378.keyword].push(err378);
                        err378.emUsed = true;
                      }
                    }
                    for (const key11 in emErrors11) {
                      if (emErrors11[key11].length) {
                        const err379 = { keyword: "errorMessage", dataPath: dataPath + "/scopes/" + i6 + "/properties/" + i10, schemaPath: "#/definitions/properties/allOf/1/items/errorMessage", params: { errors: emErrors11[key11] }, message: key11 in templates11 ? templates11[key11]() : schema20.items.errorMessage[key11] };
                        if (vErrors === null) {
                          vErrors = [err379];
                        } else {
                          vErrors.push(err379);
                        }
                        errors++;
                      }
                    }
                    const emErrs59 = [];
                    for (const err380 of vErrors) {
                      if (!err380.emUsed) {
                        emErrs59.push(err380);
                      }
                    }
                    vErrors = emErrs59;
                    errors = emErrs59.length;
                  }
                }
              } else {
                const err381 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6 + "/properties", schemaPath: "#/definitions/properties/allOf/1/type", params: { type: "array" }, message: "should be array" };
                if (vErrors === null) {
                  vErrors = [err381];
                } else {
                  vErrors.push(err381);
                }
                errors++;
              }
            }
          } else {
            const err382 = { keyword: "type", dataPath: dataPath + "/scopes/" + i6, schemaPath: "#/properties/scopes/items/type", params: { type: "object" }, message: "should be object" };
            if (vErrors === null) {
              vErrors = [err382];
            } else {
              vErrors.push(err382);
            }
            errors++;
          }
          if (errors > 0) {
            const emErrors12 = { "required": { "type": [], "properties": [] } };
            const templates12 = { required: { properties: function() {
              return "invalid scope " + JSON.stringify(data72 && data72.type) + ", missing properties=[]";
            } } };
            let emPropParams5;
            let emParamsErrors5;
            for (const err383 of vErrors) {
              if (err383.keyword !== "errorMessage" && !err383.emUsed && err383.dataPath === dataPath + "/scopes/" + i6 && err383.keyword in emErrors12 && err383.schemaPath.indexOf("#/properties/scopes/items") === 0 && /^\/[^\/]*$/.test(err383.schemaPath.slice(25))) {
                emPropParams5 = obj0$1[err383.keyword];
                emParamsErrors5 = emErrors12[err383.keyword][err383.params[emPropParams5]];
                if (emParamsErrors5) {
                  emParamsErrors5.push(err383);
                  err383.emUsed = true;
                }
              }
            }
            for (const key12 in emErrors12) {
              for (const keyProp5 in emErrors12[key12]) {
                emParamsErrors5 = emErrors12[key12][keyProp5];
                if (emParamsErrors5.length) {
                  const tmpl5 = templates12[key12] && templates12[key12][keyProp5];
                  const err384 = { keyword: "errorMessage", dataPath: dataPath + "/scopes/" + i6, schemaPath: "#/properties/scopes/items/errorMessage", params: { errors: emParamsErrors5 }, message: tmpl5 ? tmpl5() : schema17$1.properties.scopes.items.errorMessage[key12][keyProp5] };
                  if (vErrors === null) {
                    vErrors = [err384];
                  } else {
                    vErrors.push(err384);
                  }
                  errors++;
                }
              }
            }
            const emErrs60 = [];
            for (const err385 of vErrors) {
              if (!err385.emUsed) {
                emErrs60.push(err385);
              }
            }
            vErrors = emErrs60;
            errors = emErrs60.length;
          }
        }
      } else {
        const err386 = { keyword: "type", dataPath: dataPath + "/scopes", schemaPath: "#/properties/scopes/type", params: { type: "array" }, message: "should be array" };
        if (vErrors === null) {
          vErrors = [err386];
        } else {
          vErrors.push(err386);
        }
        errors++;
      }
    }
  } else {
    const err387 = { keyword: "type", dataPath, schemaPath: "#/type", params: { type: "object" }, message: "should be object" };
    if (vErrors === null) {
      vErrors = [err387];
    } else {
      vErrors.push(err387);
    }
    errors++;
  }
  validate15$1.errors = vErrors;
  return errors === 0;
}
function validate14$1(data, { dataPath = "", parentData, parentDataProperty, rootData = data } = {}) {
  let vErrors = null;
  let errors = 0;
  const _errs0 = errors;
  let valid0 = false;
  let passing0 = null;
  const _errs1 = errors;
  if (!validate15$1(data, { dataPath, parentData, parentDataProperty, rootData })) {
    vErrors = vErrors === null ? validate15$1.errors : vErrors.concat(validate15$1.errors);
    errors = vErrors.length;
  }
  var _valid0 = _errs1 === errors;
  if (_valid0) {
    valid0 = true;
    passing0 = 0;
  }
  const _errs2 = errors;
  if (Array.isArray(data)) {
    const len0 = data.length;
    for (let i0 = 0; i0 < len0; i0++) {
      if (!validate15$1(data[i0], { dataPath: dataPath + "/" + i0, parentData: data, parentDataProperty: i0, rootData })) {
        vErrors = vErrors === null ? validate15$1.errors : vErrors.concat(validate15$1.errors);
        errors = vErrors.length;
      }
    }
  } else {
    const err0 = { keyword: "type", dataPath, schemaPath: "#/oneOf/1/type", params: { type: "array" }, message: "should be array" };
    if (vErrors === null) {
      vErrors = [err0];
    } else {
      vErrors.push(err0);
    }
    errors++;
  }
  var _valid0 = _errs2 === errors;
  if (_valid0 && valid0) {
    valid0 = false;
    passing0 = [passing0, 1];
  } else {
    if (_valid0) {
      valid0 = true;
      passing0 = 1;
    }
  }
  if (!valid0) {
    const err1 = { keyword: "oneOf", dataPath, schemaPath: "#/oneOf", params: { passingSchemas: passing0 }, message: "should match exactly one schema in oneOf" };
    if (vErrors === null) {
      vErrors = [err1];
    } else {
      vErrors.push(err1);
    }
    errors++;
  } else {
    errors = _errs0;
    if (vErrors !== null) {
      if (_errs0) {
        vErrors.length = _errs0;
      } else {
        vErrors = null;
      }
    }
  }
  validate14$1.errors = vErrors;
  return errors === 0;
}
var jsonSourceMap = {};
var escapedChars = {
  "b": "\b",
  "f": "\f",
  "n": "\n",
  "r": "\r",
  "t": "	",
  '"': '"',
  "/": "/",
  "\\": "\\"
};
var A_CODE = "a".charCodeAt();
jsonSourceMap.parse = function(source, _5, options2) {
  var pointers = {};
  var line = 0;
  var column = 0;
  var pos = 0;
  var bigint = options2 && options2.bigint && typeof BigInt != "undefined";
  return {
    data: _parse("", true),
    pointers
  };
  function _parse(ptr, topLevel) {
    whitespace();
    var data;
    map14(ptr, "value");
    var char = getChar();
    switch (char) {
      case "t":
        read("rue");
        data = true;
        break;
      case "f":
        read("alse");
        data = false;
        break;
      case "n":
        read("ull");
        data = null;
        break;
      case '"':
        data = parseString();
        break;
      case "[":
        data = parseArray(ptr);
        break;
      case "{":
        data = parseObject(ptr);
        break;
      default:
        backChar();
        if ("-0123456789".indexOf(char) >= 0)
          data = parseNumber();
        else
          unexpectedToken();
    }
    map14(ptr, "valueEnd");
    whitespace();
    if (topLevel && pos < source.length)
      unexpectedToken();
    return data;
  }
  function whitespace() {
    loop:
      while (pos < source.length) {
        switch (source[pos]) {
          case " ":
            column++;
            break;
          case "	":
            column += 4;
            break;
          case "\r":
            column = 0;
            break;
          case "\n":
            column = 0;
            line++;
            break;
          default:
            break loop;
        }
        pos++;
      }
  }
  function parseString() {
    var str = "";
    var char;
    while (true) {
      char = getChar();
      if (char == '"') {
        break;
      } else if (char == "\\") {
        char = getChar();
        if (char in escapedChars)
          str += escapedChars[char];
        else if (char == "u")
          str += getCharCode();
        else
          wasUnexpectedToken();
      } else {
        str += char;
      }
    }
    return str;
  }
  function parseNumber() {
    var numStr = "";
    var integer = true;
    if (source[pos] == "-")
      numStr += getChar();
    numStr += source[pos] == "0" ? getChar() : getDigits();
    if (source[pos] == ".") {
      numStr += getChar() + getDigits();
      integer = false;
    }
    if (source[pos] == "e" || source[pos] == "E") {
      numStr += getChar();
      if (source[pos] == "+" || source[pos] == "-")
        numStr += getChar();
      numStr += getDigits();
      integer = false;
    }
    var result = +numStr;
    return bigint && integer && (result > Number.MAX_SAFE_INTEGER || result < Number.MIN_SAFE_INTEGER) ? BigInt(numStr) : result;
  }
  function parseArray(ptr) {
    whitespace();
    var arr = [];
    var i6 = 0;
    if (getChar() == "]")
      return arr;
    backChar();
    while (true) {
      var itemPtr = ptr + "/" + i6;
      arr.push(_parse(itemPtr));
      whitespace();
      var char = getChar();
      if (char == "]")
        break;
      if (char != ",")
        wasUnexpectedToken();
      whitespace();
      i6++;
    }
    return arr;
  }
  function parseObject(ptr) {
    whitespace();
    var obj = {};
    if (getChar() == "}")
      return obj;
    backChar();
    while (true) {
      var loc = getLoc();
      if (getChar() != '"')
        wasUnexpectedToken();
      var key = parseString();
      var propPtr = ptr + "/" + escapeJsonPointer(key);
      mapLoc(propPtr, "key", loc);
      map14(propPtr, "keyEnd");
      whitespace();
      if (getChar() != ":")
        wasUnexpectedToken();
      whitespace();
      obj[key] = _parse(propPtr);
      whitespace();
      var char = getChar();
      if (char == "}")
        break;
      if (char != ",")
        wasUnexpectedToken();
      whitespace();
    }
    return obj;
  }
  function read(str) {
    for (var i6 = 0; i6 < str.length; i6++)
      if (getChar() !== str[i6])
        wasUnexpectedToken();
  }
  function getChar() {
    checkUnexpectedEnd();
    var char = source[pos];
    pos++;
    column++;
    return char;
  }
  function backChar() {
    pos--;
    column--;
  }
  function getCharCode() {
    var count = 4;
    var code = 0;
    while (count--) {
      code <<= 4;
      var char = getChar().toLowerCase();
      if (char >= "a" && char <= "f")
        code += char.charCodeAt() - A_CODE + 10;
      else if (char >= "0" && char <= "9")
        code += +char;
      else
        wasUnexpectedToken();
    }
    return String.fromCharCode(code);
  }
  function getDigits() {
    var digits = "";
    while (source[pos] >= "0" && source[pos] <= "9")
      digits += getChar();
    if (digits.length)
      return digits;
    checkUnexpectedEnd();
    unexpectedToken();
  }
  function map14(ptr, prop) {
    mapLoc(ptr, prop, getLoc());
  }
  function mapLoc(ptr, prop, loc) {
    pointers[ptr] = pointers[ptr] || {};
    pointers[ptr][prop] = loc;
  }
  function getLoc() {
    return {
      line,
      column,
      pos
    };
  }
  function unexpectedToken() {
    throw new SyntaxError("Unexpected token " + source[pos] + " in JSON at position " + pos);
  }
  function wasUnexpectedToken() {
    backChar();
    unexpectedToken();
  }
  function checkUnexpectedEnd() {
    if (pos >= source.length)
      throw new SyntaxError("Unexpected end of JSON input");
  }
};
jsonSourceMap.stringify = function(data, _5, options2) {
  if (!validType(data))
    return;
  var wsLine = 0;
  var wsPos, wsColumn;
  var whitespace = typeof options2 == "object" ? options2.space : options2;
  switch (typeof whitespace) {
    case "number":
      var len = whitespace > 10 ? 10 : whitespace < 0 ? 0 : Math.floor(whitespace);
      whitespace = len && repeat(len, " ");
      wsPos = len;
      wsColumn = len;
      break;
    case "string":
      whitespace = whitespace.slice(0, 10);
      wsPos = 0;
      wsColumn = 0;
      for (var j6 = 0; j6 < whitespace.length; j6++) {
        var char = whitespace[j6];
        switch (char) {
          case " ":
            wsColumn++;
            break;
          case "	":
            wsColumn += 4;
            break;
          case "\r":
            wsColumn = 0;
            break;
          case "\n":
            wsColumn = 0;
            wsLine++;
            break;
          default:
            throw new Error("whitespace characters not allowed in JSON");
        }
        wsPos++;
      }
      break;
    default:
      whitespace = void 0;
  }
  var json = "";
  var pointers = {};
  var line = 0;
  var column = 0;
  var pos = 0;
  var es6 = options2 && options2.es6 && typeof Map == "function";
  _stringify(data, 0, "");
  return {
    json,
    pointers
  };
  function _stringify(_data, lvl, ptr) {
    map14(ptr, "value");
    switch (typeof _data) {
      case "number":
      case "bigint":
      case "boolean":
        out("" + _data);
        break;
      case "string":
        out(quoted(_data));
        break;
      case "object":
        if (_data === null) {
          out("null");
        } else if (typeof _data.toJSON == "function") {
          out(quoted(_data.toJSON()));
        } else if (Array.isArray(_data)) {
          stringifyArray();
        } else if (es6) {
          if (_data.constructor.BYTES_PER_ELEMENT)
            stringifyArray();
          else if (_data instanceof Map)
            stringifyMapSet();
          else if (_data instanceof Set)
            stringifyMapSet(true);
          else
            stringifyObject();
        } else {
          stringifyObject();
        }
    }
    map14(ptr, "valueEnd");
    function stringifyArray() {
      if (_data.length) {
        out("[");
        var itemLvl = lvl + 1;
        for (var i6 = 0; i6 < _data.length; i6++) {
          if (i6)
            out(",");
          indent2(itemLvl);
          var item = validType(_data[i6]) ? _data[i6] : null;
          var itemPtr = ptr + "/" + i6;
          _stringify(item, itemLvl, itemPtr);
        }
        indent2(lvl);
        out("]");
      } else {
        out("[]");
      }
    }
    function stringifyObject() {
      var keys4 = Object.keys(_data);
      if (keys4.length) {
        out("{");
        var propLvl = lvl + 1;
        for (var i6 = 0; i6 < keys4.length; i6++) {
          var key = keys4[i6];
          var value = _data[key];
          if (validType(value)) {
            if (i6)
              out(",");
            var propPtr = ptr + "/" + escapeJsonPointer(key);
            indent2(propLvl);
            map14(propPtr, "key");
            out(quoted(key));
            map14(propPtr, "keyEnd");
            out(":");
            if (whitespace)
              out(" ");
            _stringify(value, propLvl, propPtr);
          }
        }
        indent2(lvl);
        out("}");
      } else {
        out("{}");
      }
    }
    function stringifyMapSet(isSet) {
      if (_data.size) {
        out("{");
        var propLvl = lvl + 1;
        var first = true;
        var entries = _data.entries();
        var entry = entries.next();
        while (!entry.done) {
          var item = entry.value;
          var key = item[0];
          var value = isSet ? true : item[1];
          if (validType(value)) {
            if (!first)
              out(",");
            first = false;
            var propPtr = ptr + "/" + escapeJsonPointer(key);
            indent2(propLvl);
            map14(propPtr, "key");
            out(quoted(key));
            map14(propPtr, "keyEnd");
            out(":");
            if (whitespace)
              out(" ");
            _stringify(value, propLvl, propPtr);
          }
          entry = entries.next();
        }
        indent2(lvl);
        out("}");
      } else {
        out("{}");
      }
    }
  }
  function out(str) {
    column += str.length;
    pos += str.length;
    json += str;
  }
  function indent2(lvl) {
    if (whitespace) {
      json += "\n" + repeat(lvl, whitespace);
      line++;
      column = 0;
      while (lvl--) {
        if (wsLine) {
          line += wsLine;
          column = wsColumn;
        } else {
          column += wsColumn;
        }
        pos += wsPos;
      }
      pos += 1;
    }
  }
  function map14(ptr, prop) {
    pointers[ptr] = pointers[ptr] || {};
    pointers[ptr][prop] = {
      line,
      column,
      pos
    };
  }
  function repeat(n5, str) {
    return Array(n5 + 1).join(str);
  }
};
var VALID_TYPES = ["number", "bigint", "boolean", "string", "object"];
function validType(data) {
  return VALID_TYPES.indexOf(typeof data) >= 0;
}
var ESC_QUOTE = /"|\\/g;
var ESC_B = /[\b]/g;
var ESC_F = /\f/g;
var ESC_N = /\n/g;
var ESC_R = /\r/g;
var ESC_T = /\t/g;
function quoted(str) {
  str = str.replace(ESC_QUOTE, "\\$&").replace(ESC_F, "\\f").replace(ESC_B, "\\b").replace(ESC_N, "\\n").replace(ESC_R, "\\r").replace(ESC_T, "\\t");
  return '"' + str + '"';
}
var ESC_0 = /~/g;
var ESC_1 = /\//g;
function escapeJsonPointer(str) {
  return str.replace(ESC_0, "~0").replace(ESC_1, "~1");
}
function _validate(object, validateFn) {
  const dataPointerMap = generateDataPointerMap(object);
  const valid = validateFn(object);
  let errors = validateFn.errors;
  if (errors && errors.length) {
    (0, import_min_dash146.forEach)(errors, wrapRawErrors);
    errors = ignoreSupportiveErrors(errors);
    (0, import_min_dash146.forEach)(errors, function(error4) {
      setDataPointer(error4, dataPointerMap);
    });
  }
  return {
    valid,
    object,
    errors
  };
}
function wrapRawErrors(error4) {
  const params = error4.params;
  if (params && params.errors) {
    params.rawErrors = params.errors;
    delete params.errors;
  }
}
function setDataPointer(error4, dataPointerMap) {
  const dataPath = error4.dataPath;
  const pointer = dataPointerMap[dataPath];
  error4.dataPointer = pointer;
}
function ignoreSupportiveErrors(errors) {
  return (0, import_min_dash146.filter)(errors, function(error4) {
    return error4.keyword !== "if";
  });
}
function generateDataPointerMap(object) {
  return jsonSourceMap.stringify(object, null, 2).pointers;
}
function getSchemaVersion() {
  return version$1;
}
function validate(object) {
  return _validate(object, standaloneValidator.exports);
}
var name2 = "@camunda/zeebe-element-templates-json-schema";
var version = "0.6.0";
var standaloneZeebeValidator = { exports: {} };
standaloneZeebeValidator.exports = validate14;
standaloneZeebeValidator.exports.default = validate14;
var schema17 = { "type": "object", "allOf": [{ "required": ["name", "id", "appliesTo", "properties"], "properties": { "name": { "$id": "#/name", "type": "string", "description": "The name of the element template." }, "id": { "$id": "#/id", "type": "string", "description": "The identifier of the element template." }, "description": { "$id": "#/description", "type": "string", "description": "The description of the element template." }, "version": { "$id": "#/version", "type": "integer", "description": "Optional version of the template. If you add a version to a template it will be considered unique based on its ID and version. Two templates can have the same ID if their version is different." }, "isDefault": { "$id": "#/isDefault", "type": "boolean", "description": "Indicates whether the element template is a default template." }, "appliesTo": { "$id": "#/appliesTo", "type": "array", "description": "List of BPMN types the template can be applied to.", "default": [], "items": { "$id": "#/appliesTo/items", "type": "string", "pattern": "^[\\w\\d]+:[\\w\\d]+$", "allOf": [{ "examples": ["bpmn:Task", "bpmn:ServiceTask", "bpmn:SequenceFlow", "bpmn:Process", "bpmn:StartEvent", "bpmn:Gateway"] }], "errorMessage": { "pattern": 'invalid item for "appliesTo", should contain namespaced property, example: "bpmn:Task"' } } }, "elementType": { "$id": "#/elementType", "type": "object", "description": "The BPMN type the element will be transformed into.", "default": {}, "required": ["value"], "properties": { "value": { "$id": "#/elementType/value", "type": "string", "pattern": "^[\\w\\d]+:[\\w\\d]+$", "allOf": [{ "examples": ["bpmn:ServiceTask", "bpmn:UserTask", "bpmn:StartEvent", "bpmn:ExclusiveGateway", "bpmn:ParallelGateway"] }], "errorMessage": { "pattern": 'invalid item for "elementType", should contain namespaced property, example: "bpmn:Task"' } } }, "errorMessage": { "required": { "value": "missing elementType value" } } }, "metadata": { "$id": "#/metadata", "type": "object", "description": "Some custom properties for further configuration.", "default": {} }, "entriesVisible": { "$id": "#/entriesVisible", "type": "boolean", "description": "Select whether non-template entries are visible in the properties panel." }, "groups": { "$id": "#/groups", "type": "array", "description": "Custom fields can be ordered together via groups.", "allOf": [{ "examples": [[{ "id": "group-1", "label": "My Group" }]] }], "items": { "$id": "#/groups/group", "type": "object", "default": {}, "required": ["id", "label"], "properties": { "id": { "$id": "#/groups/group/id", "type": "string", "description": "The id of the custom group" }, "label": { "$id": "#/groups/group/label", "type": "string", "description": "The label of the custom group" } }, "errorMessage": { "required": { "id": 'missing id for group "${0#}"', "label": 'missing label for group "${0#}"' } } } }, "documentationRef": { "$id": "#/documentationRef", "type": "string", "pattern": "^(https|http)://.*", "errorMessage": { "pattern": 'Malformed documentation URL, must match "^(https|http)://.*"' } } }, "errorMessage": { "required": { "name": "missing template name", "id": "missing template id", "appliesTo": "missing appliesTo=[]", "properties": "missing properties=[]" } } }], "properties": { "properties": { "$ref": "#/definitions/properties", "$id": "#/properties" }, "icon": { "$id": "#/icon", "type": "object", "description": "Custom icon to be shown on the element", "default": {}, "properties": { "contents": { "$id": "#/icon/contents", "type": "string", "description": "The URL of an icon.", "pattern": "^(https?|data):.*", "errorMessage": { "pattern": "Malformed icon source, must be a valid HTTP(s) or data URL" } } }, "required": ["contents"], "errorMessage": { "required": { "contents": "missing icon contents" } } } } };
var schema18 = { "allOf": [{ "type": "array", "description": "List of properties of the element template.", "allOf": [{ "examples": [[{ "label": "Name", "type": "String", "binding": { "type": "property", "name": "name" } }]] }], "items": { "type": "object", "default": {}, "allOf": [{ "if": { "properties": { "type": { "const": "Dropdown" } }, "required": ["type"] }, "then": { "required": ["choices"], "errorMessage": 'must provide choices=[] with "Dropdown" type' } }], "properties": { "id": { "type": "string", "description": "Unique identifier of the property." }, "value": { "$id": "#/properties/property/value", "type": ["string", "boolean"], "description": "The value of a control field." }, "description": { "$id": "#/properties/property/description", "type": "string", "description": "The description of a control field." }, "label": { "$id": "#/properties/property/label", "type": "string", "description": "The label of a control field." }, "type": { "$id": "#/properties/property/type", "type": "string", "description": "The type of a control field." }, "editable": { "$id": "#/properties/property/editable", "type": "boolean", "description": "Indicates whether a control field is editable or not." }, "choices": { "$id": "#/properties/property/choices", "type": "array", "description": "The choices for dropdown fields.", "default": [], "items": { "$id": "#/properties/property/choices/item", "type": "object", "default": {}, "properties": { "name": { "$id": "#/properties/property/choices/item/name", "type": "string", "description": "The name of a choice." }, "value": { "$id": "#/properties/property/choices/item/value", "type": "string", "description": "The value of a choice." } }, "required": ["value", "name"], "errorMessage": { "required": '{ name, value } must be specified for "Dropdown" choices' } } }, "constraints": { "$id": "#/properties/property/constraints", "type": "object", "description": "The validation constraints of a control field.", "allOf": [{ "examples": [{ "notEmpty": true }] }], "properties": { "notEmpty": { "$id": "#/properties/property/constraints/notEmpty", "type": "boolean", "description": "The control field must not be empty." }, "minLength": { "$id": "#/properties/property/constraints/minLength", "type": "number", "description": "The minimal length of a control field value." }, "maxLength": { "$id": "#/properties/property/constraints/maxLength", "type": "number", "description": "The maximal length for a control field value." }, "pattern": { "$id": "#/properties/property/constraints/pattern", "description": "A regular expression pattern for a constraint.", "oneOf": [{ "type": "object", "default": {}, "properties": { "value": { "$id": "#/properties/property/constraints/pattern/value", "type": "string", "description": "The regular expression of a pattern." }, "message": { "$id": "#/properties/property/constraints/pattern/message", "type": "string", "description": "The validation message of a pattern." } } }, { "type": "string" }] } } }, "group": { "$id": "#/properties/property/group", "type": "string", "description": "The custom group of a control field." }, "condition": { "$id": "#/condition", "type": "object", "description": "Condition to activate the binding.", "allOf": [{ "examples": [{ "type": "simple", "property": "httpMethod", "equals": "GET" }, { "type": "simple", "property": "httpMethod", "oneOf": ["POST", "PUT", "DELETE"] }] }], "required": ["property"], "properties": { "type": { "$id": "#/condition/type", "const": "simple", "description": "The type of the condition.", "default": "simple" }, "property": { "$id": "#/condition/property", "type": "string", "description": "The id of the property to check." } }, "oneOf": [{ "properties": { "equals": { "type": ["string", "number", "boolean"] } }, "required": ["equals"] }, { "properties": { "oneOf": { "type": "array", "items": { "type": ["string", "number"] } } }, "required": ["oneOf"] }], "errorMessage": { "required": { "property": "missing property name for condition" } } } } } }, { "$schema": "http://json-schema.org/draft-07/schema", "type": "array", "description": "List of properties of the element template.", "items": { "type": "object", "default": {}, "required": ["binding"], "allOf": [{ "if": { "properties": { "binding": { "properties": { "type": { "const": "property" } }, "required": ["type"] } }, "required": ["binding"] }, "then": { "properties": { "type": { "enum": ["String", "Text", "Hidden", "Dropdown", "Boolean"], "errorMessage": 'invalid property type ${0} for binding type "property"; must be any of { String, Text, Hidden, Dropdown, Boolean }' } } } }, { "if": { "properties": { "binding": { "properties": { "type": { "enum": ["zeebe:input", "zeebe:output", "zeebe:property", "zeebe:taskHeader", "zeebe:taskDefinition:type"] } }, "required": ["type"] } }, "required": ["binding"] }, "then": { "properties": { "type": { "enum": ["String", "Text", "Hidden", "Dropdown"], "errorMessage": "invalid property type ${0} for binding type ${1/binding/type}; must be any of { String, Text, Hidden, Dropdown }" } } } }, { "if": { "properties": { "optional": { "const": true } }, "required": ["optional"] }, "then": { "properties": { "binding": { "properties": { "type": { "enum": ["zeebe:input", "zeebe:output", "zeebe:property"], "errorMessage": "optional is not supported for binding type ${0}; must be any of { zeebe:input, zeebe:output, zeebe:property }" } }, "required": ["type"] } } } }, { "if": { "properties": { "optional": { "const": true } }, "required": ["optional"] }, "then": { "properties": { "constraints": { "properties": { "notEmpty": { "const": false, "errorMessage": 'optional is not allowed for truthy "notEmpty" constraint' } }, "required": ["notEmpty"] } } } }, { "if": { "properties": { "feel": { "not": { "const": null } } }, "required": ["feel"] }, "then": { "properties": { "type": { "enum": ["String", "Text"], "errorMessage": 'feel is only supported for "String" and "Text" type' } }, "required": ["type"] } }], "properties": { "binding": { "$id": "#/properties/property/binding", "type": "object", "description": "Specifying how the property is mapped to BPMN or Zeebe extension elements and attributes.", "required": ["type"], "allOf": [{ "if": { "properties": { "type": { "enum": ["property", "zeebe:property", "zeebe:input"] } }, "required": ["type"] }, "then": { "required": ["name"], "errorMessage": "property.binding ${0/type} requires name" } }, { "if": { "properties": { "type": { "const": "zeebe:output" } }, "required": ["type"] }, "then": { "required": ["source"], "errorMessage": "property.binding ${0/type} requires source" } }, { "if": { "properties": { "type": { "const": "zeebe:taskHeader" } }, "required": ["type"] }, "then": { "required": ["key"], "errorMessage": "property.binding ${0/type} requires key" } }, { "examples": [{ "type": "property", "name": "name" }, { "type": "zeebe:input", "name": "input" }, { "type": "zeebe:output", "source": "output" }, { "type": "zeebe:property", "name": "property" }, { "type": "zeebe:taskDefinition:type" }, { "type": "zeebe:taskHeader", "key": "key" }] }], "properties": { "type": { "$id": "#/properties/property/binding/type", "type": "string", "description": "The type of a property binding.", "enum": ["property", "zeebe:taskDefinition:type", "zeebe:input", "zeebe:output", "zeebe:property", "zeebe:taskHeader"], "errorMessage": "invalid property.binding type ${0}; must be any of { property, zeebe:taskDefinition:type, zeebe:input, zeebe:output, zeebe:property, zeebe:taskHeader }" }, "name": { "$id": "#/properties/property/binding/name", "type": "string", "description": "The name of a property binding." }, "source": { "$id": "#/properties/property/binding/source", "type": "string", "description": "The source value of a property binding (zeebe:output)." }, "key": { "$id": "#/properties/property/binding/key", "type": "string", "description": "The key value of a property binding (zeebe:taskHeader)." } } }, "optional": { "$id": "#/optional", "type": "boolean", "description": "Indicates whether a property is optional. Optional bindings do not persist empty values in the underlying BPMN 2.0 XML." }, "feel": { "$id": "#/properties/property/feel", "type": "string", "default": null, "description": "Indicates whether the property can be a feel expression", "enum": [null, "optional", "required"] } }, "errorMessage": { "required": { "binding": 'missing binding for property "${0#}"' } } } }] };
var pattern0 = new RegExp("^[\\w\\d]+:[\\w\\d]+$", "u");
var pattern2 = new RegExp("^(https|http)://.*", "u");
var pattern3 = new RegExp("^(https?|data):.*", "u");
var obj0 = { "required": "missingProperty", "dependencies": "property", "dependentRequired": "property" };
var func0 = equal.exports;
function validate15(data, { dataPath = "", parentData, parentDataProperty, rootData = data } = {}) {
  let vErrors = null;
  let errors = 0;
  if (data && typeof data == "object" && !Array.isArray(data)) {
    if (data.name === void 0) {
      const err0 = { keyword: "required", dataPath, schemaPath: "#/allOf/0/required", params: { missingProperty: "name" }, message: "should have required property 'name'" };
      if (vErrors === null) {
        vErrors = [err0];
      } else {
        vErrors.push(err0);
      }
      errors++;
    }
    if (data.id === void 0) {
      const err1 = { keyword: "required", dataPath, schemaPath: "#/allOf/0/required", params: { missingProperty: "id" }, message: "should have required property 'id'" };
      if (vErrors === null) {
        vErrors = [err1];
      } else {
        vErrors.push(err1);
      }
      errors++;
    }
    if (data.appliesTo === void 0) {
      const err2 = { keyword: "required", dataPath, schemaPath: "#/allOf/0/required", params: { missingProperty: "appliesTo" }, message: "should have required property 'appliesTo'" };
      if (vErrors === null) {
        vErrors = [err2];
      } else {
        vErrors.push(err2);
      }
      errors++;
    }
    if (data.properties === void 0) {
      const err3 = { keyword: "required", dataPath, schemaPath: "#/allOf/0/required", params: { missingProperty: "properties" }, message: "should have required property 'properties'" };
      if (vErrors === null) {
        vErrors = [err3];
      } else {
        vErrors.push(err3);
      }
      errors++;
    }
    if (data.name !== void 0) {
      if (typeof data.name !== "string") {
        const err4 = { keyword: "type", dataPath: dataPath + "/name", schemaPath: "#/allOf/0/properties/name/type", params: { type: "string" }, message: "should be string" };
        if (vErrors === null) {
          vErrors = [err4];
        } else {
          vErrors.push(err4);
        }
        errors++;
      }
    }
    if (data.id !== void 0) {
      if (typeof data.id !== "string") {
        const err5 = { keyword: "type", dataPath: dataPath + "/id", schemaPath: "#/allOf/0/properties/id/type", params: { type: "string" }, message: "should be string" };
        if (vErrors === null) {
          vErrors = [err5];
        } else {
          vErrors.push(err5);
        }
        errors++;
      }
    }
    if (data.description !== void 0) {
      if (typeof data.description !== "string") {
        const err6 = { keyword: "type", dataPath: dataPath + "/description", schemaPath: "#/allOf/0/properties/description/type", params: { type: "string" }, message: "should be string" };
        if (vErrors === null) {
          vErrors = [err6];
        } else {
          vErrors.push(err6);
        }
        errors++;
      }
    }
    if (data.version !== void 0) {
      let data3 = data.version;
      if (!(typeof data3 == "number" && (!(data3 % 1) && !isNaN(data3)))) {
        const err7 = { keyword: "type", dataPath: dataPath + "/version", schemaPath: "#/allOf/0/properties/version/type", params: { type: "integer" }, message: "should be integer" };
        if (vErrors === null) {
          vErrors = [err7];
        } else {
          vErrors.push(err7);
        }
        errors++;
      }
    }
    if (data.isDefault !== void 0) {
      if (typeof data.isDefault !== "boolean") {
        const err8 = { keyword: "type", dataPath: dataPath + "/isDefault", schemaPath: "#/allOf/0/properties/isDefault/type", params: { type: "boolean" }, message: "should be boolean" };
        if (vErrors === null) {
          vErrors = [err8];
        } else {
          vErrors.push(err8);
        }
        errors++;
      }
    }
    if (data.appliesTo !== void 0) {
      let data5 = data.appliesTo;
      if (Array.isArray(data5)) {
        const len0 = data5.length;
        for (let i0 = 0; i0 < len0; i0++) {
          let data6 = data5[i0];
          if (typeof data6 === "string") {
            if (!pattern0.test(data6)) {
              const err9 = { keyword: "pattern", dataPath: dataPath + "/appliesTo/" + i0, schemaPath: "#/allOf/0/properties/appliesTo/items/pattern", params: { pattern: "^[\\w\\d]+:[\\w\\d]+$" }, message: 'should match pattern "^[\\w\\d]+:[\\w\\d]+$"' };
              if (vErrors === null) {
                vErrors = [err9];
              } else {
                vErrors.push(err9);
              }
              errors++;
            }
          } else {
            const err10 = { keyword: "type", dataPath: dataPath + "/appliesTo/" + i0, schemaPath: "#/allOf/0/properties/appliesTo/items/type", params: { type: "string" }, message: "should be string" };
            if (vErrors === null) {
              vErrors = [err10];
            } else {
              vErrors.push(err10);
            }
            errors++;
          }
          if (errors > 0) {
            const emErrors0 = { "pattern": [] };
            const templates0 = {};
            for (const err11 of vErrors) {
              if (err11.keyword !== "errorMessage" && !err11.emUsed && err11.dataPath === dataPath + "/appliesTo/" + i0 && err11.keyword in emErrors0 && err11.schemaPath.indexOf("#/allOf/0/properties/appliesTo/items") === 0 && /^\/[^\/]*$/.test(err11.schemaPath.slice(36))) {
                emErrors0[err11.keyword].push(err11);
                err11.emUsed = true;
              }
            }
            for (const key0 in emErrors0) {
              if (emErrors0[key0].length) {
                const err12 = { keyword: "errorMessage", dataPath: dataPath + "/appliesTo/" + i0, schemaPath: "#/allOf/0/properties/appliesTo/items/errorMessage", params: { errors: emErrors0[key0] }, message: key0 in templates0 ? templates0[key0]() : schema17.allOf[0].properties.appliesTo.items.errorMessage[key0] };
                if (vErrors === null) {
                  vErrors = [err12];
                } else {
                  vErrors.push(err12);
                }
                errors++;
              }
            }
            const emErrs0 = [];
            for (const err13 of vErrors) {
              if (!err13.emUsed) {
                emErrs0.push(err13);
              }
            }
            vErrors = emErrs0;
            errors = emErrs0.length;
          }
        }
      } else {
        const err14 = { keyword: "type", dataPath: dataPath + "/appliesTo", schemaPath: "#/allOf/0/properties/appliesTo/type", params: { type: "array" }, message: "should be array" };
        if (vErrors === null) {
          vErrors = [err14];
        } else {
          vErrors.push(err14);
        }
        errors++;
      }
    }
    if (data.elementType !== void 0) {
      let data7 = data.elementType;
      if (data7 && typeof data7 == "object" && !Array.isArray(data7)) {
        if (data7.value === void 0) {
          const err15 = { keyword: "required", dataPath: dataPath + "/elementType", schemaPath: "#/allOf/0/properties/elementType/required", params: { missingProperty: "value" }, message: "should have required property 'value'" };
          if (vErrors === null) {
            vErrors = [err15];
          } else {
            vErrors.push(err15);
          }
          errors++;
        }
        if (data7.value !== void 0) {
          let data8 = data7.value;
          if (typeof data8 === "string") {
            if (!pattern0.test(data8)) {
              const err16 = { keyword: "pattern", dataPath: dataPath + "/elementType/value", schemaPath: "#/allOf/0/properties/elementType/properties/value/pattern", params: { pattern: "^[\\w\\d]+:[\\w\\d]+$" }, message: 'should match pattern "^[\\w\\d]+:[\\w\\d]+$"' };
              if (vErrors === null) {
                vErrors = [err16];
              } else {
                vErrors.push(err16);
              }
              errors++;
            }
          } else {
            const err17 = { keyword: "type", dataPath: dataPath + "/elementType/value", schemaPath: "#/allOf/0/properties/elementType/properties/value/type", params: { type: "string" }, message: "should be string" };
            if (vErrors === null) {
              vErrors = [err17];
            } else {
              vErrors.push(err17);
            }
            errors++;
          }
          if (errors > 0) {
            const emErrors1 = { "pattern": [] };
            const templates1 = {};
            for (const err18 of vErrors) {
              if (err18.keyword !== "errorMessage" && !err18.emUsed && err18.dataPath === dataPath + "/elementType/value" && err18.keyword in emErrors1 && err18.schemaPath.indexOf("#/allOf/0/properties/elementType/properties/value") === 0 && /^\/[^\/]*$/.test(err18.schemaPath.slice(49))) {
                emErrors1[err18.keyword].push(err18);
                err18.emUsed = true;
              }
            }
            for (const key1 in emErrors1) {
              if (emErrors1[key1].length) {
                const err19 = { keyword: "errorMessage", dataPath: dataPath + "/elementType/value", schemaPath: "#/allOf/0/properties/elementType/properties/value/errorMessage", params: { errors: emErrors1[key1] }, message: key1 in templates1 ? templates1[key1]() : schema17.allOf[0].properties.elementType.properties.value.errorMessage[key1] };
                if (vErrors === null) {
                  vErrors = [err19];
                } else {
                  vErrors.push(err19);
                }
                errors++;
              }
            }
            const emErrs1 = [];
            for (const err20 of vErrors) {
              if (!err20.emUsed) {
                emErrs1.push(err20);
              }
            }
            vErrors = emErrs1;
            errors = emErrs1.length;
          }
        }
      } else {
        const err21 = { keyword: "type", dataPath: dataPath + "/elementType", schemaPath: "#/allOf/0/properties/elementType/type", params: { type: "object" }, message: "should be object" };
        if (vErrors === null) {
          vErrors = [err21];
        } else {
          vErrors.push(err21);
        }
        errors++;
      }
      if (errors > 0) {
        const emErrors2 = { "required": { "value": [] } };
        const templates2 = { required: {} };
        let emPropParams0;
        let emParamsErrors0;
        for (const err22 of vErrors) {
          if (err22.keyword !== "errorMessage" && !err22.emUsed && err22.dataPath === dataPath + "/elementType" && err22.keyword in emErrors2 && err22.schemaPath.indexOf("#/allOf/0/properties/elementType") === 0 && /^\/[^\/]*$/.test(err22.schemaPath.slice(32))) {
            emPropParams0 = obj0[err22.keyword];
            emParamsErrors0 = emErrors2[err22.keyword][err22.params[emPropParams0]];
            if (emParamsErrors0) {
              emParamsErrors0.push(err22);
              err22.emUsed = true;
            }
          }
        }
        for (const key2 in emErrors2) {
          for (const keyProp0 in emErrors2[key2]) {
            emParamsErrors0 = emErrors2[key2][keyProp0];
            if (emParamsErrors0.length) {
              const tmpl0 = templates2[key2] && templates2[key2][keyProp0];
              const err23 = { keyword: "errorMessage", dataPath: dataPath + "/elementType", schemaPath: "#/allOf/0/properties/elementType/errorMessage", params: { errors: emParamsErrors0 }, message: tmpl0 ? tmpl0() : schema17.allOf[0].properties.elementType.errorMessage[key2][keyProp0] };
              if (vErrors === null) {
                vErrors = [err23];
              } else {
                vErrors.push(err23);
              }
              errors++;
            }
          }
        }
        const emErrs2 = [];
        for (const err24 of vErrors) {
          if (!err24.emUsed) {
            emErrs2.push(err24);
          }
        }
        vErrors = emErrs2;
        errors = emErrs2.length;
      }
    }
    if (data.metadata !== void 0) {
      let data9 = data.metadata;
      if (!(data9 && typeof data9 == "object" && !Array.isArray(data9))) {
        const err25 = { keyword: "type", dataPath: dataPath + "/metadata", schemaPath: "#/allOf/0/properties/metadata/type", params: { type: "object" }, message: "should be object" };
        if (vErrors === null) {
          vErrors = [err25];
        } else {
          vErrors.push(err25);
        }
        errors++;
      }
    }
    if (data.entriesVisible !== void 0) {
      if (typeof data.entriesVisible !== "boolean") {
        const err26 = { keyword: "type", dataPath: dataPath + "/entriesVisible", schemaPath: "#/allOf/0/properties/entriesVisible/type", params: { type: "boolean" }, message: "should be boolean" };
        if (vErrors === null) {
          vErrors = [err26];
        } else {
          vErrors.push(err26);
        }
        errors++;
      }
    }
    if (data.groups !== void 0) {
      let data11 = data.groups;
      if (Array.isArray(data11)) {
        const len1 = data11.length;
        for (let i1 = 0; i1 < len1; i1++) {
          let data12 = data11[i1];
          if (data12 && typeof data12 == "object" && !Array.isArray(data12)) {
            if (data12.id === void 0) {
              const err27 = { keyword: "required", dataPath: dataPath + "/groups/" + i1, schemaPath: "#/allOf/0/properties/groups/items/required", params: { missingProperty: "id" }, message: "should have required property 'id'" };
              if (vErrors === null) {
                vErrors = [err27];
              } else {
                vErrors.push(err27);
              }
              errors++;
            }
            if (data12.label === void 0) {
              const err28 = { keyword: "required", dataPath: dataPath + "/groups/" + i1, schemaPath: "#/allOf/0/properties/groups/items/required", params: { missingProperty: "label" }, message: "should have required property 'label'" };
              if (vErrors === null) {
                vErrors = [err28];
              } else {
                vErrors.push(err28);
              }
              errors++;
            }
            if (data12.id !== void 0) {
              if (typeof data12.id !== "string") {
                const err29 = { keyword: "type", dataPath: dataPath + "/groups/" + i1 + "/id", schemaPath: "#/allOf/0/properties/groups/items/properties/id/type", params: { type: "string" }, message: "should be string" };
                if (vErrors === null) {
                  vErrors = [err29];
                } else {
                  vErrors.push(err29);
                }
                errors++;
              }
            }
            if (data12.label !== void 0) {
              if (typeof data12.label !== "string") {
                const err30 = { keyword: "type", dataPath: dataPath + "/groups/" + i1 + "/label", schemaPath: "#/allOf/0/properties/groups/items/properties/label/type", params: { type: "string" }, message: "should be string" };
                if (vErrors === null) {
                  vErrors = [err30];
                } else {
                  vErrors.push(err30);
                }
                errors++;
              }
            }
          } else {
            const err31 = { keyword: "type", dataPath: dataPath + "/groups/" + i1, schemaPath: "#/allOf/0/properties/groups/items/type", params: { type: "object" }, message: "should be object" };
            if (vErrors === null) {
              vErrors = [err31];
            } else {
              vErrors.push(err31);
            }
            errors++;
          }
          if (errors > 0) {
            const emErrors3 = { "required": { "id": [], "label": [] } };
            const templates3 = { required: { id: function() {
              return 'missing id for group "' + JSON.stringify(i1) + '"';
            }, label: function() {
              return 'missing label for group "' + JSON.stringify(i1) + '"';
            } } };
            let emPropParams1;
            let emParamsErrors1;
            for (const err32 of vErrors) {
              if (err32.keyword !== "errorMessage" && !err32.emUsed && err32.dataPath === dataPath + "/groups/" + i1 && err32.keyword in emErrors3 && err32.schemaPath.indexOf("#/allOf/0/properties/groups/items") === 0 && /^\/[^\/]*$/.test(err32.schemaPath.slice(33))) {
                emPropParams1 = obj0[err32.keyword];
                emParamsErrors1 = emErrors3[err32.keyword][err32.params[emPropParams1]];
                if (emParamsErrors1) {
                  emParamsErrors1.push(err32);
                  err32.emUsed = true;
                }
              }
            }
            for (const key3 in emErrors3) {
              for (const keyProp1 in emErrors3[key3]) {
                emParamsErrors1 = emErrors3[key3][keyProp1];
                if (emParamsErrors1.length) {
                  const tmpl1 = templates3[key3] && templates3[key3][keyProp1];
                  const err33 = { keyword: "errorMessage", dataPath: dataPath + "/groups/" + i1, schemaPath: "#/allOf/0/properties/groups/items/errorMessage", params: { errors: emParamsErrors1 }, message: tmpl1 ? tmpl1() : schema17.allOf[0].properties.groups.items.errorMessage[key3][keyProp1] };
                  if (vErrors === null) {
                    vErrors = [err33];
                  } else {
                    vErrors.push(err33);
                  }
                  errors++;
                }
              }
            }
            const emErrs3 = [];
            for (const err34 of vErrors) {
              if (!err34.emUsed) {
                emErrs3.push(err34);
              }
            }
            vErrors = emErrs3;
            errors = emErrs3.length;
          }
        }
      } else {
        const err35 = { keyword: "type", dataPath: dataPath + "/groups", schemaPath: "#/allOf/0/properties/groups/type", params: { type: "array" }, message: "should be array" };
        if (vErrors === null) {
          vErrors = [err35];
        } else {
          vErrors.push(err35);
        }
        errors++;
      }
    }
    if (data.documentationRef !== void 0) {
      let data15 = data.documentationRef;
      if (typeof data15 === "string") {
        if (!pattern2.test(data15)) {
          const err36 = { keyword: "pattern", dataPath: dataPath + "/documentationRef", schemaPath: "#/allOf/0/properties/documentationRef/pattern", params: { pattern: "^(https|http)://.*" }, message: 'should match pattern "^(https|http)://.*"' };
          if (vErrors === null) {
            vErrors = [err36];
          } else {
            vErrors.push(err36);
          }
          errors++;
        }
      } else {
        const err37 = { keyword: "type", dataPath: dataPath + "/documentationRef", schemaPath: "#/allOf/0/properties/documentationRef/type", params: { type: "string" }, message: "should be string" };
        if (vErrors === null) {
          vErrors = [err37];
        } else {
          vErrors.push(err37);
        }
        errors++;
      }
      if (errors > 0) {
        const emErrors4 = { "pattern": [] };
        const templates4 = {};
        for (const err38 of vErrors) {
          if (err38.keyword !== "errorMessage" && !err38.emUsed && err38.dataPath === dataPath + "/documentationRef" && err38.keyword in emErrors4 && err38.schemaPath.indexOf("#/allOf/0/properties/documentationRef") === 0 && /^\/[^\/]*$/.test(err38.schemaPath.slice(37))) {
            emErrors4[err38.keyword].push(err38);
            err38.emUsed = true;
          }
        }
        for (const key4 in emErrors4) {
          if (emErrors4[key4].length) {
            const err39 = { keyword: "errorMessage", dataPath: dataPath + "/documentationRef", schemaPath: "#/allOf/0/properties/documentationRef/errorMessage", params: { errors: emErrors4[key4] }, message: key4 in templates4 ? templates4[key4]() : schema17.allOf[0].properties.documentationRef.errorMessage[key4] };
            if (vErrors === null) {
              vErrors = [err39];
            } else {
              vErrors.push(err39);
            }
            errors++;
          }
        }
        const emErrs4 = [];
        for (const err40 of vErrors) {
          if (!err40.emUsed) {
            emErrs4.push(err40);
          }
        }
        vErrors = emErrs4;
        errors = emErrs4.length;
      }
    }
  }
  if (errors > 0) {
    const emErrors5 = { "required": { "name": [], "id": [], "appliesTo": [], "properties": [] } };
    const templates5 = { required: {} };
    let emPropParams2;
    let emParamsErrors2;
    for (const err41 of vErrors) {
      if (err41.keyword !== "errorMessage" && !err41.emUsed && err41.dataPath === dataPath && err41.keyword in emErrors5 && err41.schemaPath.indexOf("#/allOf/0") === 0 && /^\/[^\/]*$/.test(err41.schemaPath.slice(9))) {
        emPropParams2 = obj0[err41.keyword];
        emParamsErrors2 = emErrors5[err41.keyword][err41.params[emPropParams2]];
        if (emParamsErrors2) {
          emParamsErrors2.push(err41);
          err41.emUsed = true;
        }
      }
    }
    for (const key5 in emErrors5) {
      for (const keyProp2 in emErrors5[key5]) {
        emParamsErrors2 = emErrors5[key5][keyProp2];
        if (emParamsErrors2.length) {
          const tmpl2 = templates5[key5] && templates5[key5][keyProp2];
          const err42 = { keyword: "errorMessage", dataPath, schemaPath: "#/allOf/0/errorMessage", params: { errors: emParamsErrors2 }, message: tmpl2 ? tmpl2() : schema17.allOf[0].errorMessage[key5][keyProp2] };
          if (vErrors === null) {
            vErrors = [err42];
          } else {
            vErrors.push(err42);
          }
          errors++;
        }
      }
    }
    const emErrs5 = [];
    for (const err43 of vErrors) {
      if (!err43.emUsed) {
        emErrs5.push(err43);
      }
    }
    vErrors = emErrs5;
    errors = emErrs5.length;
  }
  if (data && typeof data == "object" && !Array.isArray(data)) {
    if (data.properties !== void 0) {
      let data16 = data.properties;
      if (Array.isArray(data16)) {
        const len2 = data16.length;
        for (let i22 = 0; i22 < len2; i22++) {
          let data17 = data16[i22];
          const _errs41 = errors;
          let valid18 = true;
          const _errs42 = errors;
          if (data17 && typeof data17 == "object" && !Array.isArray(data17)) {
            if (data17.type === void 0 && "type") {
              const err44 = {};
              if (vErrors === null) {
                vErrors = [err44];
              } else {
                vErrors.push(err44);
              }
              errors++;
            } else {
              if (data17.type !== void 0) {
                if (!func0(data17.type, "Dropdown")) {
                  const err45 = {};
                  if (vErrors === null) {
                    vErrors = [err45];
                  } else {
                    vErrors.push(err45);
                  }
                  errors++;
                }
              }
            }
          }
          var _valid0 = _errs42 === errors;
          errors = _errs41;
          if (vErrors !== null) {
            if (_errs41) {
              vErrors.length = _errs41;
            } else {
              vErrors = null;
            }
          }
          if (_valid0) {
            const _errs44 = errors;
            if (data17 && typeof data17 == "object" && !Array.isArray(data17)) {
              if (data17.choices === void 0) {
                const err46 = { keyword: "required", dataPath: dataPath + "/properties/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/allOf/0/then/required", params: { missingProperty: "choices" }, message: "should have required property 'choices'" };
                if (vErrors === null) {
                  vErrors = [err46];
                } else {
                  vErrors.push(err46);
                }
                errors++;
              }
            }
            if (errors > 0) {
              const emErrs6 = [];
              for (const err47 of vErrors) {
                if (err47.keyword !== "errorMessage" && !err47.emUsed && (err47.dataPath === dataPath + "/properties/" + i22 || err47.dataPath.indexOf(dataPath + "/properties/" + i22) === 0 && err47.dataPath[dataPath + "/properties/" + i22.length] === "/") && err47.schemaPath.indexOf("#/definitions/properties/allOf/0/items/allOf/0/then") === 0 && err47.schemaPath["#/definitions/properties/allOf/0/items/allOf/0/then".length] === "/") {
                  emErrs6.push(err47);
                  err47.emUsed = true;
                }
              }
              if (emErrs6.length) {
                const err48 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/allOf/0/then/errorMessage", params: { errors: emErrs6 }, message: 'must provide choices=[] with "Dropdown" type' };
                if (vErrors === null) {
                  vErrors = [err48];
                } else {
                  vErrors.push(err48);
                }
                errors++;
              }
              const emErrs7 = [];
              for (const err49 of vErrors) {
                if (!err49.emUsed) {
                  emErrs7.push(err49);
                }
              }
              vErrors = emErrs7;
              errors = emErrs7.length;
            }
            var _valid0 = _errs44 === errors;
            valid18 = _valid0;
          }
          if (!valid18) {
            const err50 = { keyword: "if", dataPath: dataPath + "/properties/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/allOf/0/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
            if (vErrors === null) {
              vErrors = [err50];
            } else {
              vErrors.push(err50);
            }
            errors++;
          }
          if (data17 && typeof data17 == "object" && !Array.isArray(data17)) {
            if (data17.id !== void 0) {
              if (typeof data17.id !== "string") {
                const err51 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/id", schemaPath: "#/definitions/properties/allOf/0/items/properties/id/type", params: { type: "string" }, message: "should be string" };
                if (vErrors === null) {
                  vErrors = [err51];
                } else {
                  vErrors.push(err51);
                }
                errors++;
              }
            }
            if (data17.value !== void 0) {
              let data20 = data17.value;
              if (typeof data20 !== "string" && typeof data20 !== "boolean") {
                const err52 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/value", schemaPath: "#/definitions/properties/allOf/0/items/properties/value/type", params: { type: schema18.allOf[0].items.properties.value.type }, message: "should be string,boolean" };
                if (vErrors === null) {
                  vErrors = [err52];
                } else {
                  vErrors.push(err52);
                }
                errors++;
              }
            }
            if (data17.description !== void 0) {
              if (typeof data17.description !== "string") {
                const err53 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/description", schemaPath: "#/definitions/properties/allOf/0/items/properties/description/type", params: { type: "string" }, message: "should be string" };
                if (vErrors === null) {
                  vErrors = [err53];
                } else {
                  vErrors.push(err53);
                }
                errors++;
              }
            }
            if (data17.label !== void 0) {
              if (typeof data17.label !== "string") {
                const err54 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/label", schemaPath: "#/definitions/properties/allOf/0/items/properties/label/type", params: { type: "string" }, message: "should be string" };
                if (vErrors === null) {
                  vErrors = [err54];
                } else {
                  vErrors.push(err54);
                }
                errors++;
              }
            }
            if (data17.type !== void 0) {
              if (typeof data17.type !== "string") {
                const err55 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/type", schemaPath: "#/definitions/properties/allOf/0/items/properties/type/type", params: { type: "string" }, message: "should be string" };
                if (vErrors === null) {
                  vErrors = [err55];
                } else {
                  vErrors.push(err55);
                }
                errors++;
              }
            }
            if (data17.editable !== void 0) {
              if (typeof data17.editable !== "boolean") {
                const err56 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/editable", schemaPath: "#/definitions/properties/allOf/0/items/properties/editable/type", params: { type: "boolean" }, message: "should be boolean" };
                if (vErrors === null) {
                  vErrors = [err56];
                } else {
                  vErrors.push(err56);
                }
                errors++;
              }
            }
            if (data17.choices !== void 0) {
              let data25 = data17.choices;
              if (Array.isArray(data25)) {
                const len3 = data25.length;
                for (let i32 = 0; i32 < len3; i32++) {
                  let data26 = data25[i32];
                  if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
                    if (data26.value === void 0) {
                      const err57 = { keyword: "required", dataPath: dataPath + "/properties/" + i22 + "/choices/" + i32, schemaPath: "#/definitions/properties/allOf/0/items/properties/choices/items/required", params: { missingProperty: "value" }, message: "should have required property 'value'" };
                      if (vErrors === null) {
                        vErrors = [err57];
                      } else {
                        vErrors.push(err57);
                      }
                      errors++;
                    }
                    if (data26.name === void 0) {
                      const err58 = { keyword: "required", dataPath: dataPath + "/properties/" + i22 + "/choices/" + i32, schemaPath: "#/definitions/properties/allOf/0/items/properties/choices/items/required", params: { missingProperty: "name" }, message: "should have required property 'name'" };
                      if (vErrors === null) {
                        vErrors = [err58];
                      } else {
                        vErrors.push(err58);
                      }
                      errors++;
                    }
                    if (data26.name !== void 0) {
                      if (typeof data26.name !== "string") {
                        const err59 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/choices/" + i32 + "/name", schemaPath: "#/definitions/properties/allOf/0/items/properties/choices/items/properties/name/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err59];
                        } else {
                          vErrors.push(err59);
                        }
                        errors++;
                      }
                    }
                    if (data26.value !== void 0) {
                      if (typeof data26.value !== "string") {
                        const err60 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/choices/" + i32 + "/value", schemaPath: "#/definitions/properties/allOf/0/items/properties/choices/items/properties/value/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err60];
                        } else {
                          vErrors.push(err60);
                        }
                        errors++;
                      }
                    }
                  } else {
                    const err61 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/choices/" + i32, schemaPath: "#/definitions/properties/allOf/0/items/properties/choices/items/type", params: { type: "object" }, message: "should be object" };
                    if (vErrors === null) {
                      vErrors = [err61];
                    } else {
                      vErrors.push(err61);
                    }
                    errors++;
                  }
                  if (errors > 0) {
                    const emErrors6 = { "required": [] };
                    const templates6 = {};
                    for (const err62 of vErrors) {
                      if (err62.keyword !== "errorMessage" && !err62.emUsed && err62.dataPath === dataPath + "/properties/" + i22 + "/choices/" + i32 && err62.keyword in emErrors6 && err62.schemaPath.indexOf("#/definitions/properties/allOf/0/items/properties/choices/items") === 0 && /^\/[^\/]*$/.test(err62.schemaPath.slice(63))) {
                        emErrors6[err62.keyword].push(err62);
                        err62.emUsed = true;
                      }
                    }
                    for (const key6 in emErrors6) {
                      if (emErrors6[key6].length) {
                        const err63 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i22 + "/choices/" + i32, schemaPath: "#/definitions/properties/allOf/0/items/properties/choices/items/errorMessage", params: { errors: emErrors6[key6] }, message: key6 in templates6 ? templates6[key6]() : schema18.allOf[0].items.properties.choices.items.errorMessage[key6] };
                        if (vErrors === null) {
                          vErrors = [err63];
                        } else {
                          vErrors.push(err63);
                        }
                        errors++;
                      }
                    }
                    const emErrs8 = [];
                    for (const err64 of vErrors) {
                      if (!err64.emUsed) {
                        emErrs8.push(err64);
                      }
                    }
                    vErrors = emErrs8;
                    errors = emErrs8.length;
                  }
                }
              } else {
                const err65 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/choices", schemaPath: "#/definitions/properties/allOf/0/items/properties/choices/type", params: { type: "array" }, message: "should be array" };
                if (vErrors === null) {
                  vErrors = [err65];
                } else {
                  vErrors.push(err65);
                }
                errors++;
              }
            }
            if (data17.constraints !== void 0) {
              let data29 = data17.constraints;
              if (data29 && typeof data29 == "object" && !Array.isArray(data29)) {
                if (data29.notEmpty !== void 0) {
                  if (typeof data29.notEmpty !== "boolean") {
                    const err66 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/constraints/notEmpty", schemaPath: "#/definitions/properties/allOf/0/items/properties/constraints/properties/notEmpty/type", params: { type: "boolean" }, message: "should be boolean" };
                    if (vErrors === null) {
                      vErrors = [err66];
                    } else {
                      vErrors.push(err66);
                    }
                    errors++;
                  }
                }
                if (data29.minLength !== void 0) {
                  if (!(typeof data29.minLength == "number")) {
                    const err67 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/constraints/minLength", schemaPath: "#/definitions/properties/allOf/0/items/properties/constraints/properties/minLength/type", params: { type: "number" }, message: "should be number" };
                    if (vErrors === null) {
                      vErrors = [err67];
                    } else {
                      vErrors.push(err67);
                    }
                    errors++;
                  }
                }
                if (data29.maxLength !== void 0) {
                  if (!(typeof data29.maxLength == "number")) {
                    const err68 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/constraints/maxLength", schemaPath: "#/definitions/properties/allOf/0/items/properties/constraints/properties/maxLength/type", params: { type: "number" }, message: "should be number" };
                    if (vErrors === null) {
                      vErrors = [err68];
                    } else {
                      vErrors.push(err68);
                    }
                    errors++;
                  }
                }
                if (data29.pattern !== void 0) {
                  let data33 = data29.pattern;
                  const _errs74 = errors;
                  let valid26 = false;
                  let passing0 = null;
                  const _errs75 = errors;
                  if (data33 && typeof data33 == "object" && !Array.isArray(data33)) {
                    if (data33.value !== void 0) {
                      if (typeof data33.value !== "string") {
                        const err69 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/constraints/pattern/value", schemaPath: "#/definitions/properties/allOf/0/items/properties/constraints/properties/pattern/oneOf/0/properties/value/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err69];
                        } else {
                          vErrors.push(err69);
                        }
                        errors++;
                      }
                    }
                    if (data33.message !== void 0) {
                      if (typeof data33.message !== "string") {
                        const err70 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/constraints/pattern/message", schemaPath: "#/definitions/properties/allOf/0/items/properties/constraints/properties/pattern/oneOf/0/properties/message/type", params: { type: "string" }, message: "should be string" };
                        if (vErrors === null) {
                          vErrors = [err70];
                        } else {
                          vErrors.push(err70);
                        }
                        errors++;
                      }
                    }
                  } else {
                    const err71 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/constraints/pattern", schemaPath: "#/definitions/properties/allOf/0/items/properties/constraints/properties/pattern/oneOf/0/type", params: { type: "object" }, message: "should be object" };
                    if (vErrors === null) {
                      vErrors = [err71];
                    } else {
                      vErrors.push(err71);
                    }
                    errors++;
                  }
                  var _valid1 = _errs75 === errors;
                  if (_valid1) {
                    valid26 = true;
                    passing0 = 0;
                  }
                  const _errs81 = errors;
                  if (typeof data33 !== "string") {
                    const err72 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/constraints/pattern", schemaPath: "#/definitions/properties/allOf/0/items/properties/constraints/properties/pattern/oneOf/1/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err72];
                    } else {
                      vErrors.push(err72);
                    }
                    errors++;
                  }
                  var _valid1 = _errs81 === errors;
                  if (_valid1 && valid26) {
                    valid26 = false;
                    passing0 = [passing0, 1];
                  } else {
                    if (_valid1) {
                      valid26 = true;
                      passing0 = 1;
                    }
                  }
                  if (!valid26) {
                    const err73 = { keyword: "oneOf", dataPath: dataPath + "/properties/" + i22 + "/constraints/pattern", schemaPath: "#/definitions/properties/allOf/0/items/properties/constraints/properties/pattern/oneOf", params: { passingSchemas: passing0 }, message: "should match exactly one schema in oneOf" };
                    if (vErrors === null) {
                      vErrors = [err73];
                    } else {
                      vErrors.push(err73);
                    }
                    errors++;
                  } else {
                    errors = _errs74;
                    if (vErrors !== null) {
                      if (_errs74) {
                        vErrors.length = _errs74;
                      } else {
                        vErrors = null;
                      }
                    }
                  }
                }
              } else {
                const err74 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/constraints", schemaPath: "#/definitions/properties/allOf/0/items/properties/constraints/type", params: { type: "object" }, message: "should be object" };
                if (vErrors === null) {
                  vErrors = [err74];
                } else {
                  vErrors.push(err74);
                }
                errors++;
              }
            }
            if (data17.group !== void 0) {
              if (typeof data17.group !== "string") {
                const err75 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/group", schemaPath: "#/definitions/properties/allOf/0/items/properties/group/type", params: { type: "string" }, message: "should be string" };
                if (vErrors === null) {
                  vErrors = [err75];
                } else {
                  vErrors.push(err75);
                }
                errors++;
              }
            }
            if (data17.condition !== void 0) {
              let data37 = data17.condition;
              const _errs87 = errors;
              let valid28 = false;
              let passing1 = null;
              const _errs88 = errors;
              if (data37 && typeof data37 == "object" && !Array.isArray(data37)) {
                if (data37.equals === void 0) {
                  const err76 = { keyword: "required", dataPath: dataPath + "/properties/" + i22 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/oneOf/0/required", params: { missingProperty: "equals" }, message: "should have required property 'equals'" };
                  if (vErrors === null) {
                    vErrors = [err76];
                  } else {
                    vErrors.push(err76);
                  }
                  errors++;
                }
                if (data37.equals !== void 0) {
                  let data38 = data37.equals;
                  if (typeof data38 !== "string" && !(typeof data38 == "number") && typeof data38 !== "boolean") {
                    const err77 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/condition/equals", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/oneOf/0/properties/equals/type", params: { type: schema18.allOf[0].items.properties.condition.oneOf[0].properties.equals.type }, message: "should be string,number,boolean" };
                    if (vErrors === null) {
                      vErrors = [err77];
                    } else {
                      vErrors.push(err77);
                    }
                    errors++;
                  }
                }
              }
              var _valid2 = _errs88 === errors;
              if (_valid2) {
                valid28 = true;
                passing1 = 0;
              }
              const _errs91 = errors;
              if (data37 && typeof data37 == "object" && !Array.isArray(data37)) {
                if (data37.oneOf === void 0) {
                  const err78 = { keyword: "required", dataPath: dataPath + "/properties/" + i22 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/oneOf/1/required", params: { missingProperty: "oneOf" }, message: "should have required property 'oneOf'" };
                  if (vErrors === null) {
                    vErrors = [err78];
                  } else {
                    vErrors.push(err78);
                  }
                  errors++;
                }
                if (data37.oneOf !== void 0) {
                  let data39 = data37.oneOf;
                  if (Array.isArray(data39)) {
                    const len4 = data39.length;
                    for (let i42 = 0; i42 < len4; i42++) {
                      let data40 = data39[i42];
                      if (typeof data40 !== "string" && !(typeof data40 == "number")) {
                        const err79 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/condition/oneOf/" + i42, schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/oneOf/1/properties/oneOf/items/type", params: { type: schema18.allOf[0].items.properties.condition.oneOf[1].properties.oneOf.items.type }, message: "should be string,number" };
                        if (vErrors === null) {
                          vErrors = [err79];
                        } else {
                          vErrors.push(err79);
                        }
                        errors++;
                      }
                    }
                  } else {
                    const err80 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/condition/oneOf", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/oneOf/1/properties/oneOf/type", params: { type: "array" }, message: "should be array" };
                    if (vErrors === null) {
                      vErrors = [err80];
                    } else {
                      vErrors.push(err80);
                    }
                    errors++;
                  }
                }
              }
              var _valid2 = _errs91 === errors;
              if (_valid2 && valid28) {
                valid28 = false;
                passing1 = [passing1, 1];
              } else {
                if (_valid2) {
                  valid28 = true;
                  passing1 = 1;
                }
              }
              if (!valid28) {
                const err81 = { keyword: "oneOf", dataPath: dataPath + "/properties/" + i22 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/oneOf", params: { passingSchemas: passing1 }, message: "should match exactly one schema in oneOf" };
                if (vErrors === null) {
                  vErrors = [err81];
                } else {
                  vErrors.push(err81);
                }
                errors++;
              } else {
                errors = _errs87;
                if (vErrors !== null) {
                  if (_errs87) {
                    vErrors.length = _errs87;
                  } else {
                    vErrors = null;
                  }
                }
              }
              if (data37 && typeof data37 == "object" && !Array.isArray(data37)) {
                if (data37.property === void 0) {
                  const err82 = { keyword: "required", dataPath: dataPath + "/properties/" + i22 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/required", params: { missingProperty: "property" }, message: "should have required property 'property'" };
                  if (vErrors === null) {
                    vErrors = [err82];
                  } else {
                    vErrors.push(err82);
                  }
                  errors++;
                }
                if (data37.type !== void 0) {
                  if (!func0(data37.type, "simple")) {
                    const err83 = { keyword: "const", dataPath: dataPath + "/properties/" + i22 + "/condition/type", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/properties/type/const", params: { allowedValue: "simple" }, message: "should be equal to constant" };
                    if (vErrors === null) {
                      vErrors = [err83];
                    } else {
                      vErrors.push(err83);
                    }
                    errors++;
                  }
                }
                if (data37.property !== void 0) {
                  if (typeof data37.property !== "string") {
                    const err84 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/condition/property", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/properties/property/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err84];
                    } else {
                      vErrors.push(err84);
                    }
                    errors++;
                  }
                }
              } else {
                const err85 = { keyword: "type", dataPath: dataPath + "/properties/" + i22 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/type", params: { type: "object" }, message: "should be object" };
                if (vErrors === null) {
                  vErrors = [err85];
                } else {
                  vErrors.push(err85);
                }
                errors++;
              }
              if (errors > 0) {
                const emErrors7 = { "required": { "property": [] } };
                const templates7 = { required: {} };
                let emPropParams3;
                let emParamsErrors3;
                for (const err86 of vErrors) {
                  if (err86.keyword !== "errorMessage" && !err86.emUsed && err86.dataPath === dataPath + "/properties/" + i22 + "/condition" && err86.keyword in emErrors7 && err86.schemaPath.indexOf("#/definitions/properties/allOf/0/items/properties/condition") === 0 && /^\/[^\/]*$/.test(err86.schemaPath.slice(59))) {
                    emPropParams3 = obj0[err86.keyword];
                    emParamsErrors3 = emErrors7[err86.keyword][err86.params[emPropParams3]];
                    if (emParamsErrors3) {
                      emParamsErrors3.push(err86);
                      err86.emUsed = true;
                    }
                  }
                }
                for (const key7 in emErrors7) {
                  for (const keyProp3 in emErrors7[key7]) {
                    emParamsErrors3 = emErrors7[key7][keyProp3];
                    if (emParamsErrors3.length) {
                      const tmpl3 = templates7[key7] && templates7[key7][keyProp3];
                      const err87 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i22 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/properties/condition/errorMessage", params: { errors: emParamsErrors3 }, message: tmpl3 ? tmpl3() : schema18.allOf[0].items.properties.condition.errorMessage[key7][keyProp3] };
                      if (vErrors === null) {
                        vErrors = [err87];
                      } else {
                        vErrors.push(err87);
                      }
                      errors++;
                    }
                  }
                }
                const emErrs9 = [];
                for (const err88 of vErrors) {
                  if (!err88.emUsed) {
                    emErrs9.push(err88);
                  }
                }
                vErrors = emErrs9;
                errors = emErrs9.length;
              }
            }
          } else {
            const err89 = { keyword: "type", dataPath: dataPath + "/properties/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/type", params: { type: "object" }, message: "should be object" };
            if (vErrors === null) {
              vErrors = [err89];
            } else {
              vErrors.push(err89);
            }
            errors++;
          }
        }
      } else {
        const err90 = { keyword: "type", dataPath: dataPath + "/properties", schemaPath: "#/definitions/properties/allOf/0/type", params: { type: "array" }, message: "should be array" };
        if (vErrors === null) {
          vErrors = [err90];
        } else {
          vErrors.push(err90);
        }
        errors++;
      }
      if (Array.isArray(data16)) {
        const len5 = data16.length;
        for (let i52 = 0; i52 < len5; i52++) {
          let data43 = data16[i52];
          const _errs104 = errors;
          let valid38 = true;
          const _errs105 = errors;
          if (data43 && typeof data43 == "object" && !Array.isArray(data43)) {
            if (data43.binding === void 0 && "binding") {
              const err91 = {};
              if (vErrors === null) {
                vErrors = [err91];
              } else {
                vErrors.push(err91);
              }
              errors++;
            } else {
              if (data43.binding !== void 0) {
                let data44 = data43.binding;
                if (data44 && typeof data44 == "object" && !Array.isArray(data44)) {
                  if (data44.type === void 0 && "type") {
                    const err92 = {};
                    if (vErrors === null) {
                      vErrors = [err92];
                    } else {
                      vErrors.push(err92);
                    }
                    errors++;
                  } else {
                    if (data44.type !== void 0) {
                      if (!func0(data44.type, "property")) {
                        const err93 = {};
                        if (vErrors === null) {
                          vErrors = [err93];
                        } else {
                          vErrors.push(err93);
                        }
                        errors++;
                      }
                    }
                  }
                }
              }
            }
          }
          var _valid3 = _errs105 === errors;
          errors = _errs104;
          if (vErrors !== null) {
            if (_errs104) {
              vErrors.length = _errs104;
            } else {
              vErrors = null;
            }
          }
          if (_valid3) {
            const _errs108 = errors;
            if (data43 && typeof data43 == "object" && !Array.isArray(data43)) {
              if (data43.type !== void 0) {
                let data46 = data43.type;
                if (!(data46 === "String" || data46 === "Text" || data46 === "Hidden" || data46 === "Dropdown" || data46 === "Boolean")) {
                  const err94 = { keyword: "enum", dataPath: dataPath + "/properties/" + i52 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/0/then/properties/type/enum", params: { allowedValues: schema18.allOf[1].items.allOf[0].then.properties.type.enum }, message: "should be equal to one of the allowed values" };
                  if (vErrors === null) {
                    vErrors = [err94];
                  } else {
                    vErrors.push(err94);
                  }
                  errors++;
                }
                if (errors > 0) {
                  const emErrs10 = [];
                  for (const err95 of vErrors) {
                    if (err95.keyword !== "errorMessage" && !err95.emUsed && (err95.dataPath === dataPath + "/properties/" + i52 + "/type" || err95.dataPath.indexOf(dataPath + "/properties/" + i52 + "/type") === 0 && err95.dataPath[dataPath + "/properties/" + i52 + "/type".length] === "/") && err95.schemaPath.indexOf("#/definitions/properties/allOf/1/items/allOf/0/then/properties/type") === 0 && err95.schemaPath["#/definitions/properties/allOf/1/items/allOf/0/then/properties/type".length] === "/") {
                      emErrs10.push(err95);
                      err95.emUsed = true;
                    }
                  }
                  if (emErrs10.length) {
                    const err96 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i52 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/0/then/properties/type/errorMessage", params: { errors: emErrs10 }, message: "invalid property type " + JSON.stringify(data46) + ' for binding type "property"; must be any of { String, Text, Hidden, Dropdown, Boolean }' };
                    if (vErrors === null) {
                      vErrors = [err96];
                    } else {
                      vErrors.push(err96);
                    }
                    errors++;
                  }
                  const emErrs11 = [];
                  for (const err97 of vErrors) {
                    if (!err97.emUsed) {
                      emErrs11.push(err97);
                    }
                  }
                  vErrors = emErrs11;
                  errors = emErrs11.length;
                }
              }
            }
            var _valid3 = _errs108 === errors;
            valid38 = _valid3;
          }
          if (!valid38) {
            const err98 = { keyword: "if", dataPath: dataPath + "/properties/" + i52, schemaPath: "#/definitions/properties/allOf/1/items/allOf/0/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
            if (vErrors === null) {
              vErrors = [err98];
            } else {
              vErrors.push(err98);
            }
            errors++;
          }
          const _errs111 = errors;
          let valid42 = true;
          const _errs112 = errors;
          if (data43 && typeof data43 == "object" && !Array.isArray(data43)) {
            if (data43.binding === void 0 && "binding") {
              const err99 = {};
              if (vErrors === null) {
                vErrors = [err99];
              } else {
                vErrors.push(err99);
              }
              errors++;
            } else {
              if (data43.binding !== void 0) {
                let data47 = data43.binding;
                if (data47 && typeof data47 == "object" && !Array.isArray(data47)) {
                  if (data47.type === void 0 && "type") {
                    const err100 = {};
                    if (vErrors === null) {
                      vErrors = [err100];
                    } else {
                      vErrors.push(err100);
                    }
                    errors++;
                  } else {
                    if (data47.type !== void 0) {
                      let data48 = data47.type;
                      if (!(data48 === "zeebe:input" || data48 === "zeebe:output" || data48 === "zeebe:property" || data48 === "zeebe:taskHeader" || data48 === "zeebe:taskDefinition:type")) {
                        const err101 = {};
                        if (vErrors === null) {
                          vErrors = [err101];
                        } else {
                          vErrors.push(err101);
                        }
                        errors++;
                      }
                    }
                  }
                }
              }
            }
          }
          var _valid4 = _errs112 === errors;
          errors = _errs111;
          if (vErrors !== null) {
            if (_errs111) {
              vErrors.length = _errs111;
            } else {
              vErrors = null;
            }
          }
          if (_valid4) {
            const _errs115 = errors;
            if (data43 && typeof data43 == "object" && !Array.isArray(data43)) {
              if (data43.type !== void 0) {
                let data49 = data43.type;
                if (!(data49 === "String" || data49 === "Text" || data49 === "Hidden" || data49 === "Dropdown")) {
                  const err102 = { keyword: "enum", dataPath: dataPath + "/properties/" + i52 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/1/then/properties/type/enum", params: { allowedValues: schema18.allOf[1].items.allOf[1].then.properties.type.enum }, message: "should be equal to one of the allowed values" };
                  if (vErrors === null) {
                    vErrors = [err102];
                  } else {
                    vErrors.push(err102);
                  }
                  errors++;
                }
                if (errors > 0) {
                  const emErrs12 = [];
                  for (const err103 of vErrors) {
                    if (err103.keyword !== "errorMessage" && !err103.emUsed && (err103.dataPath === dataPath + "/properties/" + i52 + "/type" || err103.dataPath.indexOf(dataPath + "/properties/" + i52 + "/type") === 0 && err103.dataPath[dataPath + "/properties/" + i52 + "/type".length] === "/") && err103.schemaPath.indexOf("#/definitions/properties/allOf/1/items/allOf/1/then/properties/type") === 0 && err103.schemaPath["#/definitions/properties/allOf/1/items/allOf/1/then/properties/type".length] === "/") {
                      emErrs12.push(err103);
                      err103.emUsed = true;
                    }
                  }
                  if (emErrs12.length) {
                    const err104 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i52 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/1/then/properties/type/errorMessage", params: { errors: emErrs12 }, message: "invalid property type " + JSON.stringify(data49) + " for binding type " + JSON.stringify(data43 && data43.binding && data43.binding.type) + "; must be any of { String, Text, Hidden, Dropdown }" };
                    if (vErrors === null) {
                      vErrors = [err104];
                    } else {
                      vErrors.push(err104);
                    }
                    errors++;
                  }
                  const emErrs13 = [];
                  for (const err105 of vErrors) {
                    if (!err105.emUsed) {
                      emErrs13.push(err105);
                    }
                  }
                  vErrors = emErrs13;
                  errors = emErrs13.length;
                }
              }
            }
            var _valid4 = _errs115 === errors;
            valid42 = _valid4;
          }
          if (!valid42) {
            const err106 = { keyword: "if", dataPath: dataPath + "/properties/" + i52, schemaPath: "#/definitions/properties/allOf/1/items/allOf/1/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
            if (vErrors === null) {
              vErrors = [err106];
            } else {
              vErrors.push(err106);
            }
            errors++;
          }
          const _errs118 = errors;
          let valid46 = true;
          const _errs119 = errors;
          if (data43 && typeof data43 == "object" && !Array.isArray(data43)) {
            if (data43.optional === void 0 && "optional") {
              const err107 = {};
              if (vErrors === null) {
                vErrors = [err107];
              } else {
                vErrors.push(err107);
              }
              errors++;
            } else {
              if (data43.optional !== void 0) {
                if (!func0(data43.optional, true)) {
                  const err108 = {};
                  if (vErrors === null) {
                    vErrors = [err108];
                  } else {
                    vErrors.push(err108);
                  }
                  errors++;
                }
              }
            }
          }
          var _valid5 = _errs119 === errors;
          errors = _errs118;
          if (vErrors !== null) {
            if (_errs118) {
              vErrors.length = _errs118;
            } else {
              vErrors = null;
            }
          }
          if (_valid5) {
            const _errs121 = errors;
            if (data43 && typeof data43 == "object" && !Array.isArray(data43)) {
              if (data43.binding !== void 0) {
                let data51 = data43.binding;
                if (data51 && typeof data51 == "object" && !Array.isArray(data51)) {
                  if (data51.type === void 0) {
                    const err109 = { keyword: "required", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/allOf/2/then/properties/binding/required", params: { missingProperty: "type" }, message: "should have required property 'type'" };
                    if (vErrors === null) {
                      vErrors = [err109];
                    } else {
                      vErrors.push(err109);
                    }
                    errors++;
                  }
                  if (data51.type !== void 0) {
                    let data52 = data51.type;
                    if (!(data52 === "zeebe:input" || data52 === "zeebe:output" || data52 === "zeebe:property")) {
                      const err110 = { keyword: "enum", dataPath: dataPath + "/properties/" + i52 + "/binding/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/2/then/properties/binding/properties/type/enum", params: { allowedValues: schema18.allOf[1].items.allOf[2].then.properties.binding.properties.type.enum }, message: "should be equal to one of the allowed values" };
                      if (vErrors === null) {
                        vErrors = [err110];
                      } else {
                        vErrors.push(err110);
                      }
                      errors++;
                    }
                    if (errors > 0) {
                      const emErrs14 = [];
                      for (const err111 of vErrors) {
                        if (err111.keyword !== "errorMessage" && !err111.emUsed && (err111.dataPath === dataPath + "/properties/" + i52 + "/binding/type" || err111.dataPath.indexOf(dataPath + "/properties/" + i52 + "/binding/type") === 0 && err111.dataPath[dataPath + "/properties/" + i52 + "/binding/type".length] === "/") && err111.schemaPath.indexOf("#/definitions/properties/allOf/1/items/allOf/2/then/properties/binding/properties/type") === 0 && err111.schemaPath["#/definitions/properties/allOf/1/items/allOf/2/then/properties/binding/properties/type".length] === "/") {
                          emErrs14.push(err111);
                          err111.emUsed = true;
                        }
                      }
                      if (emErrs14.length) {
                        const err112 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i52 + "/binding/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/2/then/properties/binding/properties/type/errorMessage", params: { errors: emErrs14 }, message: "optional is not supported for binding type " + JSON.stringify(data52) + "; must be any of { zeebe:input, zeebe:output, zeebe:property }" };
                        if (vErrors === null) {
                          vErrors = [err112];
                        } else {
                          vErrors.push(err112);
                        }
                        errors++;
                      }
                      const emErrs15 = [];
                      for (const err113 of vErrors) {
                        if (!err113.emUsed) {
                          emErrs15.push(err113);
                        }
                      }
                      vErrors = emErrs15;
                      errors = emErrs15.length;
                    }
                  }
                }
              }
            }
            var _valid5 = _errs121 === errors;
            valid46 = _valid5;
          }
          if (!valid46) {
            const err114 = { keyword: "if", dataPath: dataPath + "/properties/" + i52, schemaPath: "#/definitions/properties/allOf/1/items/allOf/2/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
            if (vErrors === null) {
              vErrors = [err114];
            } else {
              vErrors.push(err114);
            }
            errors++;
          }
          const _errs125 = errors;
          let valid50 = true;
          const _errs126 = errors;
          if (data43 && typeof data43 == "object" && !Array.isArray(data43)) {
            if (data43.optional === void 0 && "optional") {
              const err115 = {};
              if (vErrors === null) {
                vErrors = [err115];
              } else {
                vErrors.push(err115);
              }
              errors++;
            } else {
              if (data43.optional !== void 0) {
                if (!func0(data43.optional, true)) {
                  const err116 = {};
                  if (vErrors === null) {
                    vErrors = [err116];
                  } else {
                    vErrors.push(err116);
                  }
                  errors++;
                }
              }
            }
          }
          var _valid6 = _errs126 === errors;
          errors = _errs125;
          if (vErrors !== null) {
            if (_errs125) {
              vErrors.length = _errs125;
            } else {
              vErrors = null;
            }
          }
          if (_valid6) {
            const _errs128 = errors;
            if (data43 && typeof data43 == "object" && !Array.isArray(data43)) {
              if (data43.constraints !== void 0) {
                let data54 = data43.constraints;
                if (data54 && typeof data54 == "object" && !Array.isArray(data54)) {
                  if (data54.notEmpty === void 0) {
                    const err117 = { keyword: "required", dataPath: dataPath + "/properties/" + i52 + "/constraints", schemaPath: "#/definitions/properties/allOf/1/items/allOf/3/then/properties/constraints/required", params: { missingProperty: "notEmpty" }, message: "should have required property 'notEmpty'" };
                    if (vErrors === null) {
                      vErrors = [err117];
                    } else {
                      vErrors.push(err117);
                    }
                    errors++;
                  }
                  if (data54.notEmpty !== void 0) {
                    if (!func0(data54.notEmpty, false)) {
                      const err118 = { keyword: "const", dataPath: dataPath + "/properties/" + i52 + "/constraints/notEmpty", schemaPath: "#/definitions/properties/allOf/1/items/allOf/3/then/properties/constraints/properties/notEmpty/const", params: { allowedValue: false }, message: "should be equal to constant" };
                      if (vErrors === null) {
                        vErrors = [err118];
                      } else {
                        vErrors.push(err118);
                      }
                      errors++;
                    }
                    if (errors > 0) {
                      const emErrs16 = [];
                      for (const err119 of vErrors) {
                        if (err119.keyword !== "errorMessage" && !err119.emUsed && (err119.dataPath === dataPath + "/properties/" + i52 + "/constraints/notEmpty" || err119.dataPath.indexOf(dataPath + "/properties/" + i52 + "/constraints/notEmpty") === 0 && err119.dataPath[dataPath + "/properties/" + i52 + "/constraints/notEmpty".length] === "/") && err119.schemaPath.indexOf("#/definitions/properties/allOf/1/items/allOf/3/then/properties/constraints/properties/notEmpty") === 0 && err119.schemaPath["#/definitions/properties/allOf/1/items/allOf/3/then/properties/constraints/properties/notEmpty".length] === "/") {
                          emErrs16.push(err119);
                          err119.emUsed = true;
                        }
                      }
                      if (emErrs16.length) {
                        const err120 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i52 + "/constraints/notEmpty", schemaPath: "#/definitions/properties/allOf/1/items/allOf/3/then/properties/constraints/properties/notEmpty/errorMessage", params: { errors: emErrs16 }, message: 'optional is not allowed for truthy "notEmpty" constraint' };
                        if (vErrors === null) {
                          vErrors = [err120];
                        } else {
                          vErrors.push(err120);
                        }
                        errors++;
                      }
                      const emErrs17 = [];
                      for (const err121 of vErrors) {
                        if (!err121.emUsed) {
                          emErrs17.push(err121);
                        }
                      }
                      vErrors = emErrs17;
                      errors = emErrs17.length;
                    }
                  }
                }
              }
            }
            var _valid6 = _errs128 === errors;
            valid50 = _valid6;
          }
          if (!valid50) {
            const err122 = { keyword: "if", dataPath: dataPath + "/properties/" + i52, schemaPath: "#/definitions/properties/allOf/1/items/allOf/3/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
            if (vErrors === null) {
              vErrors = [err122];
            } else {
              vErrors.push(err122);
            }
            errors++;
          }
          const _errs132 = errors;
          let valid54 = true;
          const _errs133 = errors;
          if (data43 && typeof data43 == "object" && !Array.isArray(data43)) {
            if (data43.feel === void 0 && "feel") {
              const err123 = {};
              if (vErrors === null) {
                vErrors = [err123];
              } else {
                vErrors.push(err123);
              }
              errors++;
            } else {
              if (data43.feel !== void 0) {
                const _errs135 = errors;
                const _errs136 = errors;
                if (!func0(data43.feel, schema18.allOf[1].items.allOf[4].if.properties.feel.not.const)) {
                  const err124 = {};
                  if (vErrors === null) {
                    vErrors = [err124];
                  } else {
                    vErrors.push(err124);
                  }
                  errors++;
                }
                var valid56 = _errs136 === errors;
                if (!valid56) {
                  errors = _errs135;
                  if (vErrors !== null) {
                    if (_errs135) {
                      vErrors.length = _errs135;
                    } else {
                      vErrors = null;
                    }
                  }
                } else {
                  const err125 = {};
                  if (vErrors === null) {
                    vErrors = [err125];
                  } else {
                    vErrors.push(err125);
                  }
                  errors++;
                }
              }
            }
          }
          var _valid7 = _errs133 === errors;
          errors = _errs132;
          if (vErrors !== null) {
            if (_errs132) {
              vErrors.length = _errs132;
            } else {
              vErrors = null;
            }
          }
          if (_valid7) {
            const _errs137 = errors;
            if (data43 && typeof data43 == "object" && !Array.isArray(data43)) {
              if (data43.type === void 0) {
                const err126 = { keyword: "required", dataPath: dataPath + "/properties/" + i52, schemaPath: "#/definitions/properties/allOf/1/items/allOf/4/then/required", params: { missingProperty: "type" }, message: "should have required property 'type'" };
                if (vErrors === null) {
                  vErrors = [err126];
                } else {
                  vErrors.push(err126);
                }
                errors++;
              }
              if (data43.type !== void 0) {
                let data57 = data43.type;
                if (!(data57 === "String" || data57 === "Text")) {
                  const err127 = { keyword: "enum", dataPath: dataPath + "/properties/" + i52 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/4/then/properties/type/enum", params: { allowedValues: schema18.allOf[1].items.allOf[4].then.properties.type.enum }, message: "should be equal to one of the allowed values" };
                  if (vErrors === null) {
                    vErrors = [err127];
                  } else {
                    vErrors.push(err127);
                  }
                  errors++;
                }
                if (errors > 0) {
                  const emErrs18 = [];
                  for (const err128 of vErrors) {
                    if (err128.keyword !== "errorMessage" && !err128.emUsed && (err128.dataPath === dataPath + "/properties/" + i52 + "/type" || err128.dataPath.indexOf(dataPath + "/properties/" + i52 + "/type") === 0 && err128.dataPath[dataPath + "/properties/" + i52 + "/type".length] === "/") && err128.schemaPath.indexOf("#/definitions/properties/allOf/1/items/allOf/4/then/properties/type") === 0 && err128.schemaPath["#/definitions/properties/allOf/1/items/allOf/4/then/properties/type".length] === "/") {
                      emErrs18.push(err128);
                      err128.emUsed = true;
                    }
                  }
                  if (emErrs18.length) {
                    const err129 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i52 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/4/then/properties/type/errorMessage", params: { errors: emErrs18 }, message: 'feel is only supported for "String" and "Text" type' };
                    if (vErrors === null) {
                      vErrors = [err129];
                    } else {
                      vErrors.push(err129);
                    }
                    errors++;
                  }
                  const emErrs19 = [];
                  for (const err130 of vErrors) {
                    if (!err130.emUsed) {
                      emErrs19.push(err130);
                    }
                  }
                  vErrors = emErrs19;
                  errors = emErrs19.length;
                }
              }
            }
            var _valid7 = _errs137 === errors;
            valid54 = _valid7;
          }
          if (!valid54) {
            const err131 = { keyword: "if", dataPath: dataPath + "/properties/" + i52, schemaPath: "#/definitions/properties/allOf/1/items/allOf/4/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
            if (vErrors === null) {
              vErrors = [err131];
            } else {
              vErrors.push(err131);
            }
            errors++;
          }
          if (data43 && typeof data43 == "object" && !Array.isArray(data43)) {
            if (data43.binding === void 0) {
              const err132 = { keyword: "required", dataPath: dataPath + "/properties/" + i52, schemaPath: "#/definitions/properties/allOf/1/items/required", params: { missingProperty: "binding" }, message: "should have required property 'binding'" };
              if (vErrors === null) {
                vErrors = [err132];
              } else {
                vErrors.push(err132);
              }
              errors++;
            }
            if (data43.binding !== void 0) {
              let data58 = data43.binding;
              const _errs142 = errors;
              let valid60 = true;
              const _errs143 = errors;
              if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
                if (data58.type === void 0 && "type") {
                  const err133 = {};
                  if (vErrors === null) {
                    vErrors = [err133];
                  } else {
                    vErrors.push(err133);
                  }
                  errors++;
                } else {
                  if (data58.type !== void 0) {
                    let data59 = data58.type;
                    if (!(data59 === "property" || data59 === "zeebe:property" || data59 === "zeebe:input")) {
                      const err134 = {};
                      if (vErrors === null) {
                        vErrors = [err134];
                      } else {
                        vErrors.push(err134);
                      }
                      errors++;
                    }
                  }
                }
              }
              var _valid8 = _errs143 === errors;
              errors = _errs142;
              if (vErrors !== null) {
                if (_errs142) {
                  vErrors.length = _errs142;
                } else {
                  vErrors = null;
                }
              }
              if (_valid8) {
                const _errs145 = errors;
                if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
                  if (data58.name === void 0) {
                    const err135 = { keyword: "required", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/0/then/required", params: { missingProperty: "name" }, message: "should have required property 'name'" };
                    if (vErrors === null) {
                      vErrors = [err135];
                    } else {
                      vErrors.push(err135);
                    }
                    errors++;
                  }
                }
                if (errors > 0) {
                  const emErrs20 = [];
                  for (const err136 of vErrors) {
                    if (err136.keyword !== "errorMessage" && !err136.emUsed && (err136.dataPath === dataPath + "/properties/" + i52 + "/binding" || err136.dataPath.indexOf(dataPath + "/properties/" + i52 + "/binding") === 0 && err136.dataPath[dataPath + "/properties/" + i52 + "/binding".length] === "/") && err136.schemaPath.indexOf("#/definitions/properties/allOf/1/items/properties/binding/allOf/0/then") === 0 && err136.schemaPath["#/definitions/properties/allOf/1/items/properties/binding/allOf/0/then".length] === "/") {
                      emErrs20.push(err136);
                      err136.emUsed = true;
                    }
                  }
                  if (emErrs20.length) {
                    const err137 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/0/then/errorMessage", params: { errors: emErrs20 }, message: "property.binding " + JSON.stringify(data58 && data58.type) + " requires name" };
                    if (vErrors === null) {
                      vErrors = [err137];
                    } else {
                      vErrors.push(err137);
                    }
                    errors++;
                  }
                  const emErrs21 = [];
                  for (const err138 of vErrors) {
                    if (!err138.emUsed) {
                      emErrs21.push(err138);
                    }
                  }
                  vErrors = emErrs21;
                  errors = emErrs21.length;
                }
                var _valid8 = _errs145 === errors;
                valid60 = _valid8;
              }
              if (!valid60) {
                const err139 = { keyword: "if", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/0/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                if (vErrors === null) {
                  vErrors = [err139];
                } else {
                  vErrors.push(err139);
                }
                errors++;
              }
              const _errs147 = errors;
              let valid62 = true;
              const _errs148 = errors;
              if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
                if (data58.type === void 0 && "type") {
                  const err140 = {};
                  if (vErrors === null) {
                    vErrors = [err140];
                  } else {
                    vErrors.push(err140);
                  }
                  errors++;
                } else {
                  if (data58.type !== void 0) {
                    if (!func0(data58.type, "zeebe:output")) {
                      const err141 = {};
                      if (vErrors === null) {
                        vErrors = [err141];
                      } else {
                        vErrors.push(err141);
                      }
                      errors++;
                    }
                  }
                }
              }
              var _valid9 = _errs148 === errors;
              errors = _errs147;
              if (vErrors !== null) {
                if (_errs147) {
                  vErrors.length = _errs147;
                } else {
                  vErrors = null;
                }
              }
              if (_valid9) {
                const _errs150 = errors;
                if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
                  if (data58.source === void 0) {
                    const err142 = { keyword: "required", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/1/then/required", params: { missingProperty: "source" }, message: "should have required property 'source'" };
                    if (vErrors === null) {
                      vErrors = [err142];
                    } else {
                      vErrors.push(err142);
                    }
                    errors++;
                  }
                }
                if (errors > 0) {
                  const emErrs22 = [];
                  for (const err143 of vErrors) {
                    if (err143.keyword !== "errorMessage" && !err143.emUsed && (err143.dataPath === dataPath + "/properties/" + i52 + "/binding" || err143.dataPath.indexOf(dataPath + "/properties/" + i52 + "/binding") === 0 && err143.dataPath[dataPath + "/properties/" + i52 + "/binding".length] === "/") && err143.schemaPath.indexOf("#/definitions/properties/allOf/1/items/properties/binding/allOf/1/then") === 0 && err143.schemaPath["#/definitions/properties/allOf/1/items/properties/binding/allOf/1/then".length] === "/") {
                      emErrs22.push(err143);
                      err143.emUsed = true;
                    }
                  }
                  if (emErrs22.length) {
                    const err144 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/1/then/errorMessage", params: { errors: emErrs22 }, message: "property.binding " + JSON.stringify(data58 && data58.type) + " requires source" };
                    if (vErrors === null) {
                      vErrors = [err144];
                    } else {
                      vErrors.push(err144);
                    }
                    errors++;
                  }
                  const emErrs23 = [];
                  for (const err145 of vErrors) {
                    if (!err145.emUsed) {
                      emErrs23.push(err145);
                    }
                  }
                  vErrors = emErrs23;
                  errors = emErrs23.length;
                }
                var _valid9 = _errs150 === errors;
                valid62 = _valid9;
              }
              if (!valid62) {
                const err146 = { keyword: "if", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/1/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                if (vErrors === null) {
                  vErrors = [err146];
                } else {
                  vErrors.push(err146);
                }
                errors++;
              }
              const _errs152 = errors;
              let valid64 = true;
              const _errs153 = errors;
              if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
                if (data58.type === void 0 && "type") {
                  const err147 = {};
                  if (vErrors === null) {
                    vErrors = [err147];
                  } else {
                    vErrors.push(err147);
                  }
                  errors++;
                } else {
                  if (data58.type !== void 0) {
                    if (!func0(data58.type, "zeebe:taskHeader")) {
                      const err148 = {};
                      if (vErrors === null) {
                        vErrors = [err148];
                      } else {
                        vErrors.push(err148);
                      }
                      errors++;
                    }
                  }
                }
              }
              var _valid10 = _errs153 === errors;
              errors = _errs152;
              if (vErrors !== null) {
                if (_errs152) {
                  vErrors.length = _errs152;
                } else {
                  vErrors = null;
                }
              }
              if (_valid10) {
                const _errs155 = errors;
                if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
                  if (data58.key === void 0) {
                    const err149 = { keyword: "required", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/2/then/required", params: { missingProperty: "key" }, message: "should have required property 'key'" };
                    if (vErrors === null) {
                      vErrors = [err149];
                    } else {
                      vErrors.push(err149);
                    }
                    errors++;
                  }
                }
                if (errors > 0) {
                  const emErrs24 = [];
                  for (const err150 of vErrors) {
                    if (err150.keyword !== "errorMessage" && !err150.emUsed && (err150.dataPath === dataPath + "/properties/" + i52 + "/binding" || err150.dataPath.indexOf(dataPath + "/properties/" + i52 + "/binding") === 0 && err150.dataPath[dataPath + "/properties/" + i52 + "/binding".length] === "/") && err150.schemaPath.indexOf("#/definitions/properties/allOf/1/items/properties/binding/allOf/2/then") === 0 && err150.schemaPath["#/definitions/properties/allOf/1/items/properties/binding/allOf/2/then".length] === "/") {
                      emErrs24.push(err150);
                      err150.emUsed = true;
                    }
                  }
                  if (emErrs24.length) {
                    const err151 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/2/then/errorMessage", params: { errors: emErrs24 }, message: "property.binding " + JSON.stringify(data58 && data58.type) + " requires key" };
                    if (vErrors === null) {
                      vErrors = [err151];
                    } else {
                      vErrors.push(err151);
                    }
                    errors++;
                  }
                  const emErrs25 = [];
                  for (const err152 of vErrors) {
                    if (!err152.emUsed) {
                      emErrs25.push(err152);
                    }
                  }
                  vErrors = emErrs25;
                  errors = emErrs25.length;
                }
                var _valid10 = _errs155 === errors;
                valid64 = _valid10;
              }
              if (!valid64) {
                const err153 = { keyword: "if", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/2/if", params: { failingKeyword: "then" }, message: 'should match "then" schema' };
                if (vErrors === null) {
                  vErrors = [err153];
                } else {
                  vErrors.push(err153);
                }
                errors++;
              }
              if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
                if (data58.type === void 0) {
                  const err154 = { keyword: "required", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/required", params: { missingProperty: "type" }, message: "should have required property 'type'" };
                  if (vErrors === null) {
                    vErrors = [err154];
                  } else {
                    vErrors.push(err154);
                  }
                  errors++;
                }
                if (data58.type !== void 0) {
                  let data62 = data58.type;
                  if (typeof data62 !== "string") {
                    const err155 = { keyword: "type", dataPath: dataPath + "/properties/" + i52 + "/binding/type", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/type/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err155];
                    } else {
                      vErrors.push(err155);
                    }
                    errors++;
                  }
                  if (!(data62 === "property" || data62 === "zeebe:taskDefinition:type" || data62 === "zeebe:input" || data62 === "zeebe:output" || data62 === "zeebe:property" || data62 === "zeebe:taskHeader")) {
                    const err156 = { keyword: "enum", dataPath: dataPath + "/properties/" + i52 + "/binding/type", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/type/enum", params: { allowedValues: schema18.allOf[1].items.properties.binding.properties.type.enum }, message: "should be equal to one of the allowed values" };
                    if (vErrors === null) {
                      vErrors = [err156];
                    } else {
                      vErrors.push(err156);
                    }
                    errors++;
                  }
                  if (errors > 0) {
                    const emErrs26 = [];
                    for (const err157 of vErrors) {
                      if (err157.keyword !== "errorMessage" && !err157.emUsed && (err157.dataPath === dataPath + "/properties/" + i52 + "/binding/type" || err157.dataPath.indexOf(dataPath + "/properties/" + i52 + "/binding/type") === 0 && err157.dataPath[dataPath + "/properties/" + i52 + "/binding/type".length] === "/") && err157.schemaPath.indexOf("#/definitions/properties/allOf/1/items/properties/binding/properties/type") === 0 && err157.schemaPath["#/definitions/properties/allOf/1/items/properties/binding/properties/type".length] === "/") {
                        emErrs26.push(err157);
                        err157.emUsed = true;
                      }
                    }
                    if (emErrs26.length) {
                      const err158 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i52 + "/binding/type", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/type/errorMessage", params: { errors: emErrs26 }, message: "invalid property.binding type " + JSON.stringify(data62) + "; must be any of { property, zeebe:taskDefinition:type, zeebe:input, zeebe:output, zeebe:property, zeebe:taskHeader }" };
                      if (vErrors === null) {
                        vErrors = [err158];
                      } else {
                        vErrors.push(err158);
                      }
                      errors++;
                    }
                    const emErrs27 = [];
                    for (const err159 of vErrors) {
                      if (!err159.emUsed) {
                        emErrs27.push(err159);
                      }
                    }
                    vErrors = emErrs27;
                    errors = emErrs27.length;
                  }
                }
                if (data58.name !== void 0) {
                  if (typeof data58.name !== "string") {
                    const err160 = { keyword: "type", dataPath: dataPath + "/properties/" + i52 + "/binding/name", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/name/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err160];
                    } else {
                      vErrors.push(err160);
                    }
                    errors++;
                  }
                }
                if (data58.source !== void 0) {
                  if (typeof data58.source !== "string") {
                    const err161 = { keyword: "type", dataPath: dataPath + "/properties/" + i52 + "/binding/source", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/source/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err161];
                    } else {
                      vErrors.push(err161);
                    }
                    errors++;
                  }
                }
                if (data58.key !== void 0) {
                  if (typeof data58.key !== "string") {
                    const err162 = { keyword: "type", dataPath: dataPath + "/properties/" + i52 + "/binding/key", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/key/type", params: { type: "string" }, message: "should be string" };
                    if (vErrors === null) {
                      vErrors = [err162];
                    } else {
                      vErrors.push(err162);
                    }
                    errors++;
                  }
                }
              } else {
                const err163 = { keyword: "type", dataPath: dataPath + "/properties/" + i52 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/type", params: { type: "object" }, message: "should be object" };
                if (vErrors === null) {
                  vErrors = [err163];
                } else {
                  vErrors.push(err163);
                }
                errors++;
              }
            }
            if (data43.optional !== void 0) {
              if (typeof data43.optional !== "boolean") {
                const err164 = { keyword: "type", dataPath: dataPath + "/properties/" + i52 + "/optional", schemaPath: "#/definitions/properties/allOf/1/items/properties/optional/type", params: { type: "boolean" }, message: "should be boolean" };
                if (vErrors === null) {
                  vErrors = [err164];
                } else {
                  vErrors.push(err164);
                }
                errors++;
              }
            }
            if (data43.feel !== void 0) {
              let data67 = data43.feel;
              if (typeof data67 !== "string") {
                const err165 = { keyword: "type", dataPath: dataPath + "/properties/" + i52 + "/feel", schemaPath: "#/definitions/properties/allOf/1/items/properties/feel/type", params: { type: "string" }, message: "should be string" };
                if (vErrors === null) {
                  vErrors = [err165];
                } else {
                  vErrors.push(err165);
                }
                errors++;
              }
              if (!(data67 === null || data67 === "optional" || data67 === "required")) {
                const err166 = { keyword: "enum", dataPath: dataPath + "/properties/" + i52 + "/feel", schemaPath: "#/definitions/properties/allOf/1/items/properties/feel/enum", params: { allowedValues: schema18.allOf[1].items.properties.feel.enum }, message: "should be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err166];
                } else {
                  vErrors.push(err166);
                }
                errors++;
              }
            }
          } else {
            const err167 = { keyword: "type", dataPath: dataPath + "/properties/" + i52, schemaPath: "#/definitions/properties/allOf/1/items/type", params: { type: "object" }, message: "should be object" };
            if (vErrors === null) {
              vErrors = [err167];
            } else {
              vErrors.push(err167);
            }
            errors++;
          }
          if (errors > 0) {
            const emErrors8 = { "required": { "binding": [] } };
            const templates8 = { required: { binding: function() {
              return 'missing binding for property "' + JSON.stringify(i52) + '"';
            } } };
            let emPropParams4;
            let emParamsErrors4;
            for (const err168 of vErrors) {
              if (err168.keyword !== "errorMessage" && !err168.emUsed && err168.dataPath === dataPath + "/properties/" + i52 && err168.keyword in emErrors8 && err168.schemaPath.indexOf("#/definitions/properties/allOf/1/items") === 0 && /^\/[^\/]*$/.test(err168.schemaPath.slice(38))) {
                emPropParams4 = obj0[err168.keyword];
                emParamsErrors4 = emErrors8[err168.keyword][err168.params[emPropParams4]];
                if (emParamsErrors4) {
                  emParamsErrors4.push(err168);
                  err168.emUsed = true;
                }
              }
            }
            for (const key8 in emErrors8) {
              for (const keyProp4 in emErrors8[key8]) {
                emParamsErrors4 = emErrors8[key8][keyProp4];
                if (emParamsErrors4.length) {
                  const tmpl4 = templates8[key8] && templates8[key8][keyProp4];
                  const err169 = { keyword: "errorMessage", dataPath: dataPath + "/properties/" + i52, schemaPath: "#/definitions/properties/allOf/1/items/errorMessage", params: { errors: emParamsErrors4 }, message: tmpl4 ? tmpl4() : schema18.allOf[1].items.errorMessage[key8][keyProp4] };
                  if (vErrors === null) {
                    vErrors = [err169];
                  } else {
                    vErrors.push(err169);
                  }
                  errors++;
                }
              }
            }
            const emErrs28 = [];
            for (const err170 of vErrors) {
              if (!err170.emUsed) {
                emErrs28.push(err170);
              }
            }
            vErrors = emErrs28;
            errors = emErrs28.length;
          }
        }
      } else {
        const err171 = { keyword: "type", dataPath: dataPath + "/properties", schemaPath: "#/definitions/properties/allOf/1/type", params: { type: "array" }, message: "should be array" };
        if (vErrors === null) {
          vErrors = [err171];
        } else {
          vErrors.push(err171);
        }
        errors++;
      }
    }
    if (data.icon !== void 0) {
      let data68 = data.icon;
      if (data68 && typeof data68 == "object" && !Array.isArray(data68)) {
        if (data68.contents === void 0) {
          const err172 = { keyword: "required", dataPath: dataPath + "/icon", schemaPath: "#/properties/icon/required", params: { missingProperty: "contents" }, message: "should have required property 'contents'" };
          if (vErrors === null) {
            vErrors = [err172];
          } else {
            vErrors.push(err172);
          }
          errors++;
        }
        if (data68.contents !== void 0) {
          let data69 = data68.contents;
          if (typeof data69 === "string") {
            if (!pattern3.test(data69)) {
              const err173 = { keyword: "pattern", dataPath: dataPath + "/icon/contents", schemaPath: "#/properties/icon/properties/contents/pattern", params: { pattern: "^(https?|data):.*" }, message: 'should match pattern "^(https?|data):.*"' };
              if (vErrors === null) {
                vErrors = [err173];
              } else {
                vErrors.push(err173);
              }
              errors++;
            }
          } else {
            const err174 = { keyword: "type", dataPath: dataPath + "/icon/contents", schemaPath: "#/properties/icon/properties/contents/type", params: { type: "string" }, message: "should be string" };
            if (vErrors === null) {
              vErrors = [err174];
            } else {
              vErrors.push(err174);
            }
            errors++;
          }
          if (errors > 0) {
            const emErrors9 = { "pattern": [] };
            const templates9 = {};
            for (const err175 of vErrors) {
              if (err175.keyword !== "errorMessage" && !err175.emUsed && err175.dataPath === dataPath + "/icon/contents" && err175.keyword in emErrors9 && err175.schemaPath.indexOf("#/properties/icon/properties/contents") === 0 && /^\/[^\/]*$/.test(err175.schemaPath.slice(37))) {
                emErrors9[err175.keyword].push(err175);
                err175.emUsed = true;
              }
            }
            for (const key9 in emErrors9) {
              if (emErrors9[key9].length) {
                const err176 = { keyword: "errorMessage", dataPath: dataPath + "/icon/contents", schemaPath: "#/properties/icon/properties/contents/errorMessage", params: { errors: emErrors9[key9] }, message: key9 in templates9 ? templates9[key9]() : schema17.properties.icon.properties.contents.errorMessage[key9] };
                if (vErrors === null) {
                  vErrors = [err176];
                } else {
                  vErrors.push(err176);
                }
                errors++;
              }
            }
            const emErrs29 = [];
            for (const err177 of vErrors) {
              if (!err177.emUsed) {
                emErrs29.push(err177);
              }
            }
            vErrors = emErrs29;
            errors = emErrs29.length;
          }
        }
      } else {
        const err178 = { keyword: "type", dataPath: dataPath + "/icon", schemaPath: "#/properties/icon/type", params: { type: "object" }, message: "should be object" };
        if (vErrors === null) {
          vErrors = [err178];
        } else {
          vErrors.push(err178);
        }
        errors++;
      }
      if (errors > 0) {
        const emErrors10 = { "required": { "contents": [] } };
        const templates10 = { required: {} };
        let emPropParams5;
        let emParamsErrors5;
        for (const err179 of vErrors) {
          if (err179.keyword !== "errorMessage" && !err179.emUsed && err179.dataPath === dataPath + "/icon" && err179.keyword in emErrors10 && err179.schemaPath.indexOf("#/properties/icon") === 0 && /^\/[^\/]*$/.test(err179.schemaPath.slice(17))) {
            emPropParams5 = obj0[err179.keyword];
            emParamsErrors5 = emErrors10[err179.keyword][err179.params[emPropParams5]];
            if (emParamsErrors5) {
              emParamsErrors5.push(err179);
              err179.emUsed = true;
            }
          }
        }
        for (const key10 in emErrors10) {
          for (const keyProp5 in emErrors10[key10]) {
            emParamsErrors5 = emErrors10[key10][keyProp5];
            if (emParamsErrors5.length) {
              const tmpl5 = templates10[key10] && templates10[key10][keyProp5];
              const err180 = { keyword: "errorMessage", dataPath: dataPath + "/icon", schemaPath: "#/properties/icon/errorMessage", params: { errors: emParamsErrors5 }, message: tmpl5 ? tmpl5() : schema17.properties.icon.errorMessage[key10][keyProp5] };
              if (vErrors === null) {
                vErrors = [err180];
              } else {
                vErrors.push(err180);
              }
              errors++;
            }
          }
        }
        const emErrs30 = [];
        for (const err181 of vErrors) {
          if (!err181.emUsed) {
            emErrs30.push(err181);
          }
        }
        vErrors = emErrs30;
        errors = emErrs30.length;
      }
    }
  } else {
    const err182 = { keyword: "type", dataPath, schemaPath: "#/type", params: { type: "object" }, message: "should be object" };
    if (vErrors === null) {
      vErrors = [err182];
    } else {
      vErrors.push(err182);
    }
    errors++;
  }
  validate15.errors = vErrors;
  return errors === 0;
}
function validate14(data, { dataPath = "", parentData, parentDataProperty, rootData = data } = {}) {
  let vErrors = null;
  let errors = 0;
  const _errs0 = errors;
  let valid0 = false;
  let passing0 = null;
  const _errs1 = errors;
  if (!validate15(data, { dataPath, parentData, parentDataProperty, rootData })) {
    vErrors = vErrors === null ? validate15.errors : vErrors.concat(validate15.errors);
    errors = vErrors.length;
  }
  var _valid0 = _errs1 === errors;
  if (_valid0) {
    valid0 = true;
    passing0 = 0;
  }
  const _errs2 = errors;
  if (Array.isArray(data)) {
    const len0 = data.length;
    for (let i0 = 0; i0 < len0; i0++) {
      if (!validate15(data[i0], { dataPath: dataPath + "/" + i0, parentData: data, parentDataProperty: i0, rootData })) {
        vErrors = vErrors === null ? validate15.errors : vErrors.concat(validate15.errors);
        errors = vErrors.length;
      }
    }
  } else {
    const err0 = { keyword: "type", dataPath, schemaPath: "#/oneOf/1/type", params: { type: "array" }, message: "should be array" };
    if (vErrors === null) {
      vErrors = [err0];
    } else {
      vErrors.push(err0);
    }
    errors++;
  }
  var _valid0 = _errs2 === errors;
  if (_valid0 && valid0) {
    valid0 = false;
    passing0 = [passing0, 1];
  } else {
    if (_valid0) {
      valid0 = true;
      passing0 = 1;
    }
  }
  if (!valid0) {
    const err1 = { keyword: "oneOf", dataPath, schemaPath: "#/oneOf", params: { passingSchemas: passing0 }, message: "should match exactly one schema in oneOf" };
    if (vErrors === null) {
      vErrors = [err1];
    } else {
      vErrors.push(err1);
    }
    errors++;
  } else {
    errors = _errs0;
    if (vErrors !== null) {
      if (_errs0) {
        vErrors.length = _errs0;
      } else {
        vErrors = null;
      }
    }
  }
  validate14.errors = vErrors;
  return errors === 0;
}
function getZeebeSchemaPackage() {
  return name2;
}
function getZeebeSchemaVersion() {
  return version;
}
function validateZeebe(object) {
  return _validate(object, standaloneZeebeValidator.exports);
}

// node_modules/bpmn-js-properties-panel/dist/index.esm.js
var import_classnames2 = __toESM(require_classnames());
var BpmnPropertiesPanelContext = q({
  selectedElement: null,
  injector: null,
  getService() {
    return null;
  }
});
function useService(type, strict) {
  const {
    getService
  } = F2(BpmnPropertiesPanelContext);
  return getService(type, strict);
}
function _extends$1o() {
  _extends$1o = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1o.apply(this, arguments);
}
var AssociationIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$1o({
  width: "32",
  height: "32",
  xmlns: "http://www.w3.org/2000/svg"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  stroke: "#000",
  strokeWidth: "2",
  fill: "none",
  strokeDasharray: "3.3,6",
  strokeLinecap: "square",
  d: "M1.5 30.5l29-29"
}));
function _extends$1n() {
  _extends$1n = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1n.apply(this, arguments);
}
var BusinessRuleTaskIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$1n({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M6.494 3C2.916 3 0 5.903 0 9.475v13.383c0 3.572 2.916 6.475 6.494 6.475h19.012c3.578 0 6.494-2.903 6.494-6.475V9.475C32 5.903 29.084 3 25.506 3H6.494zm0 2h19.012C28.015 5 30 6.98 30 9.475v13.383c0 2.495-1.985 4.475-4.494 4.475H6.494C3.985 27.333 2 25.353 2 22.858V9.475C2 6.98 3.985 5 6.494 5zM5.296 7.398v12.665h16.87V7.398H5.296zm.718 4.386h15.433v3.44H9.985v-3.432h-.719v3.431H6.014v-3.44zm0 4.158h3.252v3.403H6.014v-3.403zm3.97 0h11.463v3.403H9.985v-3.403z"
}), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M6.079 8.209v3.587H21.44V8.209z"
}));
function _extends$1m() {
  _extends$1m = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1m.apply(this, arguments);
}
var CallActivityIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$1m({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M24.978 3c3.761 0 6.89 2.979 7.018 6.695l.004.238V22.4c0 3.747-3.05 6.804-6.783 6.93l-.24.003H7.023c-3.761 0-6.89-2.978-7.018-6.695L0 22.4V9.933C0 6.187 3.05 3.13 6.783 3.004L7.023 3h17.955zm0 3.667H7.022c-1.842 0-3.255 1.344-3.35 3.079l-.005.187V22.4c0 1.761 1.35 3.167 3.16 3.262l.195.005L10 25.666V15h12v10.666h2.978c1.842 0 3.255-1.344 3.35-3.079l.005-.187V9.933c0-1.761-1.35-3.166-3.16-3.261l-.195-.005zm-3.732 9.087H10.754v9.912h10.491v-9.912zm-4.475 1.817v2.658h2.658v1.542H16.77v2.658H15.23V21.77H12.57V20.23h2.658V17.57h1.542z"
}));
function _extends$1l() {
  _extends$1l = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1l.apply(this, arguments);
}
var CollaborationIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$1l({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("g", {
  fillRule: "evenodd"
}, /* @__PURE__ */ compat_module_default.createElement("path", {
  fillRule: "nonzero",
  d: "M0 0v8.62h32V0H0zm1.655 7.054v-5.37h28.62v5.37H1.656zM0 23.38V32h32v-8.62H0zm1.655 7.054v-5.37h28.62v5.37H1.656z"
}), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M24 8l4 7h-8l4-7zm0 2l-2.28 4h4.56L24 10zM23.5 21h1v3h-1zM23.5 15h1v3h-1zM8 24l-4-7h8l-4 7zm0-2l2.28-4H5.72L8 22zM7.5 8h1v3h-1zM7.5 14h1v3h-1z"
})));
function _extends$1k() {
  _extends$1k = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1k.apply(this, arguments);
}
var ConditionalFlowIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$1k({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M32 .041S20.42 5.95 14.537 8.713c1.26 1.15 2.432 2.392 3.648 3.588-5.703 5.78-3.15 3.303-8.087 8.316l-8.472 1.377L0 32l10.006-1.626.098-.598 1.279-7.873c4.975-5.052 2.403-2.555 8.118-8.346 1.218 1.214 2.43 2.435 3.648 3.648C26.29 11.018 32 .041 32 .041zM9.603 22.397L8.54 28.91 2.03 29.97l1.061-6.515 6.512-1.058z"
}));
function _extends$1j() {
  _extends$1j = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1j.apply(this, arguments);
}
var ConnectionIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$1j({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M32 .06S20.33 6.014 14.403 8.798c1.27 1.16 2.451 2.41 3.676 3.616L0 30.734 1.325 32l18.08-18.32c1.227 1.223 2.448 2.453 3.676 3.676C26.247 11.12 32 .06 32 .06z"
}));
function _extends$1i() {
  _extends$1i = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1i.apply(this, arguments);
}
var DataInputOutputAssociationIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$1i({
  width: "32",
  height: "32",
  xmlns: "http://www.w3.org/2000/svg"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  stroke: "#000",
  strokeWidth: "2",
  strokeLinecap: "round",
  strokeDasharray: "1.1,4.3",
  d: "M1.5 30.5L27 5"
}), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M31.803.197L26.5 16.107l-1.52-1.52 3.783-11.35-11.35 3.783-1.52-1.52z"
}));
function _extends$1h() {
  _extends$1h = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1h.apply(this, arguments);
}
var DataInputIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$1h({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M20.833 0H3.488v32H28V7.36L20.833 0zm-2.105 1.818v7.507h7.454v20.857H5.306V1.818h13.422zm1.818.493l5.06 5.196h-5.06V2.311zm-9.182.86v3.744H7.081v3.222h4.283v3.743l5.7-5.354-5.7-5.354zm.808 1.868l3.711 3.487-3.71 3.487V9.329H7.888V7.723h4.283V5.039z"
}));
function _extends$1g() {
  _extends$1g = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1g.apply(this, arguments);
}
var DataObjectIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$1g({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M21.345 0H4v32h24.512V7.36L21.345 0zM19.24 1.818v7.507h7.454v20.857H5.818V1.818H19.24zm1.818.493l5.06 5.196h-5.06V2.311z"
}));
function _extends$1f() {
  _extends$1f = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1f.apply(this, arguments);
}
var DataOutputIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$1f({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M20.833 0H3.488v32H28V7.36L20.833 0zm-2.105 1.818v7.507h7.454v20.857H5.306V1.818h13.422zm1.818.493l5.06 5.196h-5.06V2.311zm-9.182.86v3.744H7.081v3.222h4.283v3.743l5.7-5.354-5.7-5.354z"
}));
function _extends$1e() {
  _extends$1e = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1e.apply(this, arguments);
}
var DataStoreIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$1e({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M16.008 1c-3.712 0-7.417.306-10.319.939-1.45.316-2.7.71-3.68 1.226C1.065 3.662.297 4.304.061 5.23a.823.823 0 00-.035.15L0 5.502l.017.084c-.012 7.41 0 14.46 0 22.08l.017.082c.203.985.995 1.656 1.975 2.172.98.517 2.23.91 3.68 1.226 2.902.633 6.607.94 10.319.94 3.711 0 7.416-.307 10.318-.94 1.451-.316 2.701-.71 3.68-1.226.98-.516 1.772-1.187 1.975-2.172l.017-.082V5.541a.825.825 0 000-.106v-.016l-.002-.013a.823.823 0 00-.046-.197c-.244-.916-1.007-1.55-1.943-2.044-.98-.516-2.23-.91-3.68-1.226C23.423 1.306 19.718 1 16.006 1zm0 1.646c3.62 0 7.245.308 9.968.901 1.36.297 2.497.67 3.263 1.074.612.323.932.643 1.063.882-.131.24-.451.56-1.063.882-.766.404-1.902.777-3.263 1.074-2.723.594-6.349.901-9.968.901-3.62 0-7.245-.307-9.968-.901-1.361-.297-2.497-.67-3.264-1.074-.611-.322-.931-.642-1.062-.882.13-.24.451-.56 1.062-.882.767-.403 1.903-.777 3.264-1.074 2.723-.593 6.348-.9 9.968-.9zM1.664 7.647c.112.067.227.132.345.194.98.517 2.23.91 3.68 1.226 2.902.633 6.607.94 10.319.94 3.711 0 7.416-.307 10.318-.94 1.451-.316 2.701-.71 3.68-1.226.119-.062.234-.127.346-.194v1.93c-.08.245-.398.619-1.113.995-.766.404-1.902.777-3.263 1.074-2.723.594-6.349.901-9.968.901-3.62 0-7.245-.307-9.968-.9-1.361-.298-2.497-.671-3.264-1.075-.714-.376-1.032-.75-1.112-.995v-1.93zm0 4.187c.112.067.227.132.345.195.98.516 2.23.91 3.68 1.226 2.902.632 6.607.938 10.319.938 3.711 0 7.416-.306 10.318-.938 1.451-.317 2.701-.71 3.68-1.226.119-.063.234-.128.346-.195v1.93c-.08.245-.398.619-1.113.995-.766.404-1.902.777-3.263 1.074-2.723.594-6.349.901-9.968.901-3.62 0-7.245-.307-9.968-.9-1.361-.298-2.497-.67-3.264-1.075-.714-.376-1.032-.75-1.112-.995v-1.93zm0 4.188c.112.067.227.131.345.194.98.516 2.23.91 3.68 1.226 2.902.633 6.607.939 10.319.939 3.711 0 7.416-.306 10.318-.94 1.451-.316 2.701-.709 3.68-1.225.119-.063.234-.127.346-.194V27.47c-.08.245-.398.618-1.113.995-.766.404-1.902.777-3.263 1.074-2.723.594-6.349.9-9.968.9-3.62 0-7.245-.306-9.968-.9-1.361-.297-2.497-.67-3.264-1.074-.714-.377-1.032-.75-1.112-.995V16.022z"
}));
function _extends$1d() {
  _extends$1d = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1d.apply(this, arguments);
}
var DefaultFlowIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$1d({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M32 .06S20.33 6.014 14.403 8.798c1.27 1.16 2.451 2.41 3.676 3.616L6.84 23.804H.046v1.755h5.063L0 30.735 1.325 32l6.357-6.441h7.145v-1.756H9.414l9.99-10.123c1.228 1.223 2.45 2.453 3.677 3.676C26.247 11.12 32 .06 32 .06z"
}));
function _extends$1c() {
  _extends$1c = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1c.apply(this, arguments);
}
var EndEventCancelIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$1c({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.676.051C7.943.058.834 6.501.104 14.21c-.783 6.565 2.912 13.427 8.942 16.216 5.6 2.737 12.789 1.87 17.434-2.344 4.725-4.09 6.79-11.06 4.714-17.006C29.22 5.009 23.394.364 16.978.083A18.532 18.532 0 0015.676.05zm.317 5.006c5.695-.165 10.916 4.858 10.983 10.555.246 5.212-3.67 10.33-8.864 11.204-5.026 1.007-10.6-1.898-12.36-6.777-1.894-4.826.039-10.928 4.649-13.46a11.082 11.082 0 015.592-1.522zm-3.955 3.918L8.94 12.072l3.985 3.985-3.913 3.913 3.048 3.047 3.913-3.913 3.987 3.987 3.096-3.096-3.987-3.987 3.913-3.913-3.047-3.048-3.913 3.913-3.985-3.985z"
}));
function _extends$1b() {
  _extends$1b = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1b.apply(this, arguments);
}
var EndEventCompensationIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$1b({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.676.051C7.943.058.834 6.501.104 14.21c-.783 6.565 2.912 13.427 8.942 16.216 5.6 2.737 12.789 1.87 17.434-2.344 4.725-4.09 6.79-11.06 4.714-17.006C29.22 5.009 23.394.364 16.978.083A18.532 18.532 0 0015.676.05zm.317 5.006c5.695-.165 10.916 4.858 10.983 10.555.246 5.212-3.67 10.33-8.864 11.204-5.026 1.007-10.6-1.898-12.36-6.777-1.894-4.826.039-10.928 4.649-13.46a11.082 11.082 0 015.592-1.522zm-.56 5.744l-7.407 5.23 7.408 5.234v-5.057c2.384 1.687 4.771 3.371 7.157 5.057V10.801l-7.157 5.054v-5.054z"
}));
function _extends$1a() {
  _extends$1a = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1a.apply(this, arguments);
}
var EndEventErrorIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$1a({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.676.051C7.943.058.834 6.501.104 14.21c-.783 6.565 2.912 13.427 8.942 16.216 5.6 2.737 12.789 1.87 17.434-2.344 4.725-4.09 6.79-11.06 4.714-17.006C29.22 5.009 23.394.364 16.978.083A18.532 18.532 0 0015.676.05zm.317 5.006c5.695-.165 10.916 4.858 10.983 10.555.246 5.212-3.67 10.33-8.864 11.204-5.026 1.007-10.6-1.898-12.36-6.777-1.894-4.826.039-10.928 4.649-13.46a11.082 11.082 0 015.592-1.522zm6.132 4.166l-3.633 7.363-4.516-5.874-4.102 12.131 4.599-5.91 4.743 5.427 2.909-13.137z"
}));
function _extends$19() {
  _extends$19 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$19.apply(this, arguments);
}
var EndEventEscalationIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$19({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.676.051C7.943.058.834 6.501.104 14.21c-.783 6.565 2.912 13.427 8.942 16.216 5.6 2.737 12.789 1.87 17.434-2.344 4.725-4.09 6.79-11.06 4.714-17.006C29.22 5.009 23.394.364 16.978.083A18.532 18.532 0 0015.676.05zm.317 5.006c5.695-.165 10.916 4.858 10.983 10.555.246 5.212-3.67 10.33-8.864 11.204-5.026 1.007-10.6-1.898-12.36-6.777-1.894-4.826.039-10.928 4.649-13.46a11.082 11.082 0 015.592-1.522zm.006 3.9c-1.672 4.653-2.733 9.5-4.406 14.153 1.535-1.525 2.872-3.234 4.406-4.759l4.406 4.76c-1.497-4.71-2.91-9.445-4.406-14.155z"
}));
function _extends$18() {
  _extends$18 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$18.apply(this, arguments);
}
var EndEventLinkIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$18({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.676 0C7.943.007.834 6.45.104 14.16c-.783 6.565 2.912 13.427 8.942 16.216 5.6 2.737 12.789 1.87 17.434-2.344 4.725-4.09 6.79-11.06 4.714-17.006C29.22 4.958 23.394.313 16.978.032A18.532 18.532 0 0015.676 0zm.317 5.006c5.695-.165 10.916 4.858 10.983 10.555.246 5.212-3.67 10.33-8.864 11.204-5.026 1.007-10.6-1.898-12.36-6.777-1.894-4.826.039-10.928 4.649-13.46a11.082 11.082 0 015.592-1.522zm1.78 4.065v3.555H9.779v6.713h7.994v3.554l5.828-6.91-5.828-6.912z"
}));
function _extends$17() {
  _extends$17 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$17.apply(this, arguments);
}
var EndEventMessageIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$17({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.676 0C7.943.007.834 6.45.104 14.16c-.783 6.565 2.912 13.427 8.942 16.216 5.6 2.737 12.789 1.87 17.434-2.344 4.725-4.09 6.79-11.06 4.714-17.006C29.22 4.958 23.394.313 16.978.032A18.532 18.532 0 0015.676 0zm.317 5.006c5.695-.165 10.916 4.858 10.983 10.555.246 5.212-3.67 10.33-8.864 11.204-5.026 1.007-10.6-1.898-12.36-6.777-1.894-4.826.039-10.928 4.649-13.46a11.082 11.082 0 015.592-1.522zm-5.91 5.448l6.041 4.9 6.04-4.9H10.084zm-1.34 1.137v9.92h14.513v-9.718l-7.132 5.786-7.381-5.988z"
}));
function _extends$16() {
  _extends$16 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$16.apply(this, arguments);
}
var EndEventMultipleIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$16({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.676 0C7.943.007.834 6.45.104 14.16c-.783 6.565 2.912 13.427 8.942 16.216 5.6 2.737 12.789 1.87 17.434-2.344 4.725-4.09 6.79-11.06 4.714-17.006C29.22 4.958 23.394.313 16.978.032A18.529 18.529 0 0015.676 0zm.317 5.006c5.695-.165 10.916 4.858 10.983 10.555.246 5.212-3.67 10.33-8.864 11.204-5.026 1.007-10.6-1.898-12.36-6.777-1.894-4.826.039-10.928 4.649-13.46a11.082 11.082 0 015.592-1.522zm.011 3.039l-7.619 5.53 2.91 8.95h9.418l2.91-8.95-7.619-5.53z"
}));
function _extends$15() {
  _extends$15 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$15.apply(this, arguments);
}
var EndEventNoneIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$15({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.84.042C8.654-.01 1.913 5.437.4 12.454-1.057 18.62 1.554 25.495 6.784 29.09c5.076 3.636 12.31 3.92 17.59.544 5.309-3.251 8.435-9.744 7.445-15.921C30.91 7.307 25.795 1.738 19.442.422a16.064 16.064 0 00-3.602-.38zm.382 5.01c5.28-.017 10.13 4.353 10.669 9.61.687 5.025-2.552 10.281-7.423 11.792-4.754 1.617-10.486-.447-12.962-4.856-2.74-4.575-1.574-11.094 2.768-14.27a11.05 11.05 0 016.948-2.276z"
}));
function _extends$14() {
  _extends$14 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$14.apply(this, arguments);
}
var EndEventSignalIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$14({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.676.051C7.943.058.834 6.501.104 14.21c-.783 6.565 2.912 13.427 8.942 16.216 5.6 2.737 12.789 1.87 17.434-2.344 4.725-4.09 6.79-11.06 4.714-17.006C29.22 5.009 23.394.364 16.978.083A18.532 18.532 0 0015.676.05zm.317 5.006c5.695-.165 10.916 4.858 10.983 10.555.246 5.212-3.67 10.33-8.864 11.204-5.026 1.007-10.6-1.898-12.36-6.777-1.894-4.826.039-10.928 4.649-13.46a11.082 11.082 0 015.592-1.522zm.006 3.492c-2.261 4.07-4.532 8.136-6.797 12.204h13.595L15.999 8.55z"
}));
function _extends$13() {
  _extends$13 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$13.apply(this, arguments);
}
var EndEventTerminateIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$13({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.676.051C7.943.058.834 6.501.104 14.21c-.783 6.565 2.912 13.427 8.942 16.216 5.6 2.737 12.789 1.87 17.434-2.344 4.725-4.09 6.79-11.06 4.714-17.006C29.22 5.009 23.394.364 16.978.083A18.532 18.532 0 0015.676.05zm.317 5.006c5.695-.165 10.916 4.858 10.983 10.555.246 5.212-3.67 10.33-8.864 11.204-5.026 1.007-10.6-1.898-12.36-6.777-1.894-4.826.039-10.928 4.649-13.46a11.082 11.082 0 015.592-1.522zm.006 2.859c-5.264-.2-9.495 5.551-7.755 10.516 1.366 5.085 8.108 7.436 12.339 4.301 4.455-2.807 4.708-9.943.462-13.058A8.128 8.128 0 0016 7.915z"
}));
function _extends$12() {
  _extends$12 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$12.apply(this, arguments);
}
var EventSubProcessExpandedIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$12({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M7.295 4.78h1.779V3.003h-1.78V4.78zm3.558 0h1.779V3.003h-1.78V4.78zm3.557 0h1.78V3.003h-1.78V4.78zm3.558 0h1.78V3.003h-1.78V4.78zm3.558 0h1.779V3.003h-1.779V4.78zm3.558 0c.55.014 1.106-.034 1.654.045l.245-1.762c-.629-.096-1.266-.05-1.9-.061V4.78zM5.732 3.004a5.933 5.933 0 00-.915.093c.111.582.226 1.164.315 1.75.358-.101.947.098.746-.483-.096-.382.164-1.208-.146-1.36zm22.372 2.281c.427.234.812.547 1.13.915.42-.4 1.002-.777 1.33-1.18a5.863 5.863 0 00-1.593-1.289l-.867 1.554zm-25.27-1.44c-.587.354-1.11.811-1.539 1.345.47.333.96.86 1.417 1.077.299-.362.66-.673 1.065-.913-.328-.493-.55-1.055-.944-1.509zM30.515 7.26c-.563.046-.557.342-.378.784.154.25-.097.862.25.85.525-.023 1.14.043 1.612-.032a5.891 5.891 0 00-.362-2.027l-1.122.425zM.268 7.114A6.042 6.042 0 000 9.052h1.78c-.013-.5.047-1.003.208-1.478L.296 7.027l-.026.079-.002.008zM30.22 12.45H32v-1.779h-1.779v1.779zm-30.22.16h1.78v-1.779H0v1.78zm30.22 3.398H32v-1.78h-1.779v1.78zm-30.22.16h1.78v-1.779H0v1.779zm30.22 3.398H32v-1.78h-1.779v1.78zm-30.22.16h1.78v-1.78H0v1.78zm30.22 3.397H32v-1.779h-1.779v1.78zm-30.22.16h1.78v-1.778H0v1.778zm30.137 1.47a4.059 4.059 0 01-.522 1.32c.506.283 1.046.715 1.53.908a5.836 5.836 0 00.744-1.918c-.576-.094-1.209-.264-1.752-.31zm-29.984.51c.157.676.435 1.325.82 1.904l1.486-.977a4.065 4.065 0 01-.577-1.347l-1.73.42zm28.427 1.943c-.371.277-.79.49-1.234.627l.548 1.693a5.84 5.84 0 001.835-.96l-1.082-1.412-.066.05-.001.002zm-26.164 1.47c.567.413 1.21.722 1.886.907.14-.569.343-1.175.444-1.722a4.062 4.062 0 01-1.283-.624l-1.047 1.438zm3.88 1.119h1.779v-1.78h-1.78v1.78zm3.55 0h1.787v-1.78H9.846v1.78zm3.565 0h1.78v-1.78h-1.78v1.78zm3.558 0h1.78v-1.78h-1.78v1.78zm3.451 0h1.743v-1.78h-1.743v1.78zm3.665 0h1.779v-1.78h-1.78v1.78zm-1.922-.545V16.776H9.846V29.25h12.318zM10.967 17.905h10.068V27.97H10.967V17.905zm1.336 3.998v1.711h7.396v-1.711h-7.396z",
  opacity: ".97"
}));
function _extends$11() {
  _extends$11 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$11.apply(this, arguments);
}
var GatewayComplexIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$11({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M16.001 0a1.29 1.29 0 00-.917.373L.373 15.084a1.316 1.316 0 00.002 1.834l14.71 14.709a1.313 1.313 0 001.833 0l14.711-14.711a1.316 1.316 0 00-.002-1.834L16.917.372A1.294 1.294 0 0016.002 0zM16 2.181l13.821 13.821L16 29.823 2.179 16.003 16 2.18zm-.327 6.79v.007l-.145.027-.118.08-.083.123-.028.145v4.954L11.793 10.8l-.125-.08-.14-.029-.144.027-.122.082-.46.46-.085.125-.026.142.028.14.08.125 3.505 3.505H9.347l-.001-.002-.145.032-.118.08-.083.122-.028.146v.652l.029.147.082.119.12.08.144.032h4.956L10.8 20.207v-.001l-.084.124-.026.142.028.14.08.124.46.461.126.082.14.029.143-.027.124-.084L15.3 17.69v4.964-.001l.028.147.082.12.12.08.144.031h.652l.148-.03.118-.08.083-.12.028-.146v-4.962l3.505 3.505.126.082.14.027.142-.027.124-.084.461-.46.083-.123s.028-.144.027-.146l-.028-.14-.082-.126-3.496-3.496h4.948l.148-.03.119-.08.082-.12.028-.147v-.652l-.028-.145-.083-.122-.119-.08s-.147-.033-.147-.031h-4.964l3.512-3.512.082-.122.029-.144-.028-.14-.084-.124-.46-.461-.123-.082-.14-.027-.145.027-.122.082-3.507 3.507V9.348l-.028-.146-.082-.122-.12-.08-.147-.029h-.652z"
}));
function _extends$10() {
  _extends$10 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$10.apply(this, arguments);
}
var GatewayEventBasedIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$10({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M16 0a1.29 1.29 0 00-.918.373L.371 15.084a1.316 1.316 0 00.002 1.834l14.71 14.709a1.313 1.313 0 001.833 0l14.711-14.711a1.316 1.316 0 00-.002-1.834L16.915.372A1.294 1.294 0 0016 0zm-.002 2.181l13.821 13.821-13.821 13.821-13.821-13.82L15.998 2.18zm0 5.876l-.254.185-7.377 5.355 2.915 8.964h9.433l2.915-8.964-7.631-5.54zm0 1.07l6.614 4.8-2.526 7.769h-8.175l-2.526-7.768 6.614-4.802z"
}));
function _extends$$() {
  _extends$$ = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$$.apply(this, arguments);
}
var GatewayNoneIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$$({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M.373 15.084a1.316 1.316 0 00.002 1.834l14.71 14.709a1.313 1.313 0 001.833 0l14.711-14.711a1.316 1.316 0 00-.002-1.834L16.917.373a1.313 1.313 0 00-1.833 0L.373 15.084zm1.806.918L16 2.182l13.821 13.82L16 29.823 2.179 16.003z"
}));
function _extends$_() {
  _extends$_ = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$_.apply(this, arguments);
}
var GatewayOrIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$_({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M16.001 0a1.29 1.29 0 00-.917.373L.373 15.084a1.316 1.316 0 00.002 1.834l14.71 14.709a1.313 1.313 0 001.833 0l14.711-14.711a1.316 1.316 0 00-.002-1.834L16.917.372A1.294 1.294 0 0016.002 0zM16 2.181l13.821 13.821L16 29.823 2.179 16.003 16 2.18zm0 6.379a7.447 7.447 0 00-7.44 7.441A7.447 7.447 0 0016 23.443 7.447 7.447 0 0023.443 16a7.447 7.447 0 00-7.441-7.441zm0 .825a6.61 6.61 0 016.617 6.616A6.61 6.61 0 0116 22.618 6.61 6.61 0 019.385 16 6.61 6.61 0 0116 9.385z"
}));
function _extends$Z() {
  _extends$Z = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$Z.apply(this, arguments);
}
var GatewayParallelIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$Z({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M16.001 0a1.29 1.29 0 00-.917.373L.373 15.084a1.316 1.316 0 00.002 1.834l14.71 14.709a1.313 1.313 0 001.833 0l14.711-14.711a1.316 1.316 0 00-.002-1.834L16.917.372A1.294 1.294 0 0016.002 0zM16 2.181l13.821 13.821L16 29.823 2.179 16.003 16 2.18zm-.377 5.708l-.168.032-.136.092-.096.14-.032.168v6.868h-6.87l-.002-.002-.166.037-.137.092v-.002l-.095.141-.033.167v.753s.032.169.034.17l.094.138.138.092.167.036h6.87v6.867l-.001-.001.033.17.095.138.138.092s.166.035.167.037h.752l.17-.036.137-.092.095-.137.033-.17v-6.867h6.868l.17-.035.137-.092.095-.137.033-.17v-.753s-.033-.165-.032-.167l-.096-.14-.138-.093s-.17-.037-.17-.035H16.81V8.323l-.033-.168-.094-.14-.138-.092-.17-.034h-.752z"
}));
function _extends$Y() {
  _extends$Y = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$Y.apply(this, arguments);
}
var GatewayXorIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$Y({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M16 0a1.29 1.29 0 00-.918.373L.371 15.084a1.316 1.316 0 00.002 1.834l14.71 14.709a1.313 1.313 0 001.833 0l14.711-14.711a1.316 1.316 0 00-.002-1.834L16.915.372A1.294 1.294 0 0016 0zm-.002 2.181l13.821 13.821-13.821 13.821-13.821-13.82L15.998 2.18zm-5.162 7.69l-.166.032-.141.096-.532.532s-.097.142-.097.144l-.03.164.032.162.093.144 4.857 4.858-4.855 4.855v-.001L9.9 21l-.03.164.032.162s.093.142.093.144l.531.532.146.095.162.032.164-.03.144-.097 4.855-4.856 4.857 4.857.145.095.162.032.164-.03.144-.097.531-.532.095-.14.033-.168-.033-.162-.095-.146L17.144 16 22 11.144l.095-.14.033-.166-.033-.163-.097-.144-.532-.532-.14-.095-.163-.032-.166.032-.141.095L16 14.855l-4.858-4.858v-.002l-.144-.092-.162-.032z"
}));
function _extends$X() {
  _extends$X = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$X.apply(this, arguments);
}
var GroupIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$X({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M6.34.016c-2.333.025-4.684 1.77-5.29 4.17C.608 5.848.88 7.608.804 9.314v2.922h2.041c.038-2.332-.076-4.673.062-7C3.14 3.355 4.869 1.938 6.643 2.04h8.956V.009c-3.086 0-6.173-.02-9.258 0v.007zm13.094 2.023h1.92V.009h-1.92v2.03zm5.756 0c1.265-.069 2.66.045 3.602 1.055 1.036.983 1.201 2.523 1.122 3.91v6.313h2.078c-.03-2.677.062-5.36-.047-8.032-.17-2.743-2.62-5.111-5.215-5.236-.511-.064-1.027-.02-1.54-.033v2.023zM.803 18.319h2.041v-2.026H.804v2.026zm29.11 1.084h2.08v-2.03h-2.08v2.03zM.804 26.148c.004 2.218 1.393 4.366 3.313 5.28 1.728.853 3.681.448 5.521.544.43-.112 1.29.231 1.435-.183v-1.847c-1.788-.043-3.584.094-5.365-.082-1.67-.354-2.919-2.048-2.863-3.844v-3.644H.804v3.777zm29.11-.068c.04 1.961-1.508 3.787-3.381 3.842-1.954.06-3.914.02-5.87.026v2.03c2.118-.042 4.242.08 6.355-.063 2.524-.264 4.818-2.644 4.94-5.323.08-1.039.014-2.085.035-3.126h-2.078v2.613zm-15.006 5.898h1.92v-2.03h-1.92v2.03z"
}));
function _extends$W() {
  _extends$W = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$W.apply(this, arguments);
}
var IntermediateEventCatchCancelIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$W({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.975.049C8.195-.111.935 6.286.125 14.03c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.93 23.445.454 17.201.095c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.22.872 11.725 4.985 6.962c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.215-2.282-2.022-5.3-3.217-8.357-3.22zM16 5.021c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.082 11.082 0 0116 5.021zm-3.956 3.946l-3.096 3.097 3.985 3.985-3.913 3.913 3.047 3.048 3.913-3.913 3.988 3.987 3.097-3.096L19.076 16l3.914-3.913-3.048-3.048-3.913 3.913-3.986-3.985zm-.002 1.222l3.988 3.987 3.913-3.913 1.826 1.826-3.913 3.913 3.985 3.986-1.873 1.873-3.985-3.985-3.913 3.913-1.827-1.827 3.914-3.913-3.988-3.987 1.873-1.873z"
}));
function _extends$V() {
  _extends$V = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$V.apply(this, arguments);
}
var IntermediateEventCatchCompensationIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$V({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.975.049C8.195-.11.935 6.286.125 14.03c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.93 23.445.453 17.201.095c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.22.872 11.725 4.985 6.962c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 5.021c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 5.021zm-.56 5.772l-7.408 5.231 7.409 5.234v-5.057c2.385 1.687 4.771 3.371 7.157 5.057V10.793l-7.157 5.055v-5.055zm-.865 1.665v7.125l-5.048-3.562 5.048-3.563zm7.161 0v7.132l-5.048-3.566 5.048-3.566z"
}));
function _extends$U() {
  _extends$U = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$U.apply(this, arguments);
}
var IntermediateEventCatchConditionIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$U({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.97.04h-.127C8.713-.018 2.003 5.334.437 12.286c-1.51 6.123.98 13.005 6.136 16.665 5.125 3.788 12.546 4.105 17.912.623 5.272-3.276 8.33-9.766 7.325-15.916-.904-6.241-5.79-11.7-11.95-13.143A16.082 16.082 0 0015.97.04zm-.181 1.724c.115 0 .23 0 .347.003 6.625-.066 12.823 5.149 13.89 11.69 1.13 5.91-1.908 12.349-7.262 15.138-5.473 3.013-12.866 1.884-17.116-2.726C1.291 21.372.444 13.914 3.802 8.602c2.493-4.112 7.169-6.819 11.987-6.838zm.283 1.554c-.117 0-.234.002-.351.005-6.1 0-11.691 5.049-12.346 11.114-.78 5.684 2.795 11.612 8.218 13.52 5.139 1.943 11.416.101 14.624-4.38 3.461-4.583 3.262-11.538-.596-15.831-2.36-2.747-5.924-4.423-9.549-4.428zm-.078 1.695c.078 0 .156 0 .234.003 5.4 0 10.321 4.556 10.734 9.942.563 5.13-2.958 10.364-7.971 11.678-4.832 1.41-10.457-.935-12.746-5.446-2.463-4.559-1.2-10.795 3.014-13.883a11.072 11.072 0 016.735-2.294zm-5.352 4.266V22.761h10.716V9.279H10.642zm.863.866h8.987v11.75h-8.987v-11.75zm.927 1.323v.862h7.133v-.862h-7.133zm0 2.602v.866h7.133v-.866h-7.133zm0 3.008v.862h7.133v-.862h-7.133zm0 2.717v.863h7.133v-.863h-7.133z"
}));
function _extends$T() {
  _extends$T = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$T.apply(this, arguments);
}
var IntermediateEventCatchErrorIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$T({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.975.049C8.195-.11.935 6.286.125 14.03c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.93 23.445.453 17.201.095c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.22.872 11.725 4.985 6.962c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 5.021c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 5.021zm6.132 4.194c-1.21 2.455-2.422 4.91-3.633 7.364l-4.516-5.875-4.103 12.133 4.6-5.912c1.58 1.81 3.162 3.619 4.744 5.429L22.13 9.215zM14.383 13.1l4.295 5.445 1.073-2.387-1.027 4.131-4.384-5.157-1.778 2.75 1.821-4.782z"
}));
function _extends$S() {
  _extends$S = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$S.apply(this, arguments);
}
var IntermediateEventCatchEscalationIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$S({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.975.049C8.195-.11.935 6.286.125 14.03c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.93 23.445.453 17.201.095c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.22.872 11.725 4.985 6.962c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 5.021c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 5.021zm.006 3.927c-1.672 4.654-2.734 9.502-4.406 14.155 1.534-1.525 2.872-3.234 4.406-4.759l4.406 4.76c-1.496-4.71-2.91-9.446-4.406-14.156zm.032 2.929c.822 2.586 1.598 5.186 2.42 7.771l-2.42-2.612c-.682.597-2.452 2.884-2.338 2.388.87-2.487 1.447-5.067 2.338-7.547z"
}));
function _extends$R() {
  _extends$R = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$R.apply(this, arguments);
}
var IntermediateEventCatchLinkIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$R({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.975.049C8.195-.11.935 6.286.125 14.03c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.93 23.445.453 17.201.095c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.22.872 11.725 4.985 6.962c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 5.021c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 5.021zm1.78 4.093v3.555H9.785v6.714h7.994v3.554l5.829-6.911-5.83-6.912zm.974 2.584l3.61 4.295-3.61 4.294v-1.933h-7.88v-4.688h7.88v-1.968z"
}));
function _extends$Q() {
  _extends$Q = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$Q.apply(this, arguments);
}
var IntermediateEventCatchMessageIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$Q({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.975.049C8.195-.11.935 6.286.125 14.03c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.93 23.445.453 17.201.095c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.22.872 11.725 4.985 6.962c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 5.021c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 5.021zm-7.245 5.475v11.06h14.502v-11.06H8.754zm3.222 1.728h8.057c-1.427.878-2.854 2.806-4.281 3.016l-3.776-3.016zm9.554 1.017v6.587H10.48V13.24l5.524 4.414 5.526-4.414z"
}));
function _extends$P() {
  _extends$P = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$P.apply(this, arguments);
}
var IntermediateEventCatchMultipleIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$P({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.975.003C8.195-.156.935 6.24.125 13.985c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.884 23.445.407 17.201.049c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.174.872 11.679 4.985 6.916c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 4.975c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 4.975zm.006 3.073l-7.62 5.531 2.91 8.95h9.42l2.91-8.95-7.62-5.53zm0 1.067l6.604 4.794-2.523 7.757h-8.162l-2.522-7.757 6.603-4.794z"
}));
function _extends$O() {
  _extends$O = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$O.apply(this, arguments);
}
var IntermediateEventCatchNonInterruptingConditionIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$O({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M10.638 9.563V23.056h10.724V9.563H10.638zm.863.866h8.995v11.76H11.5V10.43zm.928 1.324v.862h7.139v-.862h-7.14zm0 2.605v.866h7.139v-.866h-7.14zm0 3.01v.863h7.139v-.863h-7.14zm0 2.72v.863h7.139v-.864h-7.14zM15.999.308h-.004l-.188.001h-.011l-.188.004h-.011L15.41.32h-.011l-.187.008h-.005L15.2.33l-.187.01h-.005l-.005.001-.187.013h-.011L14.62.37h-.01l-.186.018h-.011l-.185.02-.005.001h-.006l-.185.022-.005.001h-.005l-.185.025h-.005l-.005.001-.185.027h-.005l-.005.001-.184.029h-.005l-.005.001-.183.031-.006.001-.005.001-.182.033-.006.001-.005.001-.182.035-.005.001-.005.001-.182.038h-.005l-.005.002-.181.04h-.005l-.005.002-.18.042-.006.001-.005.001-.18.044-.005.002h-.005l-.17.045-.152.054-.139.082-.121.106-.1.127-.074.143-.046.155-.017.16.013.16.043.156.07.145.097.13.119.108.137.085.15.058.159.03.16-.001.133-.023.165-.043.168-.041.171-.04.171-.037.172-.036.17-.033.173-.03.17-.03.177-.027.171-.025.175-.022.175-.02.175-.02.176-.016.175-.014.177-.012.176-.01.177-.007.174-.006.177-.003.178-.001h.177l.178.004.174.006.177.007.176.01.177.012.175.014.176.017.175.018.175.02.175.023.171.025.176.027.17.03.174.03.17.033.171.036.154.033.16.02.161-.01.156-.04.146-.069.131-.094.111-.117.087-.135.061-.15.032-.158.002-.16-.027-.16-.057-.15L20 1.023l-.108-.12-.128-.097-.145-.073-.128-.038-.158-.035-.005-.001-.005-.001L19.14.62h-.005l-.005-.002-.182-.035h-.006L18.938.58l-.182-.033h-.006l-.005-.002-.183-.03-.005-.001-.006-.001-.183-.029h-.005l-.006-.001-.184-.027h-.005l-.005-.001-.185-.024h-.005L17.968.43 17.783.41l-.006-.001h-.005l-.185-.02h-.006l-.005-.001L17.39.37h-.005L17.38.368l-.187-.015h-.005l-.005-.001-.187-.013h-.011L16.8.328h-.011L16.6.32h-.011l-.187-.006h-.011L16.204.31h-.011L16.005.31H16zm9.016 2.935l-.16.004-.158.033-.15.062-.134.09-.116.111-.093.132-.067.147-.038.156-.01.161.022.16.05.153.078.141.103.124.102.087.045.034.142.106.137.105.14.11.136.11.135.112.134.115.134.117.13.115.132.122.128.12.127.122.126.125.124.126.124.128.121.13.118.128.118.132.117.133.113.134.113.136.11.136.109.137.109.142.104.14.103.14.101.142.1.144.099.146.095.145.094.147.093.15.092.15.087.149.087.15.084.152.084.155.08.152.08.155.04.081.084.138.11.119.128.096.145.072.155.043.16.013.16-.016.155-.046.144-.074.127-.099.106-.12.083-.14.055-.151.026-.16-.004-.16-.034-.158-.05-.124-.042-.085-.002-.004-.003-.005-.084-.165-.002-.004-.003-.005-.086-.164-.002-.004-.003-.005-.088-.162-.002-.005-.003-.005-.09-.161-.002-.005-.003-.004-.092-.16-.003-.005-.002-.005-.094-.16-.003-.004-.003-.004-.096-.159-.002-.004-.003-.005-.098-.157-.003-.004-.003-.005-.1-.156-.003-.004-.003-.005-.101-.154-.003-.005-.003-.004-.104-.154-.003-.004-.003-.005-.106-.152-.003-.005-.003-.004-.108-.151-.003-.004-.003-.005-.11-.15-.003-.004-.003-.004-.111-.15-.004-.003-.003-.005-.113-.147-.004-.004-.003-.005-.115-.146-.004-.004-.003-.004-.117-.145-.004-.004-.003-.004-.12-.144-.003-.004-.003-.004-.121-.142-.004-.004-.003-.004-.123-.141-.003-.004-.004-.004-.125-.14-.003-.004-.004-.004-.127-.138-.003-.004-.004-.004-.128-.136-.004-.004-.004-.004-.13-.135-.004-.004-.004-.004-.132-.134-.003-.004-.004-.003-.134-.133-.004-.003-.004-.004-.135-.13-.004-.004-.004-.004-.136-.128-.004-.004-.004-.004-.138-.126-.004-.004-.004-.003-.14-.125-.004-.004-.004-.003-.14-.123-.005-.004-.004-.003-.142-.121-.004-.004-.004-.003-.144-.12-.004-.003-.004-.003-.145-.117-.004-.004-.004-.003-.147-.115-.004-.004-.004-.003-.148-.113-.004-.003-.004-.004-.149-.111-.004-.003-.004-.004-.05-.036-.14-.083-.15-.055-.16-.027zm-18.381.344l-.161.008-.157.037-.147.066-.111.074-.04.032-.005.003-.004.004-.145.117-.004.003-.004.004-.144.119-.004.003-.004.004-.142.12-.004.004-.004.004-.141.123-.004.003-.004.004-.14.125-.004.003-.004.004-.138.126-.004.004-.004.004-.136.128-.004.004-.004.004-.135.13-.004.004-.004.003-.134.133-.004.003L4.682 5l-.132.134-.003.004-.004.004-.13.135-.004.004-.004.004-.128.136-.004.004-.004.004-.126.138-.004.004-.003.004-.125.14-.004.004-.003.004-.123.14-.004.005-.003.004-.121.142-.004.004-.003.004-.12.144-.003.004-.003.004-.117.145-.004.004-.003.004-.115.146-.004.005-.003.004-.113.147-.003.005-.004.004-.111.149-.003.004-.004.004-.11.15-.002.005-.003.004-.108.151-.003.004-.003.005-.106.152-.003.005-.003.004-.104.154-.003.004-.003.005-.102.154-.003.005-.002.004-.1.156-.003.005-.003.004-.098.157-.003.005-.003.004-.096.159-.002.004-.003.005-.094.16-.003.004-.002.004-.092.16-.003.005-.003.005-.09.161-.002.005-.003.005-.088.162-.002.005-.003.004-.086.164-.002.005-.002.004-.084.165-.003.005-.002.004-.082.166-.002.004-.003.005-.08.167-.002.004-.002.005-.078.168-.002.004-.002.005-.045.1-.053.153-.023.16.007.16.037.157.065.148.092.132.114.114.134.09.148.064.157.035.161.006.16-.025.152-.054.14-.08.121-.106.1-.126.065-.118.043-.095.074-.16.075-.155.077-.157.08-.155.08-.152.083-.155.085-.152.086-.15.088-.149.091-.15.094-.15.094-.147.095-.145.099-.146.1-.144.1-.142.104-.14.104-.14.11-.142.107-.137.11-.136.114-.136.113-.134.117-.133.118-.132.117-.129.122-.13.124-.127.123-.126.127-.125.127-.122.128-.12.132-.122.13-.115.133-.117.135-.115.135-.111.136-.11.037-.03.117-.11.094-.132.068-.146.04-.156.01-.161-.02-.16-.05-.154-.076-.141-.102-.125-.123-.104-.14-.08-.153-.051-.16-.023zM16 3.595h-.005l-.148.001h-.01l-.147.003h-.011l-.147.005h-.011l-.146.007h-.011l-.146.009h-.011l-.146.01h-.005l-.005.001-.146.012h-.011l-.145.014h-.006l-.005.001-.05.006-.158.031-.15.06-.135.088-.117.111-.094.13-.069.147-.04.156-.01.16.019.16.049.154.076.142.102.125.123.105.14.08.152.051.16.023.134-.003.045-.005.135-.013.133-.01.136-.01.135-.007.137-.006.136-.004.136-.003h.274l.136.003.136.004.136.006.136.007.136.01.133.01.135.013.135.014.135.016.134.018.132.018.134.021.133.023.133.024.133.025.13.027.132.03.132.03.129.031.13.034.129.035.129.036.13.04.126.038.128.042.126.042.128.045.127.047.126.047.12.048.127.051.123.052.006.002.147.048.16.021.16-.009.157-.038.147-.067.131-.093.112-.116.089-.135.062-.149.033-.158.004-.16-.027-.16-.055-.151-.083-.139-.107-.12-.127-.099-.118-.063-.004-.001-.005-.003-.005-.002-.133-.056-.005-.002-.005-.002-.134-.054-.004-.002-.005-.002-.135-.053-.005-.002-.005-.002-.135-.051-.005-.002-.005-.002-.135-.05-.005-.001-.005-.002-.137-.048-.005-.001-.005-.002-.137-.046-.005-.002-.005-.002-.137-.044-.005-.002-.005-.001-.138-.043-.006-.002-.005-.001-.138-.042-.005-.001-.005-.002-.14-.04H19.4l-.005-.002-.14-.038-.005-.001-.005-.002-.14-.036-.005-.001-.005-.001-.141-.035-.005-.001-.005-.001-.142-.033-.005-.001-.005-.001-.142-.031-.005-.002h-.005l-.142-.03-.005-.001-.005-.001-.143-.028h-.005l-.005-.002-.143-.025-.006-.001-.005-.001-.143-.024-.005-.001-.006-.001-.143-.022-.006-.001h-.005l-.144-.022h-.005l-.006-.001-.144-.019h-.005l-.006-.001-.144-.017h-.006l-.005-.001-.145-.016h-.011l-.145-.014H17.1l-.005-.001-.146-.012h-.01l-.146-.01-.006-.001h-.005l-.146-.009h-.011l-.147-.006h-.01L16.32 3.6h-.011l-.147-.003h-.011l-.147-.001H16zm-5.482 1.366l-.16.008-.157.037-.123.053-.06.032-.005.002-.004.003-.128.069-.004.002-.005.003-.126.07-.005.003-.004.002-.126.072-.005.003-.004.003-.125.073-.004.003-.005.003-.124.075-.004.003-.005.002-.123.077-.004.003-.005.003-.122.078-.004.003-.005.003-.121.08-.004.002-.005.003-.12.082-.005.003-.004.003-.12.083-.004.003-.004.003-.118.084-.005.003-.004.003-.118.086-.004.003-.004.003-.117.088-.004.003-.004.003-.116.089-.004.003-.004.004-.114.09-.005.003-.004.003-.113.092-.004.004-.004.003-.113.093-.004.004-.004.003-.111.095-.005.003-.004.004-.11.096-.004.004-.004.003-.11.098-.003.003-.004.004-.108.1-.004.003-.004.003-.107.101-.004.004-.004.003-.106.102-.004.004-.003.004-.105.103-.004.004-.004.004-.103.105-.004.004-.004.003-.102.106-.003.004-.004.004-.1.107-.004.004-.004.004-.099.108-.004.004-.003.004-.098.11-.003.003-.004.004-.096.11-.004.005-.003.004-.095.111-.003.004-.004.004-.093.113-.003.004-.004.004-.092.113-.003.004-.003.005-.09.114-.004.004-.003.004-.089.116-.003.004-.003.004-.088.117-.003.004-.003.004-.086.118-.003.004-.003.005-.084.118-.003.004-.003.005-.083.12-.003.003-.003.005-.082.12-.003.005-.002.004-.068.103-.076.142-.048.154-.018.16.011.161.041.156.07.146.095.13.117.11.136.086.15.06.158.03.162.002.158-.03.15-.057.138-.085.119-.109.082-.105.065-.099.075-.11.077-.113.077-.107.08-.11.08-.108.084-.108.083-.105.086-.106.086-.104.088-.104.089-.101.09-.102.093-.101.093-.099.094-.097.095-.096.098-.097.098-.095.099-.093.1-.092.103-.091.101-.089.104-.088.104-.086.106-.086.106-.083.106-.082.109-.082.108-.079.11-.078.11-.076.112-.076.112-.074.113-.072.113-.071.115-.07.115-.068.118-.067.117-.065.12-.065.054-.029.135-.088.116-.111.094-.132.068-.146.04-.156.009-.161-.02-.16-.05-.153-.078-.142-.102-.125-.123-.103-.141-.079-.153-.051-.16-.022zm13.91 2.116l-.162.008-.157.037-.147.066-.132.092-.113.116-.09.134-.063.148-.034.157-.005.162.025.159.055.152.082.138.086.103.09.09.094.098.092.099.093.1.091.103.089.101.088.104.086.104.086.106.083.105.083.108.08.108.081.11.077.107.077.112.075.111.075.114.072.113.071.113.07.114.068.118.067.115.065.118.064.117.062.117.061.121.059.119.059.122.056.121.054.12.055.125.051.123.051.125.048.123.048.127.047.126.044.125.043.128.042.129.039.126.038.13.022.076.058.15.085.137.11.119.129.096.145.07.155.043.16.013.161-.017.154-.046.144-.075.126-.1.106-.12.082-.14.055-.151.025-.16-.005-.16-.026-.132-.023-.082-.002-.005-.001-.005-.042-.139-.001-.005-.002-.005-.043-.138-.001-.005-.002-.005-.044-.137-.002-.005-.002-.005-.046-.137-.002-.005-.001-.005-.048-.137-.002-.005-.002-.005-.05-.135-.001-.005-.002-.005-.051-.135-.002-.005-.002-.005-.053-.135-.002-.005-.002-.005-.054-.133-.002-.005-.002-.005-.057-.133-.002-.005-.002-.005-.057-.132-.003-.005-.002-.005-.06-.132-.001-.005-.002-.004-.061-.132-.003-.004-.002-.005-.063-.13-.002-.005-.002-.005-.064-.13-.003-.004-.002-.005-.066-.129-.002-.004-.003-.005-.067-.128-.002-.005-.003-.004-.069-.128-.002-.004-.003-.005-.07-.126-.003-.005-.003-.004-.072-.126-.002-.005-.003-.004-.074-.125-.002-.004-.003-.005-.075-.124-.003-.004-.003-.005-.076-.123-.003-.004-.003-.005-.078-.122-.003-.004-.003-.005-.08-.121-.003-.004-.003-.005-.081-.12-.003-.005-.003-.004-.083-.12-.003-.004-.003-.004-.084-.118-.003-.005-.003-.004-.086-.118-.003-.004-.004-.004-.087-.117-.003-.004-.003-.004-.09-.116-.002-.004-.004-.004-.09-.114-.003-.005-.004-.004-.091-.113-.004-.004-.003-.004-.094-.113-.003-.004-.003-.004-.095-.111-.004-.004-.003-.004-.096-.11-.004-.005-.003-.004-.098-.11-.004-.003-.003-.004-.1-.108-.003-.004-.004-.004-.1-.107-.004-.004-.004-.004-.102-.106-.003-.003-.004-.004-.093-.095-.124-.103-.14-.08-.153-.05-.16-.023zM4.45 13.135l-.161.002-.158.032-.15.06-.135.088-.118.11-.094.131-.069.146-.035.129-.026.132v.005l-.002.005-.025.143-.001.005-.001.006-.024.143-.001.005-.001.006-.022.143-.001.006-.001.005-.02.144-.001.005-.001.005-.019.145v.005l-.001.006-.017.144v.006l-.001.005-.016.145v.011l-.014.145v.005l-.001.006-.012.146v.01l-.01.146-.001.006v.005l-.009.146v.011l-.007.146v.011l-.004.147v.011l-.003.147v.01l-.002.148v.01l.001.148v.01l.003.147v.011l.005.147v.01l.007.147v.011l.009.146v.011l.01.146v.01l.013.146v.011l.014.145v.005l.001.006.016.145v.011l.018.144v.006l.001.005.019.144v.006l.001.005.021.144v.005l.002.006.022.143v.006l.002.005.024.143v.005l.002.006.025.143.001.005.001.005.028.143.001.005.001.005.03.142v.005l.002.006.03.141.002.005.001.005.033.142v.005l.002.005.035.14v.006l.002.005.036.14.002.005.001.005.038.14.001.005.002.005.04.14v.005l.002.005.042.138.001.006.002.005.042.138.002.005.002.005.017.054.064.148.09.134.114.114.132.092.148.065.157.037.16.007.16-.023.153-.052.14-.08.123-.104.102-.125.076-.142.049-.153.02-.16-.011-.161-.031-.13-.017-.051-.039-.126-.038-.13-.037-.128-.035-.13-.033-.128-.033-.134-.03-.13-.029-.131-.026-.13-.026-.133-.024-.133-.023-.133-.02-.132-.02-.136-.017-.132-.016-.135-.014-.135-.012-.133-.012-.138-.009-.133-.007-.136-.006-.138-.004-.134-.003-.136v-.274l.003-.136.004-.134.006-.139.007-.136.01-.133.01-.138.013-.132.014-.135.016-.135.017-.132.02-.137.02-.13.023-.134.024-.133.024-.126.016-.16-.014-.161-.044-.155-.072-.145-.098-.128-.12-.108-.137-.084-.15-.057-.16-.029zm26.698 1.601l-.161.01-.157.04-.146.067-.131.093-.112.117-.088.135-.061.149-.033.157-.005.134.006.14.006.176.003.177.001.178-.001.177-.003.178-.006.177-.007.176-.01.177-.012.176-.015.176-.016.173-.018.175-.02.175-.024.174-.025.175-.026.17-.03.174-.03.173-.033.17-.036.172-.037.17-.04.17-.042.172-.043.168-.045.166-.048.169-.05.167-.052.168-.053.164-.056.166-.058.166-.06.16-.062.165-.062.158-.066.165-.068.16-.07.16-.07.158-.075.159-.074.155-.079.158-.08.158-.06.15-.03.158-.001.161.029.159.058.15.085.137.108.119.13.097.144.07.156.044.16.013.16-.017.155-.046.143-.074.127-.1.107-.12.07-.115.083-.164.003-.005.002-.004.082-.166.002-.005.003-.004.08-.167.002-.005.002-.004.078-.168.002-.005.002-.004.076-.169.002-.004.002-.005.074-.17.002-.004.002-.005.072-.17.002-.005.002-.005.07-.171.001-.005.002-.005.068-.172.002-.004.002-.005.065-.173.002-.005.002-.005.063-.173.002-.005.002-.005.06-.174.003-.005.001-.005.06-.175.001-.005.002-.005.057-.176.001-.005.002-.005.055-.177.001-.005.002-.005.052-.177.002-.005.001-.005.051-.178.001-.005.002-.005.048-.179.002-.005v-.005l.047-.179.001-.005.002-.005.044-.18v-.005l.002-.005.042-.18.001-.006.001-.005.04-.181.001-.005.001-.005.037-.182.002-.005v-.005l.036-.182v-.006l.002-.005.033-.182v-.006l.002-.005.03-.183.001-.005.001-.005.029-.184v-.005l.001-.006.027-.184v-.005l.001-.005.024-.185v-.005l.001-.005.022-.185v-.006l.001-.005.02-.185v-.006l.001-.005.017-.186v-.005l.001-.005.015-.187v-.005l.001-.005.013-.187v-.01l.01-.187.001-.006v-.005l.009-.187v-.011l.006-.187V16.7l.004-.188v-.011l.001-.188v-.01l-.001-.188v-.011l-.004-.188v-.011l-.006-.187v-.011l-.007-.145-.022-.16-.05-.152-.08-.141-.103-.124-.125-.102-.141-.077-.153-.05-.16-.02zm-30.21.572l-.161.001-.158.032-.15.06-.136.087-.117.11-.095.131-.068.146-.04.156-.012.133-.001.14v.01l.001.188v.011l.004.188v.011l.006.187v.011l.008.187v.011l.011.187v.005l.001.005.013.187v.01l.016.187v.01l.018.186v.011l.02.185.001.005v.006l.022.185.001.005v.005l.025.185v.005l.001.005.027.184v.006l.001.005.029.184v.005l.001.005.031.183.001.005.001.006.033.182.001.005.001.006.035.182.001.005.001.005.038.182v.005l.002.005.04.181v.005l.002.005.042.18.001.006.001.005.044.18.002.005v.005l.047.18.001.004.002.005.048.179.002.005.001.005.05.178.002.005.001.005.053.177.002.005.001.005.055.177.002.005.001.005.057.176.002.005.001.005.06.175.001.005.002.005.061.174.002.005.002.005.063.173.002.005.002.005.065.173.002.005.002.004.067.172.002.005.002.005.07.171.002.005.002.005.072.17.002.005.002.004.074.17.002.005.002.004.076.169.002.004.002.005.078.168.002.004.002.005.08.167.003.004.002.005.082.166.002.004.003.005.02.04.086.136.11.118.13.095.146.07.156.041.16.012.16-.019.155-.048.142-.075.126-.1.105-.123.08-.14.054-.152.024-.16-.006-.16-.036-.158-.051-.123-.018-.034-.078-.158-.074-.155-.074-.16-.071-.157-.07-.16-.068-.16-.067-.165-.062-.158-.062-.164-.059-.161-.058-.166-.056-.166-.053-.164-.052-.168-.05-.167-.048-.17-.045-.165-.043-.168-.043-.172-.039-.17-.037-.17-.036-.172-.033-.17-.03-.173-.03-.174-.027-.17-.025-.175-.022-.174-.021-.175-.018-.175-.017-.173-.014-.176-.012-.176-.01-.177-.007-.176-.006-.177-.003-.178-.001-.177v-.134l-.013-.16-.044-.156-.072-.144-.097-.129-.12-.108-.137-.085-.15-.057-.159-.028zm26.798 2.024l-.16.007-.157.038-.148.066-.132.092-.113.115-.09.134-.062.148-.03.127-.001.004-.023.134-.024.133-.026.133-.026.13-.03.132-.03.129-.032.134-.033.128-.035.13-.037.128-.038.13-.04.126-.04.128-.044.128-.044.126-.046.126-.048.126-.05.125-.05.125-.051.122-.054.123-.055.122-.056.12-.058.122-.06.12-.061.12-.063.119-.062.116-.067.119-.066.116-.069.115-.069.115-.07.113-.073.113-.074.112-.076.113-.077.112-.077.107-.08.11-.08.107-.085.11-.044.056-.088.135-.06.15-.033.158-.002.16.027.16.057.15.083.138.108.12.128.098.144.072.155.045.16.015.161-.016.155-.044.144-.073.128-.098.09-.099.05-.061.003-.004.003-.005.089-.115.003-.004.003-.005.088-.116.003-.004.003-.005.086-.117.003-.004.003-.005.084-.118.003-.004.003-.005.083-.12.003-.004.003-.004.081-.12.003-.005.003-.004.08-.121.003-.005.003-.004.078-.122.003-.005.003-.004.077-.123.002-.005.003-.004.075-.124.003-.005.003-.004.073-.125.003-.005.003-.004.072-.126.002-.004.003-.005.07-.126.003-.005.002-.005.07-.127.002-.004.002-.005.068-.128.002-.005.002-.004.066-.13.003-.004.002-.005.064-.13.002-.004.003-.005.062-.13.002-.005.003-.005.06-.13.003-.005.002-.005.06-.132.002-.005.002-.005.057-.132.003-.005.002-.005.056-.133.002-.005.002-.005.054-.134.002-.004.002-.005.053-.135.002-.005.002-.005.051-.135.002-.005.002-.005.05-.135.001-.005.002-.005.048-.137.001-.005.002-.005.046-.137.002-.005.002-.005.044-.137.002-.005.002-.005.042-.138.002-.005.001-.006.042-.138.001-.005.002-.005.04-.14v-.005l.002-.005.038-.14.001-.005.002-.005.036-.14.001-.005.001-.005.035-.141.001-.005.001-.005.033-.142.001-.005.001-.005.031-.141.001-.006.002-.005.029-.142v-.005l.002-.005.028-.143v-.005l.002-.005.025-.143.001-.006.001-.005.024-.143.001-.005.001-.006.001-.006.01-.161-.02-.16-.05-.154-.077-.141-.102-.125-.123-.104-.141-.079-.153-.051-.16-.022zM6.841 23.019l-.16.024-.152.053-.14.08-.122.105-.101.126-.076.142-.048.154-.018.16.011.161.041.156.07.146.077.109.04.048.003.004.003.004.095.111.003.004.004.004.096.11.004.005.003.004.098.109.003.004.004.004.1.108.003.004.003.004.101.107.004.004.003.004.102.105.004.004.004.004.103.105.004.004.004.003.105.104.003.004.004.003.106.102.004.004.004.004.107.1.004.004.004.004.108.099.004.003.004.004.11.098.003.003.004.004.11.096.004.003.005.004.11.095.005.003.004.004.113.093.004.003.004.004.113.091.004.004.005.003.114.09.004.004.004.003.116.089.004.003.004.003.117.088.004.003.004.003.118.086.004.003.005.003.118.084.004.003.005.003.119.083.004.003.005.003.12.081.005.003.004.003.121.08.005.003.004.003.122.078.005.003.004.003.123.076.005.003.004.003.124.075.005.003.004.003.125.073.004.003.005.002.126.073.004.002.005.003.126.07.005.003.004.002.128.07.004.002.005.002.128.067.005.003.004.002.13.066.004.002.005.003.13.064.004.002.005.003.13.062.005.002.004.003.132.06.004.003.005.002.132.06.005.002.005.002.132.057.005.002.005.002.133.057.005.002.005.002.133.054.005.002.005.002.13.05.154.045.16.016.16-.015.156-.045.144-.072.128-.098.108-.12.083-.138.057-.15.028-.16-.003-.16-.032-.159-.061-.149-.088-.135-.11-.117-.132-.094-.12-.058-.124-.049-.126-.051-.122-.051-.122-.054-.12-.054-.126-.058-.119-.057-.12-.06-.12-.06-.118-.063-.117-.064-.119-.066-.116-.066-.115-.068-.115-.07-.113-.07-.115-.074-.112-.074-.11-.075-.11-.076-.112-.08-.11-.08-.109-.081-.106-.082-.104-.082-.106-.086-.105-.087-.101-.086-.105-.091-.1-.09-.1-.091-.1-.094-.097-.094-.1-.098-.093-.095-.096-.1-.093-.098-.092-.101-.089-.1-.09-.102-.088-.104-.036-.043-.114-.114-.133-.091-.148-.065-.157-.036-.161-.006zm15.063 2.701l-.16.014-.156.044-.12.057-.06.034-.12.066-.117.064-.118.062-.12.061-.12.06-.118.057-.126.058-.12.054-.122.054-.122.05-.126.052-.125.05-.124.046-.127.047-.125.044-.129.043-.126.04-.13.042-.128.038-.127.035-.13.036-.131.034-.129.031-.132.03-.13.03-.135.027-.133.026-.13.023-.13.022-.137.021-.132.02-.134.017-.132.015-.138.015-.135.013-.133.01-.138.01-.136.007-.134.006-.136.004-.14.003-.16.018-.155.047-.142.076-.127.1-.105.122-.08.14-.054.151-.025.16.006.16.035.158.064.148.09.134.114.114.133.092.147.065.157.036.134.008.145-.002h.011l.147-.005h.01l.147-.007h.011l.146-.009h.011l.146-.01h.005l.005-.001.146-.012h.011l.145-.014h.005l.006-.001.145-.016h.011l.144-.018h.006l.005-.001.144-.02h.011l.144-.021.005-.001h.006l.143-.023.006-.001h.005l.143-.025h.005l.006-.002.143-.026h.005l.005-.002.143-.027.005-.001.005-.001.142-.03h.005l.005-.002.142-.03.005-.002.005-.001.142-.033.005-.001.005-.001.14-.035.006-.001.005-.001.14-.037h.005l.005-.002.14-.038.005-.002h.005l.14-.04.005-.002.005-.001.138-.042.005-.001.006-.002.138-.043.005-.001.005-.002.137-.044.005-.002.005-.002.137-.046.005-.002.005-.001.137-.048.005-.002.005-.002.135-.05.005-.001.005-.002.135-.051.005-.002.005-.002.135-.053.005-.002.004-.002.134-.054.005-.002.005-.002.133-.057.005-.002.005-.002.132-.057.005-.003.005-.002.132-.06.005-.001.004-.002.131-.061.005-.003.005-.002.13-.062.005-.003.005-.002.13-.064.004-.003.005-.002.128-.066.005-.002.005-.003.128-.067.005-.002.004-.003.127-.069.005-.002.005-.003.126-.07.005-.003.004-.003.065-.037.132-.093.112-.115.089-.135.062-.149.034-.157.003-.161-.026-.16-.055-.15-.082-.14-.107-.12-.127-.1-.144-.073-.154-.046-.16-.016zM6.33 27.127l-.16.023-.152.053-.14.08-.122.105-.101.126-.076.142-.048.154-.02.16.012.161.041.156.07.146.094.13.096.093.032.026.004.003.004.004.145.117.004.003.004.004.146.115.005.003.004.004.147.113.005.003.004.004.149.111.004.003.004.003.15.11.005.003.004.003.151.108.004.003.005.003.152.106.005.003.004.003.154.104.004.003.005.003.154.102.005.002.004.003.156.1.005.003.004.003.157.098.005.003.004.002.159.096.004.003.005.003.16.094.004.003.004.002.16.092.005.003.005.002.161.09.005.003.005.002.162.088.005.003.004.002.164.086.005.003.004.002.165.084.005.003.004.002.166.082.004.002.005.003.167.08.004.002.005.002.168.078.004.002.005.002.168.076.005.002.005.002.17.074.004.002.005.002.17.072.005.002.005.002.17.07.006.002.005.001.171.068.005.002.005.002.173.065.005.002.005.002.173.063.005.002.005.002.174.06.005.003.005.001.175.06.005.001.005.002.176.057.005.001.005.002.176.055.006.001.005.002.177.052.005.002.005.001.178.05.005.002.005.002.178.048.006.001.005.002.179.046.005.001.005.002.18.044h.005l.005.002.18.042.006.001.005.001.159.035.16.02.16-.01.157-.04.146-.069.13-.094.112-.117.087-.136.06-.149.033-.158.002-.161-.028-.159-.057-.15-.084-.138-.108-.12-.128-.098-.144-.072-.128-.039-.154-.033-.168-.04-.171-.041-.17-.044-.168-.046-.167-.047-.168-.05-.165-.051-.166-.054-.166-.056-.163-.057-.165-.06-.161-.062-.164-.064-.16-.065-.16-.068-.162-.07-.157-.07-.157-.074-.157-.075-.156-.077-.153-.079-.156-.082-.153-.082-.154-.086-.15-.086-.152-.09-.148-.09-.147-.092-.149-.095-.145-.095-.144-.098-.145-.1-.143-.102-.14-.103-.14-.104-.14-.108-.139-.11-.136-.11-.027-.022-.133-.091-.148-.065-.157-.036-.161-.006zm19.215.087l-.16.01-.157.039-.146.067-.11.076-.064.051-.139.11-.14.108-.14.104-.14.103-.143.101-.145.101-.144.098-.145.095-.149.095-.148.093-.147.089-.152.09-.15.086-.154.086-.153.082-.156.082-.153.079-.156.077-.157.075-.158.073-.157.071-.16.07-.16.068-.161.065-.164.064-.161.061-.165.06-.163.058-.166.056-.166.054-.166.051-.167.05-.167.047-.17.046-.168.044-.171.042-.168.039-.17.037-.11.023-.154.047-.143.075-.126.1-.106.122-.081.139-.054.152-.025.16.006.16.035.158.063.148.09.133.114.115.132.092.148.065.157.037.16.007.133-.016.115-.024.005-.001.005-.001.181-.04h.005l.005-.002.18-.042.006-.001.005-.001.18-.044.005-.002.005-.001.18-.046.004-.002h.005l.179-.05h.005l.005-.002.178-.05.005-.002.005-.002.177-.052.005-.002.005-.001.177-.055.005-.002.005-.001.176-.057.005-.002.005-.002.175-.059.005-.001.005-.002.174-.061.005-.002.005-.002.173-.063.005-.002.005-.002.173-.065.004-.002.005-.002.172-.068.005-.002.005-.002.171-.07.005-.001.005-.002.17-.072.005-.002.004-.002.17-.074.005-.002.004-.002.169-.076.004-.002.005-.002.168-.078.004-.002.005-.003.167-.08.004-.002.005-.002.166-.082.004-.002.005-.003.165-.084.004-.002.005-.003.163-.086.005-.002.005-.003.162-.088.005-.002.005-.003.161-.09.005-.002.004-.003.16-.092.005-.003.005-.002.16-.094.004-.003.004-.003.158-.096.005-.002.004-.003.158-.098.004-.003.005-.003.156-.1.004-.003.004-.003.155-.101.005-.003.004-.003.154-.104.004-.003.004-.003.153-.106.004-.003.005-.003.151-.108.004-.003.005-.003.15-.11.004-.003.004-.003.149-.112.004-.003.004-.003.148-.113.004-.004.004-.003.147-.115.004-.004.004-.003.068-.055.116-.113.092-.132.066-.147.038-.157.008-.16-.022-.16-.05-.153-.08-.14-.103-.125-.124-.102-.142-.077-.153-.05-.16-.02z"
}));
function _extends$N() {
  _extends$N = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$N.apply(this, arguments);
}
var IntermediateEventCatchNonInterruptingEscalationIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$N({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M16.012 9.222c-1.673 4.657-2.735 9.508-4.409 14.164 1.536-1.526 2.874-3.236 4.41-4.762l4.408 4.762c-1.497-4.712-2.911-9.451-4.409-14.164zm.032 2.93c.823 2.588 1.599 5.19 2.421 7.777l-2.42-2.614c-.683.598-2.454 2.886-2.34 2.39.871-2.489 1.448-5.07 2.34-7.552zM16.012.312c-1.448.02-2.93.157-4.302.628-.852.447-.255 1.863.66 1.574 2.255-.608 4.648-.607 6.922-.108.934.075 1.228-1.376.338-1.67C18.451.44 17.227.317 16.012.311zm9.012 2.934c-.913-.104-1.272 1.258-.454 1.648 1.834 1.36 3.293 3.185 4.31 5.22.526.776 1.842.098 1.515-.78a15.522 15.522 0 00-5.06-6.006c-.1-.044-.203-.07-.31-.082zM6.65 3.59c-.762.089-1.24.809-1.805 1.267C3.38 6.295 2.163 8.007 1.37 9.905c-.266.898 1.094 1.484 1.564.675a14.825 14.825 0 014.327-5.56c.476-.515.09-1.419-.612-1.431zm9.362.007c-.698.066-1.689-.16-2.033.635-.282.733.535 1.358 1.217 1.125 1.806-.147 3.63.203 5.293.907.902.255 1.472-1.112.656-1.573-1.6-.735-3.374-1.089-5.133-1.094zm-5.479 1.365c-.835.15-1.517.76-2.21 1.226-1.203.94-2.318 2.061-3.057 3.402-.33.904 1.063 1.552 1.547.723 1.045-1.656 2.596-2.925 4.285-3.873.545-.499.171-1.463-.565-1.478zm13.903 2.115c-.875-.07-1.22 1.173-.501 1.627 1.325 1.34 2.188 3.062 2.748 4.84.468.84 1.869.21 1.557-.699-.604-2.118-1.751-4.097-3.351-5.615a.93.93 0 00-.453-.153zM4.467 13.132c-.822-.07-.996.826-1.046 1.455-.256 1.93-.094 3.933.562 5.769.406.844 1.807.365 1.612-.551a11.498 11.498 0 01-.334-5.808.874.874 0 00-.794-.865zm26.687 1.6c-.746-.037-1.014.785-.879 1.395.043 2.393-.57 4.771-1.66 6.894-.31.884 1.02 1.536 1.53.75a15.632 15.632 0 001.821-8.372.876.876 0 00-.812-.667zm-30.197.571c-.782-.073-1.044.775-.933 1.404.068 2.414.661 4.833 1.809 6.962.534.77 1.842.076 1.505-.798a14.833 14.833 0 01-1.603-6.861.876.876 0 00-.778-.707zm26.787 2.024c-.777-.048-.952.797-1.021 1.392-.354 1.692-1.202 3.231-2.216 4.608-.407.872.925 1.638 1.48.852 1.361-1.733 2.296-3.827 2.582-6.017a.874.874 0 00-.825-.835zM6.857 23.012c-.808.018-1.082 1.122-.47 1.59 1.393 1.607 3.187 2.886 5.194 3.599.91.222 1.43-1.165.598-1.596a11.495 11.495 0 01-4.723-3.396.899.899 0 00-.599-.197zm15.057 2.7c-.81.194-1.504.76-2.325.972-1.203.458-2.5.536-3.758.664-.869.307-.573 1.728.346 1.663 2.201-.034 4.412-.626 6.293-1.778.604-.495.227-1.532-.556-1.521zM6.346 27.118c-.833.008-1.11 1.218-.395 1.617 1.986 1.602 4.358 2.749 6.868 3.226.933.076 1.227-1.376.338-1.67a14.838 14.838 0 01-6.345-3.066.929.929 0 00-.466-.107zm19.208.087c-.766.09-1.241.841-1.922 1.158-1.516.991-3.251 1.58-4.996 2.005-.872.405-.346 1.849.584 1.604 2.543-.526 4.98-1.66 6.963-3.344.47-.52.072-1.42-.63-1.423z"
}));
function _extends$M() {
  _extends$M = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$M.apply(this, arguments);
}
var IntermediateEventCatchNonInterruptingMessageIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$M({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M8.742 10.464v11.072h14.516V10.464H8.742zm3.224 1.73h8.066a69569 69569 0 00-4.034 3.22l-4.032-3.22zm9.565 1.018v6.594H10.469v-6.593L16 17.63l5.532-4.419zM16 0h-.005l-.188.001h-.011l-.188.004h-.011l-.187.006h-.011l-.187.008h-.005L15.2.02l-.187.01h-.005l-.005.001-.187.013h-.011L14.62.06h-.01l-.186.018h-.011l-.185.02-.005.001h-.006l-.185.022-.005.001h-.005l-.185.025h-.005l-.005.001-.185.027h-.005l-.005.001-.184.029h-.005l-.005.001-.183.031-.006.001-.005.001-.182.033-.006.001-.005.001-.182.035-.005.001-.005.001-.182.038h-.005l-.005.002-.181.04h-.005l-.005.002-.18.042-.006.001-.005.001-.18.044-.005.002h-.005l-.17.045-.152.054-.139.082-.121.106-.1.127-.074.143-.046.155-.017.16.013.16.043.156.07.145.097.13.119.108.137.085.15.058.159.03.16-.001.133-.023.165-.043.168-.041.171-.04.171-.037.172-.036.17-.033.173-.03.17-.03.177-.027.171-.025.175-.022.175-.02.175-.02.176-.016.175-.014.177-.012.176-.01.177-.007.174-.006.177-.003L16 1.73h.177l.178.004.174.006.177.007.176.01.177.012.175.014.176.017.175.018.175.02.175.023.171.025.176.027.17.03.174.03.17.033.171.036.154.033.16.02.161-.01.156-.04.146-.069.131-.094.111-.117.087-.135.061-.15.032-.158.002-.16-.027-.16-.057-.15L20 .714l-.108-.12-.128-.097-.145-.073-.128-.038-.158-.035-.005-.001-.005-.001L19.14.31h-.005l-.005-.002-.182-.035h-.006l-.005-.002-.182-.033h-.006l-.005-.002-.183-.03-.005-.001-.006-.001-.183-.029h-.005l-.006-.001-.184-.027h-.005l-.005-.001-.185-.024h-.005L17.968.12 17.783.1l-.006-.001h-.005l-.185-.02h-.006l-.005-.001L17.39.06h-.005L17.38.06l-.187-.015h-.005l-.005-.001-.187-.013h-.011L16.8.02h-.011L16.6.01h-.011l-.187-.006h-.011L16.204 0h-.011L16.005 0H16zm9.015 2.935l-.16.004-.158.033-.15.062-.134.09-.116.111-.093.132-.067.147-.038.156-.01.161.022.16.05.153.078.141.103.124.102.087.045.034.142.106.137.105.14.11.136.11.135.112.134.115.134.117.13.115.132.122.128.12.127.122.126.125.124.126.124.128.121.13.118.128.118.132.117.133.113.134.113.136.11.136.109.137.109.142.104.14.103.14.101.142.1.144.099.146.095.145.094.147.093.15.092.15.087.149.087.15.084.152.084.155.08.152.08.155.04.081.084.138.11.119.128.096.145.072.155.043.16.013.16-.016.155-.046.144-.074.127-.099.106-.12.083-.14.055-.151.026-.16-.004-.16-.034-.158-.05-.124-.042-.085-.002-.004-.003-.005-.084-.165-.002-.004-.003-.005-.086-.164-.002-.004-.003-.005-.088-.162-.002-.005-.003-.005-.09-.161-.002-.005-.003-.004-.092-.16-.003-.005-.002-.005-.094-.16-.003-.004-.003-.004-.096-.159-.002-.004-.003-.005-.098-.157-.003-.004-.003-.005-.1-.156-.003-.004-.003-.005-.101-.154-.003-.005-.003-.004-.104-.154-.003-.004-.003-.005-.106-.152-.003-.005-.003-.004-.108-.151-.003-.004-.003-.005-.11-.15-.003-.004-.003-.004-.111-.15-.004-.003-.003-.005-.113-.147-.004-.004-.003-.005-.115-.146-.004-.004-.003-.004-.117-.145-.004-.004-.003-.004-.12-.144-.003-.004-.003-.004-.121-.142-.004-.004-.003-.004-.123-.141-.003-.004-.004-.004-.125-.14-.003-.004-.004-.004-.127-.138-.003-.004-.004-.004-.128-.136-.004-.004-.004-.004-.13-.135-.004-.004-.004-.004-.132-.134-.003-.004-.004-.003-.134-.133-.004-.003-.004-.004-.135-.13-.004-.004-.004-.004-.136-.128-.004-.004-.004-.004-.138-.126-.004-.004-.004-.003-.14-.125-.004-.004-.004-.003-.14-.123-.005-.004-.004-.003-.142-.121-.004-.004-.004-.003-.144-.12-.004-.003-.004-.003-.145-.117-.004-.004-.004-.003-.147-.115-.004-.004-.004-.003-.148-.113-.004-.003-.004-.004-.149-.111-.004-.003-.004-.004-.05-.036-.14-.083-.15-.055-.16-.027zM6.634 3.28l-.161.008-.157.037-.147.066-.111.074-.04.032-.005.003-.004.004-.145.117-.004.003-.004.004-.144.119-.004.003-.004.004-.142.12-.004.004-.004.004-.141.123-.004.003-.004.004-.14.125-.004.003-.004.004-.138.126-.004.004-.004.004-.136.128-.004.004-.004.004-.135.13-.004.004-.004.003-.134.133-.004.003-.004.004-.132.134-.003.004-.004.004-.13.135-.004.004-.004.004-.128.136-.004.004-.004.004-.126.138-.004.004-.003.004-.125.14-.004.004-.003.004-.123.14-.004.005-.003.004-.121.142-.004.004-.003.004-.12.144-.003.004-.003.004-.117.145-.004.004-.003.004-.115.146-.004.005-.003.004-.113.147-.003.005-.004.004-.111.149-.003.004-.004.004-.11.15-.002.005-.003.004-.108.151-.003.004-.003.005-.106.152-.003.005-.003.004-.104.154-.003.004-.003.005-.102.154-.003.005-.002.004-.1.156-.003.005-.003.004-.098.157-.003.005-.003.004-.096.159-.002.004-.003.005-.094.16-.003.004-.002.004-.092.16-.003.005-.003.005-.09.161-.002.005-.003.005-.088.162-.002.005-.003.004-.086.164-.002.005-.002.004-.084.165-.003.005-.002.004-.082.166-.002.004-.003.005-.08.167-.002.004-.002.005-.078.168-.002.004-.002.005-.045.1-.053.153-.023.16.007.16.037.157.065.148.092.132.114.114.134.09.148.064.157.035.161.006.16-.025.152-.054.14-.08.121-.106.1-.126.065-.118.043-.095.074-.16.075-.155.077-.157.08-.155.08-.152.083-.155.085-.152.086-.15.088-.149.091-.15.094-.15.094-.147.095-.145.099-.146.1-.144.1-.142.104-.14.104-.14.11-.142.107-.137.11-.136.114-.136.113-.134.117-.133.118-.132.117-.129.122-.13.124-.127.123-.126.127-.125.127-.122.128-.12.132-.122.13-.115.133-.117.135-.115.135-.111.136-.11.037-.03.117-.11.094-.132.068-.146.04-.156.01-.161-.02-.16-.05-.154-.076-.141-.102-.125-.123-.104-.14-.08-.153-.051-.16-.023zM16 3.286h-.005l-.148.001h-.01l-.147.003h-.011l-.147.005h-.011l-.146.007h-.011l-.146.009h-.011l-.146.01h-.005l-.005.001-.146.012h-.011l-.145.014h-.006l-.005.001-.05.006-.158.031-.15.06-.135.088-.117.111-.094.13-.069.147-.04.156-.01.16.019.16.049.154.076.142.102.125.123.105.14.08.152.051.16.023.134-.003.045-.005.135-.013.133-.01.136-.01.135-.007.137-.006.136-.004.136-.003h.274l.136.003.136.004.136.006.136.007.136.01.133.01.135.013.135.014.135.016.134.018.132.018.134.021.133.023.133.024.133.025.13.027.132.03.132.03.129.031.13.034.129.035.129.036.13.04.126.038.128.042.126.042.128.045.127.047.126.047.12.048.127.051.123.052.006.002.147.048.16.021.16-.009.157-.038.147-.067.131-.093.112-.116.089-.135.062-.149.033-.158.004-.16-.027-.16-.055-.151-.083-.139-.107-.12-.127-.099-.118-.063-.004-.001-.005-.003-.005-.002-.133-.056-.005-.002-.005-.002-.134-.054-.004-.002-.005-.002-.135-.053-.005-.002-.005-.002-.135-.051-.005-.002-.005-.002-.135-.05-.005-.001-.005-.002-.137-.048-.005-.001-.005-.002-.137-.046-.005-.002-.005-.002-.137-.044-.005-.002-.005-.001-.138-.043-.006-.002-.005-.001-.138-.042-.005-.001-.005-.002-.14-.04H19.4l-.005-.002-.14-.038-.005-.001-.005-.002-.14-.036-.005-.001-.005-.001-.141-.035-.005-.001-.005-.001-.142-.033-.005-.001-.005-.001-.142-.031-.005-.002h-.005l-.142-.03-.005-.001-.005-.001-.143-.028h-.005l-.005-.002-.143-.025-.006-.001-.005-.001-.143-.024-.005-.001-.006-.001-.143-.022-.006-.001h-.005l-.144-.022h-.005l-.006-.001-.144-.019h-.005l-.006-.001-.144-.017h-.006l-.005-.001-.145-.016h-.011l-.145-.014H17.1l-.005-.001-.146-.012h-.01l-.146-.01-.006-.001h-.005l-.146-.009h-.011l-.147-.006h-.01l-.147-.005h-.011l-.147-.003h-.011l-.147-.001H16zm-5.482 1.366l-.16.008-.157.037-.123.053-.06.032-.005.002-.004.003-.128.069-.004.002-.005.003-.126.07-.005.003-.004.002-.126.072-.005.003-.004.003-.125.073-.004.003-.005.003-.124.075-.004.003-.005.002-.123.077-.004.003-.005.003-.122.078-.004.003-.005.003-.121.08-.004.002-.005.003-.12.082-.005.003-.004.003-.12.083-.004.003-.004.003-.118.084-.005.003-.004.003-.118.086-.004.003-.004.003-.117.088-.004.003-.004.003-.116.089-.004.003-.004.004-.114.09-.005.003-.004.003-.113.092-.004.004-.004.003-.113.093-.004.004-.004.003-.111.095-.005.003-.004.004-.11.096-.004.004-.004.003-.11.098-.003.003-.004.004-.108.1-.004.003-.004.003-.107.101-.004.004-.004.003-.106.102-.004.004-.003.004-.105.103-.004.004-.004.004-.103.105-.004.004-.004.003-.102.106-.003.004-.004.004-.1.107-.004.004-.004.004-.099.108-.004.004-.003.004-.098.11-.003.003-.004.004-.096.11-.004.005-.003.004-.095.111-.003.004-.004.004-.093.113-.003.004-.004.004-.092.113-.003.004-.003.005-.09.114-.004.004-.003.004-.089.116-.003.004-.003.004-.088.117-.003.004-.003.004-.086.118-.003.004-.003.005-.084.118-.003.004-.003.005-.083.12-.003.003-.003.005-.082.12-.003.005-.002.004-.068.103-.076.142-.048.154-.018.16.011.161.041.156.07.146.095.13.117.11.136.086.15.06.158.03.162.002.158-.03.15-.057.138-.085.119-.109.082-.105.065-.099.075-.11.077-.113.077-.107.08-.11.08-.108.084-.108.083-.105.086-.106.086-.104.088-.104.089-.101.09-.102.093-.101.093-.099.094-.097.095-.096.098-.097.098-.095.099-.093.1-.092.103-.091.101-.089.104-.088.104-.086.106-.086.106-.083.106-.082.109-.082.108-.079.11-.078.11-.076.112-.076.112-.074.113-.072.113-.071.115-.07.115-.068.118-.067.117-.065.12-.065.054-.029.135-.088.116-.111.094-.132.068-.146.04-.156.009-.161-.02-.16-.05-.153-.078-.142-.102-.125-.123-.103-.141-.079-.153-.051-.16-.022zm13.91 2.116l-.162.008-.157.037-.147.066-.132.092-.113.116-.09.134-.063.148-.034.157-.005.162.025.159.055.152.082.138.086.103.09.09.094.098.092.099.093.1.091.103.089.101.088.104.086.104.086.106.083.105.083.108.08.108.081.11.077.107.077.112.075.111.075.114.072.113.071.113.07.114.068.118.067.115.065.118.064.117.062.117.061.121.059.119.059.122.056.121.054.12.055.125.051.123.051.125.048.123.048.127.047.126.044.125.043.128.042.129.039.126.038.13.022.076.058.15.085.137.11.119.129.096.145.07.155.043.16.013.161-.017.154-.046.144-.075.126-.1.106-.12.082-.14.055-.151.025-.16-.005-.16-.026-.132-.023-.082-.002-.005-.001-.005-.042-.139-.001-.005-.002-.005-.043-.138-.001-.005-.002-.005-.044-.137-.002-.005-.002-.005-.046-.137-.002-.005-.001-.005-.048-.137-.002-.005-.002-.005-.05-.135-.001-.005-.002-.005-.051-.135-.002-.005-.002-.005-.053-.135-.002-.005-.002-.005-.054-.133-.002-.005-.002-.005-.057-.133-.002-.005-.002-.005-.057-.132-.003-.005-.002-.005-.06-.132-.001-.005-.002-.004-.061-.132-.003-.004-.002-.005-.063-.13-.002-.005-.002-.005-.064-.13-.003-.004-.002-.005-.066-.129-.002-.004-.003-.005-.067-.128-.002-.005-.003-.004-.069-.128-.002-.004-.003-.005-.07-.126-.003-.005-.003-.004-.072-.126-.002-.005-.003-.004-.074-.125-.002-.004-.003-.005-.075-.124-.003-.004-.003-.005-.076-.123-.003-.004-.003-.005-.078-.122-.003-.004-.003-.005-.08-.121-.003-.004-.003-.005-.081-.12-.003-.005-.003-.004-.083-.12-.003-.004-.003-.004-.084-.118-.003-.005-.003-.004-.086-.118-.003-.004-.004-.004-.087-.117-.003-.004-.003-.004-.09-.116-.002-.004-.004-.004-.09-.114-.003-.005-.004-.004-.091-.113-.004-.004-.003-.004-.094-.113-.003-.004-.003-.004-.095-.111-.004-.004-.003-.004-.096-.11-.004-.005-.003-.004-.098-.11-.004-.003-.003-.004-.1-.108-.003-.004-.004-.004-.1-.107-.004-.004-.004-.004-.102-.106-.003-.003-.004-.004-.093-.095-.124-.103-.14-.08-.153-.05-.16-.023zM4.45 12.826l-.161.002-.158.032-.15.06-.135.088-.118.11-.094.131-.069.146-.035.129-.026.132v.005l-.002.005-.025.143-.001.005-.001.006-.024.143-.001.005-.001.006-.022.143-.001.006-.001.005-.02.144-.001.005-.001.005-.019.145v.005l-.001.006-.017.144v.006l-.001.005-.016.145v.011l-.014.145v.005l-.001.006-.012.146v.01l-.01.146-.001.006v.005l-.009.146v.011l-.007.146v.011l-.004.147v.011l-.003.147v.01l-.002.148v.01l.001.148v.01l.003.147v.011l.005.147v.01l.007.147v.011l.009.146v.011l.01.146v.01l.013.146v.011l.014.145v.005l.001.006.016.145v.011l.018.144v.006l.001.005.019.144v.006l.001.005.021.144v.005l.002.006.022.143v.006l.002.005.024.143v.005l.002.006.025.143.001.005.001.005.028.143.001.005.001.005.03.142v.005l.002.006.03.141.002.005.001.005.033.142v.005l.002.005.035.14v.006l.002.005.036.14.002.005.001.005.038.14.001.005.002.005.04.14v.005l.002.005.042.138.001.006.002.005.042.138.002.005.002.005.017.054.064.148.09.134.114.114.132.092.148.065.157.037.16.007.16-.023.153-.052.14-.08.123-.104.102-.125.076-.142.049-.153.02-.16-.011-.161-.031-.13-.017-.051-.039-.126-.038-.13-.037-.128-.035-.13-.033-.128-.033-.134-.03-.13-.029-.131-.026-.13-.026-.133-.024-.133-.023-.133-.02-.132-.02-.136-.017-.132-.016-.135-.014-.135-.012-.133-.012-.138-.009-.133-.007-.136-.006-.138-.004-.134-.003-.136v-.274l.003-.136.004-.134.006-.139.007-.136.01-.133.01-.138.013-.132.014-.135.016-.135.017-.132.02-.137.02-.13.023-.134.024-.133.024-.126.016-.16-.014-.161-.044-.155-.072-.145-.098-.128-.12-.108-.137-.084-.15-.057-.16-.029zm26.698 1.601l-.161.01-.157.04-.146.067-.131.093-.112.117-.088.135-.061.149-.033.157-.005.134.006.14.006.176.003.177.001.178-.001.177-.003.178-.006.177-.007.176-.01.177-.012.176-.015.176-.016.173-.018.175-.02.175-.024.174-.025.175-.026.17-.03.174-.03.173-.033.17-.036.172-.037.17-.04.17-.042.172-.043.168-.045.166-.048.169-.05.167-.052.168-.053.164-.056.166-.058.166-.06.16-.062.165-.062.158-.066.165-.068.16-.07.16-.07.158-.075.159-.074.155-.079.158-.08.158-.06.15-.03.158-.001.161.029.159.058.15.085.137.108.119.13.097.144.07.156.044.16.013.16-.017.155-.046.143-.074.127-.1.107-.12.07-.115.083-.164.003-.005.002-.004.082-.166.002-.005.003-.004.08-.167.002-.005.002-.004.078-.168.002-.005.002-.004.076-.169.002-.004.002-.005.074-.17.002-.004.002-.005.072-.17.002-.005.002-.005.07-.171.001-.005.002-.005.068-.172.002-.004.002-.005.065-.173.002-.005.002-.005.063-.173.002-.005.002-.005.06-.174.003-.005.001-.005.06-.175.001-.005.002-.005.057-.176.001-.005.002-.005.055-.177.001-.005.002-.005.052-.177.002-.005.001-.005.051-.178.001-.005.002-.005.048-.179.002-.005v-.005l.047-.179.001-.005.002-.005.044-.18v-.005l.002-.005.042-.18.001-.006.001-.005.04-.181.001-.005.001-.005.037-.182.002-.005v-.005l.036-.182v-.006l.002-.005.033-.182v-.006l.002-.005.03-.183.001-.005.001-.005.029-.184v-.005l.001-.006.027-.184v-.005l.001-.005.024-.185v-.005l.001-.005.022-.185v-.006l.001-.005.02-.185v-.006l.001-.005.017-.186v-.005l.001-.005.015-.187v-.005l.001-.005.013-.187v-.01l.01-.187.001-.006v-.005l.009-.187v-.011l.006-.187v-.011l.004-.188v-.011l.001-.188v-.01l-.001-.188v-.011l-.004-.188v-.011l-.006-.187v-.011l-.007-.145-.022-.16-.05-.152-.08-.141-.103-.124-.125-.102-.141-.077-.153-.05-.16-.02zM.938 15L.777 15l-.158.032-.15.06-.136.087-.117.11-.095.131-.068.146-.04.156-.012.133-.001.14v.01l.001.188v.011l.004.188v.011l.006.187v.011l.008.187v.011l.011.187v.005l.001.005.013.187v.01l.016.187v.01l.018.186v.011l.02.185.001.005v.006l.022.185.001.005v.005l.025.185v.005l.001.005.027.184v.006l.001.005.029.184v.005l.001.005.031.183.001.005.001.006.033.182.001.005.001.006.035.182.001.005.001.005.038.182v.005l.002.005.04.181v.005l.002.005.042.18.001.006.001.005.044.18.002.005v.005l.047.18.001.004.002.005.048.179.002.005.001.005.05.178.002.005.001.005.053.177.002.005.001.005.055.177.002.005.001.005.057.176.002.005.001.005.06.175.001.005.002.005.061.174.002.005.002.005.063.173.002.005.002.005.065.173.002.005.002.004.067.172.002.005.002.005.07.171.002.005.002.005.072.17.002.005.002.004.074.17.002.005.002.004.076.169.002.004.002.005.078.168.002.004.002.005.08.167.003.004.002.005.082.166.002.004.003.005.02.04.086.136.11.118.13.095.146.07.156.041.16.012.16-.019.155-.048.142-.075.126-.1.105-.123.08-.14.054-.152.024-.16-.006-.16-.036-.158-.051-.123-.018-.034-.078-.158L3.1 22.1l-.074-.16-.071-.157-.07-.16-.068-.16-.067-.165-.062-.158-.062-.164-.059-.161-.058-.166-.056-.166-.053-.164-.052-.168-.05-.167-.048-.17-.045-.165-.043-.168-.043-.172-.039-.17-.037-.17-.036-.172-.033-.17-.03-.173-.03-.174-.027-.17-.025-.175-.022-.174-.021-.175-.018-.175-.017-.173-.014-.176-.012-.176-.01-.177-.007-.176-.006-.177-.003-.178L1.73 16v-.134l-.013-.16-.044-.156-.072-.144-.097-.129-.12-.108-.137-.085-.15-.057L.938 15zm26.798 2.024l-.16.007-.157.038-.148.066-.132.092-.113.115-.09.134-.062.148-.03.127-.001.004-.023.134-.024.133-.026.133-.026.13-.03.132-.03.129-.032.134-.033.128-.035.13-.037.128-.038.13-.04.126-.04.128-.044.128-.044.126-.046.126-.048.126-.05.125-.05.125-.051.122-.054.123-.055.122-.056.12-.058.122-.06.12-.061.12-.063.119-.062.116-.067.119-.066.116-.069.115-.069.115-.07.113-.073.113-.074.112-.076.113-.077.112-.077.107-.08.11-.08.107-.085.11-.044.056-.088.135-.06.15-.033.158-.002.16.027.16.057.15.083.138.108.12.128.098.144.072.155.045.16.015.161-.016.155-.044.144-.073.128-.098.09-.099.05-.061.003-.004.003-.005.089-.115.003-.004.003-.005.088-.116.003-.004.003-.005.086-.117.003-.004.003-.005.084-.118.003-.004.003-.005.083-.12.003-.004.003-.004.081-.12.003-.005.003-.004.08-.121.003-.005.003-.004.078-.122.003-.005.003-.004.077-.123.002-.005.003-.004.075-.124.003-.005.003-.004.073-.125.003-.005.003-.004.072-.126.002-.004.003-.005.07-.126.003-.005.002-.005.07-.127.002-.004.002-.005.068-.128.002-.005.002-.004.066-.13.003-.004.002-.005.064-.13.002-.004.003-.005.062-.13.002-.005.003-.005.06-.13.003-.005.002-.005.06-.132.002-.005.002-.005.057-.132.003-.005.002-.005.056-.133.002-.005.002-.005.054-.134.002-.004.002-.005.053-.135.002-.005.002-.005.051-.135.002-.005.002-.005.05-.135.001-.005.002-.005.048-.137.001-.005.002-.005.046-.137.002-.005.002-.005.044-.137.002-.005.002-.005.042-.138.002-.005.001-.006.042-.138.001-.005.002-.005.04-.14V19.4l.002-.005.038-.14.001-.005.002-.005.036-.14.001-.005.001-.005.035-.141.001-.005.001-.005.033-.142.001-.005.001-.005.031-.141.001-.006.002-.005.029-.142v-.005l.002-.005.028-.143v-.005l.002-.005.025-.143.001-.006.001-.005.024-.143.001-.005.001-.006.001-.006.01-.161-.02-.16-.05-.154-.077-.141-.102-.125-.123-.104-.141-.079-.153-.051-.16-.022zM6.841 22.71l-.16.024-.152.053-.14.08-.122.105-.101.126-.076.142-.048.154-.018.16.011.161.041.156.07.146.077.109.04.048.003.004.003.004.095.111.003.004.004.004.096.11.004.005.003.004.098.109.003.004.004.004.1.108.003.004.003.004.101.107.004.004.003.004.102.105.004.004.004.004.103.105.004.004.004.003.105.104.003.004.004.003.106.102.004.004.004.004.107.1.004.004.004.004.108.099.004.003.004.004.11.098.003.003.004.004.11.096.004.003.005.004.11.095.005.003.004.004.113.093.004.003.004.004.113.091.004.004.005.003.114.09.004.004.004.003.116.089.004.003.004.003.117.088.004.003.004.003.118.086.004.003.005.003.118.084.004.003.005.003.119.083.004.003.005.003.12.081.005.003.004.003.121.08.005.003.004.003.122.078.005.003.004.003.123.076.005.003.004.003.124.075.005.003.004.003.125.073.004.003.005.002.126.073.004.002.005.003.126.07.005.003.004.002.128.07.004.002.005.002.128.067.005.003.004.002.13.066.004.002.005.003.13.064.004.002.005.003.13.062.005.002.004.003.132.06.004.003.005.002.132.06.005.002.005.002.132.057.005.002.005.002.133.057.005.002.005.002.133.054.005.002.005.002.13.05.154.045.16.016.16-.015.156-.045.144-.072.128-.098.108-.12.083-.138.057-.15.028-.16-.003-.16-.032-.159-.061-.149-.088-.135-.11-.117-.132-.094-.12-.058-.124-.049-.126-.051-.122-.051-.122-.054-.12-.054-.126-.058-.119-.057-.12-.06-.12-.06-.118-.063-.117-.064-.119-.066-.116-.066-.115-.068-.115-.07-.113-.07-.115-.074-.112-.074-.11-.075-.11-.076-.112-.08-.11-.08-.109-.081-.106-.082-.104-.082-.106-.086-.105-.087-.101-.086-.105-.091-.1-.09-.1-.091-.1-.094-.097-.094-.1-.098-.093-.095-.096-.1-.093-.098-.092-.101-.089-.1-.09-.102-.088-.104-.036-.043-.114-.114-.133-.091-.148-.065-.157-.036-.161-.006zm15.063 2.701l-.16.014-.156.044-.12.057-.06.034-.12.066-.117.064-.118.062-.12.061-.12.06-.118.057-.126.058-.12.054-.122.054-.122.05-.126.052-.125.05-.124.046-.127.047-.125.044-.129.043-.126.04-.13.042-.128.038-.127.035-.13.036-.131.034-.129.031-.132.03-.13.03-.135.027-.133.026-.13.023-.13.022-.137.021-.132.02-.134.017-.132.015-.138.015-.135.013-.133.01-.138.01-.136.007-.134.006-.136.004-.14.003-.16.018-.155.047-.142.076-.127.1-.105.122-.08.14-.054.151-.025.16.006.16.035.158.064.148.09.134.114.114.133.092.147.065.157.036.134.008.145-.002h.011l.147-.005h.01l.147-.007h.011l.146-.009h.011l.146-.01h.005l.005-.001.146-.012h.011l.145-.014h.005l.006-.001.145-.016h.011l.144-.018h.006l.005-.001.144-.02h.011l.144-.021.005-.001h.006l.143-.023.006-.001h.005l.143-.025h.005l.006-.002.143-.026h.005l.005-.002.143-.027.005-.001.005-.001.142-.03h.005l.005-.002.142-.03.005-.002.005-.001.142-.033.005-.001.005-.001.14-.035.006-.001.005-.001.14-.037h.005l.005-.002.14-.038.005-.002h.005l.14-.04.005-.002.005-.001.138-.042.005-.001.006-.002.138-.043.005-.001.005-.002.137-.044.005-.002.005-.002.137-.046.005-.002.005-.001.137-.048.005-.002.005-.002.135-.05.005-.001.005-.002.135-.051.005-.002.005-.002.135-.053.005-.002.004-.002.134-.054.005-.002.005-.002.133-.057.005-.002.005-.002.132-.057.005-.003.005-.002.132-.06.005-.001.004-.002.131-.061.005-.003.005-.002.13-.062.005-.003.005-.002.13-.064.004-.003.005-.002.128-.066.005-.002.005-.003.128-.067.005-.002.004-.003.127-.069.005-.002.005-.003.126-.07.005-.003.004-.003.065-.037.132-.093.112-.115.089-.135.062-.149.034-.157.003-.161-.026-.16-.055-.15-.082-.14-.107-.12-.127-.1-.144-.073-.154-.046-.16-.016zM6.33 26.818l-.16.023-.152.053-.14.08-.122.105-.101.126-.076.142-.048.154-.02.16.012.161.041.156.07.146.094.13.096.093.032.026.004.003.004.004.145.117.004.003.004.004.146.115.005.003.004.004.147.113.005.003.004.004.149.111.004.003.004.003.15.11.005.003.004.003.151.108.004.003.005.003.152.106.005.003.004.003.154.104.004.003.005.003.154.102.005.002.004.003.156.1.005.003.004.003.157.098.005.003.004.002.159.096.004.003.005.003.16.094.004.003.004.002.16.092.005.003.005.002.161.09.005.003.005.002.162.088.005.003.004.002.164.086.005.003.004.002.165.084.005.003.004.002.166.082.004.002.005.003.167.08.004.002.005.002.168.078.004.002.005.002.168.076.005.002.005.002.17.074.004.002.005.002.17.072.005.002.005.002.17.07.006.002.005.001.171.068.005.002.005.002.173.065.005.002.005.002.173.063.005.002.005.002.174.06.005.003.005.001.175.06.005.001.005.002.176.057.005.001.005.002.176.055.006.001.005.002.177.052.005.002.005.001.178.05.005.002.005.002.178.048.006.001.005.002.179.046.005.001.005.002.18.044h.005l.005.002.18.042.006.001.005.001.159.035.16.02.16-.01.157-.04.146-.069.13-.094.112-.117.087-.136.06-.149.033-.158.002-.161-.028-.159-.057-.15-.084-.138-.108-.12-.128-.098-.144-.072-.128-.039-.154-.033-.168-.04-.171-.041-.17-.044-.168-.046-.167-.047-.168-.05-.165-.051-.166-.054-.166-.056-.163-.057-.165-.06-.161-.062-.164-.064-.16-.065-.16-.068-.162-.07-.157-.07-.157-.074-.157-.075-.156-.077-.153-.079-.156-.082-.153-.082-.154-.086-.15-.086-.152-.09-.148-.09-.147-.092-.149-.095-.145-.095-.144-.098-.145-.1-.143-.102-.14-.103-.14-.104-.14-.108-.139-.11-.136-.11-.027-.022-.133-.091-.148-.065-.157-.036-.161-.006zm19.215.087l-.16.01-.157.039-.146.067-.11.076-.064.051-.139.11-.14.108-.14.104-.14.103-.143.101-.145.101-.144.098-.145.095-.149.095-.148.093-.147.089-.152.09-.15.086-.154.086-.153.082-.156.082-.153.079-.156.077-.157.075-.158.073-.157.071-.16.07-.16.068-.161.065-.164.064-.161.061-.165.06-.163.058-.166.056-.166.054-.166.051-.167.05-.167.047-.17.046-.168.044-.171.042-.168.039-.17.037-.11.023-.154.047-.143.075-.126.1-.106.122-.081.139-.054.152-.025.16.006.16.035.158.063.148.09.133.114.115.132.092.148.065.157.037.16.007.133-.016.115-.024.005-.001.005-.001.181-.04h.005l.005-.002.18-.042.006-.001.005-.001.18-.044.005-.002.005-.001.18-.046.004-.002h.005l.179-.05h.005l.005-.002.178-.05.005-.002.005-.002.177-.052.005-.002.005-.001.177-.055.005-.002.005-.001.176-.057.005-.002.005-.002.175-.059.005-.001.005-.002.174-.061.005-.002.005-.002.173-.063.005-.002.005-.002.173-.065.004-.002.005-.002.172-.068.005-.002.005-.002.171-.07.005-.001.005-.002.17-.072.005-.002.004-.002.17-.074.005-.002.004-.002.169-.076.004-.002.005-.002.168-.078.004-.002.005-.003.167-.08.004-.002.005-.002.166-.082.004-.002.005-.003.165-.084.004-.002.005-.003.163-.086.005-.002.005-.003.162-.088.005-.002.005-.003.161-.09.005-.002.004-.003.16-.092.005-.003.005-.002.16-.094.004-.003.004-.003.158-.096.005-.002.004-.003.158-.098.004-.003.005-.003.156-.1.004-.003.004-.003.155-.101.005-.003.004-.003.154-.104.004-.003.004-.003.153-.106.004-.003.005-.003.151-.108.004-.003.005-.003.15-.11.004-.003.004-.003.149-.112.004-.003.004-.003.148-.113.004-.004.004-.003.147-.115.004-.004.004-.003.068-.055.116-.113.092-.132.066-.147.038-.157.008-.16-.022-.16-.05-.153-.08-.14-.103-.125-.124-.102-.142-.077-.153-.05-.16-.02z"
}));
function _extends$L() {
  _extends$L = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$L.apply(this, arguments);
}
var IntermediateEventCatchNonInterruptingMultipleIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$L({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M23.637 13.902l-7.625-5.535-7.624 5.535 2.912 8.956h9.425l2.912-8.956zm-1.017.33l-2.524 7.762H11.93l-2.524-7.762 6.607-4.796 6.608 4.796zM16.012.311c-1.448.02-2.93.157-4.302.628-.852.447-.255 1.863.66 1.574 2.255-.608 4.648-.607 6.922-.108.934.075 1.228-1.376.338-1.67C18.451.44 17.227.317 16.012.311zm9.012 2.934c-.913-.104-1.272 1.258-.454 1.648 1.834 1.36 3.293 3.185 4.31 5.22.526.776 1.842.098 1.515-.78a15.522 15.522 0 00-5.06-6.006c-.1-.044-.203-.07-.31-.082zM6.65 3.59c-.762.089-1.24.809-1.805 1.267C3.38 6.295 2.163 8.007 1.37 9.905c-.266.898 1.094 1.484 1.564.675a14.825 14.825 0 014.327-5.56c.476-.515.09-1.419-.612-1.431zm9.362.007c-.698.066-1.689-.16-2.033.635-.282.733.535 1.358 1.217 1.125 1.806-.147 3.63.203 5.293.907.902.255 1.472-1.112.656-1.573-1.6-.735-3.374-1.089-5.133-1.094zm-5.479 1.365c-.835.15-1.517.76-2.21 1.226-1.203.94-2.318 2.061-3.057 3.402-.33.904 1.063 1.552 1.547.723 1.045-1.656 2.596-2.925 4.285-3.873.545-.499.171-1.463-.565-1.478zm13.903 2.115c-.875-.07-1.22 1.173-.501 1.627 1.325 1.34 2.188 3.062 2.748 4.84.468.84 1.869.21 1.557-.699-.604-2.118-1.751-4.097-3.351-5.615a.93.93 0 00-.453-.153zM4.467 13.132c-.822-.07-.996.826-1.046 1.455-.256 1.93-.094 3.933.562 5.769.406.844 1.807.365 1.612-.551a11.498 11.498 0 01-.334-5.808.874.874 0 00-.794-.865zm26.687 1.6c-.746-.037-1.014.785-.879 1.395.043 2.393-.57 4.771-1.66 6.894-.31.884 1.02 1.536 1.53.75a15.632 15.632 0 001.821-8.372.876.876 0 00-.812-.667zm-30.197.571c-.782-.073-1.044.775-.933 1.404.068 2.414.661 4.833 1.809 6.962.534.77 1.842.076 1.505-.798a14.833 14.833 0 01-1.603-6.861.876.876 0 00-.778-.707zm26.787 2.024c-.777-.048-.952.797-1.021 1.392-.354 1.692-1.202 3.231-2.216 4.608-.407.872.925 1.638 1.48.852 1.361-1.733 2.296-3.827 2.582-6.017a.874.874 0 00-.825-.835zM6.857 23.012c-.808.018-1.082 1.122-.47 1.59 1.393 1.607 3.187 2.886 5.194 3.599.91.222 1.43-1.165.598-1.596a11.495 11.495 0 01-4.723-3.396.899.899 0 00-.599-.197zm15.057 2.7c-.81.194-1.504.76-2.325.972-1.203.458-2.5.536-3.758.664-.869.307-.573 1.728.346 1.663 2.201-.034 4.412-.626 6.293-1.778.604-.495.227-1.532-.556-1.521zM6.346 27.118c-.833.008-1.11 1.218-.395 1.617 1.986 1.602 4.358 2.749 6.868 3.226.933.076 1.227-1.376.338-1.67a14.838 14.838 0 01-6.345-3.066.929.929 0 00-.466-.107zm19.208.087c-.766.09-1.241.841-1.922 1.158-1.516.991-3.251 1.58-4.996 2.005-.872.405-.346 1.849.584 1.604 2.543-.526 4.98-1.66 6.963-3.344.47-.52.072-1.42-.63-1.423z"
}));
function _extends$K() {
  _extends$K = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$K.apply(this, arguments);
}
var IntermediateEventCatchNonInterruptingParallelIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$K({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M13.51 9.081v4.428H9.08v4.982h4.428v4.428h4.982V18.49h4.428v-4.982H18.49V9.081h-4.982zm.83.83h3.32v4.428h4.429v3.322H17.66v4.428h-3.32v-4.454H9.91v-3.296h4.428V9.911zM16 0h-.005l-.188.001h-.011l-.188.004h-.011l-.187.006h-.011l-.187.008h-.005L15.2.02l-.187.01h-.005l-.005.001-.187.013h-.011L14.62.06h-.01l-.186.018h-.011l-.185.02-.005.001h-.006l-.185.022-.005.001h-.005l-.185.025h-.005l-.005.001-.185.027h-.005l-.005.001-.184.029h-.005l-.005.001-.183.031-.006.001-.005.001-.182.033-.006.001-.005.001-.182.035-.005.001-.005.001-.182.038h-.005l-.005.002-.181.04h-.005l-.005.002-.18.042-.006.001-.005.001-.18.044-.005.002h-.005l-.17.045-.152.054-.139.082-.121.106-.1.127-.074.143-.046.155-.017.16.013.16.043.156.07.145.097.13.119.108.137.085.15.058.159.03.16-.001.133-.023.165-.043.168-.041.171-.04.171-.037.172-.036.17-.033.173-.03.17-.03.177-.027.171-.025.175-.022.175-.02.175-.02.176-.016.175-.014.177-.012.176-.01.177-.007.174-.006.177-.003L16 1.73h.177l.178.004.174.006.177.007.176.01.177.012.175.014.176.017.175.018.175.02.175.023.171.025.176.027.17.03.174.03.17.033.171.036.154.033.16.02.161-.01.156-.04.146-.069.131-.094.111-.117.087-.135.061-.15.032-.158.002-.16-.027-.16-.057-.15L20 .714l-.108-.12-.128-.097-.145-.073-.128-.038-.158-.035-.005-.001-.005-.001L19.14.31h-.005l-.005-.002-.182-.035h-.006l-.005-.002-.182-.033h-.006l-.005-.002-.183-.03-.005-.001-.006-.001-.183-.029h-.005l-.006-.001-.184-.027h-.005l-.005-.001-.185-.024h-.005L17.968.12 17.783.1l-.006-.001h-.005l-.185-.02h-.006l-.005-.001L17.39.06h-.005L17.38.06l-.187-.015h-.005l-.005-.001-.187-.013h-.011L16.8.02h-.011L16.6.01h-.011l-.187-.006h-.011L16.204 0h-.011L16.005 0H16zm9.015 2.935l-.16.004-.158.033-.15.062-.134.09-.116.111-.093.132-.067.147-.038.156-.01.161.022.16.05.153.078.141.103.124.102.087.045.034.142.106.137.105.14.11.136.11.135.112.134.115.134.117.13.115.132.122.128.12.127.122.126.125.124.126.124.128.121.13.118.128.118.132.117.133.113.134.113.136.11.136.109.137.109.142.104.14.103.14.101.142.1.144.099.146.095.145.094.147.093.15.092.15.087.149.087.15.084.152.084.155.08.152.08.155.04.081.084.138.11.119.128.096.145.072.155.043.16.013.16-.016.155-.046.144-.074.127-.099.106-.12.083-.14.055-.151.026-.16-.004-.16-.034-.158-.05-.124-.042-.085-.002-.004-.003-.005-.084-.165-.002-.004-.003-.005-.086-.164-.002-.004-.003-.005-.088-.162-.002-.005-.003-.005-.09-.161-.002-.005-.003-.004-.092-.16-.003-.005-.002-.005-.094-.16-.003-.004-.003-.004-.096-.159-.002-.004-.003-.005-.098-.157-.003-.004-.003-.005-.1-.156-.003-.004-.003-.005-.101-.154-.003-.005-.003-.004-.104-.154-.003-.004-.003-.005-.106-.152-.003-.005-.003-.004-.108-.151-.003-.004-.003-.005-.11-.15-.003-.004-.003-.004-.111-.15-.004-.003-.003-.005-.113-.147-.004-.004-.003-.005-.115-.146-.004-.004-.003-.004-.117-.145-.004-.004-.003-.004-.12-.144-.003-.004-.003-.004-.121-.142-.004-.004-.003-.004-.123-.141-.003-.004-.004-.004-.125-.14-.003-.004-.004-.004-.127-.138-.003-.004-.004-.004-.128-.136-.004-.004-.004-.004-.13-.135-.004-.004-.004-.004-.132-.134-.003-.004-.004-.003-.134-.133-.004-.003-.004-.004-.135-.13-.004-.004-.004-.004-.136-.128-.004-.004-.004-.004-.138-.126-.004-.004-.004-.003-.14-.125-.004-.004-.004-.003-.14-.123-.005-.004-.004-.003-.142-.121-.004-.004-.004-.003-.144-.12-.004-.003-.004-.003-.145-.117-.004-.004-.004-.003-.147-.115-.004-.004-.004-.003-.148-.113-.004-.003-.004-.004-.149-.111-.004-.003-.004-.004-.05-.036-.14-.083-.15-.055-.16-.027zM6.634 3.28l-.161.008-.157.037-.147.066-.111.074-.04.032-.005.003-.004.004-.145.117-.004.003-.004.004-.144.119-.004.003-.004.004-.142.12-.004.004-.004.004-.141.123-.004.003-.004.004-.14.125-.004.003-.004.004-.138.126-.004.004-.004.004-.136.128-.004.004-.004.004-.135.13-.004.004-.004.003-.134.133-.004.003-.004.004-.132.134-.003.004-.004.004-.13.135-.004.004-.004.004-.128.136-.004.004-.004.004-.126.138-.004.004-.003.004-.125.14-.004.004-.003.004-.123.14-.004.005-.003.004-.121.142-.004.004-.003.004-.12.144-.003.004-.003.004-.117.145-.004.004-.003.004-.115.146-.004.005-.003.004-.113.147-.003.005-.004.004-.111.149-.003.004-.004.004-.11.15-.002.005-.003.004-.108.151-.003.004-.003.005-.106.152-.003.005-.003.004-.104.154-.003.004-.003.005-.102.154-.003.005-.002.004-.1.156-.003.005-.003.004-.098.157-.003.005-.003.004-.096.159-.002.004-.003.005-.094.16-.003.004-.002.004-.092.16-.003.005-.003.005-.09.161-.002.005-.003.005-.088.162-.002.005-.003.004-.086.164-.002.005-.002.004-.084.165-.003.005-.002.004-.082.166-.002.004-.003.005-.08.167-.002.004-.002.005-.078.168-.002.004-.002.005-.045.1-.053.153-.023.16.007.16.037.157.065.148.092.132.114.114.134.09.148.064.157.035.161.006.16-.025.152-.054.14-.08.121-.106.1-.126.065-.118.043-.095.074-.16.075-.155.077-.157.08-.155.08-.152.083-.155.085-.152.086-.15.088-.149.091-.15.094-.15.094-.147.095-.145.099-.146.1-.144.1-.142.104-.14.104-.14.11-.142.107-.137.11-.136.114-.136.113-.134.117-.133.118-.132.117-.129.122-.13.124-.127.123-.126.127-.125.127-.122.128-.12.132-.122.13-.115.133-.117.135-.115.135-.111.136-.11.037-.03.117-.11.094-.132.068-.146.04-.156.01-.161-.02-.16-.05-.154-.076-.141-.102-.125-.123-.104-.14-.08-.153-.051-.16-.023zM16 3.286h-.005l-.148.001h-.01l-.147.003h-.011l-.147.005h-.011l-.146.007h-.011l-.146.009h-.011l-.146.01h-.005l-.005.001-.146.012h-.011l-.145.014h-.006l-.005.001-.05.006-.158.031-.15.06-.135.088-.117.111-.094.13-.069.147-.04.156-.01.16.019.16.049.154.076.142.102.125.123.105.14.08.152.051.16.023.134-.003.045-.005.135-.013.133-.01.136-.01.135-.007.137-.006.136-.004.136-.003h.274l.136.003.136.004.136.006.136.007.136.01.133.01.135.013.135.014.135.016.134.018.132.018.134.021.133.023.133.024.133.025.13.027.132.03.132.03.129.031.13.034.129.035.129.036.13.04.126.038.128.042.126.042.128.045.127.047.126.047.12.048.127.051.123.052.006.002.147.048.16.021.16-.009.157-.038.147-.067.131-.093.112-.116.089-.135.062-.149.033-.158.004-.16-.027-.16-.055-.151-.083-.139-.107-.12-.127-.099-.118-.063-.004-.001-.005-.003-.005-.002-.133-.056-.005-.002-.005-.002-.134-.054-.004-.002-.005-.002-.135-.053-.005-.002-.005-.002-.135-.051-.005-.002-.005-.002-.135-.05-.005-.001-.005-.002-.137-.048-.005-.001-.005-.002-.137-.046-.005-.002-.005-.002-.137-.044-.005-.002-.005-.001-.138-.043-.006-.002-.005-.001-.138-.042-.005-.001-.005-.002-.14-.04H19.4l-.005-.002-.14-.038-.005-.001-.005-.002-.14-.036-.005-.001-.005-.001-.141-.035-.005-.001-.005-.001-.142-.033-.005-.001-.005-.001-.142-.031-.005-.002h-.005l-.142-.03-.005-.001-.005-.001-.143-.028h-.005l-.005-.002-.143-.025-.006-.001-.005-.001-.143-.024-.005-.001-.006-.001-.143-.022-.006-.001h-.005l-.144-.022h-.005l-.006-.001-.144-.019h-.005l-.006-.001-.144-.017h-.006l-.005-.001-.145-.016h-.011l-.145-.014H17.1l-.005-.001-.146-.012h-.01l-.146-.01-.006-.001h-.005l-.146-.009h-.011l-.147-.006h-.01l-.147-.005h-.011l-.147-.003h-.011l-.147-.001H16zm-5.482 1.366l-.16.008-.157.037-.123.053-.06.032-.005.002-.004.003-.128.069-.004.002-.005.003-.126.07-.005.003-.004.002-.126.072-.005.003-.004.003-.125.073-.004.003-.005.003-.124.075-.004.003-.005.002-.123.077-.004.003-.005.003-.122.078-.004.003-.005.003-.121.08-.004.002-.005.003-.12.082-.005.003-.004.003-.12.083-.004.003-.004.003-.118.084-.005.003-.004.003-.118.086-.004.003-.004.003-.117.088-.004.003-.004.003-.116.089-.004.003-.004.004-.114.09-.005.003-.004.003-.113.092-.004.004-.004.003-.113.093-.004.004-.004.003-.111.095-.005.003-.004.004-.11.096-.004.004-.004.003-.11.098-.003.003-.004.004-.108.1-.004.003-.004.003-.107.101-.004.004-.004.003-.106.102-.004.004-.003.004-.105.103-.004.004-.004.004-.103.105-.004.004-.004.003-.102.106-.003.004-.004.004-.1.107-.004.004-.004.004-.099.108-.004.004-.003.004-.098.11-.003.003-.004.004-.096.11-.004.005-.003.004-.095.111-.003.004-.004.004-.093.113-.003.004-.004.004-.092.113-.003.004-.003.005-.09.114-.004.004-.003.004-.089.116-.003.004-.003.004-.088.117-.003.004-.003.004-.086.118-.003.004-.003.005-.084.118-.003.004-.003.005-.083.12-.003.003-.003.005-.082.12-.003.005-.002.004-.068.103-.076.142-.048.154-.018.16.011.161.041.156.07.146.095.13.117.11.136.086.15.06.158.03.162.002.158-.03.15-.057.138-.085.119-.109.082-.105.065-.099.075-.11.077-.113.077-.107.08-.11.08-.108.084-.108.083-.105.086-.106.086-.104.088-.104.089-.101.09-.102.093-.101.093-.099.094-.097.095-.096.098-.097.098-.095.099-.093.1-.092.103-.091.101-.089.104-.088.104-.086.106-.086.106-.083.106-.082.109-.082.108-.079.11-.078.11-.076.112-.076.112-.074.113-.072.113-.071.115-.07.115-.068.118-.067.117-.065.12-.065.054-.029.135-.088.116-.111.094-.132.068-.146.04-.156.009-.161-.02-.16-.05-.153-.078-.142-.102-.125-.123-.103-.141-.079-.153-.051-.16-.022zm13.91 2.116l-.162.008-.157.037-.147.066-.132.092-.113.116-.09.134-.063.148-.034.157-.005.162.025.159.055.152.082.138.086.103.09.09.094.098.092.099.093.1.091.103.089.101.088.104.086.104.086.106.083.105.083.108.08.108.081.11.077.107.077.112.075.111.075.114.072.113.071.113.07.114.068.118.067.115.065.118.064.117.062.117.061.121.059.119.059.122.056.121.054.12.055.125.051.123.051.125.048.123.048.127.047.126.044.125.043.128.042.129.039.126.038.13.022.076.058.15.085.137.11.119.129.096.145.07.155.043.16.013.161-.017.154-.046.144-.075.126-.1.106-.12.082-.14.055-.151.025-.16-.005-.16-.026-.132-.023-.082-.002-.005-.001-.005-.042-.139-.001-.005-.002-.005-.043-.138-.001-.005-.002-.005-.044-.137-.002-.005-.002-.005-.046-.137-.002-.005-.001-.005-.048-.137-.002-.005-.002-.005-.05-.135-.001-.005-.002-.005-.051-.135-.002-.005-.002-.005-.053-.135-.002-.005-.002-.005-.054-.133-.002-.005-.002-.005-.057-.133-.002-.005-.002-.005-.057-.132-.003-.005-.002-.005-.06-.132-.001-.005-.002-.004-.061-.132-.003-.004-.002-.005-.063-.13-.002-.005-.002-.005-.064-.13-.003-.004-.002-.005-.066-.129-.002-.004-.003-.005-.067-.128-.002-.005-.003-.004-.069-.128-.002-.004-.003-.005-.07-.126-.003-.005-.003-.004-.072-.126-.002-.005-.003-.004-.074-.125-.002-.004-.003-.005-.075-.124-.003-.004-.003-.005-.076-.123-.003-.004-.003-.005-.078-.122-.003-.004-.003-.005-.08-.121-.003-.004-.003-.005-.081-.12-.003-.005-.003-.004-.083-.12-.003-.004-.003-.004-.084-.118-.003-.005-.003-.004-.086-.118-.003-.004-.004-.004-.087-.117-.003-.004-.003-.004-.09-.116-.002-.004-.004-.004-.09-.114-.003-.005-.004-.004-.091-.113-.004-.004-.003-.004-.094-.113-.003-.004-.003-.004-.095-.111-.004-.004-.003-.004-.096-.11-.004-.005-.003-.004-.098-.11-.004-.003-.003-.004-.1-.108-.003-.004-.004-.004-.1-.107-.004-.004-.004-.004-.102-.106-.003-.003-.004-.004-.093-.095-.124-.103-.14-.08-.153-.05-.16-.023zM4.45 12.826l-.161.002-.158.032-.15.06-.135.088-.118.11-.094.131-.069.146-.035.129-.026.132v.005l-.002.005-.025.143-.001.005-.001.006-.024.143-.001.005-.001.006-.022.143-.001.006-.001.005-.02.144-.001.005-.001.005-.019.145v.005l-.001.006-.017.144v.006l-.001.005-.016.145v.011l-.014.145v.005l-.001.006-.012.146v.01l-.01.146-.001.006v.005l-.009.146v.011l-.007.146v.011l-.004.147v.011l-.003.147v.01l-.002.148v.01l.001.148v.01l.003.147v.011l.005.147v.01l.007.147v.011l.009.146v.011l.01.146v.01l.013.146v.011l.014.145v.005l.001.006.016.145v.011l.018.144v.006l.001.005.019.144v.006l.001.005.021.144v.005l.002.006.022.143v.006l.002.005.024.143v.005l.002.006.025.143.001.005.001.005.028.143.001.005.001.005.03.142v.005l.002.006.03.141.002.005.001.005.033.142v.005l.002.005.035.14v.006l.002.005.036.14.002.005.001.005.038.14.001.005.002.005.04.14v.005l.002.005.042.138.001.006.002.005.042.138.002.005.002.005.017.054.064.148.09.134.114.114.132.092.148.065.157.037.16.007.16-.023.153-.052.14-.08.123-.104.102-.125.076-.142.049-.153.02-.16-.011-.161-.031-.13-.017-.051-.039-.126-.038-.13-.037-.128-.035-.13-.033-.128-.033-.134-.03-.13-.029-.131-.026-.13-.026-.133-.024-.133-.023-.133-.02-.132-.02-.136-.017-.132-.016-.135-.014-.135-.012-.133-.012-.138-.009-.133-.007-.136-.006-.138-.004-.134-.003-.136v-.274l.003-.136.004-.134.006-.139.007-.136.01-.133.01-.138.013-.132.014-.135.016-.135.017-.132.02-.137.02-.13.023-.134.024-.133.024-.126.016-.16-.014-.161-.044-.155-.072-.145-.098-.128-.12-.108-.137-.084-.15-.057-.16-.029zm26.698 1.601l-.161.01-.157.04-.146.067-.131.093-.112.117-.088.135-.061.149-.033.157-.005.134.006.14.006.176.003.177.001.178-.001.177-.003.178-.006.177-.007.176-.01.177-.012.176-.015.176-.016.173-.018.175-.02.175-.024.174-.025.175-.026.17-.03.174-.03.173-.033.17-.036.172-.037.17-.04.17-.042.172-.043.168-.045.166-.048.169-.05.167-.052.168-.053.164-.056.166-.058.166-.06.16-.062.165-.062.158-.066.165-.068.16-.07.16-.07.158-.075.159-.074.155-.079.158-.08.158-.06.15-.03.158-.001.161.029.159.058.15.085.137.108.119.13.097.144.07.156.044.16.013.16-.017.155-.046.143-.074.127-.1.107-.12.07-.115.083-.164.003-.005.002-.004.082-.166.002-.005.003-.004.08-.167.002-.005.002-.004.078-.168.002-.005.002-.004.076-.169.002-.004.002-.005.074-.17.002-.004.002-.005.072-.17.002-.005.002-.005.07-.171.001-.005.002-.005.068-.172.002-.004.002-.005.065-.173.002-.005.002-.005.063-.173.002-.005.002-.005.06-.174.003-.005.001-.005.06-.175.001-.005.002-.005.057-.176.001-.005.002-.005.055-.177.001-.005.002-.005.052-.177.002-.005.001-.005.051-.178.001-.005.002-.005.048-.179.002-.005v-.005l.047-.179.001-.005.002-.005.044-.18v-.005l.002-.005.042-.18.001-.006.001-.005.04-.181.001-.005.001-.005.037-.182.002-.005v-.005l.036-.182v-.006l.002-.005.033-.182v-.006l.002-.005.03-.183.001-.005.001-.005.029-.184v-.005l.001-.006.027-.184v-.005l.001-.005.024-.185v-.005l.001-.005.022-.185v-.006l.001-.005.02-.185v-.006l.001-.005.017-.186v-.005l.001-.005.015-.187v-.005l.001-.005.013-.187v-.01l.01-.187.001-.006v-.005l.009-.187v-.011l.006-.187v-.011l.004-.188v-.011l.001-.188v-.01l-.001-.188v-.011l-.004-.188v-.011l-.006-.187v-.011l-.007-.145-.022-.16-.05-.152-.08-.141-.103-.124-.125-.102-.141-.077-.153-.05-.16-.02zM.938 15L.777 15l-.158.032-.15.06-.136.087-.117.11-.095.131-.068.146-.04.156-.012.133-.001.14v.01l.001.188v.011l.004.188v.011l.006.187v.011l.008.187v.011l.011.187v.005l.001.005.013.187v.01l.016.187v.01l.018.186v.011l.02.185.001.005v.006l.022.185.001.005v.005l.025.185v.005l.001.005.027.184v.006l.001.005.029.184v.005l.001.005.031.183.001.005.001.006.033.182.001.005.001.006.035.182.001.005.001.005.038.182v.005l.002.005.04.181v.005l.002.005.042.18.001.006.001.005.044.18.002.005v.005l.047.18.001.004.002.005.048.179.002.005.001.005.05.178.002.005.001.005.053.177.002.005.001.005.055.177.002.005.001.005.057.176.002.005.001.005.06.175.001.005.002.005.061.174.002.005.002.005.063.173.002.005.002.005.065.173.002.005.002.004.067.172.002.005.002.005.07.171.002.005.002.005.072.17.002.005.002.004.074.17.002.005.002.004.076.169.002.004.002.005.078.168.002.004.002.005.08.167.003.004.002.005.082.166.002.004.003.005.02.04.086.136.11.118.13.095.146.07.156.041.16.012.16-.019.155-.048.142-.075.126-.1.105-.123.08-.14.054-.152.024-.16-.006-.16-.036-.158-.051-.123-.018-.034-.078-.158L3.1 22.1l-.074-.16-.071-.157-.07-.16-.068-.16-.067-.165-.062-.158-.062-.164-.059-.161-.058-.166-.056-.166-.053-.164-.052-.168-.05-.167-.048-.17-.045-.165-.043-.168-.043-.172-.039-.17-.037-.17-.036-.172-.033-.17-.03-.173-.03-.174-.027-.17-.025-.175-.022-.174-.021-.175-.018-.175-.017-.173-.014-.176-.012-.176-.01-.177-.007-.176-.006-.177-.003-.178L1.73 16v-.134l-.013-.16-.044-.156-.072-.144-.097-.129-.12-.108-.137-.085-.15-.057L.938 15zm26.798 2.024l-.16.007-.157.038-.148.066-.132.092-.113.115-.09.134-.062.148-.03.127-.001.004-.023.134-.024.133-.026.133-.026.13-.03.132-.03.129-.032.134-.033.128-.035.13-.037.128-.038.13-.04.126-.04.128-.044.128-.044.126-.046.126-.048.126-.05.125-.05.125-.051.122-.054.123-.055.122-.056.12-.058.122-.06.12-.061.12-.063.119-.062.116-.067.119-.066.116-.069.115-.069.115-.07.113-.073.113-.074.112-.076.113-.077.112-.077.107-.08.11-.08.107-.085.11-.044.056-.088.135-.06.15-.033.158-.002.16.027.16.057.15.083.138.108.12.128.098.144.072.155.045.16.015.161-.016.155-.044.144-.073.128-.098.09-.099.05-.061.003-.004.003-.005.089-.115.003-.004.003-.005.088-.116.003-.004.003-.005.086-.117.003-.004.003-.005.084-.118.003-.004.003-.005.083-.12.003-.004.003-.004.081-.12.003-.005.003-.004.08-.121.003-.005.003-.004.078-.122.003-.005.003-.004.077-.123.002-.005.003-.004.075-.124.003-.005.003-.004.073-.125.003-.005.003-.004.072-.126.002-.004.003-.005.07-.126.003-.005.002-.005.07-.127.002-.004.002-.005.068-.128.002-.005.002-.004.066-.13.003-.004.002-.005.064-.13.002-.004.003-.005.062-.13.002-.005.003-.005.06-.13.003-.005.002-.005.06-.132.002-.005.002-.005.057-.132.003-.005.002-.005.056-.133.002-.005.002-.005.054-.134.002-.004.002-.005.053-.135.002-.005.002-.005.051-.135.002-.005.002-.005.05-.135.001-.005.002-.005.048-.137.001-.005.002-.005.046-.137.002-.005.002-.005.044-.137.002-.005.002-.005.042-.138.002-.005.001-.006.042-.138.001-.005.002-.005.04-.14V19.4l.002-.005.038-.14.001-.005.002-.005.036-.14.001-.005.001-.005.035-.141.001-.005.001-.005.033-.142.001-.005.001-.005.031-.141.001-.006.002-.005.029-.142v-.005l.002-.005.028-.143v-.005l.002-.005.025-.143.001-.006.001-.005.024-.143.001-.005.001-.006.001-.006.01-.161-.02-.16-.05-.154-.077-.141-.102-.125-.123-.104-.141-.079-.153-.051-.16-.022zM6.841 22.71l-.16.024-.152.053-.14.08-.122.105-.101.126-.076.142-.048.154-.018.16.011.161.041.156.07.146.077.109.04.048.003.004.003.004.095.111.003.004.004.004.096.11.004.005.003.004.098.109.003.004.004.004.1.108.003.004.003.004.101.107.004.004.003.004.102.105.004.004.004.004.103.105.004.004.004.003.105.104.003.004.004.003.106.102.004.004.004.004.107.1.004.004.004.004.108.099.004.003.004.004.11.098.003.003.004.004.11.096.004.003.005.004.11.095.005.003.004.004.113.093.004.003.004.004.113.091.004.004.005.003.114.09.004.004.004.003.116.089.004.003.004.003.117.088.004.003.004.003.118.086.004.003.005.003.118.084.004.003.005.003.119.083.004.003.005.003.12.081.005.003.004.003.121.08.005.003.004.003.122.078.005.003.004.003.123.076.005.003.004.003.124.075.005.003.004.003.125.073.004.003.005.002.126.073.004.002.005.003.126.07.005.003.004.002.128.07.004.002.005.002.128.067.005.003.004.002.13.066.004.002.005.003.13.064.004.002.005.003.13.062.005.002.004.003.132.06.004.003.005.002.132.06.005.002.005.002.132.057.005.002.005.002.133.057.005.002.005.002.133.054.005.002.005.002.13.05.154.045.16.016.16-.015.156-.045.144-.072.128-.098.108-.12.083-.138.057-.15.028-.16-.003-.16-.032-.159-.061-.149-.088-.135-.11-.117-.132-.094-.12-.058-.124-.049-.126-.051-.122-.051-.122-.054-.12-.054-.126-.058-.119-.057-.12-.06-.12-.06-.118-.063-.117-.064-.119-.066-.116-.066-.115-.068-.115-.07-.113-.07-.115-.074-.112-.074-.11-.075-.11-.076-.112-.08-.11-.08-.109-.081-.106-.082-.104-.082-.106-.086-.105-.087-.101-.086-.105-.091-.1-.09-.1-.091-.1-.094-.097-.094-.1-.098-.093-.095-.096-.1-.093-.098-.092-.101-.089-.1-.09-.102-.088-.104-.036-.043-.114-.114-.133-.091-.148-.065-.157-.036-.161-.006zm15.063 2.701l-.16.014-.156.044-.12.057-.06.034-.12.066-.117.064-.118.062-.12.061-.12.06-.118.057-.126.058-.12.054-.122.054-.122.05-.126.052-.125.05-.124.046-.127.047-.125.044-.129.043-.126.04-.13.042-.128.038-.127.035-.13.036-.131.034-.129.031-.132.03-.13.03-.135.027-.133.026-.13.023-.13.022-.137.021-.132.02-.134.017-.132.015-.138.015-.135.013-.133.01-.138.01-.136.007-.134.006-.136.004-.14.003-.16.018-.155.047-.142.076-.127.1-.105.122-.08.14-.054.151-.025.16.006.16.035.158.064.148.09.134.114.114.133.092.147.065.157.036.134.008.145-.002h.011l.147-.005h.01l.147-.007h.011l.146-.009h.011l.146-.01h.005l.005-.001.146-.012h.011l.145-.014h.005l.006-.001.145-.016h.011l.144-.018h.006l.005-.001.144-.02h.011l.144-.021.005-.001h.006l.143-.023.006-.001h.005l.143-.025h.005l.006-.002.143-.026h.005l.005-.002.143-.027.005-.001.005-.001.142-.03h.005l.005-.002.142-.03.005-.002.005-.001.142-.033.005-.001.005-.001.14-.035.006-.001.005-.001.14-.037h.005l.005-.002.14-.038.005-.002h.005l.14-.04.005-.002.005-.001.138-.042.005-.001.006-.002.138-.043.005-.001.005-.002.137-.044.005-.002.005-.002.137-.046.005-.002.005-.001.137-.048.005-.002.005-.002.135-.05.005-.001.005-.002.135-.051.005-.002.005-.002.135-.053.005-.002.004-.002.134-.054.005-.002.005-.002.133-.057.005-.002.005-.002.132-.057.005-.003.005-.002.132-.06.005-.001.004-.002.131-.061.005-.003.005-.002.13-.062.005-.003.005-.002.13-.064.004-.003.005-.002.128-.066.005-.002.005-.003.128-.067.005-.002.004-.003.127-.069.005-.002.005-.003.126-.07.005-.003.004-.003.065-.037.132-.093.112-.115.089-.135.062-.149.034-.157.003-.161-.026-.16-.055-.15-.082-.14-.107-.12-.127-.1-.144-.073-.154-.046-.16-.016zM6.33 26.818l-.16.023-.152.053-.14.08-.122.105-.101.126-.076.142-.048.154-.02.16.012.161.041.156.07.146.094.13.096.093.032.026.004.003.004.004.145.117.004.003.004.004.146.115.005.003.004.004.147.113.005.003.004.004.149.111.004.003.004.003.15.11.005.003.004.003.151.108.004.003.005.003.152.106.005.003.004.003.154.104.004.003.005.003.154.102.005.002.004.003.156.1.005.003.004.003.157.098.005.003.004.002.159.096.004.003.005.003.16.094.004.003.004.002.16.092.005.003.005.002.161.09.005.003.005.002.162.088.005.003.004.002.164.086.005.003.004.002.165.084.005.003.004.002.166.082.004.002.005.003.167.08.004.002.005.002.168.078.004.002.005.002.168.076.005.002.005.002.17.074.004.002.005.002.17.072.005.002.005.002.17.07.006.002.005.001.171.068.005.002.005.002.173.065.005.002.005.002.173.063.005.002.005.002.174.06.005.003.005.001.175.06.005.001.005.002.176.057.005.001.005.002.176.055.006.001.005.002.177.052.005.002.005.001.178.05.005.002.005.002.178.048.006.001.005.002.179.046.005.001.005.002.18.044h.005l.005.002.18.042.006.001.005.001.159.035.16.02.16-.01.157-.04.146-.069.13-.094.112-.117.087-.136.06-.149.033-.158.002-.161-.028-.159-.057-.15-.084-.138-.108-.12-.128-.098-.144-.072-.128-.039-.154-.033-.168-.04-.171-.041-.17-.044-.168-.046-.167-.047-.168-.05-.165-.051-.166-.054-.166-.056-.163-.057-.165-.06-.161-.062-.164-.064-.16-.065-.16-.068-.162-.07-.157-.07-.157-.074-.157-.075-.156-.077-.153-.079-.156-.082-.153-.082-.154-.086-.15-.086-.152-.09-.148-.09-.147-.092-.149-.095-.145-.095-.144-.098-.145-.1-.143-.102-.14-.103-.14-.104-.14-.108-.139-.11-.136-.11-.027-.022-.133-.091-.148-.065-.157-.036-.161-.006zm19.215.087l-.16.01-.157.039-.146.067-.11.076-.064.051-.139.11-.14.108-.14.104-.14.103-.143.101-.145.101-.144.098-.145.095-.149.095-.148.093-.147.089-.152.09-.15.086-.154.086-.153.082-.156.082-.153.079-.156.077-.157.075-.158.073-.157.071-.16.07-.16.068-.161.065-.164.064-.161.061-.165.06-.163.058-.166.056-.166.054-.166.051-.167.05-.167.047-.17.046-.168.044-.171.042-.168.039-.17.037-.11.023-.154.047-.143.075-.126.1-.106.122-.081.139-.054.152-.025.16.006.16.035.158.063.148.09.133.114.115.132.092.148.065.157.037.16.007.133-.016.115-.024.005-.001.005-.001.181-.04h.005l.005-.002.18-.042.006-.001.005-.001.18-.044.005-.002.005-.001.18-.046.004-.002h.005l.179-.05h.005l.005-.002.178-.05.005-.002.005-.002.177-.052.005-.002.005-.001.177-.055.005-.002.005-.001.176-.057.005-.002.005-.002.175-.059.005-.001.005-.002.174-.061.005-.002.005-.002.173-.063.005-.002.005-.002.173-.065.004-.002.005-.002.172-.068.005-.002.005-.002.171-.07.005-.001.005-.002.17-.072.005-.002.004-.002.17-.074.005-.002.004-.002.169-.076.004-.002.005-.002.168-.078.004-.002.005-.003.167-.08.004-.002.005-.002.166-.082.004-.002.005-.003.165-.084.004-.002.005-.003.163-.086.005-.002.005-.003.162-.088.005-.002.005-.003.161-.09.005-.002.004-.003.16-.092.005-.003.005-.002.16-.094.004-.003.004-.003.158-.096.005-.002.004-.003.158-.098.004-.003.005-.003.156-.1.004-.003.004-.003.155-.101.005-.003.004-.003.154-.104.004-.003.004-.003.153-.106.004-.003.005-.003.151-.108.004-.003.005-.003.15-.11.004-.003.004-.003.149-.112.004-.003.004-.003.148-.113.004-.004.004-.003.147-.115.004-.004.004-.003.068-.055.116-.113.092-.132.066-.147.038-.157.008-.16-.022-.16-.05-.153-.08-.14-.103-.125-.124-.102-.142-.077-.153-.05-.16-.02z",
  opacity: ".98"
}));
function _extends$J() {
  _extends$J = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$J.apply(this, arguments);
}
var IntermediateEventCatchNonInterruptingSignalIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$J({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M16.012 8.816L9.21 21.026h13.606l-6.803-12.21zm0 1.776l5.332 9.57H10.681l5.331-9.57zm0-10.281c-1.448.02-2.93.157-4.302.628-.852.447-.255 1.863.66 1.574 2.255-.608 4.648-.607 6.922-.108.934.075 1.228-1.376.338-1.67C18.451.44 17.227.317 16.012.311zm9.012 2.934c-.913-.104-1.272 1.258-.454 1.648 1.834 1.36 3.293 3.185 4.31 5.22.526.776 1.842.098 1.515-.78a15.522 15.522 0 00-5.06-6.006c-.1-.044-.203-.07-.31-.082zM6.65 3.59c-.762.089-1.24.809-1.805 1.267C3.38 6.295 2.163 8.007 1.37 9.905c-.266.898 1.094 1.484 1.564.675a14.825 14.825 0 014.327-5.56c.476-.515.09-1.419-.612-1.431zm9.362.007c-.698.066-1.689-.16-2.033.635-.282.733.535 1.358 1.217 1.125 1.806-.147 3.63.203 5.293.907.902.255 1.472-1.112.656-1.573-1.6-.735-3.374-1.089-5.133-1.094zm-5.479 1.365c-.835.15-1.517.76-2.21 1.226-1.203.94-2.318 2.061-3.057 3.402-.33.904 1.063 1.552 1.547.723 1.045-1.656 2.596-2.925 4.285-3.873.545-.499.171-1.463-.565-1.478zm13.903 2.115c-.875-.07-1.22 1.173-.501 1.627 1.325 1.34 2.188 3.062 2.748 4.84.468.84 1.869.21 1.557-.699-.604-2.118-1.751-4.097-3.351-5.615a.93.93 0 00-.453-.153zM4.467 13.132c-.822-.07-.996.826-1.046 1.455-.256 1.93-.094 3.933.562 5.769.406.844 1.807.365 1.612-.551a11.498 11.498 0 01-.334-5.808.874.874 0 00-.794-.865zm26.687 1.6c-.746-.037-1.014.785-.879 1.395.043 2.393-.57 4.771-1.66 6.894-.31.884 1.02 1.536 1.53.75a15.632 15.632 0 001.821-8.372.876.876 0 00-.812-.667zm-30.197.571c-.782-.073-1.044.775-.933 1.404.068 2.414.661 4.833 1.809 6.962.534.77 1.842.076 1.505-.798a14.833 14.833 0 01-1.603-6.861.876.876 0 00-.778-.707zm26.787 2.024c-.777-.048-.952.797-1.021 1.392-.354 1.692-1.202 3.231-2.216 4.608-.407.872.925 1.638 1.48.852 1.361-1.733 2.296-3.827 2.582-6.017a.874.874 0 00-.825-.835zM6.857 23.012c-.808.018-1.082 1.122-.47 1.59 1.393 1.607 3.187 2.886 5.194 3.599.91.222 1.43-1.165.598-1.596a11.495 11.495 0 01-4.723-3.396.899.899 0 00-.599-.197zm15.057 2.7c-.81.194-1.504.76-2.325.972-1.203.458-2.5.536-3.758.664-.869.307-.573 1.728.346 1.663 2.201-.034 4.412-.626 6.293-1.778.604-.495.227-1.532-.556-1.521zM6.346 27.118c-.833.008-1.11 1.218-.395 1.617 1.986 1.602 4.358 2.749 6.868 3.226.933.076 1.227-1.376.338-1.67a14.838 14.838 0 01-6.345-3.066.929.929 0 00-.466-.107zm19.208.087c-.766.09-1.241.841-1.922 1.158-1.516.991-3.251 1.58-4.996 2.005-.872.405-.346 1.849.584 1.604 2.543-.526 4.98-1.66 6.963-3.344.47-.52.072-1.42-.63-1.423z"
}));
function _extends$I() {
  _extends$I = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$I.apply(this, arguments);
}
var IntermediateEventCatchNonInterruptingTimerIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$I({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.998 8.406c-3.018-.041-5.92 1.926-7.031 4.727-1.138 2.695-.51 6.012 1.537 8.103 1.99 2.141 5.268 2.93 8.014 1.927 2.878-.98 4.992-3.827 5.068-6.87.153-2.957-1.624-5.88-4.3-7.137a7.552 7.552 0 00-3.288-.75zm0 1.384c2.759-.052 5.373 1.973 6.015 4.655.704 2.578-.482 5.517-2.791 6.867-2.358 1.48-5.682 1.086-7.618-.918-2.043-1.971-2.407-5.381-.84-7.745 1.11-1.763 3.15-2.88 5.234-2.86zm1.962 1.765l-2.074 3.762c-.64.068-.793 1.04-.202 1.3.39.27.696-.18 1.052-.165h3.17v-.865h-3.182l1.993-3.615c-.252-.14-.505-.278-.757-.417zm-1.965-8.268h-.158l-.147.003h-.011l-.147.005h-.011l-.146.007h-.011l-.146.009h-.011l-.146.01h-.005l-.005.001-.146.012h-.011l-.145.014h-.006l-.005.001-.05.006-.158.031-.15.06-.135.088-.117.111-.094.13-.069.147-.04.156-.01.16.019.16.049.154.076.142.102.125.123.105.14.08.152.051.16.023.134-.003.045-.005.135-.013.133-.01.136-.01.135-.007.137-.006.136-.004.136-.003h.274l.136.003.136.004.136.006.136.007.136.01.133.01.135.013.135.014.135.016.134.018.132.018.134.021.133.023.133.024.133.025.13.027.132.03.132.03.129.031.13.034.129.035.129.036.13.04.126.038.128.042.126.042.128.045.127.047.126.048.12.047.127.051.123.052.006.002.147.048.16.021.16-.009.157-.038.147-.067.131-.093.112-.116.089-.135.062-.149.033-.158.004-.16-.027-.16-.055-.151-.083-.138-.107-.121-.127-.099-.118-.063-.004-.001-.005-.003-.005-.002-.133-.056-.005-.002-.005-.002-.134-.054-.004-.002-.005-.002-.135-.053-.005-.002-.005-.002-.135-.051-.005-.002-.005-.002-.135-.05-.005-.001-.005-.002-.137-.048-.005-.001-.005-.002-.137-.046-.005-.002-.005-.002-.137-.044-.005-.002-.005-.001-.138-.043-.005-.002-.006-.001-.138-.042-.005-.001-.005-.002-.14-.04H19.4l-.005-.002-.14-.038-.005-.001-.005-.002-.14-.036-.005-.001-.005-.001-.141-.035-.005-.001-.005-.001-.142-.033-.005-.001-.005-.001-.141-.031-.006-.002h-.005l-.142-.03-.005-.001-.005-.001-.143-.028h-.005l-.005-.001-.143-.026-.006-.001-.005-.001-.143-.024-.005-.001-.006-.001-.143-.022-.006-.001h-.005l-.144-.022h-.005l-.006-.001-.144-.019h-.005l-.006-.001-.144-.017h-.006l-.005-.001-.145-.016h-.011l-.145-.014H17.1l-.005-.001-.146-.012h-.01l-.146-.01-.006-.001h-.005l-.146-.009h-.011l-.147-.006h-.01l-.147-.005h-.011l-.147-.003h-.01l-.148-.001h-.01zM10.357 4.66l-.156.037-.123.053-.06.032-.005.002-.004.003-.128.069-.004.002-.005.003-.126.07-.005.003-.004.002-.126.072-.005.003-.004.003-.125.073-.004.003-.005.003-.124.075-.004.003-.005.002-.123.077-.004.003-.005.003-.122.078-.004.003-.005.003-.121.08-.004.002-.005.003-.12.082-.005.003-.004.003-.12.083-.004.003-.004.003-.118.084-.005.003-.004.003-.118.086-.004.003-.004.003-.117.088-.004.003-.004.003-.116.089-.004.003-.004.004-.114.09-.005.003-.004.003-.113.092-.004.004-.004.003-.113.093-.004.004-.004.003-.111.095-.004.003-.005.004-.11.096-.004.004-.004.003-.109.098-.004.003-.004.004-.108.1-.004.003-.004.003-.107.101-.004.004-.004.003-.106.102-.003.004-.004.004-.105.103-.004.004-.004.004-.103.105-.004.004-.004.003-.102.106-.003.004-.004.004-.1.107-.004.004-.004.004-.099.108-.004.004-.003.004-.098.11-.003.003-.004.004-.096.11-.004.005-.003.004-.095.111-.003.004-.004.004-.093.113-.003.004-.004.004-.092.113-.003.004-.003.005-.09.114-.004.004-.003.004-.089.116-.003.004-.003.004-.088.117-.003.004-.003.005-.086.117-.003.004-.003.005-.084.118-.003.004-.003.005-.083.12-.003.003-.003.005-.082.12-.003.005-.002.004-.068.103-.076.142-.048.154-.018.16.011.161.041.156.07.146.095.13.117.11.136.086.15.06.158.03.162.002.158-.029.15-.058.138-.085.119-.108.082-.106.065-.099.075-.11.077-.113.077-.107.08-.11.08-.108.084-.108.083-.105.086-.106.086-.104.088-.104.089-.101.09-.102.093-.101.093-.099.094-.097.095-.096.098-.097.098-.095.099-.093.1-.092.103-.091.101-.089.104-.088.104-.086.106-.086.106-.083.106-.082.109-.082.108-.079.11-.078.11-.076.112-.076.112-.074.113-.072.113-.071.115-.07.115-.068.118-.067.117-.065.12-.065.054-.029.135-.088.116-.111.094-.132.068-.146.04-.156.009-.161-.02-.16-.05-.153-.078-.142-.102-.125-.123-.103-.141-.079-.153-.051-.16-.022-.16.008zm13.91 2.116l-.158.037-.147.066-.132.092-.113.116-.09.134-.063.148-.034.157-.005.162.026.159.054.152.082.139.086.102.09.09.094.098.093.099.092.1.091.103.089.101.088.104.086.104.086.106.083.105.083.108.08.108.081.11.077.107.077.112.075.111.075.114.072.113.071.113.07.115.068.117.067.115.065.118.064.117.062.118.061.12.059.119.059.122.056.121.054.12.055.125.051.123.051.125.048.123.049.127.046.126.044.125.043.128.042.129.039.126.038.13.022.076.058.15.086.137.109.119.129.096.145.07.155.043.16.013.161-.017.155-.046.143-.074.126-.1.106-.122.082-.138.055-.152.025-.16-.005-.16-.026-.132-.023-.082-.002-.005-.001-.005-.042-.139-.001-.005-.002-.005-.043-.138-.001-.005-.002-.005-.044-.137-.002-.005-.002-.005-.046-.137-.002-.005-.001-.005-.048-.137-.002-.005-.002-.005-.05-.135-.001-.005-.002-.005-.051-.135-.002-.005-.002-.005-.053-.135-.002-.005-.002-.005-.054-.133-.002-.005-.002-.005-.057-.133-.002-.005-.002-.005-.057-.132-.003-.005-.002-.005-.059-.132-.002-.005-.002-.004-.061-.132-.003-.004-.002-.005-.062-.13-.003-.005-.002-.005-.064-.13-.003-.004-.002-.005-.066-.129-.002-.004-.003-.005-.067-.128-.002-.005-.003-.004-.069-.128-.002-.004-.003-.005-.07-.126-.003-.005-.003-.004-.072-.126-.002-.005-.003-.004-.073-.125-.003-.004-.003-.005-.075-.124-.003-.004-.003-.005-.076-.123-.003-.004-.003-.005-.078-.122-.003-.004-.003-.005-.08-.121-.003-.004-.003-.005-.08-.12-.004-.005-.003-.004-.083-.12-.003-.004-.003-.004-.084-.118-.003-.005-.003-.004-.086-.117-.003-.005-.003-.004-.088-.117-.003-.004-.003-.004-.09-.116-.002-.004-.004-.004-.09-.114-.003-.005-.004-.004-.091-.113-.004-.004-.003-.004-.093-.113-.004-.004-.003-.004-.095-.111-.004-.004-.003-.004-.096-.11-.004-.005-.003-.004-.098-.109-.004-.004-.003-.004-.1-.108-.003-.004-.004-.004-.1-.107-.004-.004-.004-.004-.102-.106-.003-.003-.004-.004-.093-.095-.124-.103-.14-.08-.153-.05-.16-.023-.16.008zM4.288 12.828l-.158.032-.15.06-.135.088-.117.11-.095.131-.069.146-.035.129-.026.132v.005l-.002.005-.025.143-.001.005-.001.006-.024.143-.001.005-.001.006-.022.143-.001.006-.001.005-.02.144-.001.005-.001.006-.019.144v.005l-.001.006-.017.144v.006l-.001.005-.016.145v.011l-.014.145v.006l-.001.005-.012.146v.01l-.01.146-.001.006v.005l-.009.146v.011l-.007.146v.011l-.004.147v.011l-.003.147v.01l-.002.148v.01l.001.148v.01l.003.147v.011l.005.147v.01l.007.147v.011l.009.146v.011l.01.146v.01l.013.146v.011l.014.145v.005l.001.006.016.145v.011l.018.144v.006l.001.005.019.144v.006l.001.005.021.144v.005l.002.006.022.143v.006l.002.005.024.143v.005l.002.006.025.143.001.005.001.005.028.143.001.005.001.005.03.142v.005l.002.006.03.141.002.005.001.006.033.14v.006l.002.005.035.14v.006l.002.005.036.14.002.005.001.005.038.14.001.005.002.005.04.14v.005l.002.005.042.138.001.006.002.005.042.138.002.005.002.005.017.054.064.148.09.134.114.114.132.092.148.065.157.037.16.007.16-.023.153-.052.14-.08.123-.103.102-.126.076-.142.049-.153.02-.16-.01-.161-.032-.13-.017-.051-.039-.126-.038-.13-.037-.128-.035-.13-.033-.128-.033-.134-.03-.13-.029-.131-.026-.13-.026-.132-.024-.134-.023-.133-.02-.132-.02-.136-.017-.132-.016-.135-.014-.135-.012-.133-.012-.138-.009-.133-.007-.136-.006-.138-.004-.134-.003-.136v-.274l.003-.136.004-.134.006-.139.007-.136.01-.132.01-.139.013-.132.014-.135.016-.135.017-.132.02-.137.02-.13.023-.134.024-.133.024-.126.016-.16-.014-.161-.044-.155-.072-.145-.098-.128-.12-.108-.137-.084-.15-.057-.16-.029-.16.002zm23.286 4.202l-.156.038-.148.066-.132.092-.113.115-.09.134-.062.148-.03.127-.001.004-.023.134-.024.134-.026.132-.026.13-.03.132-.03.129-.032.134-.033.128-.035.13-.037.128-.038.13-.04.126-.04.128-.044.128-.044.126-.046.126-.048.126-.05.125-.05.125-.051.122-.054.123-.055.122-.056.12-.058.122-.06.12-.061.12-.062.119-.063.116-.067.119-.066.116-.068.115-.07.115-.07.113-.073.113-.074.112-.076.113-.077.112-.077.107-.08.11-.08.108-.085.109-.044.056-.088.135-.06.15-.033.158-.002.16.027.16.057.15.083.138.108.12.128.098.144.072.155.045.16.015.161-.016.155-.044.144-.073.128-.098.09-.099.05-.061.003-.004.003-.005.089-.115.003-.004.003-.005.088-.116.003-.004.003-.005.086-.117.003-.004.003-.005.084-.118.003-.004.003-.005.083-.12.003-.004.003-.004.082-.12.003-.005.002-.004.08-.121.003-.005.003-.004.078-.122.003-.005.003-.004.077-.123.002-.005.003-.004.075-.124.003-.005.003-.004.073-.125.003-.004.003-.005.072-.126.002-.004.003-.005.07-.126.003-.005.002-.005.07-.127.002-.004.002-.005.068-.128.002-.005.002-.004.066-.13.003-.004.002-.005.064-.13.002-.004.003-.005.062-.13.003-.005.002-.005.06-.13.003-.005.002-.005.06-.132.002-.005.002-.005.057-.132.003-.005.002-.005.056-.133.002-.005.002-.005.054-.134.002-.004.002-.005.053-.135.002-.005.002-.005.051-.135.002-.005.002-.005.05-.135.001-.005.002-.005.048-.137.001-.005.002-.005.046-.137.002-.005.002-.005.044-.137.002-.005.002-.005.042-.138.002-.005.002-.006.04-.138.002-.005.002-.005.04-.14V19.4l.002-.005.038-.14.001-.005.002-.005.036-.14.001-.005.001-.005.035-.141.001-.005.001-.005.033-.141.001-.006.001-.005.031-.141.002-.006v-.005l.03-.142.001-.005.001-.005.028-.143v-.005l.002-.005.025-.143.001-.006.001-.005.024-.143.001-.005.001-.006.001-.006.01-.161-.02-.16-.05-.154-.077-.141-.102-.125-.123-.104-.141-.079-.153-.051-.16-.022-.16.007zM6.681 22.734l-.152.053-.14.08-.122.105-.101.126-.076.142-.048.154-.018.16.011.161.041.156.07.146.077.11.04.047.003.004.003.004.095.111.003.004.004.004.096.11.004.005.003.004.098.109.003.004.004.004.1.108.003.004.003.004.101.107.004.004.003.004.102.106.004.003.004.004.103.105.004.004.004.004.105.103.004.004.003.003.106.102.004.004.004.004.107.1.004.004.004.004.108.099.004.003.004.004.11.098.003.003.004.004.11.096.005.004.004.003.11.095.005.003.004.004.113.093.004.003.004.004.113.091.004.004.005.003.114.09.004.004.004.003.116.089.004.003.004.003.117.088.004.003.004.003.118.086.004.003.005.003.118.084.004.003.005.003.119.083.004.003.005.003.12.081.005.003.004.003.121.08.005.003.004.003.122.078.005.003.004.003.123.076.005.003.004.003.124.075.005.003.004.003.125.073.004.003.005.003.126.072.004.002.005.003.126.07.005.003.004.002.128.07.004.002.005.002.128.068.005.002.004.002.13.066.004.003.005.002.13.064.004.002.005.003.13.062.005.002.004.003.132.06.004.003.005.002.132.06.005.002.005.002.132.057.005.002.005.003.133.056.005.002.005.002.133.054.005.002.005.002.13.05.154.045.16.016.161-.015.155-.045.144-.072.128-.098.108-.12.083-.138.057-.15.028-.16-.003-.16-.032-.158-.061-.15-.088-.135-.11-.117-.132-.094-.12-.058-.124-.049-.126-.051-.122-.051-.122-.054-.12-.054-.126-.058-.119-.057-.12-.06-.12-.06-.118-.063-.117-.064-.119-.066-.116-.066-.115-.068-.115-.07-.113-.07-.115-.074-.112-.074-.11-.075-.11-.076-.112-.079-.11-.08-.109-.082-.106-.082-.104-.082-.106-.086-.105-.087-.101-.086-.105-.091-.1-.09-.1-.091-.1-.094-.097-.094-.1-.098-.093-.095-.096-.1-.093-.098-.092-.101-.089-.1-.09-.102-.088-.104-.036-.043-.114-.114-.133-.091-.148-.065-.157-.036-.161-.006-.16.024zm15.063 2.691l-.156.044-.12.057-.06.034-.12.066-.116.064-.119.062-.12.061-.12.06-.118.057-.126.058-.12.054-.122.054-.122.05-.126.052-.125.05-.124.046-.127.047-.125.044-.129.043-.126.04-.13.042-.128.038-.127.036-.13.035-.131.034-.129.031-.132.03-.13.03-.135.027-.133.026-.13.023-.13.022-.137.021-.132.02-.134.017-.132.015-.138.015-.135.013-.133.01-.138.01-.136.007-.134.006-.136.004-.14.003-.16.018-.155.047-.142.076-.127.1-.105.122-.08.14-.054.151-.025.16.006.16.035.158.064.148.09.134.114.114.133.092.147.065.157.036.134.008.145-.002h.011l.147-.005h.01l.147-.007h.011l.146-.009h.011l.146-.01h.005l.005-.001.146-.012h.011l.145-.014h.005l.006-.001.145-.016h.011l.144-.018h.006l.005-.001.144-.02h.011l.144-.021h.005l.006-.002.143-.022h.006l.005-.002.143-.024h.005l.006-.002.143-.026h.005l.005-.002.143-.027.005-.001.005-.001.142-.03h.005l.005-.002.142-.03.005-.002.005-.001.142-.033.005-.001.005-.001.14-.035.006-.001.005-.001.14-.036.005-.002.005-.001.14-.038.005-.001.005-.002.14-.04h.005l.005-.002.138-.042.005-.001.006-.002.138-.043.005-.001.005-.002.137-.044.005-.002.005-.002.137-.046.005-.002.005-.001.137-.048.005-.002.005-.002.135-.05.005-.001.005-.002.135-.051.005-.002.005-.002.135-.053.005-.002.004-.002.134-.054.005-.002.005-.002.133-.056.005-.003.005-.002.132-.057.005-.002.005-.003.132-.059.005-.002.004-.002.131-.061.005-.003.005-.002.13-.062.005-.003.005-.002.13-.064.004-.002.005-.003.129-.066.004-.002.005-.003.128-.067.005-.002.004-.003.127-.069.005-.002.005-.003.126-.07.005-.003.004-.002.065-.038.132-.093.112-.115.089-.135.062-.149.034-.157.004-.161-.027-.16-.055-.15-.082-.14-.107-.12-.127-.1-.144-.073-.154-.045-.16-.017-.161.014zM15.994 0l-.187.001h-.011l-.188.004h-.011l-.187.006h-.011l-.187.008h-.005L15.2.02l-.187.01h-.005l-.005.001-.187.013h-.01L14.62.06h-.01l-.186.018h-.011l-.185.02-.005.001h-.006l-.185.022-.005.001h-.005l-.185.025h-.005l-.005.001-.184.027h-.006l-.005.001-.184.029h-.005l-.005.001-.183.031-.005.001-.006.001-.182.033-.006.001-.005.001-.182.035-.005.001-.005.001-.182.038h-.005l-.005.002-.181.04h-.005l-.005.002-.18.042-.006.001-.005.001-.18.044-.005.002h-.005l-.17.045-.152.054-.139.082-.121.106-.1.127-.074.143-.046.155-.017.16.013.16.043.156.07.145.097.13.119.108.137.085.15.058.159.03.16-.001.133-.023.165-.043.168-.041.171-.04.171-.037.172-.036.17-.033.173-.03.17-.03.177-.027.171-.025.175-.022.175-.02.175-.02.176-.016.175-.014.177-.012.176-.01.177-.007.174-.006.177-.003L16 1.73h.177l.178.004.174.006.177.007.176.01.177.012.175.014.176.017.175.018.175.02.175.023.171.025.177.027.17.03.173.03.17.033.171.036.154.033.16.02.161-.01.156-.04.146-.069.131-.094.111-.117.088-.135.06-.15.032-.158.002-.16-.027-.16-.057-.15L20 .714l-.108-.12-.128-.097-.144-.073-.129-.038-.158-.035-.005-.001-.005-.001L19.14.31h-.005l-.005-.002-.182-.035h-.006l-.005-.002-.182-.033h-.006l-.005-.002-.183-.03-.005-.001-.005-.001-.184-.029h-.005l-.006-.001-.184-.027h-.005l-.005-.001-.185-.024h-.005L17.968.12 17.783.1l-.006-.001h-.005l-.185-.02h-.006l-.005-.001L17.39.06 17.385.06h-.005l-.187-.015h-.005l-.005-.001-.187-.013h-.01L16.799.02h-.011L16.6.01h-.011l-.187-.006h-.011L16.204 0h-.011L16.005 0h-.01zm8.86 2.939l-.157.033-.15.062-.134.09-.116.111-.093.132-.067.147-.038.156-.01.161.022.16.05.153.078.141.103.124.102.087.045.034.142.106.137.105.14.11.136.11.135.112.134.115.134.117.13.115.132.122.128.12.127.122.127.125.123.126.124.128.121.13.118.128.118.132.117.133.113.134.113.136.11.136.109.137.109.142.104.14.103.14.101.142.1.144.099.146.095.145.094.147.093.15.092.15.087.149.087.15.085.152.083.155.08.152.08.155.04.081.084.138.11.119.128.096.145.072.155.043.16.013.161-.016.155-.046.143-.074.127-.099.106-.12.083-.14.055-.151.026-.16-.004-.16-.034-.158-.05-.124-.042-.085-.002-.004-.003-.005-.084-.165-.002-.004-.003-.005-.086-.164-.002-.004-.003-.005-.088-.162-.002-.005-.003-.005-.09-.161-.002-.005-.003-.004-.092-.16-.002-.005-.003-.005-.094-.16-.003-.004-.003-.004-.096-.159-.002-.004-.003-.005-.098-.157-.003-.004-.003-.005-.1-.156-.003-.004-.002-.005-.102-.154-.003-.005-.003-.004-.104-.154-.003-.004-.003-.005-.106-.152-.003-.004-.003-.005-.108-.151-.003-.004-.003-.005-.11-.15-.003-.004-.003-.004-.111-.15-.004-.003-.003-.005-.113-.147-.004-.004-.003-.005-.115-.146-.004-.004-.003-.004-.117-.145-.004-.004-.003-.004-.12-.144-.003-.004-.003-.004-.121-.142-.003-.004-.004-.004-.123-.141-.003-.004-.004-.004-.125-.14-.003-.004-.004-.004-.127-.138-.003-.004-.004-.004-.128-.136-.004-.004-.004-.004-.13-.135-.004-.004-.003-.004-.133-.134-.003-.004-.004-.003-.134-.133-.004-.003-.004-.004-.135-.13-.004-.004-.004-.004-.136-.128-.004-.004-.004-.004-.138-.126-.004-.004-.004-.003-.14-.125-.004-.004-.004-.003-.14-.123-.005-.004-.004-.003-.142-.121-.004-.004-.004-.003-.144-.12-.004-.003-.004-.003-.145-.117-.004-.004-.004-.003-.147-.115-.004-.004-.004-.003-.148-.113-.004-.003-.004-.004-.149-.111-.004-.003-.004-.004-.05-.036-.14-.083-.15-.055-.16-.027-.16.004zm-18.381.348l-.157.037-.147.066-.111.074-.04.032-.005.003-.004.004-.145.117-.004.003-.004.004-.144.119-.004.003-.004.004-.142.12-.004.004-.004.004-.141.123-.004.003-.004.004-.14.125-.004.003-.004.004-.138.126-.004.004-.004.004-.136.128-.004.004-.004.004-.135.13-.004.004-.004.003-.134.133-.004.003-.004.004-.132.134-.003.004-.004.004-.13.135-.004.004-.004.004-.128.136-.004.004-.004.004-.126.138-.004.004-.003.004-.125.14-.004.004-.003.004-.123.14-.004.005-.003.004-.121.142-.004.004-.003.004-.12.144-.003.004-.003.004-.117.145-.004.004-.003.004-.115.146-.004.005-.003.004-.113.147-.003.005-.004.004-.111.149-.003.004-.004.004-.11.15-.002.005-.003.004-.108.151-.003.005-.003.004-.106.152-.003.005-.003.004-.104.154-.003.004-.003.005-.102.154-.003.005-.002.004-.1.156-.003.005-.003.004-.098.157-.003.005-.003.004-.096.159-.002.004-.003.005-.094.16-.003.004-.002.004-.092.16-.003.005-.003.005-.09.161-.002.005-.003.005-.088.162-.002.005-.003.004-.086.164-.002.005-.002.004-.084.165-.003.005-.002.004-.082.166-.002.005-.003.004-.08.167-.002.004-.002.005-.078.168-.002.004-.002.005-.045.1-.053.153-.023.16.007.16.037.157.065.148.092.132.114.114.134.09.148.064.157.035.161.006.16-.025.152-.054.14-.08.121-.106.1-.126.065-.118.043-.095.074-.16.075-.155.077-.157.08-.155.08-.152.083-.155.085-.152.086-.15.088-.149.091-.15.094-.15.094-.147.095-.145.099-.146.1-.144.1-.142.104-.14.104-.14.11-.142.107-.137.11-.136.114-.136.113-.134.117-.133.118-.132.117-.129.122-.13.124-.127.123-.126.127-.125.127-.122.128-.12.132-.122.13-.115.133-.117.135-.115.135-.111.136-.11.037-.03.117-.11.094-.132.068-.146.04-.156.01-.161-.02-.16-.05-.154-.076-.141-.102-.125-.123-.104-.14-.08-.153-.051-.16-.023-.161.008zm24.514 11.15l-.157.04-.146.067-.131.093-.112.117-.088.135-.061.149-.033.157-.005.134.006.14.006.176.003.177.001.178-.001.177-.003.178-.006.177-.007.176-.01.177-.012.176-.015.176-.016.173-.018.175-.02.175-.024.174-.024.175-.027.17-.03.174-.03.173-.033.17-.036.172-.037.17-.04.17-.042.172-.043.168-.045.166-.048.169-.05.167-.052.168-.053.164-.056.166-.058.166-.06.161-.061.164-.063.158-.066.165-.068.16-.07.16-.07.158-.075.159-.074.155-.078.158-.081.158-.06.15-.03.158-.001.161.029.159.058.15.085.137.108.12.13.096.144.07.156.044.16.013.16-.017.155-.046.143-.074.127-.1.107-.12.07-.115.083-.164.003-.005.002-.004.082-.166.002-.005.003-.004.08-.167.002-.005.002-.004.078-.168.002-.004.002-.005.076-.169.002-.004.002-.005.074-.17.002-.004.002-.005.072-.17.002-.005.002-.005.07-.17.002-.006.001-.005.068-.172.002-.004.002-.005.065-.173.002-.005.002-.005.063-.173.002-.005.002-.005.06-.174.003-.005.001-.005.06-.175.001-.005.002-.005.057-.176.001-.005.002-.005.055-.177.001-.005.002-.005.052-.177.002-.005.001-.005.051-.178.001-.005.002-.005.048-.179.002-.005v-.005l.047-.179.001-.005.002-.005.044-.18v-.005l.002-.005.042-.18.001-.006.001-.005.04-.18.001-.006.001-.005.038-.182v-.005l.002-.005.035-.182v-.006l.002-.005.033-.182v-.006l.002-.005.03-.183.001-.005.001-.005.029-.184v-.005l.001-.006.027-.184v-.005l.001-.005.024-.185v-.005l.001-.005.022-.185v-.006l.001-.005.02-.185v-.006l.001-.005.017-.186v-.005l.001-.005.015-.187v-.005l.001-.005.013-.187v-.01l.01-.187.001-.006v-.005l.009-.187v-.011l.006-.187v-.011l.004-.188v-.011l.001-.188v-.01l-.001-.188v-.011l-.004-.188v-.011l-.006-.187v-.011l-.007-.145-.022-.16-.05-.152-.08-.141-.103-.124-.125-.102-.141-.077-.153-.05-.16-.02-.161.009zM.777 15l-.158.032-.15.06-.136.087-.117.11-.095.131-.068.146-.04.156-.012.133-.001.14v.01l.001.188v.011l.004.188v.011l.006.187v.011l.008.187v.011l.011.187v.005l.001.005.013.187v.01l.016.187v.01l.018.186v.011l.02.185.001.005v.006l.022.185.001.005v.005l.025.185v.005l.001.005.027.184v.006l.001.005.029.184v.005l.001.005.031.183.001.005.001.006.033.182.001.005.001.006.035.182.001.005.001.005.038.182v.005l.002.005.04.181v.005l.002.005.042.18.001.006.001.005.044.18.002.005v.005l.047.18.001.004.002.005.048.179.002.005.001.005.05.178.002.005.001.005.053.177.002.005.001.005.055.177.002.005.001.005.057.176.002.005.001.005.06.175.001.005.002.005.061.174.002.005.002.005.063.173.002.005.002.005.065.173.002.005.002.004.067.172.002.005.002.005.07.171.002.005.002.005.072.17.002.005.002.005.074.169.002.005.002.004.076.169.002.005.002.004.078.168.002.004.002.005.08.167.003.004.002.005.082.166.002.004.003.005.02.04.086.136.11.118.13.095.146.07.156.041.16.012.16-.019.155-.048.142-.075.126-.1.105-.123.08-.14.054-.152.024-.16-.006-.16-.036-.158-.051-.123-.018-.034-.078-.158L3.1 22.1l-.074-.16-.071-.156-.07-.162-.068-.16-.067-.164-.062-.158-.062-.164-.059-.161-.058-.166-.056-.166-.053-.164-.052-.168-.05-.167-.048-.17-.045-.165-.043-.168-.043-.172-.039-.17-.037-.17-.036-.172-.033-.17-.03-.173-.03-.174-.027-.17-.025-.175-.022-.174-.021-.175-.018-.175-.017-.173-.014-.176-.012-.176-.01-.177-.007-.176-.006-.177-.003-.178L1.73 16v-.134l-.013-.16-.044-.156-.072-.144-.097-.129-.12-.108-.137-.085-.15-.057L.938 15 .777 15zM6.17 26.842l-.152.052-.14.08-.122.105-.101.126-.076.142-.048.154-.02.16.012.161.041.156.07.146.094.13.096.093.032.026.004.003.004.004.145.117.004.003.004.004.146.115.005.003.004.004.147.113.005.003.004.004.149.111.004.003.004.003.15.11.005.003.004.003.151.108.005.003.004.003.152.106.005.003.004.003.154.104.004.003.005.003.154.102.005.002.004.003.156.1.005.003.004.003.157.098.005.003.004.002.159.096.004.003.005.003.16.094.004.003.004.002.16.092.005.003.005.002.161.09.005.003.005.003.162.088.005.002.004.002.164.087.005.002.004.002.165.084.005.003.004.002.166.082.004.002.005.003.167.08.004.002.005.002.168.078.004.002.005.002.169.076.004.002.005.002.17.074.004.002.005.002.17.072.005.002.005.002.17.07.006.002.005.001.171.068.005.002.005.002.173.065.005.002.005.002.173.063.005.002.005.002.174.061.005.002.005.001.175.06.005.001.005.002.176.057.005.001.005.002.177.055.005.001.005.002.177.052.005.002.005.001.178.051.005.001.005.002.178.048.006.002h.005l.179.047.005.001.005.002.18.044h.005l.005.002.18.042.006.001.005.001.159.035.16.02.16-.01.157-.04.146-.069.13-.094.112-.117.087-.136.06-.149.033-.158.002-.161-.028-.159-.057-.15-.084-.138-.108-.12-.128-.098-.144-.072-.128-.039-.154-.033-.168-.04-.171-.041-.169-.044-.17-.045-.166-.048-.168-.05-.165-.051-.166-.054-.166-.056-.163-.057-.165-.06-.161-.062-.164-.064-.16-.065-.16-.068-.162-.07-.157-.07-.157-.074-.157-.075-.156-.077-.153-.079-.156-.082-.153-.082-.154-.086-.15-.086-.152-.09-.148-.09-.147-.092-.149-.095-.145-.095-.144-.098-.145-.1-.143-.102-.14-.103-.14-.104-.14-.108-.139-.11-.136-.11-.027-.022-.133-.091-.148-.065-.157-.036-.161-.006-.16.024zm19.214.073l-.156.039-.146.067-.11.076-.064.051-.139.11-.14.108-.14.104-.14.103-.143.101-.145.101-.144.098-.145.095-.149.095-.148.093-.147.089-.152.09-.15.086-.154.086-.153.082-.156.082-.153.079-.156.077-.157.075-.157.073-.158.071-.16.07-.16.068-.161.065-.164.064-.161.061-.165.06-.163.058-.166.056-.166.054-.166.051-.167.05-.167.048-.17.045-.168.044-.171.042-.168.039-.17.037-.11.023-.154.047-.143.075-.126.1-.106.122-.081.139-.054.152-.025.16.006.16.035.158.063.148.09.133.114.115.132.092.148.065.157.037.16.008.133-.017.115-.024h.005l.005-.002.181-.04h.005l.005-.002.18-.042.006-.001.005-.001.18-.044.005-.002h.005l.18-.047.004-.001.005-.002.179-.048.005-.002.005-.001.178-.05.005-.002.005-.002.177-.052.005-.002.005-.001.177-.055.005-.002.005-.001.176-.057.005-.002.005-.002.175-.059.005-.001.005-.002.174-.061.005-.002.005-.002.173-.063.005-.002.005-.002.173-.065.005-.002.004-.002.172-.068.005-.001.005-.002.171-.07.005-.002.005-.002.17-.072.005-.002.005-.002.169-.074.005-.002.004-.002.169-.076.004-.002.005-.002.168-.078.004-.002.005-.002.167-.08.004-.003.005-.002.166-.082.004-.002.005-.003.165-.084.004-.002.005-.002.163-.087.005-.002.005-.002.162-.088.005-.003.005-.003.161-.09.005-.002.004-.003.16-.092.005-.002.005-.003.16-.094.004-.003.004-.003.158-.096.005-.002.004-.003.158-.098.004-.003.005-.003.156-.1.004-.003.004-.002.155-.102.005-.003.004-.003.154-.104.004-.003.005-.003.152-.106.004-.003.005-.003.151-.108.004-.003.005-.003.15-.11.004-.003.004-.003.149-.111.004-.004.004-.003.148-.113.004-.004.004-.003.147-.115.004-.004.004-.003.068-.055.116-.113.092-.132.066-.147.038-.157.008-.16-.022-.16-.05-.153-.08-.14-.103-.125-.124-.102-.142-.077-.153-.05-.16-.02-.16.009z"
}));
function _extends$H() {
  _extends$H = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$H.apply(this, arguments);
}
var IntermediateEventCatchParallelMultipleIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$H({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.975.003C8.195-.157.935 6.24.125 13.985c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.884 23.445.408 17.201.049c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.174.872 11.679 4.985 6.916c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.215-2.282-2.022-5.3-3.217-8.357-3.22zM16 4.975c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.082 11.082 0 0116 4.975zm-2.15 3.281v5.534H8.213v4.38h5.636v5.534h4.31V18.17h5.639v-4.38h-5.64V8.256h-4.31zm.865.865h2.583v5.534h5.635v2.65h-5.635v5.533h-2.583v-5.534h-5.64v-2.649h5.64V9.121z"
}));
function _extends$G() {
  _extends$G = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$G.apply(this, arguments);
}
var IntermediateEventCatchSignalIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$G({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.975.049C8.195-.11.935 6.286.125 14.03c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.93 23.445.453 17.201.095c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.22.872 11.725 4.985 6.962c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 5.021c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 5.021zm.006 3.521L9.206 20.745h13.598L16.005 8.542zm0 1.775l5.329 9.564H10.677l5.328-9.564z"
}));
function _extends$F() {
  _extends$F = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$F.apply(this, arguments);
}
var IntermediateEventCatchTimerIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$F({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.97.04h-.127C8.713-.018 2.003 5.334.437 12.286c-1.51 6.123.98 13.005 6.136 16.665 5.125 3.788 12.546 4.105 17.912.623 5.272-3.276 8.33-9.766 7.325-15.916-.904-6.241-5.79-11.7-11.95-13.143A16.082 16.082 0 0015.97.04zm-.181 1.724c.115 0 .23 0 .347.003 6.625-.066 12.823 5.149 13.89 11.69 1.13 5.91-1.908 12.349-7.262 15.138-5.473 3.013-12.866 1.884-17.116-2.726C1.291 21.372.444 13.914 3.802 8.602c2.493-4.112 7.169-6.819 11.987-6.838zm.283 1.554c-.117 0-.234.002-.351.005-6.1 0-11.691 5.049-12.346 11.114-.78 5.684 2.795 11.612 8.218 13.52 5.139 1.943 11.416.101 14.624-4.38 3.461-4.583 3.262-11.538-.596-15.831-2.36-2.747-5.924-4.423-9.549-4.428zm-.078 1.695c.078 0 .156 0 .234.003 5.4 0 10.321 4.556 10.734 9.942.563 5.13-2.958 10.364-7.971 11.678-4.832 1.41-10.457-.935-12.746-5.446-2.463-4.559-1.2-10.795 3.014-13.883a11.072 11.072 0 016.735-2.294zm-.137 3.42c-2.965.02-5.792 1.968-6.884 4.722-1.137 2.693-.509 6.007 1.536 8.096 1.988 2.14 5.263 2.929 8.007 1.926 2.875-.98 4.987-3.824 5.063-6.865.154-2.954-1.622-5.875-4.295-7.13a7.545 7.545 0 00-3.427-.75zm.27 1.381c2.708.013 5.249 2.014 5.88 4.652.704 2.576-.481 5.512-2.788 6.862-2.356 1.478-5.677 1.084-7.611-.918-2.042-1.97-2.405-5.376-.839-7.738 1.11-1.762 3.146-2.877 5.229-2.857h.13zm1.831 1.764l-2.072 3.76c-.64.068-.792 1.039-.202 1.298.39.27.696-.18 1.051-.164h3.168v-.864h-3.18l1.992-3.612-.757-.418z"
}));
function _extends$E() {
  _extends$E = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$E.apply(this, arguments);
}
var IntermediateEventNoneIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$E({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.848.001C8.113-.093.931 6.281.125 13.983c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.207C29.105 4.938 23.55.48 17.367.06A16.448 16.448 0 0015.848 0v.001zm.293 1.727c7.113-.099 13.662 5.97 14.077 13.08.56 6.299-3.516 12.735-9.582 14.679-5.798 2.004-12.806-.12-16.283-5.237C.717 19.159.874 11.638 5.016 6.876 7.722 3.638 11.902 1.63 16.14 1.728zm-.415 1.555C9.157 3.258 3.256 9.156 3.278 15.729c-.16 5.965 4.365 11.725 10.293 12.737 5.409 1.065 11.37-1.744 13.775-6.753 2.534-4.986 1.386-11.627-2.953-15.251-2.364-2.077-5.512-3.27-8.667-3.18zm.507 1.692c5.82-.026 11.013 5.318 10.79 11.143-.024 5.3-4.313 10.267-9.636 10.803-5.075.667-10.426-2.588-11.885-7.553-1.535-4.744.494-10.46 4.925-12.885a11.072 11.072 0 015.806-1.508z"
}));
function _extends$D() {
  _extends$D = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$D.apply(this, arguments);
}
var IntermediateEventThrowCompensationIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$D({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.975.003C8.195-.156.935 6.24.125 13.985c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.884 23.445.407 17.201.049c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.174.872 11.679 4.985 6.916c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 4.975c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 4.975zm-.56 5.772l-7.408 5.231 7.409 5.234v-5.057c2.385 1.687 4.771 3.371 7.157 5.057V10.747l-7.157 5.055v-5.055z"
}));
function _extends$C() {
  _extends$C = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$C.apply(this, arguments);
}
var IntermediateEventThrowEscalationIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$C({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.975.049C8.195-.11.935 6.286.125 14.03c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.93 23.445.453 17.201.095c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.22.872 11.725 4.985 6.962c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 5.021c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 5.021zm.006 3.927c-1.672 4.654-2.734 9.502-4.406 14.155 1.534-1.525 2.872-3.234 4.406-4.759l4.406 4.76c-1.496-4.71-2.91-9.446-4.406-14.156z"
}));
function _extends$B() {
  _extends$B = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$B.apply(this, arguments);
}
var IntermediateEventThrowLinkIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$B({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.975.049C8.195-.11.935 6.286.125 14.03c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.93 23.445.453 17.201.095c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.22.872 11.725 4.985 6.962c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 5.021c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 5.021zm1.78 4.093v3.555H9.785v6.714h7.994v3.554l5.829-6.911-5.83-6.912z"
}));
function _extends$A() {
  _extends$A = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$A.apply(this, arguments);
}
var IntermediateEventThrowMessageIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$A({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.975.003C8.195-.156.935 6.24.125 13.985c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.884 23.445.407 17.201.049c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.174.872 11.679 4.985 6.916c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 4.975c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 4.975zm-5.91 5.475l6.04 4.901 6.042-4.9H10.088zm-1.341 1.138v9.921h14.514V11.79l-7.132 5.787-7.382-5.99z"
}));
function _extends$z() {
  _extends$z = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$z.apply(this, arguments);
}
var IntermediateEventThrowMultipleIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$z({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.975.003C8.195-.156.935 6.24.125 13.985c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.884 23.445.407 17.201.049c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.174.872 11.679 4.985 6.916c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 4.975c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 4.975zm.006 3.073l-7.62 5.532 2.91 8.95h9.42l2.91-8.95-7.62-5.532z"
}));
function _extends$y() {
  _extends$y = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$y.apply(this, arguments);
}
var IntermediateEventThrowSignalIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$y({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.975.003C8.195-.156.935 6.24.125 13.985c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.884 23.445.407 17.201.049c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.174.872 11.679 4.985 6.916c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 4.975c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 4.975zm.006 3.52c-2.261 4.07-4.533 8.136-6.798 12.205h13.596L16.005 8.495z"
}));
function _extends$x() {
  _extends$x = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$x.apply(this, arguments);
}
var LaneIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$x({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M0 7v18.62h32V7H0zm1.655 17.056V8.684h28.62v15.372H1.656z"
}));
function _extends$w() {
  _extends$w = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$w.apply(this, arguments);
}
var ManualTaskIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$w({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M6.494 3C2.916 3 0 5.903 0 9.475v13.383c0 3.572 2.916 6.475 6.494 6.475h19.012c3.578 0 6.494-2.903 6.494-6.475V9.475C32 5.903 29.084 3 25.506 3H6.494zm0 2h19.012C28.015 5 30 6.98 30 9.475v13.383c0 2.495-1.985 4.475-4.494 4.475H6.494C3.985 27.333 2 25.353 2 22.858V9.475C2 6.98 3.985 5 6.494 5zm4.43 1.328c-.222.005-.43.09-.606.203-.985.638-4.356 2.977-5.096 3.486-.67.46-1.12 1.153-1.38 1.974-.27.858-.235 1.793-.232 2.576.002.59.016 1.104.17 1.727.22.908.634 1.63 1.23 2.118.597.49 1.363.732 2.23.734 3.038.012 6.078.016 9.119 0 .327-.002.645-.127.848-.37.204-.241.287-.56.291-.914a1.732 1.732 0 00-.097-.625h.327c.335 0 .641-.11.852-.316.21-.206.317-.475.374-.754a1.783 1.783 0 00-.126-1.143 1.18 1.18 0 00.877-.521c.196-.306.257-.666.258-1.025.001-.375-.088-.738-.293-1.033a1.179 1.179 0 00-.958-.512h-.478c.108-.237.156-.505.155-.782-.003-.373-.098-.721-.316-.99a1.21 1.21 0 00-.943-.43c-2.273-.004-4.236.018-6.412.012l-.19-.001c.102-.104.202-.205.312-.314.337-.336.662-.652.83-.869.4-.516.46-1.215.123-1.729-.178-.272-.439-.456-.72-.494a.93.93 0 00-.148-.008zm.029.728l.022.001c.055.008.115.027.209.172.132.201.126.606-.09.884-.079.102-.431.465-.767.8-.337.334-.657.643-.815.836-.153.186-.096.338-.056.435.04.096.085.212.298.263.063.014.066.01.086.012l.066.003c2.429.027 4.986-.004 7.223-.003.194 0 .293.056.379.162.086.105.151.286.153.533 0 .257-.065.467-.155.59-.09.124-.183.182-.37.183-1.706-.001-3.411-.005-5.117-.009v.731c2.23.004 4.461.01 6.692.012.17 0 .265.06.361.2.096.138.164.364.163.615 0 .268-.058.501-.143.634-.085.132-.162.193-.385.195-2.32-.001-4.554-.006-6.688-.003v.73c1.905 0 3.809.003 5.713.001.194.005.316.09.416.26.102.173.151.442.093.728-.04.193-.102.313-.17.38-.067.065-.148.108-.343.108h-5.71l.002.734c1.445 0 2.89-.01 4.334-.001.162 0 .232.041.297.123.064.081.123.238.12.488-.003.244-.061.385-.12.455-.06.07-.127.11-.296.11-3.037.016-6.076.012-9.113 0-.735-.002-1.316-.196-1.77-.568-.454-.372-.793-.935-.986-1.728-.134-.546-.146-.978-.148-1.558-.003-.796-.018-1.664.199-2.354.222-.705.582-1.24 1.096-1.593.75-.515 4.14-2.866 5.079-3.474a.504.504 0 01.241-.087z"
}));
function _extends$v() {
  _extends$v = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$v.apply(this, arguments);
}
var MessageFlowIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$v({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M4.073 26.607l1.295 1.296L1.325 32l-.662-.633L0 30.735l4.073-4.128zm6.953-7.046l1.296 1.296L1.325 32l7.555-7.656-1.295-1.296 1.455-1.474 1.986-2.013zM32 .06s-2.699 5.189-5.417 10.462l-.326.633c-1.14 2.214-2.265 4.407-3.176 6.2-1.228-1.222-2.449-2.452-3.676-3.675l-3.57 3.618-1.297-1.296 3.541-3.588c-.98-.964-1.932-1.958-2.923-2.91l-.753-.706c2.68-1.258 6.533-3.165 9.95-4.876l.617-.309C28.838 1.673 32 .06 32 .06zm-4.126 4.06l-.015.007-.115.057-.048.024-.115.057L17.7 9.172l5.017 4.948 5.157-10z"
}));
function _extends$u() {
  _extends$u = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$u.apply(this, arguments);
}
var ParticipantIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$u({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M0 5v22.069h32V5H0zm30.276 1.684v18.82H6.62V6.684h23.655zm-28.62 0h3.31v18.82h-3.31V6.684z"
}));
function _extends$t() {
  _extends$t = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$t.apply(this, arguments);
}
var ProcessIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$t({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  fillRule: "evenodd",
  d: "M16.177 0l.137.002c.452.009.9.037 1.342.082.346.036.62.303.68.646l.437 2.536c.055.319.296.57.608.655.986.269 1.923.653 2.796 1.14.28.155.624.145.885-.039l2.083-1.47a.775.775 0 01.937.022c.86.699 1.645 1.484 2.343 2.343.22.27.223.653.023.937l-1.439 2.038a.833.833 0 00-.031.896c.512.889.92 1.846 1.204 2.855a.833.833 0 00.653.601l2.435.42c.342.059.61.333.645.679a15.928 15.928 0 01.08 2.064l-.003.114c-.012.382-.038.76-.077 1.134a.775.775 0 01-.645.68l-2.396.412a.835.835 0 00-.656.61 12.511 12.511 0 01-1.2 2.917.832.832 0 00.034.892l1.396 1.978c.2.284.196.667-.023.936a16.104 16.104 0 01-2.343 2.343.775.775 0 01-.937.023l-1.99-1.404a.833.833 0 00-.88-.026c-.907.516-1.886.922-2.916 1.2a.833.833 0 00-.61.656l-.414 2.396a.775.775 0 01-.679.646 16.096 16.096 0 01-3.312 0 .775.775 0 01-.679-.646l-.423-2.452a.834.834 0 00-.598-.636 12.474 12.474 0 01-1.468-.514 12.49 12.49 0 01-1.417-.68.833.833 0 00-.878.03l-2.026 1.43a.775.775 0 01-.937-.023 16.069 16.069 0 01-2.342-2.342.774.774 0 01-.024-.936l1.402-1.986a.833.833 0 00.032-.896 12.507 12.507 0 01-1.214-2.911.833.833 0 00-.655-.606l-2.386-.412a.775.775 0 01-.646-.678 16.097 16.097 0 010-3.314.775.775 0 01.646-.678l2.386-.412a.833.833 0 00.655-.606 12.507 12.507 0 011.214-2.911.833.833 0 00-.032-.896L3.552 6.853a.774.774 0 01.023-.936 16.091 16.091 0 012.343-2.343.775.775 0 01.937-.023l2.03 1.433c.26.177.6.182.874.028.915-.512 1.88-.9 2.87-1.167a.833.833 0 00.612-.656l.424-2.46a.775.775 0 01.679-.645C14.845.032 15.348.004 15.85 0h.326zM16 6.4c-5.302 0-9.6 4.297-9.6 9.599 0 5.302 4.298 9.6 9.6 9.6s9.6-4.298 9.6-9.6-4.298-9.6-9.6-9.6zm-3 4.283c0-1.425 1.637-2.203 2.715-1.29l5.69 4.815c.794.672.794 1.91 0 2.583l-5.69 4.815c-1.078.913-2.715.134-2.715-1.29z"
}));
function _extends$s() {
  _extends$s = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$s.apply(this, arguments);
}
var ReceiveTaskIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$s({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M6.494 3C2.916 3 0 5.903 0 9.475v13.383c0 3.572 2.916 6.475 6.494 6.475h19.012c3.578 0 6.494-2.903 6.494-6.475V9.475C32 5.903 29.084 3 25.506 3H6.494zm0 2h19.012C28.015 5 30 6.98 30 9.475v13.383c0 2.495-1.985 4.475-4.494 4.475H6.494C3.985 27.333 2 25.353 2 22.858V9.475C2 6.98 3.985 5 6.494 5zM5.23 7.764v11.577h17.55V7.764H5.23zm1.816.758h13.917l-6.959 4.577-6.958-4.577zm-1.06.21l8.018 5.274 8.018-5.275v9.853H5.987V8.73z"
}));
function _extends$r() {
  _extends$r = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$r.apply(this, arguments);
}
var ScriptTaskIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$r({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M6.494 3C2.916 3 0 5.903 0 9.475v13.383c0 3.572 2.916 6.475 6.494 6.475h19.012c3.578 0 6.494-2.903 6.494-6.475V9.475C32 5.903 29.084 3 25.506 3H6.494zm0 2h19.012C28.015 5 30 6.98 30 9.475v13.383c0 2.495-1.985 4.475-4.494 4.475H6.494C3.985 27.333 2 25.353 2 22.858V9.475C2 6.98 3.985 5 6.494 5zm2.99 3.077l-.077.045-.026.015c-1.09.646-1.84 1.239-2.336 1.818-.496.579-.735 1.162-.742 1.725-.014 1.119.812 1.958 1.544 2.708.732.75 1.385 1.456 1.446 2.041.032.298-.039.598-.364 1.008-.324.408-.911.897-1.85 1.445l-1.388.808h8.56l.101-.059c.996-.58 1.667-1.116 2.094-1.655.429-.54.603-1.107.547-1.638-.11-1.052-.967-1.818-1.688-2.556-.721-.739-1.306-1.436-1.298-2.092.004-.331.132-.7.535-1.171.402-.47 1.08-1.02 2.119-1.636l1.362-.806h-8.54zm.241.867h5.271a6.83 6.83 0 00-1.113 1.01c-.496.58-.736 1.163-.743 1.726-.014 1.119.812 1.958 1.544 2.708.732.75 1.385 1.456 1.446 2.041.032.298-.039.598-.364 1.008-.312.393-.872.862-1.753 1.386H8.728c.367-.286.658-.566.88-.847.43-.54.604-1.107.548-1.638-.11-1.052-.968-1.818-1.688-2.556-.721-.739-1.306-1.435-1.298-2.092.004-.331.132-.7.534-1.171.389-.454 1.04-.984 2.021-1.575zm-1.233 1.48v.4h4.12v-.4h-4.12zm-.154 2.158v.4H12.6v-.4H8.34zm1.931 2.158v.4h4.126v-.4H10.27zm.59 2.158v.4h4.276v-.4h-4.276z"
}));
function _extends$q() {
  _extends$q = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$q.apply(this, arguments);
}
var SendTaskIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$q({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M6.494 3C2.916 3 0 5.903 0 9.475v13.383c0 3.572 2.916 6.475 6.494 6.475h19.012c3.578 0 6.494-2.903 6.494-6.475V9.475C32 5.903 29.084 3 25.506 3H6.494zm0 2h19.012C28.015 5 30 6.98 30 9.475v13.383c0 2.495-1.985 4.475-4.494 4.475H6.494C3.985 27.333 2 25.353 2 22.858V9.475C2 6.98 3.985 5 6.494 5zm-1.38 3.16l8.332 4.717L21.78 8.16H5.114zm.021 1.745v9.309H21.8V9.905l-8.353 4.655-8.31-4.655z"
}));
function _extends$p() {
  _extends$p = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$p.apply(this, arguments);
}
var ServiceTaskIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$p({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M6.494 3C2.916 3 0 5.903 0 9.475v13.383c0 3.572 2.916 6.475 6.494 6.475h19.012c3.578 0 6.494-2.903 6.494-6.475V9.475C32 5.903 29.084 3 25.506 3H6.494zm0 2h19.012C28.015 5 30 6.98 30 9.475v13.383c0 2.495-1.985 4.475-4.494 4.475H6.494C3.985 27.333 2 25.353 2 22.858V9.475C2 6.98 3.985 5 6.494 5zm1.22 1.681V7.84c-.329.093-.63.223-.914.382l-.83-.82-1.554 1.561.83.82c-.16.288-.285.594-.372.911l-1.177.002v2.2l1.189-.004c.109.431.345.819.58 1.165v-1.898l-1.038.004v-.737l1.034-.002.058-.294c.084-.429.252-.838.493-1.203l.165-.25-.727-.718.523-.526.728.719.247-.165c.379-.25.793-.417 1.206-.505l.291-.06-.002-1.01h.75L9.19 8.417H11.16c-.185-.221-.951-.508-1.237-.588L9.93 6.68H7.713zm2.078 2.105l.003 1.158a4.19 4.19 0 00-.915.383l-.83-.821-1.553 1.562.83.82c-.16.288-.286.593-.373.91l-1.176.003v2.2l1.188-.004c.094.326.224.624.383.905l-.85.847 1.57 1.543.847-.843c.29.161.599.286.919.373v1.198c.756.006 1.56.003 2.206.003V17.81a4.19 4.19 0 00.915-.383l.847.835 1.554-1.56-.848-.836c.16-.288.286-.594.373-.912l1.152-.007V12.75l-1.165.007a4.09 4.09 0 00-.382-.905l.805-.807-1.57-1.546-.804.806a4.16 4.16 0 00-.915-.372l.007-1.147H9.792zm.732.73h.751l-.006 1.005.297.058c.43.085.844.252 1.21.492l.25.162.701-.704.528.52-.702.704.169.25c.248.374.412.779.505 1.196l.061.292 1.016-.006v.737l-1.01.006-.058.292c-.085.43-.252.838-.494 1.205l-.165.25.744.733-.523.525-.743-.734-.248.165c-.378.247-.789.418-1.203.503l-.294.058v1.067h-.745v-1.059l-.295-.057a3.395 3.395 0 01-1.21-.492l-.248-.162-.747.743-.528-.52.747-.744-.17-.25a3.546 3.546 0 01-.506-1.196l-.06-.291-1.04.004v-.738l1.034-.002.058-.294c.085-.428.252-.837.493-1.203l.165-.25-.726-.718.522-.526.728.72.248-.166a3.546 3.546 0 011.205-.504l.292-.06-.003-1.01zm.388 2.685a1.65 1.65 0 00-1.645 1.645c0 .904.74 1.645 1.645 1.645a1.65 1.65 0 001.645-1.645 1.65 1.65 0 00-1.645-1.645zm0 .73a.91.91 0 01.915.915.91.91 0 01-.915.914.91.91 0 01-.915-.914.91.91 0 01.915-.915z"
}));
function _extends$o() {
  _extends$o = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$o.apply(this, arguments);
}
var StartEventCompensationIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$o({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.995.001C9.705-.084 3.643 3.964 1.257 9.775-1.235 15.485.06 22.577 4.42 27.03c4.193 4.513 11.102 6.17 16.887 4.058 5.996-2.042 10.423-7.93 10.664-14.269.403-6.227-3.26-12.44-8.87-15.153A15.924 15.924 0 0015.994 0zm0 1.73c6.213-.108 12.122 4.355 13.726 10.357 1.678 5.653-.592 12.198-5.463 15.547-5.06 3.719-12.564 3.45-17.343-.626C2.101 23.171.377 16.07 2.848 10.44c2.14-5.205 7.515-8.774 13.147-8.708zm-.566 9.03l-7.415 5.235 7.415 5.238v-5.062c2.386 1.689 4.775 3.375 7.163 5.062V10.761l-7.163 5.058v-5.058zm-.866 1.666v7.13L9.51 15.993l5.052-3.565zm7.166 0v7.137l-5.052-3.568 5.052-3.569z"
}));
function _extends$n() {
  _extends$n = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$n.apply(this, arguments);
}
var StartEventConditionIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$n({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M16 0C7.174 0 0 7.174 0 16s7.174 16 16 16 16-7.174 16-16S24.826 0 16 0zm0 1.73c7.892 0 14.27 6.378 14.27 14.27 0 7.891-6.379 14.27-14.27 14.27S1.73 23.891 1.73 16C1.73 8.108 8.108 1.73 16 1.73zm-5.362 7.523v13.493h10.724V9.253H10.638zm.863.866h8.995V21.88H11.501V10.12zm.928 1.324v.863h7.139v-.863h-7.139zm0 2.605v.867h7.139v-.867h-7.139zm0 3.01v.864h7.139v-.863h-7.139zm0 2.72v.863h7.139v-.863h-7.139z"
}));
function _extends$m() {
  _extends$m = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$m.apply(this, arguments);
}
var StartEventErrorIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$m({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.995.005C9.705-.08 3.643 3.968 1.257 9.78-1.235 15.49.06 22.581 4.42 27.034c4.193 4.513 11.102 6.17 16.887 4.058 5.996-2.042 10.423-7.93 10.664-14.269.403-6.227-3.26-12.44-8.87-15.153A15.924 15.924 0 0015.994.005zm0 1.73c6.213-.108 12.122 4.355 13.726 10.357 1.678 5.653-.592 12.198-5.463 15.547-5.06 3.719-12.564 3.45-17.343-.626-4.814-3.838-6.538-10.939-4.067-16.57 2.14-5.205 7.515-8.774 13.147-8.708zm6.13 7.45l-3.635 7.37-4.52-5.88c-1.37 4.048-2.738 8.095-4.106 12.143l4.603-5.917 4.748 5.433 2.91-13.149zm-7.754 3.889l4.299 5.449 1.073-2.39-1.028 4.135-4.387-5.16-1.78 2.75 1.823-4.784z"
}));
function _extends$l() {
  _extends$l = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$l.apply(this, arguments);
}
var StartEventEscalationIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$l({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.995.001C9.705-.084 3.643 3.964 1.257 9.775-1.235 15.485.06 22.577 4.42 27.03c4.193 4.513 11.102 6.17 16.887 4.058 5.996-2.042 10.423-7.93 10.664-14.269.403-6.227-3.26-12.44-8.87-15.153A15.924 15.924 0 0015.994 0zm0 1.73c6.213-.108 12.122 4.355 13.726 10.357 1.678 5.653-.592 12.198-5.463 15.547-5.06 3.719-12.564 3.45-17.343-.626C2.101 23.171.377 16.07 2.848 10.44c2.14-5.205 7.515-8.774 13.147-8.708zm0 7.183c-1.674 4.658-2.736 9.509-4.41 14.166 1.535-1.526 2.874-3.236 4.41-4.763l4.41 4.763c-1.499-4.713-2.913-9.453-4.41-14.166zm.032 2.931c.822 2.588 1.598 5.19 2.42 7.778l-2.42-2.615c-.683.598-2.455 2.887-2.34 2.39.871-2.489 1.448-5.07 2.34-7.553z"
}));
function _extends$k() {
  _extends$k = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$k.apply(this, arguments);
}
var StartEventMessageIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$k({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.995.001C9.705-.084 3.643 3.964 1.257 9.775-1.235 15.485.06 22.577 4.42 27.03c4.193 4.513 11.102 6.17 16.887 4.058 5.996-2.042 10.423-7.93 10.664-14.269.403-6.227-3.26-12.44-8.87-15.153A15.924 15.924 0 0015.994 0zm0 1.73c6.213-.108 12.122 4.355 13.726 10.357 1.678 5.653-.592 12.198-5.463 15.547-5.06 3.719-12.564 3.45-17.343-.626C2.101 23.171.377 16.07 2.848 10.44c2.14-5.205 7.515-8.774 13.147-8.708zm-7.257 8.732v11.069h14.513v-11.07H8.738zm3.224 1.73h8.064c-1.428.878-2.857 2.807-4.285 3.018l-3.779-3.019zm9.562 1.017v6.593H10.465V13.21l5.528 4.417 5.53-4.418z"
}));
function _extends$j() {
  _extends$j = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$j.apply(this, arguments);
}
var StartEventMultipleIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$j({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.995.001C9.705-.084 3.643 3.964 1.257 9.775-1.235 15.485.06 22.577 4.42 27.03c4.193 4.513 11.102 6.17 16.887 4.058 5.996-2.042 10.423-7.93 10.664-14.269.403-6.227-3.26-12.44-8.87-15.153A15.924 15.924 0 0015.994 0zm0 1.73c6.213-.108 12.122 4.355 13.726 10.357 1.678 5.653-.592 12.198-5.463 15.547-5.06 3.719-12.564 3.45-17.343-.626C2.101 23.171.377 16.07 2.848 10.44c2.14-5.205 7.515-8.774 13.147-8.708zm0 6.328l-7.626 5.536c.97 2.986 1.942 5.971 2.913 8.957h9.426l2.912-8.957-7.625-5.536zm0 1.068l6.609 4.798-2.525 7.763H11.91l-2.524-7.763 6.609-4.798z"
}));
function _extends$i() {
  _extends$i = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$i.apply(this, arguments);
}
var StartEventNonInterruptingConditionIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$i({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M10.632 9.189V22.68h10.723V9.189H10.632zm.862.865h8.994v11.76H11.494v-11.76zm.928 1.324v.863h7.138v-.863h-7.138zm0 2.605v.866h7.138v-.866h-7.138zm0 3.01v.863h7.138v-.863h-7.138zm0 2.72v.862h7.138v-.863h-7.138zM16.12 0h-.232l-.22.004h-.012l-.221.006h-.012l-.22.01h-.012l-.22.013h-.012l-.22.016h-.012l-.22.019h-.005l-.006.001-.22.021h-.006l-.005.001-.22.025h-.011l-.22.028h-.005l-.006.002-.219.03h-.005l-.006.001-.218.033-.006.001-.006.001-.217.036-.006.001-.006.001-.217.039-.006.001-.006.001-.216.042-.006.001-.006.001-.215.045-.006.001-.006.002-.215.047-.006.002-.006.001-.214.05-.006.002-.006.002-.115.029-.152.053-.14.081-.122.106-.1.126-.075.143-.047.154-.018.16.012.16.042.156.07.145.095.13.118.11.137.086.15.059.158.03h.161l.132-.022.11-.028.202-.047.203-.046.208-.043.202-.039.206-.037.206-.034.205-.03.208-.03.205-.025.209-.023.208-.02.21-.017.209-.015.207-.011.21-.009.21-.006.207-.003h.21l.21.002.207.005.207.008.212.011.207.014.208.017.209.019.208.022.205.025.206.028.207.03.208.035.205.036.202.039.052.01.16.018.16-.012.156-.042.146-.07.13-.096.109-.119.085-.136.06-.15.03-.159v-.16l-.03-.16-.059-.15-.086-.136-.109-.118-.13-.096-.145-.07-.128-.038-.057-.011-.006-.002h-.006l-.216-.042-.006-.001-.006-.001-.217-.039H18.9l-.006-.002-.217-.035-.006-.001-.006-.001-.218-.032-.006-.001-.006-.001-.218-.03h-.006l-.006-.001-.219-.027h-.011l-.22-.024-.005-.001h-.006l-.22-.021h-.006l-.006-.001-.22-.017-.005-.001h-.006L17.06.03h-.012l-.22-.012h-.012l-.22-.01h-.012l-.22-.005h-.012L16.132 0h-.012zm8.715 2.783l-.157.034-.149.063-.134.089-.116.112-.092.132-.067.147-.038.157-.008.16.021.16.051.153.079.141.103.124.102.087.052.038h.001l.087.064v.001l.082.061.002.001.076.059h.001l.084.065.082.066.002.001.079.063.002.002.077.063.081.067.002.002.077.065.076.065.001.002.08.07.078.07h.002l.075.068.077.072.002.001.073.069.077.073.072.07.002.001.077.076.07.07v.001l.075.076.07.073.002.001.074.079.002.002.069.074.069.075.074.082.07.08.002.001.068.079h.001l.067.079.068.082.065.078.001.002.068.083.067.084.063.081.001.002.067.087.002.002.063.084.001.001.064.087.008.01.008.01.095.12.093.121.09.119.087.119.088.122.086.123.084.12.081.122.001.002.084.126.08.126.08.127.077.126.079.131.074.127.075.131.073.131.07.13.07.133.069.133.045.09.086.137.109.119.13.096.144.07.156.042.16.013.16-.017.155-.047.143-.075.126-.1.106-.121.082-.14.054-.151.025-.16-.005-.16-.035-.158-.05-.124-.048-.095-.002-.004-.002-.004-.073-.14-.002-.005-.002-.004-.074-.14-.002-.004-.002-.004-.076-.14-.002-.003-.002-.004-.077-.139-.003-.004-.002-.004-.078-.138-.003-.004-.002-.003-.08-.137-.002-.004-.003-.004-.081-.136-.002-.004-.003-.004-.083-.136-.002-.003-.002-.004-.085-.135-.002-.004-.003-.003-.085-.134-.003-.004-.002-.004-.087-.132-.003-.004-.003-.004-.088-.132-.003-.003-.002-.004-.09-.13-.003-.005-.003-.003-.091-.13-.003-.004-.002-.004-.093-.129-.003-.003-.003-.004-.094-.128-.003-.004-.003-.003-.095-.127-.003-.004-.003-.004-.097-.125-.003-.004-.003-.004-.09-.114-.06-.082-.003-.003-.002-.003-.069-.091-.002-.004-.002-.003-.07-.09-.003-.003-.002-.003-.07-.09-.003-.003-.002-.003-.071-.09-.002-.003-.003-.002-.072-.089-.002-.003-.002-.003-.073-.088-.002-.003-.002-.002-.074-.087-.002-.003-.002-.003-.074-.086-.003-.003-.002-.003-.074-.086-.003-.002-.002-.003-.075-.085-.003-.003-.002-.002-.076-.084-.002-.003-.003-.003-.076-.083-.002-.003-.003-.003-.077-.082-.002-.003-.003-.002-.077-.082-.003-.003-.003-.002-.078-.081-.002-.003-.003-.003-.078-.08-.003-.002-.003-.003-.079-.08-.002-.002-.003-.002-.08-.08-.002-.002-.003-.002-.08-.078-.003-.003-.003-.002-.08-.077-.003-.003-.003-.002-.082-.077-.002-.002-.003-.002-.082-.076-.003-.002-.002-.003-.083-.075-.003-.002-.002-.003-.084-.074-.002-.002-.003-.002-.084-.074-.003-.002-.002-.002-.085-.073-.002-.002-.003-.003-.085-.071-.003-.003-.002-.002-.086-.07-.003-.003-.002-.002-.086-.07-.003-.003-.003-.002-.086-.07-.003-.002-.003-.002-.087-.069-.002-.002-.003-.002-.088-.068-.002-.002-.003-.002-.088-.067-.003-.003-.003-.002-.088-.066-.003-.002-.003-.002-.089-.066-.003-.002-.003-.002-.057-.042-.14-.082-.15-.055-.16-.026-.16.004zM6.377 3.21l-.157.037-.148.066-.111.074-.007.006-.003.002-.003.002-.086.069-.003.002-.002.002-.086.07-.003.002-.002.002-.086.07-.002.003-.003.002-.085.071-.002.002-.003.003-.084.071-.003.003-.002.002-.084.072-.003.003-.002.002-.083.073-.003.003-.002.002-.083.074-.002.002-.003.003-.082.074-.003.003-.002.002-.081.076-.003.002-.003.002-.08.077-.003.002-.003.003-.08.076-.002.003-.003.002-.08.078-.002.002-.003.003-.079.078-.002.003-.003.002-.078.08-.003.002-.002.002-.078.08-.002.003-.003.002-.077.08-.003.004-.002.002-.077.081-.002.003-.003.003-.076.082-.002.002-.003.003-.075.082-.002.003-.003.003-.074.083-.003.003-.002.003-.074.084-.003.003-.002.002-.074.085-.002.003-.002.003-.073.085-.003.003-.002.003-.072.086-.002.003-.003.003-.071.087-.003.003-.002.002-.07.088-.003.003-.002.003-.07.088-.003.003-.002.003-.07.09-.002.002-.002.003-.069.09-.002.003-.003.003-.068.09-.002.003-.002.003-.067.092-.003.003-.002.003-.067.092-.002.003-.002.003-.066.092-.002.003-.002.004-.066.093-.002.003-.002.003-.065.094-.002.003-.002.004-.064.094-.002.003-.002.004-.063.095-.002.003-.002.003-.063.097-.002.003-.002.003-.046.073-.05.07-.003.002-.002.003-.067.093-.003.003-.002.003-.066.094-.002.003-.002.003-.066.094-.002.003-.002.003-.064.094-.002.004-.002.003-.064.094-.002.004-.002.003-.062.095-.002.003-.002.003-.062.096-.002.003-.002.003-.06.096-.003.003-.002.003-.06.096-.001.004-.002.003-.059.096-.002.004-.002.003-.058.097-.002.003-.001.003-.057.098-.002.003-.002.003-.056.098-.002.003-.002.003-.055.098-.002.004-.001.003-.055.098-.001.004-.002.003-.054.099-.001.003-.002.003-.052.1-.002.002-.002.004-.051.1-.002.002-.002.004-.05.1-.002.003-.002.003-.05.1v.003l-.002.004-.05.1v.003l-.002.004-.048.1-.002.004-.001.003-.047.101-.002.003-.001.004-.013.027-.052.152-.024.16.006.16.037.157.064.148.091.133.114.114.134.09.147.065.157.036.162.006.159-.024.152-.053.14-.08.122-.105.1-.126.066-.117.01-.023.044-.095.045-.095.002-.003.042-.087.048-.097.048-.095v-.001l.048-.092.001-.001.047-.09.05-.093.002-.002.049-.09.052-.092.001-.002.051-.089.001-.002.051-.087.053-.088.001-.002.055-.091.057-.091.057-.09.001-.002.057-.089.055-.083.001-.002.06-.09.06-.088.062-.089.001-.001.06-.084.063-.088.065-.089.017-.023.016-.025.06-.094.059-.09v-.002l.058-.086.057-.086.001-.001.062-.09.062-.088.001-.002.06-.085.002-.002.06-.082.063-.087.064-.084.002-.002.061-.08.065-.084.064-.08v-.001l.067-.083.067-.082.07-.083.069-.08.063-.074.074-.083.068-.077.002-.002.07-.076.07-.075.072-.077.001-.001.067-.07.076-.078.002-.002.07-.07.075-.075.002-.002.072-.07.075-.072.002-.002.073-.069.074-.068.001-.001.08-.073.076-.068.002-.002.072-.063v-.001l.078-.067.079-.068.002-.001.08-.068.002-.002.077-.063.082-.066.001-.001.075-.06.002-.002.006-.004.117-.111.094-.131.068-.146.04-.156.01-.161-.019-.16-.049-.154-.076-.141-.102-.125-.123-.105-.14-.079-.153-.052-.16-.023-.16.007zm24.596 11.088l-.156.04-.146.067-.131.094-.112.117-.087.135-.061.15-.033.157-.004.134.007.142.005.152.004.15.002.149v.153l.001.011v.015l.004.11.002.11v.002l.002.106v.321l-.003.102-.002.106-.004.107-.005.105-.006.106-.006.106-.008.106v.002l-.008.103v.002l-.01.1-.01.105-.01.105-.013.105-.012.099v.002l-.014.108-.014.1-.016.105-.016.103v.002l-.017.099-.018.104-.019.103v.002l-.019.097-.02.104-.022.103v.001l-.022.098-.023.103v.002l-.024.096-.025.103v.002l-.024.096-.027.102v.003l-.026.093v.001l-.029.103v.002l-.03.099-.028.097v.002l-.03.095-.03.096v.001l-.033.1-.031.095v.002l-.035.1v.003l-.034.094v.003l-.035.096v.001l-.034.09v.002l-.038.098-.036.093v.002l-.038.095-.079.194-.08.188-.085.189-.087.19-.09.184-.092.183-.095.184-.05.093-.064.148-.034.158-.005.16.026.16.054.151.082.14.106.12.127.1.143.075.154.046.16.017.161-.013.156-.042.144-.071.13-.096.109-.119.072-.112.053-.099.003-.005.003-.006.102-.195.003-.006.003-.006.098-.196.003-.006.003-.006.096-.197.002-.006.003-.006.093-.2.002-.006.003-.006.09-.2.002-.006.003-.007.086-.202.003-.006.002-.006.084-.203.002-.005.001-.005.04-.102.002-.003.001-.003.04-.103.001-.003.001-.003.04-.103v-.004l.001-.003.039-.103v-.003l.002-.003.037-.104.001-.003.001-.003.037-.104v-.004l.002-.003.035-.104.002-.003v-.004l.035-.104.002-.004v-.003l.034-.105.002-.003v-.003l.034-.105v-.004l.002-.003.032-.106.001-.003.001-.003.031-.106.001-.003.001-.004.031-.106.001-.003.001-.004.03-.106v-.003l.002-.004.028-.107.001-.003.001-.003.028-.107.001-.004.001-.003.027-.107.001-.004v-.003l.027-.108.001-.003v-.004l.026-.108.001-.003v-.004l.025-.108.001-.003v-.004l.025-.108v-.004l.001-.003.023-.109v-.003l.001-.004.022-.109v-.003l.002-.004.02-.109.001-.004v-.003l.02-.11.002-.003v-.004l.02-.11v-.007l.019-.11v-.003l.001-.004.017-.11v-.004l.001-.003.017-.11v-.008l.016-.11v-.004l.001-.004.015-.11v-.008l.015-.111v-.008l.013-.111v-.007l.013-.112v-.007l.011-.112v-.004l.001-.004.01-.112v-.007l.01-.112v-.008l.008-.112v-.008l.007-.113v-.007l.007-.113v-.008l.005-.113v-.007l.005-.114v-.007l.003-.114v-.007l.003-.114v-.129l.001-.114v-.13l-.003-.114v-.008l-.003-.115v-.007l-.003-.102v-.155l-.003-.158v-.01l-.004-.158v-.01l-.006-.158v-.01l-.007-.148-.023-.16-.051-.152-.08-.14-.103-.124-.125-.102-.142-.077-.153-.05-.16-.02-.161.01zm-30.213.66l-.157.034-.149.063-.134.09-.115.113-.092.132-.067.147-.037.156-.009.134.001.11V15.95l.006.22v.012l.01.22v.012l.012.22v.006l.001.006.015.22v.005l.001.006.018.22.001.006v.006l.022.219v.006l.001.006.024.219.001.006v.006l.028.218.001.006v.006l.031.218.001.006.001.006.033.218.001.006.001.005.037.218v.006l.002.005.04.217v.006l.001.006.043.216.001.006.001.006.046.216v.005l.002.006.048.215.002.006.001.006.051.214.002.006v.006l.055.214.002.005.001.006.057.213.002.006.001.005.06.213.002.005.001.006.063.212.002.005.001.006.066.21.002.006.002.006.068.21.002.005.002.005.07.21.003.005.002.005.074.208.002.006.002.005.077.207.002.006.002.005.08.206.002.005.002.006.082.204.002.006.002.005.086.204.002.005.002.006.088.202.002.005.003.006.09.2.003.006.002.005.094.2.002.006.003.005.096.199.002.005.003.005.03.062.086.137.11.118.128.097.145.07.156.043.16.013.16-.017.155-.047.143-.074.127-.1.106-.121.081-.14.055-.15.025-.16-.005-.161-.034-.158-.05-.124-.028-.055-.092-.19-.087-.188-.087-.192-.083-.19-.08-.193-.078-.194-.076-.196-.073-.195-.07-.197-.067-.198-.065-.199-.063-.2-.059-.2-.056-.2-.055-.204-.05-.201-.049-.202-.046-.205-.043-.206-.04-.203-.038-.207-.034-.204-.032-.207-.028-.205-.026-.207-.023-.208-.02-.207-.018-.207-.014-.208-.011-.207-.009-.208-.005-.207-.002-.104-.017-.16-.046-.155-.074-.143-.1-.126-.121-.107-.139-.081-.152-.055-.159-.025-.161.004zm24.585 11.83l-.156.039-.146.068-.11.076-.015.012-.163.129-.166.127-.168.125-.17.124-.17.12-.172.118-.173.115-.176.114-.177.111-.18.11-.178.105-.182.104-.182.101-.184.1-.184.095-.189.095-.186.09-.188.089-.19.086-.19.082-.193.081-.195.078-.191.074-.197.073-.195.07-.196.065-.198.064-.198.061-.2.058-.2.055-.2.052-.2.049-.151.035-.153.05-.141.078-.125.103-.103.124-.078.14-.05.154-.022.16.009.16.038.157.067.147.093.132.116.112.134.089.149.062.158.034.16.003.133-.02.158-.035.006-.002.006-.001.213-.052.006-.002.007-.001.212-.056.006-.001.006-.002.212-.058.006-.002.006-.002.211-.061.006-.002.006-.002.21-.064.006-.002.006-.002.21-.067.005-.002.006-.002.208-.07.006-.002.006-.003.207-.073.006-.002.006-.002.206-.077.006-.002.005-.002.206-.08.005-.001.006-.003.204-.082.006-.002.005-.002.203-.085.006-.003.005-.002.202-.088.006-.002.005-.003.2-.09.006-.003.006-.003.2-.093.005-.003.005-.002.198-.096.006-.003.005-.003.197-.099.005-.002.005-.003.196-.102.005-.002.005-.003.195-.105.005-.002.005-.003.193-.107.005-.003.005-.003.191-.11.005-.003.005-.003.19-.112.005-.003.005-.003.189-.115.005-.003.005-.003.187-.117.005-.003.004-.004.186-.12.005-.003.004-.003.184-.122.005-.003.005-.004.182-.125.004-.003.005-.003.18-.128.005-.003.005-.003.179-.13.004-.003.005-.004.177-.132.004-.004.005-.003.175-.135.005-.003.004-.004.173-.137.005-.003.004-.004.019-.015.115-.113.092-.132.066-.147.038-.157.008-.16-.022-.16-.052-.153-.079-.14-.103-.124-.125-.102-.142-.078-.153-.05-.16-.02-.16.01zm-19.17.054l-.153.051-.14.079-.124.103-.103.125-.077.141-.05.153-.02.16.009.161.04.156.067.147.093.131.095.094.047.04.005.004.005.004.17.14.005.004.005.004.172.137.004.004.005.003.086.067.003.002.003.002.087.067.003.002.003.002.088.066.002.003.003.002.089.065.002.002.003.002.09.065.002.002.003.002.09.064.002.002.003.002.09.063.003.002.003.002.09.063.003.002.003.002.092.062.002.002.003.002.092.061.003.002.003.002.092.06.003.003.003.001.093.06.003.002.003.002.093.06.003.001.003.002.094.058.003.002.003.002.095.058.003.001.003.002.095.057.003.002.003.002.095.056.003.002.003.002.096.055.004.002.003.001.096.055.003.002.003.002.098.053.003.002.003.002.097.053.004.002.003.001.098.053.003.001.003.002.099.052.003.001.003.002.1.05.003.002.003.002.1.05.003.002.003.001.1.05h.003l.004.003.1.048.004.001.003.002.101.048.003.001.004.002.101.046.004.002.003.001.102.046.004.002.003.001.103.045.003.002.003.001.103.045.004.001.003.002.104.043.003.001.004.002.104.042.003.002.004.001.104.042.004.001.003.002.105.04.004.002.003.001.106.04.003.002h.004l.106.04.004.001.003.002.107.038.003.001.004.001.107.038.003.001.004.001.107.037.004.001.004.001.108.036.003.001.004.001.108.035.004.001.003.001.11.034.003.001.004.001.109.033.004.002h.003l.11.033h.004l.003.002.11.031.004.001.004.001.084.023.081.028.004.001.003.001.109.037.003.001.004.001.109.036.003.001.004.001.109.035h.003l.004.002.11.033.003.001.003.001.11.033.003.001.004.001.109.031.004.002h.003l.11.031.003.001.004.001.11.03h.003l.003.001.11.029h.004l.003.002.11.027.003.001.004.001.11.027h.003l.004.001.004.001.16.022.16-.008.157-.038.147-.067.132-.092.112-.116.09-.134.062-.149.034-.157.004-.161-.025-.16-.055-.151-.082-.139-.107-.12-.127-.1-.143-.074-.124-.04h-.003l-.104-.025-.103-.026h-.002l-.095-.026h-.001l-.101-.027h-.002l-.1-.028h-.002l-.103-.03-.104-.032-.097-.03h-.002l-.103-.033-.102-.033-.101-.034-.106-.036-.027-.01-.027-.007-.107-.03-.104-.029-.104-.03h-.002l-.097-.03-.102-.032-.102-.032-.102-.034-.103-.035-.096-.034-.1-.036-.101-.037h-.002l-.094-.036-.096-.037-.097-.04h-.002l-.099-.04-.098-.042h-.002l-.092-.04-.097-.043-.095-.043-.097-.044h-.002l-.09-.043-.094-.045-.094-.046-.093-.047-.09-.046-.096-.05-.088-.047-.002-.001-.09-.049-.094-.052-.002-.002-.087-.049-.087-.05h-.002l-.088-.053h-.001l-.09-.055-.086-.052-.002-.001-.089-.055-.084-.054h-.002l-.09-.059h-.001l-.085-.056-.001-.001-.084-.056-.082-.056h-.001l-.086-.06-.082-.058H7.79l-.086-.062-.002-.002-.08-.058-.081-.06h-.001l-.085-.064-.002-.002-.076-.058-.002-.002-.082-.064-.161-.128-.162-.133-.04-.034-.132-.092-.147-.066-.157-.038-.16-.008-.16.022z"
}));
function _extends$h() {
  _extends$h = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$h.apply(this, arguments);
}
var StartEventNonInterruptingEscalationIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$h({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M16 9.209c-1.674 4.655-2.735 9.504-4.408 14.16 1.534-1.526 2.873-3.235 4.407-4.761l4.408 4.76c-1.497-4.71-2.91-9.448-4.408-14.16zm.031 2.93c.822 2.586 1.598 5.187 2.42 7.774l-2.42-2.614c-.682.598-2.453 2.886-2.34 2.389.873-2.488 1.45-5.068 2.34-7.55zM16.132.364c-1.51.016-3.055.139-4.492.614-.854.442-.266 1.861.651 1.578 2.266-.58 4.656-.596 6.944-.144.935.063 1.21-1.391.318-1.674-1.118-.26-2.274-.361-3.42-.374zm8.865 2.777c-.931-.1-1.262 1.29-.425 1.666 1.863 1.364 3.222 3.298 4.322 5.296.617.737 1.875-.145 1.398-.979-1.184-2.275-2.808-4.384-4.923-5.866a.863.863 0 00-.372-.117zM6.55 3.564c-.734.078-1.196.762-1.735 1.206C3.552 6.02 2.55 7.511 1.681 9.053c-.31.533-.71 1.33-.03 1.767.615.432 1.282-.132 1.446-.742.796-1.475 1.746-2.89 2.934-4.08.43-.548 1.292-.822 1.34-1.595a.874.874 0 00-.822-.839zm24.582 11.078c-.771-.033-1.004.82-.873 1.437.13 2.395-.471 4.797-1.615 6.897-.33.876.984 1.559 1.512.785a14.276 14.276 0 001.761-8.54.865.865 0 00-.785-.579zm-30.195.666c-.774-.06-1.032.785-.905 1.407.117 2.41.732 4.81 1.858 6.945.528.774 1.84.09 1.51-.786A15.932 15.932 0 011.728 16a.876.876 0 00-.79-.692zm24.57 11.817c-.762.099-1.243.835-1.919 1.16-1.514 1.002-3.237 1.632-4.978 2.092-.864.423-.307 1.855.616 1.591 2.528-.578 4.93-1.75 6.913-3.421.469-.522.07-1.42-.631-1.422zm-19.16.042c-.845.001-1.12 1.228-.395 1.628 1.665 1.401 3.667 2.348 5.76 2.912.618.178 1.482.565 1.893-.177.355-.628-.226-1.297-.87-1.326-1.972-.515-3.912-1.285-5.5-2.594-.26-.213-.522-.472-.888-.443z"
}));
function _extends$g() {
  _extends$g = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$g.apply(this, arguments);
}
var StartEventNonInterruptingMessageIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$g({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M8.746 10.393v11.064h14.506V10.393H8.746zm3.223 1.728h8.06c-1.428.879-2.856 2.807-4.283 3.018l-3.777-3.018zm9.557 1.018v6.59H10.473v-6.59l5.525 4.416 5.528-4.416zM16.132 0c-1.51.016-3.055.139-4.492.614-.854.442-.266 1.861.651 1.578 2.266-.58 4.656-.596 6.944-.144.935.063 1.21-1.391.318-1.674-1.118-.26-2.274-.361-3.42-.374zm8.865 2.777c-.931-.1-1.262 1.29-.425 1.666 1.863 1.364 3.222 3.298 4.322 5.296.617.737 1.875-.145 1.398-.979-1.184-2.275-2.808-4.384-4.923-5.866a.863.863 0 00-.372-.117zM6.55 3.2c-.734.078-1.196.762-1.735 1.206C3.552 5.656 2.55 7.147 1.681 8.69c-.31.533-.71 1.33-.03 1.767.615.432 1.282-.132 1.446-.742.796-1.475 1.746-2.89 2.934-4.08.43-.548 1.292-.822 1.34-1.595a.874.874 0 00-.822-.839zm24.582 11.078c-.771-.033-1.004.82-.873 1.437.13 2.395-.471 4.797-1.615 6.897-.33.876.984 1.559 1.512.785a14.276 14.276 0 001.761-8.54.865.865 0 00-.785-.579zm-30.195.666c-.774-.06-1.032.785-.905 1.407.117 2.41.732 4.81 1.858 6.945.528.774 1.84.09 1.51-.786a15.932 15.932 0 01-1.672-6.874.876.876 0 00-.79-.692zm24.57 11.817c-.762.099-1.243.835-1.919 1.16-1.514 1.002-3.237 1.632-4.978 2.092-.864.423-.307 1.855.616 1.591 2.528-.578 4.93-1.75 6.913-3.421.469-.522.07-1.42-.631-1.422zm-19.16.042c-.845.001-1.12 1.228-.395 1.628 1.665 1.401 3.667 2.348 5.76 2.912.618.178 1.482.565 1.893-.177.355-.628-.226-1.297-.87-1.326-1.972-.515-3.912-1.285-5.5-2.594-.26-.213-.522-.472-.888-.443z"
}));
function _extends$f() {
  _extends$f = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$f.apply(this, arguments);
}
var StartEventNonInterruptingMultipleIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$f({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M23.621 13.524L16 7.99l-7.622 5.534 2.911 8.952h9.422l2.911-8.952zm-1.016.33l-2.523 7.759h-8.165l-2.524-7.76L16 9.059l6.606 4.796zM16.132 0c-1.51.016-3.055.139-4.492.614-.854.442-.266 1.861.651 1.578 2.266-.58 4.656-.596 6.944-.144.935.063 1.21-1.391.318-1.674-1.118-.26-2.274-.361-3.42-.374zm8.865 2.777c-.931-.1-1.262 1.29-.425 1.666 1.863 1.364 3.222 3.298 4.322 5.296.617.737 1.875-.145 1.398-.979-1.184-2.275-2.808-4.384-4.923-5.866a.863.863 0 00-.372-.117zM6.55 3.2c-.734.078-1.196.762-1.735 1.206C3.552 5.656 2.55 7.147 1.681 8.69c-.31.533-.71 1.33-.03 1.767.615.432 1.282-.132 1.446-.742.796-1.475 1.746-2.89 2.934-4.08.43-.548 1.292-.822 1.34-1.595a.874.874 0 00-.822-.839zm24.582 11.078c-.771-.033-1.004.82-.873 1.437.13 2.395-.471 4.797-1.615 6.897-.33.876.984 1.559 1.512.785a14.276 14.276 0 001.761-8.54.865.865 0 00-.785-.579zm-30.195.666c-.774-.06-1.032.785-.905 1.407.117 2.41.732 4.81 1.858 6.945.528.774 1.84.09 1.51-.786a15.932 15.932 0 01-1.672-6.874.876.876 0 00-.79-.692zm24.57 11.817c-.762.099-1.243.835-1.919 1.16-1.514 1.002-3.237 1.632-4.978 2.092-.864.423-.307 1.855.616 1.591 2.528-.578 4.93-1.75 6.913-3.421.469-.522.07-1.42-.631-1.422zm-19.16.042c-.845.001-1.12 1.228-.395 1.628 1.665 1.401 3.667 2.348 5.76 2.912.618.178 1.482.565 1.893-.177.355-.628-.226-1.297-.87-1.326-1.972-.515-3.912-1.285-5.5-2.594-.26-.213-.522-.472-.888-.443z"
}));
function _extends$e() {
  _extends$e = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$e.apply(this, arguments);
}
var StartEventNonInterruptingParallelMultipleIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$e({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M13.503 9.016v4.428H9.075v4.98h4.428v4.428h4.98v-4.427h4.428v-4.981h-4.427V9.016h-4.981zm.83.83h3.32v4.428h4.428v3.32h-4.428v4.428h-3.32v-4.454H9.905v-3.294h4.428V9.846zM16.12 0h-.232l-.22.004h-.012l-.221.006h-.012l-.22.01h-.012l-.22.013h-.012l-.22.016h-.012l-.22.019h-.005l-.006.001-.22.021h-.006l-.005.001-.22.025h-.011l-.22.028h-.005l-.006.002-.219.03h-.005l-.006.001-.218.033-.006.001-.006.001-.217.036-.006.001-.006.001-.217.039-.006.001-.006.001-.216.042-.006.001-.006.001-.215.045-.006.001-.006.002-.215.047-.006.002-.006.001-.214.05-.006.002-.006.002-.115.029-.152.053-.14.081-.122.106-.1.126-.075.143-.047.154-.018.16.012.16.042.156.07.145.095.13.118.11.137.086.15.059.158.03h.161l.132-.022.11-.028.202-.047.203-.046.208-.043.202-.039.206-.037.206-.034.205-.03.208-.03.205-.025.209-.023.208-.02.21-.017.209-.015.207-.011.21-.009.21-.006.207-.003h.21l.21.002.207.005.207.008.212.011.207.014.208.017.209.019.208.022.205.025.206.028.207.03.208.035.205.036.202.039.052.01.16.018.16-.012.156-.042.146-.07.13-.096.109-.119.085-.136.06-.15.03-.159v-.16l-.03-.16-.059-.15-.086-.136-.109-.118-.13-.096-.145-.07-.128-.038-.057-.011-.006-.002h-.006l-.216-.042-.006-.001-.006-.001-.217-.039H18.9l-.006-.002-.217-.035-.006-.001-.006-.001-.218-.032-.006-.001-.006-.001-.218-.03h-.006l-.006-.001-.219-.027h-.011l-.22-.024-.005-.001h-.006l-.22-.021h-.006l-.006-.001-.22-.017-.005-.001h-.006L17.06.03h-.012l-.22-.012h-.012l-.22-.01h-.012l-.22-.005h-.012L16.132 0h-.012zm8.715 2.783l-.157.034-.149.063-.134.089-.116.112-.092.132-.067.147-.038.157-.008.16.021.16.051.153.079.141.103.124.102.087.052.038h.001l.087.064v.001l.082.061.002.001.076.059h.001l.084.065.082.066.002.001.079.063.002.002.077.063.081.067.002.002.077.065.076.065.001.002.08.07.078.07h.002l.075.068.077.072.002.001.073.069.077.073.072.07.002.001.077.076.07.07v.001l.075.076.07.073.002.001.074.079.002.002.069.074.069.075.074.082.07.08.002.001.068.079h.001l.067.079.068.082.065.078.001.002.068.083.067.084.063.081.001.002.067.087.002.002.063.084.001.001.064.087.008.01.008.01.095.12.093.121.09.119.087.119.088.122.086.123.084.12.081.122.001.002.084.126.08.126.08.127.077.126.079.131.074.127.075.131.073.131.07.13.07.133.069.133.045.09.086.137.109.119.13.096.144.07.156.042.16.013.16-.017.155-.047.143-.075.126-.1.106-.121.082-.14.054-.151.025-.16-.005-.16-.035-.158-.05-.124-.048-.095-.002-.004-.002-.004-.073-.14-.002-.005-.002-.004-.074-.14-.002-.004-.002-.004-.076-.14-.002-.003-.002-.004-.077-.139-.003-.004-.002-.004-.078-.138-.003-.004-.002-.003-.08-.137-.002-.004-.003-.004-.081-.136-.002-.004-.003-.004-.083-.136-.002-.003-.002-.004-.085-.135-.002-.004-.003-.003-.085-.134-.003-.004-.002-.004-.087-.132-.003-.004-.003-.004-.088-.132-.003-.003-.002-.004-.09-.13-.003-.005-.003-.003-.091-.13-.003-.004-.002-.004-.093-.129-.003-.003-.003-.004-.094-.128-.003-.004-.003-.003-.095-.127-.003-.004-.003-.004-.097-.125-.003-.004-.003-.004-.09-.114-.06-.082-.003-.003-.002-.003-.069-.091-.002-.004-.002-.003-.07-.09-.003-.003-.002-.003-.07-.09-.003-.003-.002-.003-.071-.09-.002-.003-.003-.002-.072-.089-.002-.003-.002-.003-.073-.088-.002-.003-.002-.002-.074-.087-.002-.003-.002-.003-.074-.086-.003-.003-.002-.003-.074-.086-.003-.002-.002-.003-.075-.085-.003-.003-.002-.002-.076-.084-.002-.003-.003-.003-.076-.083-.002-.003-.003-.003-.077-.082-.002-.003-.003-.002-.077-.082-.003-.003-.003-.002-.078-.081-.002-.003-.003-.003-.078-.08-.003-.002-.003-.003-.079-.08-.002-.002-.003-.002-.08-.08-.002-.002-.003-.002-.08-.078-.003-.003-.003-.002-.08-.077-.003-.003-.003-.002-.082-.077-.002-.002-.003-.002-.082-.076-.003-.002-.002-.003-.083-.075-.003-.002-.002-.003-.084-.074-.002-.002-.003-.002-.084-.074-.003-.002-.002-.002-.085-.073-.002-.002-.003-.003-.085-.071-.003-.003-.002-.002-.086-.07-.003-.003-.002-.002-.086-.07-.003-.003-.003-.002-.086-.07-.003-.002-.003-.002-.087-.069-.002-.002-.003-.002-.088-.068-.002-.002-.003-.002-.088-.067-.003-.003-.003-.002-.088-.066-.003-.002-.003-.002-.089-.066-.003-.002-.003-.002-.057-.042-.14-.082-.15-.055-.16-.026-.16.004zM6.377 3.21l-.157.037-.148.066-.111.074-.007.006-.003.002-.003.002-.086.069-.003.002-.002.002-.086.07-.003.002-.002.002-.086.07-.002.003-.003.002-.085.071-.002.002-.003.003-.084.071-.003.003-.002.002-.084.072-.003.003-.002.002-.083.073-.003.003-.002.002-.083.074-.002.002-.003.003-.082.074-.003.003-.002.002-.081.076-.003.002-.003.002-.08.077-.003.002-.003.003-.08.076-.002.003-.003.002-.08.078-.002.002-.003.003-.079.078-.002.003-.003.002-.078.08-.003.002-.002.002-.078.08-.002.003-.003.002-.077.08-.003.004-.002.002-.077.081-.002.003-.003.003-.076.082-.002.002-.003.003-.075.082-.002.003-.003.003-.074.083-.003.003-.002.003-.074.084-.003.003-.002.002-.074.085-.002.003-.002.003-.073.085-.003.003-.002.003-.072.086-.002.003-.003.003-.071.087-.003.003-.002.002-.07.088-.003.003-.002.003-.07.088-.003.003-.002.003-.07.09-.002.002-.002.003-.069.09-.002.003-.003.003-.068.09-.002.003-.002.003-.067.092-.003.003-.002.003-.067.092-.002.003-.002.003-.066.092-.002.003-.002.004-.066.093-.002.003-.002.003-.065.094-.002.003-.002.004-.064.094-.002.003-.002.004-.063.095-.002.003-.002.003-.063.097-.002.003-.002.003-.046.073-.05.07-.003.002-.002.003-.067.093-.003.003-.002.003-.066.094-.002.003-.002.003-.066.094-.002.003-.002.003-.064.094-.002.004-.002.003-.064.094-.002.004-.002.003-.062.095-.002.003-.002.003-.062.096-.002.003-.002.003-.06.096-.003.003-.002.003-.06.096-.001.004-.002.003-.059.096-.002.004-.002.003-.058.097-.002.003-.001.003-.057.098-.002.003-.002.003-.056.098-.002.003-.002.003-.055.098-.002.004-.001.003-.055.098-.001.004-.002.003-.054.099-.001.003-.002.003-.052.1-.002.002-.002.004-.051.1-.002.002-.002.004-.05.1-.002.003-.002.003-.05.1v.003l-.002.004-.05.1v.003l-.002.004-.048.1-.002.004-.001.003-.047.101-.002.003-.001.004-.013.027-.052.152-.024.16.006.16.037.157.064.148.091.133.114.114.134.09.147.065.157.036.162.006.159-.024.152-.053.14-.08.122-.105.1-.126.066-.117.01-.023.044-.095.045-.095.002-.003.042-.087.048-.097.048-.095v-.001l.048-.092.001-.001.047-.09.05-.093.002-.002.049-.09.052-.092.001-.002.051-.089.001-.002.051-.087.053-.088.001-.002.055-.091.057-.091.057-.09.001-.002.057-.089.055-.083.001-.002.06-.09.06-.088.062-.089.001-.001.06-.084.063-.088.065-.089.017-.023.016-.025.06-.094.059-.09v-.002l.058-.086.057-.086.001-.001.062-.09.062-.088.001-.002.06-.085.002-.002.06-.082.063-.087.064-.084.002-.002.061-.08.065-.084.064-.08v-.001l.067-.083.067-.082.07-.083.069-.08.063-.074.074-.083.068-.077.002-.002.07-.076.07-.075.072-.077.001-.001.067-.07.076-.078.002-.002.07-.07.075-.075.002-.002.072-.07.075-.072.002-.002.073-.069.074-.068.001-.001.08-.073.076-.068.002-.002.072-.063v-.001l.078-.067.079-.068.002-.001.08-.068.002-.002.077-.063.082-.066.001-.001.075-.06.002-.002.006-.004.117-.111.094-.131.068-.146.04-.156.01-.161-.019-.16-.049-.154-.076-.141-.102-.125-.123-.105-.14-.079-.153-.052-.16-.023-.16.007zm24.596 11.088l-.156.04-.146.067-.131.094-.112.117-.087.135-.061.15-.033.157-.004.134.007.142.005.152.004.15.002.149v.153l.001.011v.015l.004.11.002.11v.002l.002.106v.321l-.003.102-.002.106-.004.107-.005.105-.006.106-.006.106-.008.106v.002l-.008.103v.002l-.01.1-.01.105-.01.105-.013.105-.012.099v.002l-.014.108-.014.1-.016.105-.016.103v.002l-.017.099-.018.104-.019.103v.002l-.019.097-.02.104-.022.103v.001l-.022.098-.023.103v.002l-.024.096-.025.103v.002l-.024.096-.027.102v.003l-.026.093v.001l-.029.103v.002l-.03.099-.028.097v.002l-.03.095-.03.096v.001l-.033.1-.031.095v.002l-.035.1v.003l-.034.094v.003l-.035.096v.001l-.034.09v.002l-.038.098-.036.093v.002l-.038.095-.079.194-.08.188-.085.189-.087.19-.09.184-.092.183-.095.184-.05.093-.064.148-.034.158-.005.16.026.16.054.151.082.14.106.12.127.1.143.075.154.046.16.017.161-.013.156-.042.144-.071.13-.096.109-.119.072-.112.053-.099.003-.005.003-.006.102-.195.003-.006.003-.006.098-.196.003-.006.003-.006.096-.197.002-.006.003-.006.093-.2.002-.006.003-.006.09-.2.002-.006.003-.007.086-.202.003-.006.002-.006.084-.203.002-.005.001-.005.04-.102.002-.003.001-.003.04-.103.001-.003.001-.003.04-.103v-.004l.001-.003.039-.103v-.003l.002-.003.037-.104.001-.003.001-.003.037-.104v-.004l.002-.003.035-.104.002-.003v-.004l.035-.104.002-.004v-.003l.034-.105.002-.003v-.003l.034-.105v-.004l.002-.003.032-.106.001-.003.001-.003.031-.106.001-.003.001-.004.031-.106.001-.003.001-.004.03-.106v-.003l.002-.004.028-.107.001-.003.001-.003.028-.107.001-.004.001-.003.027-.107.001-.004v-.003l.027-.108.001-.003v-.004l.026-.108.001-.003v-.004l.025-.108.001-.003v-.004l.025-.108v-.004l.001-.003.023-.109v-.003l.001-.004.022-.109v-.003l.002-.004.02-.109.001-.004v-.003l.02-.11.002-.003v-.004l.02-.11v-.007l.019-.11v-.003l.001-.004.017-.11v-.004l.001-.003.017-.11v-.008l.016-.11v-.004l.001-.004.015-.11v-.008l.015-.111v-.008l.013-.111v-.007l.013-.112v-.007l.011-.112v-.004l.001-.004.01-.112v-.007l.01-.112v-.008l.008-.112v-.008l.007-.113v-.007l.007-.113v-.008l.005-.113v-.007l.005-.114v-.007l.003-.114v-.007l.003-.114v-.129l.001-.114v-.13l-.003-.114v-.008l-.003-.115v-.007l-.003-.102v-.155l-.003-.158v-.01l-.004-.158v-.01l-.006-.158v-.01l-.007-.148-.023-.16-.051-.152-.08-.14-.103-.124-.125-.102-.142-.077-.153-.05-.16-.02-.161.01zm-30.213.66l-.157.034-.149.063-.134.09-.115.113-.092.132-.067.147-.037.156-.009.134.001.11V15.95l.006.22v.012l.01.22v.012l.012.22v.006l.001.006.015.22v.005l.001.006.018.22.001.006v.006l.022.219v.006l.001.006.024.219.001.006v.006l.028.218.001.006v.006l.031.218.001.006.001.006.033.218.001.006.001.005.037.218v.006l.002.005.04.217v.006l.001.006.043.216.001.006.001.006.046.216v.005l.002.006.048.215.002.006.001.006.051.214.002.006v.006l.055.214.002.005.001.006.057.213.002.006.001.005.06.213.002.005.001.006.063.212.002.005.001.006.066.21.002.006.002.006.068.21.002.005.002.005.07.21.003.005.002.005.074.208.002.006.002.005.077.207.002.006.002.005.08.206.002.005.002.006.082.204.002.006.002.005.086.204.002.005.002.006.088.202.002.005.003.006.09.2.003.006.002.005.094.2.002.006.003.005.096.199.002.005.003.005.03.062.086.137.11.118.128.097.145.07.156.043.16.013.16-.017.155-.047.143-.074.127-.1.106-.121.081-.14.055-.15.025-.16-.005-.161-.034-.158-.05-.124-.028-.055-.092-.19-.087-.188-.087-.192-.083-.19-.08-.193-.078-.194-.076-.196-.073-.195-.07-.197-.067-.198-.065-.199-.063-.2-.059-.2-.056-.2-.055-.204-.05-.201-.049-.202-.046-.205-.043-.206-.04-.203-.038-.207-.034-.204-.032-.207-.028-.205-.026-.207-.023-.208-.02-.207-.018-.207-.014-.208-.011-.207-.009-.208-.005-.207-.002-.104-.017-.16-.046-.155-.074-.143-.1-.126-.121-.107-.139-.081-.152-.055-.159-.025-.161.004zm24.585 11.83l-.156.039-.146.068-.11.076-.015.012-.163.129-.166.127-.168.125-.17.124-.17.12-.172.118-.173.115-.176.114-.177.111-.18.11-.178.105-.182.104-.182.101-.184.1-.184.095-.189.095-.186.09-.188.089-.19.086-.19.082-.193.081-.195.078-.191.074-.197.073-.195.07-.196.065-.198.064-.198.061-.2.058-.2.055-.2.052-.2.049-.151.035-.153.05-.141.078-.125.103-.103.124-.078.14-.05.154-.022.16.009.16.038.157.067.147.093.132.116.112.134.089.149.062.158.034.16.003.133-.02.158-.035.006-.002.006-.001.213-.052.006-.002.007-.001.212-.056.006-.001.006-.002.212-.058.006-.002.006-.002.211-.061.006-.002.006-.002.21-.064.006-.002.006-.002.21-.067.005-.002.006-.002.208-.07.006-.002.006-.003.207-.073.006-.002.006-.002.206-.077.006-.002.005-.002.206-.08.005-.001.006-.003.204-.082.006-.002.005-.002.203-.085.006-.003.005-.002.202-.088.006-.002.005-.003.2-.09.006-.003.006-.003.2-.093.005-.003.005-.002.198-.096.006-.003.005-.003.197-.099.005-.002.005-.003.196-.102.005-.002.005-.003.195-.105.005-.002.005-.003.193-.107.005-.003.005-.003.191-.11.005-.003.005-.003.19-.112.005-.003.005-.003.189-.115.005-.003.005-.003.187-.117.005-.003.004-.004.186-.12.005-.003.004-.003.184-.122.005-.003.005-.004.182-.125.004-.003.005-.003.18-.128.005-.003.005-.003.179-.13.004-.003.005-.004.177-.132.004-.004.005-.003.175-.135.005-.003.004-.004.173-.137.005-.003.004-.004.019-.015.115-.113.092-.132.066-.147.038-.157.008-.16-.022-.16-.052-.153-.079-.14-.103-.124-.125-.102-.142-.078-.153-.05-.16-.02-.16.01zm-19.17.054l-.153.051-.14.079-.124.103-.103.125-.077.141-.05.153-.02.16.009.161.04.156.067.147.093.131.095.094.047.04.005.004.005.004.17.14.005.004.005.004.172.137.004.004.005.003.086.067.003.002.003.002.087.067.003.002.003.002.088.066.002.003.003.002.089.065.002.002.003.002.09.065.002.002.003.002.09.064.002.002.003.002.09.063.003.002.003.002.09.063.003.002.003.002.092.062.002.002.003.002.092.061.003.002.003.002.092.06.003.003.003.001.093.06.003.002.003.002.093.06.003.001.003.002.094.058.003.002.003.002.095.058.003.001.003.002.095.057.003.002.003.002.095.056.003.002.003.002.096.055.004.002.003.001.096.055.003.002.003.002.098.053.003.002.003.002.097.053.004.002.003.001.098.053.003.001.003.002.099.052.003.001.003.002.1.05.003.002.003.002.1.05.003.002.003.001.1.05h.003l.004.003.1.048.004.001.003.002.101.048.003.001.004.002.101.046.004.002.003.001.102.046.004.002.003.001.103.045.003.002.003.001.103.045.004.001.003.002.104.043.003.001.004.002.104.042.003.002.004.001.104.042.004.001.003.002.105.04.004.002.003.001.106.04.003.002h.004l.106.04.004.001.003.002.107.038.003.001.004.001.107.038.003.001.004.001.107.037.004.001.004.001.108.036.003.001.004.001.108.035.004.001.003.001.11.034.003.001.004.001.109.033.004.002h.003l.11.033h.004l.003.002.11.031.004.001.004.001.084.023.081.028.004.001.003.001.109.037.003.001.004.001.109.036.003.001.004.001.109.035h.003l.004.002.11.033.003.001.003.001.11.033.003.001.004.001.109.031.004.002h.003l.11.031.003.001.004.001.11.03h.003l.003.001.11.029h.004l.003.002.11.027.003.001.004.001.11.027h.003l.004.001.004.001.16.022.16-.008.157-.038.147-.067.132-.092.112-.116.09-.134.062-.149.034-.157.004-.161-.025-.16-.055-.151-.082-.139-.107-.12-.127-.1-.143-.074-.124-.04h-.003l-.104-.025-.103-.026h-.002l-.095-.026h-.001l-.101-.027h-.002l-.1-.028h-.002l-.103-.03-.104-.032-.097-.03h-.002l-.103-.033-.102-.033-.101-.034-.106-.036-.027-.01-.027-.007-.107-.03-.104-.029-.104-.03h-.002l-.097-.03-.102-.032-.102-.032-.102-.034-.103-.035-.096-.034-.1-.036-.101-.037h-.002l-.094-.036-.096-.037-.097-.04h-.002l-.099-.04-.098-.042h-.002l-.092-.04-.097-.043-.095-.043-.097-.044h-.002l-.09-.043-.094-.045-.094-.046-.093-.047-.09-.046-.096-.05-.088-.047-.002-.001-.09-.049-.094-.052-.002-.002-.087-.049-.087-.05h-.002l-.088-.053h-.001l-.09-.055-.086-.052-.002-.001-.089-.055-.084-.054h-.002l-.09-.059h-.001l-.085-.056-.001-.001-.084-.056-.082-.056h-.001l-.086-.06-.082-.058H7.79l-.086-.062-.002-.002-.08-.058-.081-.06h-.001l-.085-.064-.002-.002-.076-.058-.002-.002-.082-.064-.161-.128-.162-.133-.04-.034-.132-.092-.147-.066-.157-.038-.16-.008-.16.022z",
  opacity: ".98"
}));
function _extends$d() {
  _extends$d = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$d.apply(this, arguments);
}
var StartEventNonInterruptingSignalIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$d({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M16.007 8.82L9.21 21.022h13.596L16.007 8.82zm0 1.775l5.328 9.563H10.68l5.327-9.563zM16.14.386c-1.571.236-4.195-.284-4.9 1.381.619 1.703 2.745.069 4.085.365 1.421-.13 2.84.2 4.235.259C21.27.784 18.19.344 17 .413a20.456 20.456 0 00-.86-.027zM25 3.162c-2.19.694.401 2.26 1.181 3.094 1.083 1.152 1.954 2.484 2.715 3.864 1.48 1.005 1.845-1.26.81-2.03-1.158-1.897-2.613-3.704-4.513-4.89l-.192-.038zm-18.438.423c-1.793.712-2.909 2.548-4.01 4.061-.773.814-2.211 3.653.005 3.211 1.123-1.469 1.87-3.306 3.267-4.614.664-.7 2.73-2.013.738-2.658zm24.57 11.072c-1.659.435-.468 2.667-.99 3.895a13.427 13.427 0 01-1.497 4.435c-.23 1.659 1.991 1.165 2.018-.199a14.277 14.277 0 001.254-7.552.865.865 0 00-.785-.579zm-30.18.666c-1.677.386-.633 2.667-.608 3.876.371 1.623.792 3.35 1.79 4.696 2.382.321.571-2.338.292-3.492a15.92 15.92 0 01-.684-4.39.877.877 0 00-.79-.69zm24.558 11.81c-1.755.865-3.303 2.266-5.274 2.765-1.162-.016-3.074 1.271-1.331 2.102 2.66-.447 5.163-1.733 7.236-3.445.472-.506.06-1.432-.631-1.421zm-19.151.043c-2.004.786.416 2.405 1.43 2.913 1.608.904 3.379 1.636 5.208 1.877 1.77-.804-.228-2.094-1.357-2.073-1.75-.537-3.403-1.396-4.798-2.586l-.227-.104-.256-.027z"
}));
function _extends$c() {
  _extends$c = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$c.apply(this, arguments);
}
var StartEventNonInterruptingTimerIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$c({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.991 8.7c-3.018-.042-5.92 1.925-7.03 4.725-1.138 2.695-.509 6.011 1.537 8.102 1.99 2.142 5.267 2.93 8.013 1.927 2.877-.98 4.99-3.826 5.067-6.87.153-2.956-1.624-5.88-4.299-7.135a7.551 7.551 0 00-3.288-.75zm0 1.383c2.758-.052 5.372 1.972 6.014 4.654.704 2.578-.482 5.516-2.79 6.867-2.358 1.48-5.682 1.085-7.617-.919-2.043-1.97-2.407-5.38-.84-7.743 1.11-1.764 3.149-2.88 5.233-2.86zm1.962 1.764l-2.074 3.762c-.64.068-.793 1.04-.202 1.3.39.27.696-.18 1.052-.165h3.17v-.865h-3.182l1.993-3.614-.757-.418zM16.12.358h-.232l-.22.004h-.012l-.221.006h-.012l-.22.01h-.012l-.22.013h-.012l-.22.016h-.012l-.22.019h-.005l-.006.001-.22.021h-.006l-.005.001-.22.025h-.011l-.22.028h-.005l-.006.002-.219.03h-.005l-.006.001-.218.033-.006.001-.006.001-.217.036-.006.001-.006.001-.217.039-.006.001-.006.001-.216.042-.006.001-.006.001-.215.045-.006.001-.006.002-.215.047-.006.002-.006.001-.214.05-.006.002-.006.002-.115.029-.152.053-.14.081-.122.106-.1.126-.075.143-.047.154-.018.16.012.16.042.156.07.145.095.13.118.11.137.086.15.059.158.03h.161l.132-.022.11-.028.202-.047.203-.046.208-.043.202-.039.206-.037.206-.034.205-.03.208-.03.205-.025.209-.023.208-.02.21-.017.209-.015.207-.011.21-.009.21-.006.207-.003h.21l.21.002.207.005.207.008.212.011.207.014.208.017.209.019.208.022.205.025.206.028.207.03.208.035.205.036.202.039.052.01.16.018.16-.012.156-.042.146-.07.13-.096.109-.119.085-.136.06-.15.03-.159v-.16l-.03-.16-.059-.15-.086-.136L19.823.9l-.13-.096-.145-.07-.128-.038-.057-.011-.006-.002h-.006L19.135.64l-.006-.001-.006-.001-.217-.039H18.9l-.006-.002-.217-.035-.006-.001-.006-.001-.218-.032-.006-.001-.006-.001-.218-.03h-.006l-.006-.001-.219-.027h-.011l-.22-.024-.005-.001h-.006l-.22-.021h-.006L17.512.42l-.22-.017-.005-.001h-.006l-.22-.015h-.012l-.22-.012h-.012l-.22-.01h-.012l-.22-.005h-.012l-.221-.003h-.012zm8.715 2.783l-.157.034-.149.063-.134.089-.116.112-.092.132-.067.147-.038.157-.008.16.021.16.051.153.079.141.103.124.102.087.052.038h.001l.087.064v.001l.082.061.002.001.076.059h.001l.084.065.082.066.002.001.079.063.002.002.077.063.081.067.002.002.077.065.076.065.001.002.08.07.078.07h.002l.075.068.077.072.002.001.073.069.077.073.072.07.002.001.077.076.07.07v.001l.075.076.07.073.002.001.074.079.002.002.069.074.069.075.074.082.07.08.002.001.068.079h.001l.067.079.068.082.065.078.001.002.068.083.067.084.063.081.001.002.067.087.002.002.063.084.001.001.064.087.008.01.008.01.095.12.093.121.09.119.087.119.088.122.086.123.084.12.081.122.001.002.084.126.08.126.08.127.077.126.079.131.074.127.075.131.073.131.07.13.07.133.069.133.045.09.086.137.109.119.13.096.144.07.156.042.16.013.16-.017.155-.047.143-.075.126-.1.106-.121.082-.14.054-.151.025-.16-.005-.16-.035-.158-.05-.124-.048-.095-.002-.004-.002-.004-.073-.14-.002-.005-.002-.004-.074-.14-.002-.004-.002-.004-.076-.14-.002-.003-.002-.004-.077-.139-.003-.004-.002-.004-.078-.138-.003-.004-.002-.003-.08-.137-.002-.004-.003-.004-.081-.136-.002-.004-.003-.004-.083-.136-.002-.003-.002-.004-.085-.135-.002-.004-.003-.003-.085-.134-.003-.004-.002-.004-.087-.132-.003-.004-.003-.004-.088-.132-.003-.003-.002-.004-.09-.13-.003-.005-.003-.003-.091-.13-.003-.004-.002-.004-.093-.129-.003-.003-.003-.004-.094-.128-.003-.004-.003-.003-.095-.127-.003-.004-.003-.004-.097-.125-.003-.004-.003-.004-.09-.114-.06-.082-.003-.003-.002-.003-.069-.091-.002-.004-.002-.003-.07-.09-.003-.003-.002-.003-.07-.09-.003-.003-.002-.003-.071-.09-.002-.003-.003-.002-.072-.089-.002-.003-.002-.003-.073-.088-.002-.003-.002-.002-.074-.087-.002-.003-.002-.003-.074-.086-.003-.003-.002-.003-.074-.086-.003-.002-.002-.003-.075-.085-.003-.003-.002-.002-.076-.084-.002-.003-.003-.003-.076-.083-.002-.003-.003-.003-.077-.082-.002-.003-.003-.002-.077-.082-.003-.003-.003-.002-.078-.081-.002-.003-.003-.003-.078-.08-.003-.002-.003-.003-.079-.08-.002-.002-.003-.002-.08-.08-.002-.002-.003-.002-.08-.078-.003-.003-.003-.002-.08-.077-.003-.003-.003-.002-.082-.077-.002-.002-.003-.002-.082-.076-.003-.002-.002-.003-.083-.075-.003-.002-.002-.003-.084-.074-.002-.002-.003-.002-.084-.074-.003-.002-.002-.002-.085-.073-.002-.002-.003-.003-.085-.071-.003-.003-.002-.002-.086-.07-.003-.003-.002-.002-.086-.07-.003-.003-.003-.002-.086-.07-.003-.002-.003-.002-.087-.069-.002-.002-.003-.002-.088-.068-.002-.002-.003-.002-.088-.067-.003-.003-.003-.002-.088-.066-.003-.002-.003-.002-.089-.066-.003-.002-.003-.002-.057-.042-.14-.082-.15-.055-.16-.026-.16.004zm-18.458.426l-.157.037-.148.066-.111.074-.007.006-.003.002-.003.002-.086.069-.003.002-.002.002-.086.07-.003.002-.002.002-.086.07-.002.003-.003.002-.085.071-.002.002-.003.003-.084.071-.003.003-.002.002-.084.072-.003.003-.002.002-.083.073-.003.003-.002.002-.083.074-.002.002-.003.003-.082.074-.003.003-.002.002-.081.076-.003.002-.003.002-.08.077-.003.002-.003.003-.08.076-.002.003-.003.002-.08.078-.002.002-.003.003-.079.078-.002.003-.003.002-.078.08-.003.002-.002.002-.078.08-.002.003-.003.002-.077.08-.003.004-.002.002-.077.081-.002.003-.003.003-.076.082-.002.002-.003.003-.075.082-.002.003-.003.003-.074.083-.003.003-.002.003-.074.084-.003.003-.002.002-.074.085-.002.003-.002.003-.073.085-.003.003-.002.003-.072.086-.002.003-.003.003-.071.087-.003.003-.002.002-.07.088-.003.003-.002.003-.07.088-.003.003-.002.003-.07.09-.002.002-.002.003-.069.09-.002.003-.003.003-.068.09-.002.003-.002.003-.067.092-.003.003-.002.003-.067.092-.002.003-.002.003-.066.092-.002.003-.002.004-.066.093-.002.003-.002.003-.065.094-.002.003-.002.004-.064.094-.002.003-.002.004-.063.095-.002.003-.002.003-.063.097-.002.003-.002.003-.046.073-.05.07-.003.002-.002.003-.067.093-.003.003-.002.003-.066.094-.002.003-.002.003-.066.094-.002.003-.002.003-.064.094-.002.004-.002.003-.064.094-.002.004-.002.003-.062.095-.002.003-.002.003-.062.096-.002.003-.002.003-.06.096-.003.003-.002.003-.06.096-.001.004-.002.003-.059.096-.002.004-.002.003-.058.097-.002.003-.001.003-.057.098-.002.003-.002.003-.056.098-.002.003-.002.003-.055.098-.002.004-.001.003-.055.098-.001.004-.002.003-.054.099-.001.003-.002.003-.052.1-.002.002-.002.004-.051.1-.002.002-.002.004-.05.1-.002.003-.002.003-.05.1v.003l-.002.004-.05.1V9.5l-.002.004-.048.1-.002.004-.001.003-.047.101-.002.003-.001.004-.013.027-.052.152-.024.16.006.16.037.157.064.148.091.133.114.114.134.09.147.065.157.036.162.006.159-.024.152-.053.14-.08.122-.105.1-.126.066-.117.01-.023.044-.095.045-.095.002-.003.042-.087.048-.097.048-.095v-.001l.048-.092.001-.001.047-.09.05-.093.002-.002.049-.09.052-.092.001-.002.051-.089.001-.002.051-.087.053-.088.001-.002.055-.091.057-.091.057-.09.001-.002.057-.089.055-.083.001-.002.06-.09.06-.088.062-.089.001-.001.06-.084.063-.088.065-.089.017-.023.016-.025.06-.094.059-.09v-.002l.058-.086.057-.086.001-.001.062-.09.062-.088.001-.002.06-.085.002-.002.06-.082.063-.087.064-.084.002-.002.061-.08.065-.084.064-.08v-.001l.067-.083.067-.082.07-.083.069-.08.063-.074.074-.083.068-.077.002-.002.07-.076.07-.075.072-.077.001-.001.067-.07.076-.078.002-.002.07-.07.075-.075.002-.002.072-.07.075-.072.002-.002.073-.069.074-.068.001-.001.08-.073.076-.068.002-.002.072-.063v-.001l.078-.067.079-.068.002-.001.08-.068.002-.002.077-.063.082-.066.001-.001.075-.06.002-.002.006-.004.117-.111.094-.131.068-.146.04-.156.01-.161-.019-.16-.049-.154-.076-.141-.102-.125-.123-.105-.14-.079-.153-.052-.16-.023-.16.007zm24.596 11.088l-.156.04-.146.067-.131.094-.112.117-.087.135-.061.15-.033.157-.004.134.007.142.005.152.004.15.002.149v.153l.001.011v.015l.004.11.002.11v.002l.002.106v.321l-.003.102-.002.106-.004.107-.005.105-.006.106-.006.106-.008.106v.002l-.008.103v.002l-.01.1-.01.105-.01.105-.013.105-.012.099v.002l-.014.108-.014.1-.016.105-.016.103v.002l-.017.099-.018.104-.019.103v.002l-.019.097-.02.104-.022.103v.001l-.022.098-.023.103v.002l-.024.096-.025.103v.002l-.024.096-.027.102v.003l-.026.093v.001l-.029.103v.002l-.03.099-.028.097v.002l-.03.095-.03.096v.001l-.033.1-.031.095v.002l-.035.1v.003l-.034.094v.003l-.035.096v.001l-.034.09v.002l-.038.098-.036.093v.002l-.038.095-.079.194-.08.188-.085.189-.087.19-.09.184-.092.183-.095.184-.05.093-.064.148-.034.158-.005.16.026.16.054.151.082.14.106.12.127.1.143.075.154.046.16.017.161-.013.156-.042.144-.071.13-.096.109-.119.072-.112.053-.099.003-.005.003-.006.102-.195.003-.006.003-.006.098-.196.003-.006.003-.006.096-.197.002-.006.003-.006.093-.2.002-.006.003-.006.09-.2.002-.006.003-.007.086-.202.003-.006.002-.006.084-.203.002-.005.001-.005.04-.102.002-.003.001-.003.04-.103.001-.003.001-.003.04-.103v-.004l.001-.003.039-.103v-.003l.002-.003.037-.104.001-.003.001-.003.037-.104v-.004l.002-.003.035-.104.002-.003v-.004l.035-.104.002-.004v-.003l.034-.105.002-.003v-.003l.034-.105v-.004l.002-.003.032-.106.001-.003.001-.003.031-.106.001-.003.001-.004.031-.106.001-.003.001-.004.03-.106v-.003l.002-.004.028-.107.001-.003.001-.003.028-.107.001-.004.001-.003.027-.107.001-.004v-.003l.027-.108.001-.003v-.004l.026-.108.001-.003v-.004l.025-.108.001-.003v-.004l.025-.108v-.004l.001-.003.023-.109v-.003l.001-.004.022-.109v-.003l.002-.004.02-.109.001-.004v-.003l.02-.11.002-.003v-.004l.02-.11v-.007l.019-.11v-.003l.001-.004.017-.11v-.004l.001-.003.017-.11v-.008l.016-.11v-.004l.001-.004.015-.11v-.008l.015-.111v-.008l.013-.111v-.007l.013-.112v-.007l.011-.112v-.004l.001-.004.01-.112v-.007l.01-.112v-.008l.008-.112v-.008l.007-.113v-.007l.007-.113v-.008l.005-.113v-.007l.005-.114v-.007l.003-.114v-.007l.003-.114v-.129l.001-.114v-.13l-.003-.114V16.5l-.003-.115v-.007l-.003-.102v-.155l-.003-.158v-.01l-.004-.158v-.01l-.006-.158v-.01l-.007-.148-.023-.16-.051-.152-.08-.14-.103-.124-.125-.102-.142-.077-.153-.05-.16-.02-.161.01zm-30.213.66l-.157.034-.149.063-.134.09-.115.113-.092.132-.067.147-.037.156-.009.134.001.11V16.308l.006.22v.012l.01.22v.012l.012.22v.006l.001.006.015.22v.005l.001.006.018.22.001.006v.006l.022.219v.006l.001.006.024.219.001.006v.006l.028.218.001.006v.006l.031.218.001.006.001.006.033.218.001.006.001.005.037.218v.006l.002.005.04.217v.006l.001.006.043.216.001.006.001.006.046.216v.005l.002.006.048.215.002.006.001.006.051.214.002.006v.006l.055.214.002.005.001.006.057.213.002.006.001.005.06.213.002.005.001.006.063.212.002.005.001.006.066.21.002.006.002.006.068.21.002.005.002.005.07.21.003.005.002.005.074.208.002.006.002.005.077.207.002.006.002.005.08.206.002.005.002.006.082.204.002.006.002.005.086.204.002.005.002.006.088.202.002.005.003.006.09.2.003.006.002.005.094.2.002.006.003.005.096.199.002.005.003.005.03.062.086.137.11.118.128.097.145.07.156.043.16.013.16-.017.155-.047.143-.074.127-.1.106-.121.081-.14.055-.15.025-.16-.005-.161-.034-.158-.05-.124-.028-.055-.092-.19-.087-.188-.087-.192-.083-.19-.08-.193-.078-.194-.076-.196-.073-.195-.07-.197-.067-.198-.065-.199-.063-.2-.059-.2-.056-.2-.055-.204-.05-.201-.049-.202-.046-.205-.043-.206-.04-.203-.038-.207-.034-.204-.032-.207-.028-.205-.026-.207-.023-.208-.02-.207-.018-.207-.014-.208-.011-.207-.009-.208-.005-.207-.002-.104-.017-.16-.046-.155-.074-.143-.1-.126-.121-.107-.139-.081-.152-.055-.159-.025-.161.004zm24.585 11.83l-.156.039-.146.068-.11.076-.015.012-.163.129-.166.127-.168.125-.17.124-.17.12-.172.118-.173.115-.176.114-.177.111-.18.11-.178.105-.182.104-.182.101-.184.1-.184.095-.189.095-.186.09-.188.089-.19.086-.19.082-.193.081-.195.078-.191.074-.197.073-.195.07-.196.065-.198.064-.198.061-.2.058-.2.055-.2.052-.2.049-.151.035-.153.05-.141.078-.125.103-.103.124-.078.14-.05.154-.022.16.009.16.038.157.067.147.093.132.116.112.134.089.149.062.158.034.16.003.133-.02.158-.035.006-.002.006-.001.213-.052.006-.002.007-.001.212-.056.006-.001.006-.002.212-.058.006-.002.006-.002.211-.061.006-.002.006-.002.21-.064.006-.002.006-.002.21-.067.005-.002.006-.002.208-.07.006-.002.006-.003.207-.073.006-.002.006-.002.206-.077.006-.002.005-.002.206-.08.005-.001.006-.003.204-.082.006-.002.005-.002.203-.085.006-.003.005-.002.202-.088.006-.002.005-.003.2-.09.006-.003.006-.003.2-.093.005-.003.005-.002.198-.096.006-.003.005-.003.197-.099.005-.002.005-.003.196-.102.005-.002.005-.003.195-.105.005-.002.005-.003.193-.107.005-.003.005-.003.191-.11.005-.003.005-.003.19-.112.005-.003.005-.003.189-.115.005-.003.005-.003.187-.117.005-.003.004-.004.186-.12.005-.003.004-.003.184-.122.005-.003.005-.004.182-.125.004-.003.005-.003.18-.128.005-.003.005-.003.179-.13.004-.003.005-.004.177-.132.004-.004.005-.003.175-.135.005-.003.004-.004.173-.137.005-.003.004-.004.019-.015.115-.113.092-.132.066-.147.038-.157.008-.16-.022-.16-.052-.153-.079-.14-.103-.124-.125-.102-.142-.078-.153-.05-.16-.02-.16.01zm-19.17.054l-.153.051-.14.079-.124.103-.103.125-.077.141-.05.153-.02.16.009.161.04.156.067.147.093.131.095.094.047.04.005.004.005.004.17.14.005.004.005.004.172.137.004.004.005.003.086.067.003.002.003.002.087.067.003.002.003.002.088.066.002.003.003.002.089.065.002.002.003.002.09.065.002.002.003.002.09.064.002.002.003.002.09.063.003.002.003.002.09.063.003.002.003.002.092.062.002.002.003.002.092.061.003.002.003.002.092.06.003.003.003.001.093.06.003.002.003.002.093.06.003.001.003.002.094.058.003.002.003.002.095.058.003.001.003.002.095.057.003.002.003.002.095.056.003.002.003.002.096.055.004.002.003.001.096.055.003.002.003.002.098.053.003.002.003.002.097.053.004.002.003.001.098.053.003.001.003.002.099.052.003.001.003.002.1.05.003.002.003.002.1.05.003.002.003.001.1.05h.003l.004.003.1.048.004.001.003.002.101.048.003.001.004.002.101.046.004.002.003.001.102.046.004.002.003.001.103.045.003.002.003.001.103.045.004.001.003.002.104.043.003.001.004.002.104.042.003.002.004.001.104.042.004.001.003.002.105.04.004.002.003.001.106.04.003.002h.004l.106.04.004.001.003.002.107.038.003.001.004.001.107.038.003.001.004.001.107.037.004.001.004.001.108.036.003.001.004.001.108.035.004.001.003.001.11.034.003.001.004.001.109.033.004.002h.003l.11.033h.004l.003.002.11.031.004.001.004.001.084.023.081.028.004.001.003.001.109.037.003.001.004.001.109.036.003.001.004.001.109.035h.003l.004.002.11.033.003.001.003.001.11.033.003.001.004.001.109.031.004.002h.003l.11.031.003.001.004.001.11.03h.003l.003.001.11.029h.004l.003.002.11.027.003.001.004.001.11.027h.003l.004.001.004.001.16.022.16-.008.157-.038.147-.067.132-.092.112-.116.09-.134.062-.149.034-.157.004-.161-.025-.16-.055-.151-.082-.139-.107-.12-.127-.1-.143-.074-.124-.04h-.003l-.104-.025-.103-.026h-.002l-.095-.026h-.001l-.101-.027h-.002l-.1-.028h-.002l-.103-.03-.104-.032-.097-.03h-.002l-.103-.033-.102-.033-.101-.034-.106-.036-.027-.01-.027-.007-.107-.03-.104-.029-.104-.03h-.002l-.097-.03-.102-.032-.102-.032-.102-.034-.103-.035-.096-.034-.1-.036-.101-.037h-.002l-.094-.036-.096-.037-.097-.04h-.002l-.099-.04-.098-.042h-.002l-.092-.04-.097-.043-.095-.043-.097-.044h-.002l-.09-.043-.094-.045-.094-.046-.093-.047-.09-.046-.096-.05-.088-.047-.002-.001-.09-.049-.094-.052-.002-.002-.087-.049-.087-.05h-.002l-.088-.053h-.001l-.09-.055-.086-.052-.002-.001-.089-.055-.084-.054h-.002l-.09-.059h-.001l-.085-.056-.001-.001-.084-.056-.082-.056h-.001l-.086-.06-.082-.058H7.79l-.086-.062-.002-.002-.08-.058-.081-.06h-.001l-.085-.064-.002-.002-.076-.058-.002-.002-.082-.064-.161-.128-.162-.133-.04-.034-.132-.092-.147-.066-.157-.038-.16-.008-.16.022z"
}));
function _extends$b() {
  _extends$b = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$b.apply(this, arguments);
}
var StartEventNoneIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$b({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.847.004C9.61-.016 3.624 4.014 1.257 9.78-1.235 15.49.06 22.581 4.42 27.034c4.193 4.513 11.101 6.17 16.887 4.058 5.996-2.042 10.423-7.93 10.664-14.268.403-6.228-3.26-12.441-8.87-15.154A15.924 15.924 0 0015.846.004zm.439 1.729c6.105.033 11.856 4.45 13.435 10.359 1.678 5.653-.592 12.198-5.463 15.547-5.06 3.719-12.564 3.45-17.343-.625-4.814-3.84-6.538-10.94-4.067-16.57 2.14-5.206 7.515-8.775 13.147-8.71.097-.001.194-.002.29-.001z"
}));
function _extends$a() {
  _extends$a = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$a.apply(this, arguments);
}
var StartEventParallelMultipleIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$a({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.847 0C9.61-.02 3.624 4.01 1.257 9.775-1.235 15.485.06 22.577 4.42 27.03c4.193 4.513 11.101 6.17 16.887 4.058 5.996-2.042 10.423-7.93 10.664-14.268.403-6.228-3.26-12.441-8.87-15.154A15.924 15.924 0 0015.846 0zm.439 1.729c6.105.033 11.856 4.45 13.435 10.359 1.678 5.653-.592 12.198-5.463 15.547-5.06 3.719-12.564 3.45-17.343-.625C2.101 23.17.377 16.07 2.848 10.44c2.134-5.2 7.522-8.78 13.147-8.71.097-.001.194-.002.29-.001zM13.504 9.08v4.427H9.077v4.98h4.427v4.427h4.98v-4.427h4.428v-4.98h-4.427V9.08h-4.98zm.83.83h3.32v4.427h4.428v3.32h-4.427v4.427h-3.32v-4.453H9.906v-3.294h4.427V9.91z"
}));
function _extends$9() {
  _extends$9 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$9.apply(this, arguments);
}
var StartEventSignalIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$9({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M15.995.005C9.705-.08 3.643 3.968 1.257 9.78-1.235 15.49.06 22.581 4.42 27.034c4.193 4.513 11.102 6.17 16.887 4.058 5.996-2.042 10.423-7.93 10.664-14.269.403-6.227-3.26-12.44-8.87-15.153A15.924 15.924 0 0015.994.005zm0 1.73c6.213-.108 12.122 4.355 13.726 10.357 1.678 5.653-.592 12.198-5.463 15.547-5.06 3.719-12.564 3.45-17.343-.626-4.814-3.838-6.538-10.939-4.067-16.57 2.14-5.205 7.515-8.774 13.147-8.708zm0 6.776L9.19 20.724H22.8L15.995 8.511zm0 1.777l5.332 9.572H10.662l5.333-9.572z"
}));
function _extends$8() {
  _extends$8 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$8.apply(this, arguments);
}
var StartEventTimerIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$8({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M16 0C7.174 0 0 7.174 0 16s7.174 16 16 16 16-7.174 16-16S24.826 0 16 0zm0 1.73c7.892 0 14.27 6.378 14.27 14.27 0 7.891-6.379 14.27-14.27 14.27S1.73 23.891 1.73 16C1.73 8.108 8.108 1.73 16 1.73zm-.143 6.676c-2.967.02-5.797 1.97-6.89 4.727-1.138 2.695-.51 6.012 1.537 8.102 1.99 2.142 5.268 2.932 8.014 1.928 2.878-.98 4.992-3.827 5.068-6.87.153-2.957-1.624-5.881-4.3-7.137a7.552 7.552 0 00-3.43-.75zm.27 1.383c2.71.012 5.254 2.015 5.886 4.656.704 2.577-.482 5.517-2.791 6.867-2.358 1.48-5.682 1.085-7.618-.918-2.043-1.971-2.407-5.381-.84-7.745 1.11-1.763 3.15-2.88 5.234-2.86h.13zm1.833 1.765l-2.074 3.763c-.64.068-.793 1.04-.202 1.3.39.27.696-.18 1.052-.165h3.17v-.865h-3.181l1.992-3.615-.757-.418z"
}));
function _extends$7() {
  _extends$7 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$7.apply(this, arguments);
}
var SubprocessCollapsedIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$7({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M5.637 3A5.644 5.644 0 000 8.637v15.417a5.644 5.644 0 005.637 5.637h20.726A5.644 5.644 0 0032 24.054V8.637A5.644 5.644 0 0026.363 3H5.637zm0 1.778h20.726a3.83 3.83 0 013.859 3.859v15.417a3.83 3.83 0 01-3.859 3.858h-4.201V16.695H9.838v11.217H5.637a3.83 3.83 0 01-3.859-3.858V8.637a3.83 3.83 0 013.859-3.859zm5.33 13.046h10.066v10.065H10.967V17.824zm4.189 1.431V22.06H12.35v1.689h2.804V26.554h1.69V23.749h2.804V22.06h-2.804V19.255h-1.69z"
}));
function _extends$6() {
  _extends$6 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$6.apply(this, arguments);
}
var SubprocessExpandedIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$6({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M5.636 3A5.642 5.642 0 000 8.636v15.418a5.643 5.643 0 005.636 5.636h20.728A5.643 5.643 0 0032 24.054V8.636A5.642 5.642 0 0026.364 3H5.636zm0 1.778h20.728a3.83 3.83 0 013.858 3.858v15.418a3.83 3.83 0 01-3.858 3.858h-4.203V16.723H9.84v11.189H5.636a3.83 3.83 0 01-3.858-3.858V8.636a3.83 3.83 0 013.858-3.858zm5.331 13.074h10.066v10.06H10.967v-10.06zm1.336 3.996v1.711h7.394v-1.71h-7.394z"
}));
function _extends$5() {
  _extends$5 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$5.apply(this, arguments);
}
var TaskNoneIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$5({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M6.494 2.667C2.916 2.667 0 5.57 0 9.142v13.383C0 26.097 2.916 29 6.494 29h19.012C29.084 29 32 26.097 32 22.525V9.142c0-3.572-2.916-6.475-6.494-6.475H6.494zm0 2h19.012c2.509 0 4.494 1.98 4.494 4.475v13.383C30 25.02 28.015 27 25.506 27H6.494C3.985 27 2 25.02 2 22.525V9.142c0-2.495 1.985-4.475 4.494-4.475z"
}));
function _extends$4() {
  _extends$4 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$4.apply(this, arguments);
}
var TextAnnotationicon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$4({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M22.087 0v31.647H32v-1.788h-8.125V1.788H32V0h-9.913zm-2.924 13.999l-2.737 2.167 2.167 2.738 2.738-2.167-2.168-2.738zm-5.475 4.335L10.95 20.5l2.168 2.738 2.737-2.168-2.167-2.737zm-5.475 4.335l-2.738 2.167 2.168 2.738 2.737-2.168-2.167-2.737zm-5.476 4.335L0 29.17l2.167 2.738 2.738-2.168-2.168-2.737z"
}));
function _extends$3() {
  _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
var TransactionIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$3({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  d: "M5.422 3A5.424 5.424 0 000 8.422v15.822a5.424 5.424 0 005.422 5.423h21.156A5.424 5.424 0 0032 24.244V8.422A5.424 5.424 0 0026.578 3H5.422zm0 1.244h21.156a4.155 4.155 0 014.178 4.178v15.822a4.155 4.155 0 01-4.178 4.178H5.422a4.155 4.155 0 01-4.178-4.178V8.422a4.155 4.155 0 014.178-4.178zm1.056 1.778a3.373 3.373 0 00-3.367 3.366v13.89a3.373 3.373 0 003.367 3.366h19.044a3.373 3.373 0 003.367-3.366V9.388a3.373 3.373 0 00-3.367-3.366H6.478zm0 1.245h19.044c1.187 0 2.122.935 2.122 2.121v13.89a2.104 2.104 0 01-2.122 2.122H6.478a2.104 2.104 0 01-2.122-2.122V9.388c0-1.186.935-2.121 2.122-2.121z"
}));
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
var UserTaskIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$2({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ compat_module_default.createElement("path", {
  fillRule: "evenodd",
  d: "M10.263 7.468c-1.698 0-2.912 1.305-2.915 2.791v.001c0 .45.121.924.311 1.352.138.309.308.593.516.82-1.235.423-2.683 1.119-3.414 2.49l-.04.075v4.44h11.083v-4.44l-.04-.074c-.72-1.352-2.136-2.047-3.36-2.471.597-.608.774-1.392.774-2.192-.004-1.487-1.218-2.792-2.915-2.792zm-1.16 1.583c.08 0 .165.003.26.008.757.045 1.012.181 1.207.31.196.13.334.252.851.268.404-.016.598-.087.737-.169.056-.033.103-.067.152-.1.128.275.197.578.198.893 0 .894-.154 1.52-.975 2.034l.08.604c.171.052.348.11.527.171.025.105.054.242.073.387.02.153.029.311.016.43a.422.422 0 01-.056.19c-.417.417-1.157.66-1.908.66-.75 0-1.49-.243-1.908-.66a.422.422 0 01-.056-.19 1.949 1.949 0 01.016-.43c.02-.146.049-.284.074-.388.177-.062.352-.118.521-.17l.048-.648a.616.616 0 00-.126-.118c-.183-.138-.405-.44-.562-.793-.157-.353-.254-.757-.254-1.08 0-.387.105-.758.297-1.079l.11-.04c.143-.046.339-.09.679-.09zm-1.448 4.304l-.002.014c-.025.185-.04.387-.018.589.021.202.074.42.248.593.595.594 1.494.857 2.382.857.889 0 1.788-.263 2.382-.857.174-.174.227-.391.249-.593a2.496 2.496 0 00-.018-.59l-.002-.01c.903.396 1.776.963 2.258 1.81v3.599H13.53v-2.538h-.67v2.538H7.651v-2.538h-.67v2.538H5.39v-3.599c.483-.849 1.359-1.416 2.264-1.813zM6.495 3C2.914 3 0 5.903 0 9.475v13.383c0 3.572 2.916 6.475 6.494 6.475h19.012c3.578 0 6.494-2.903 6.494-6.475V9.475C32 5.903 29.084 3 25.506 3H6.494zm0 2h19.01C28.016 5 30 6.98 30 9.475v13.383c0 2.495-1.985 4.475-4.494 4.475H6.494C3.985 27.333 2 25.353 2 22.858V9.475C2 6.98 3.985 5 6.494 5z"
}));
var iconsByType = {
  "Association": AssociationIcon,
  "BusinessRuleTask": BusinessRuleTaskIcon,
  "CallActivity": CallActivityIcon,
  "Collaboration": CollaborationIcon,
  "ConditionalFlow": ConditionalFlowIcon,
  "SequenceFlow": ConnectionIcon,
  "DataInput": DataInputIcon,
  "DataInputAssociation": DataInputOutputAssociationIcon,
  "DataOutput": DataOutputIcon,
  "DataOutputAssociation": DataInputOutputAssociationIcon,
  "DataObjectReference": DataObjectIcon,
  "DataStoreReference": DataStoreIcon,
  "DefaultFlow": DefaultFlowIcon,
  "CancelEndEvent": EndEventCancelIcon,
  "CompensateEndEvent": EndEventCompensationIcon,
  "ErrorEndEvent": EndEventErrorIcon,
  "EscalationEndEvent": EndEventEscalationIcon,
  "LinkEndEvent": EndEventLinkIcon,
  "MessageEndEvent": EndEventMessageIcon,
  "MultipleEndEvent": EndEventMultipleIcon,
  "EndEvent": EndEventNoneIcon,
  "SignalEndEvent": EndEventSignalIcon,
  "TerminateEndEvent": EndEventTerminateIcon,
  "EventSubProcess": EventSubProcessExpandedIcon,
  "ComplexGateway": GatewayComplexIcon,
  "EventBasedGateway": GatewayEventBasedIcon,
  "ExclusiveGateway": GatewayXorIcon,
  "Gateway": GatewayNoneIcon,
  "InclusiveGateway": GatewayOrIcon,
  "ParallelGateway": GatewayParallelIcon,
  "Group": GroupIcon,
  "CancelIntermediateCatchEvent": IntermediateEventCatchCancelIcon,
  "CompensateIntermediateCatchEvent": IntermediateEventCatchCompensationIcon,
  "ConditionalIntermediateCatchEvent": IntermediateEventCatchConditionIcon,
  "ErrorIntermediateCatchEvent": IntermediateEventCatchErrorIcon,
  "EscalationIntermediateCatchEvent": IntermediateEventCatchEscalationIcon,
  "LinkIntermediateCatchEvent": IntermediateEventCatchLinkIcon,
  "MessageIntermediateCatchEvent": IntermediateEventCatchMessageIcon,
  "MultipleIntermediateCatchEvent": IntermediateEventCatchMultipleIcon,
  "ConditionalIntermediateCatchEventNonInterrupting": IntermediateEventCatchNonInterruptingConditionIcon,
  "EscalationIntermediateCatchEventNonInterrupting": IntermediateEventCatchNonInterruptingEscalationIcon,
  "MessageIntermediateCatchEventNonInterrupting": IntermediateEventCatchNonInterruptingMessageIcon,
  "MultipleIntermediateCatchEventNonInterrupting": IntermediateEventCatchNonInterruptingMultipleIcon,
  "ParallelIntermediateCatchEventNonInterrupting": IntermediateEventCatchNonInterruptingParallelIcon,
  "SignalIntermediateCatchEventNonInterrupting": IntermediateEventCatchNonInterruptingSignalIcon,
  "TimerIntermediateCatchEventNonInterrupting": IntermediateEventCatchNonInterruptingTimerIcon,
  "ParallelMultipleIntermediateCatchEvent": IntermediateEventCatchParallelMultipleIcon,
  "SignalIntermediateCatchEvent": IntermediateEventCatchSignalIcon,
  "TimerIntermediateCatchEvent": IntermediateEventCatchTimerIcon,
  "IntermediateThrowEvent": IntermediateEventNoneIcon,
  "CompensateIntermediateThrowEvent": IntermediateEventThrowCompensationIcon,
  "EscalationIntermediateThrowEvent": IntermediateEventThrowEscalationIcon,
  "LinkIntermediateThrowEvent": IntermediateEventThrowLinkIcon,
  "MessageIntermediateThrowEvent": IntermediateEventThrowMessageIcon,
  "MultipleIntermediateThrowEvent": IntermediateEventThrowMultipleIcon,
  "SignalIntermediateThrowEvent": IntermediateEventThrowSignalIcon,
  "Lane": LaneIcon,
  "ManualTask": ManualTaskIcon,
  "MessageFlow": MessageFlowIcon,
  "Participant": ParticipantIcon,
  "Process": ProcessIcon,
  "ReceiveTask": ReceiveTaskIcon,
  "ScriptTask": ScriptTaskIcon,
  "SendTask": SendTaskIcon,
  "ServiceTask": ServiceTaskIcon,
  "CompensateStartEvent": StartEventCompensationIcon,
  "ConditionalStartEvent": StartEventConditionIcon,
  "ErrorStartEvent": StartEventErrorIcon,
  "EscalationStartEvent": StartEventEscalationIcon,
  "MessageStartEvent": StartEventMessageIcon,
  "MultipleStartEvent": StartEventMultipleIcon,
  "ConditionalStartEventNonInterrupting": StartEventNonInterruptingConditionIcon,
  "EscalationStartEventNonInterrupting": StartEventNonInterruptingEscalationIcon,
  "MessageStartEventNonInterrupting": StartEventNonInterruptingMessageIcon,
  "MultipleStartEventNonInterrupting": StartEventNonInterruptingMultipleIcon,
  "ParallelMultipleStartEventNonInterrupting": StartEventNonInterruptingParallelMultipleIcon,
  "SignalStartEventNonInterrupting": StartEventNonInterruptingSignalIcon,
  "TimerStartEventNonInterrupting": StartEventNonInterruptingTimerIcon,
  "CancelBoundaryEvent": IntermediateEventCatchCancelIcon,
  "CompensateBoundaryEvent": IntermediateEventCatchCompensationIcon,
  "ConditionalBoundaryEvent": IntermediateEventCatchConditionIcon,
  "ErrorBoundaryEvent": IntermediateEventCatchErrorIcon,
  "EscalationBoundaryEvent": IntermediateEventCatchEscalationIcon,
  "LinkBoundaryEvent": IntermediateEventCatchLinkIcon,
  "MessageBoundaryEvent": IntermediateEventCatchMessageIcon,
  "MultipleBoundaryEvent": IntermediateEventCatchMultipleIcon,
  "BoundaryEvent": IntermediateEventNoneIcon,
  "ConditionalBoundaryEventNonInterrupting": IntermediateEventCatchNonInterruptingConditionIcon,
  "EscalationBoundaryEventNonInterrupting": IntermediateEventCatchNonInterruptingEscalationIcon,
  "MessageBoundaryEventNonInterrupting": IntermediateEventCatchNonInterruptingMessageIcon,
  "MultipleBoundaryEventNonInterrupting": IntermediateEventCatchNonInterruptingMultipleIcon,
  "ParallelBoundaryEventNonInterrupting": IntermediateEventCatchNonInterruptingParallelIcon,
  "SignalBoundaryEventNonInterrupting": IntermediateEventCatchNonInterruptingSignalIcon,
  "TimerBoundaryEventNonInterrupting": IntermediateEventCatchNonInterruptingTimerIcon,
  "ParallelMultipleBoundaryEvent": IntermediateEventCatchParallelMultipleIcon,
  "SignalBoundaryEvent": IntermediateEventCatchSignalIcon,
  "TimerBoundaryEvent": IntermediateEventCatchTimerIcon,
  "StartEvent": StartEventNoneIcon,
  "ParallelMultipleStartEvent": StartEventParallelMultipleIcon,
  "SignalStartEvent": StartEventSignalIcon,
  "TimerStartEvent": StartEventTimerIcon,
  "CollapsedSubProcess": SubprocessCollapsedIcon,
  "CollapsedAdHocSubProcess": SubprocessCollapsedIcon,
  "ExpandedSubProcess": SubprocessExpandedIcon,
  "ExpandedAdHocSubProcess": SubprocessExpandedIcon,
  "Task": TaskNoneIcon,
  "TextAnnotation": TextAnnotationicon,
  "Transaction": TransactionIcon,
  "UserTask": UserTaskIcon
};
function getConcreteType(element) {
  const {
    type: elementType
  } = element;
  let type = getRawType(elementType);
  const eventDefinition = getEventDefinition$2(element);
  if (eventDefinition) {
    type = `${getEventDefinitionPrefix(eventDefinition)}${type}`;
    if (is(element, "bpmn:StartEvent") && !isInterrupting(element) || is(element, "bpmn:BoundaryEvent") && !isCancelActivity(element)) {
      type = `${type}NonInterrupting`;
    }
    return type;
  }
  if (is(element, "bpmn:SubProcess") && !is(element, "bpmn:Transaction")) {
    if (isEventSubProcess(element)) {
      type = `Event${type}`;
    } else {
      const expanded = isExpanded(element) && !isPlane2(element);
      type = `${expanded ? "Expanded" : "Collapsed"}${type}`;
    }
  }
  if (isDefaultFlow2(element)) {
    type = "DefaultFlow";
  }
  if (isConditionalFlow(element)) {
    type = "ConditionalFlow";
  }
  return type;
}
var PanelHeaderProvider = {
  getDocumentationRef: (element) => {
    const elementTemplates = getTemplatesService();
    if (elementTemplates) {
      return getTemplateDocumentation(element, elementTemplates);
    }
  },
  getElementLabel: (element) => {
    if (is(element, "bpmn:Process")) {
      return getBusinessObject(element).name;
    }
    return getLabel(element);
  },
  getElementIcon: (element) => {
    const concreteType = getConcreteType(element);
    const elementTemplates = getTemplatesService();
    if (elementTemplates) {
      const template = getTemplate(element, elementTemplates);
      if (template && template.icon) {
        return () => o5("img", {
          class: "bio-properties-panel-header-template-icon",
          width: "32",
          height: "32",
          src: template.icon.contents
        });
      }
    }
    return iconsByType[concreteType];
  },
  getTypeLabel: (element) => {
    const elementTemplates = getTemplatesService();
    if (elementTemplates) {
      const template = getTemplate(element, elementTemplates);
      if (template && template.name) {
        return template.name;
      }
    }
    const concreteType = getConcreteType(element);
    return concreteType.replace(/(\B[A-Z])/g, " $1").replace(/(\bNon Interrupting)/g, "($1)");
  }
};
function isCancelActivity(element) {
  const businessObject = getBusinessObject(element);
  return businessObject && businessObject.cancelActivity !== false;
}
function getEventDefinition$2(element) {
  const businessObject = getBusinessObject(element), eventDefinitions = businessObject.eventDefinitions;
  return eventDefinitions && eventDefinitions[0];
}
function getRawType(type) {
  return type.split(":")[1];
}
function getEventDefinitionPrefix(eventDefinition) {
  const rawType = getRawType(eventDefinition.$type);
  return rawType.replace("EventDefinition", "");
}
function isDefaultFlow2(element) {
  const businessObject = getBusinessObject(element);
  const sourceBusinessObject = getBusinessObject(element.source);
  if (!is(element, "bpmn:SequenceFlow") || !sourceBusinessObject) {
    return false;
  }
  return sourceBusinessObject.default && sourceBusinessObject.default === businessObject && (is(sourceBusinessObject, "bpmn:Gateway") || is(sourceBusinessObject, "bpmn:Activity"));
}
function isConditionalFlow(element) {
  const businessObject = getBusinessObject(element);
  const sourceBusinessObject = getBusinessObject(element.source);
  if (!is(element, "bpmn:SequenceFlow") || !sourceBusinessObject) {
    return false;
  }
  return businessObject.conditionExpression && is(sourceBusinessObject, "bpmn:Activity");
}
function isPlane2(element) {
  const di = element && (element.di || getBusinessObject(element).di);
  return is(di, "bpmndi:BPMNPlane");
}
function getTemplatesService() {
  return useService("elementTemplates", false);
}
function getTemplate(element, elementTemplates) {
  return elementTemplates.get(element);
}
function getTemplateDocumentation(element, elementTemplates) {
  const template = getTemplate(element, elementTemplates);
  return template && template.documentationRef;
}
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
var EmptyIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends$1({
  xmlns: "http://www.w3.org/2000/svg",
  xmlnsXlink: "http://www.w3.org/1999/xlink",
  width: "64",
  height: "64"
}, props), /* @__PURE__ */ compat_module_default.createElement("defs", null, /* @__PURE__ */ compat_module_default.createElement("rect", {
  id: "a",
  width: "57",
  height: "47",
  x: "3",
  y: "8",
  rx: "7"
}), /* @__PURE__ */ compat_module_default.createElement("mask", {
  id: "b",
  width: "57",
  height: "47",
  x: "0",
  y: "0",
  fill: "#fff",
  maskContentUnits: "userSpaceOnUse",
  maskUnits: "objectBoundingBox"
}, /* @__PURE__ */ compat_module_default.createElement("use", {
  xlinkHref: "#a"
}))), /* @__PURE__ */ compat_module_default.createElement("g", {
  fill: "none",
  fillRule: "evenodd"
}, /* @__PURE__ */ compat_module_default.createElement("path", {
  fill: "#818798",
  d: "M52 11a5 5 0 015 5v31a5 5 0 01-5 5H11a5 5 0 01-5-5V16a5 5 0 015-5h41zm0 2H11a3 3 0 00-2.995 2.824L8 16v31a3 3 0 002.824 2.995L11 50h41a3 3 0 002.995-2.824L55 47V16a3 3 0 00-2.824-2.995L52 13z"
}), /* @__PURE__ */ compat_module_default.createElement("path", {
  fill: "#D5D7DD",
  d: "M16 24h31v6H16zM21 33h21v6H21z"
}), /* @__PURE__ */ compat_module_default.createElement("use", {
  stroke: "#B9BCC6",
  strokeDasharray: "5 2",
  strokeWidth: "2",
  mask: "url(#b)",
  xlinkHref: "#a"
})));
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i6 = 1; i6 < arguments.length; i6++) {
      var source = arguments[i6];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var MultipleIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ compat_module_default.createElement("svg", _extends({
  xmlns: "http://www.w3.org/2000/svg",
  xmlnsXlink: "http://www.w3.org/1999/xlink",
  width: "128",
  height: "64"
}, props), /* @__PURE__ */ compat_module_default.createElement("defs", null, /* @__PURE__ */ compat_module_default.createElement("path", {
  id: "a",
  d: "M9 9h110v47H9z"
}), /* @__PURE__ */ compat_module_default.createElement("mask", {
  id: "b",
  width: "110",
  height: "47",
  x: "0",
  y: "0",
  fill: "#fff",
  maskContentUnits: "userSpaceOnUse",
  maskUnits: "objectBoundingBox"
}, /* @__PURE__ */ compat_module_default.createElement("use", {
  xlinkHref: "#a"
}))), /* @__PURE__ */ compat_module_default.createElement("g", {
  fill: "none",
  fillRule: "evenodd"
}, /* @__PURE__ */ compat_module_default.createElement("path", {
  fill: "#818798",
  d: "M25 20.272L37.728 33 25 45.728 12.272 33 25 20.272zm0 2.829L15.1 33l9.9 9.9 9.9-9.9-9.9-9.9z"
}), /* @__PURE__ */ compat_module_default.createElement("path", {
  fill: "#D5D7DD",
  d: "M17 47h16v6H17z"
}), /* @__PURE__ */ compat_module_default.createElement("path", {
  fill: "#818798",
  d: "M35 32h27v2H35z"
}), /* @__PURE__ */ compat_module_default.createElement("path", {
  fill: "#818798",
  d: "M60 30v6l6-3z"
}), /* @__PURE__ */ compat_module_default.createElement("path", {
  fill: "#D5D7DD",
  d: "M80 34h21v6H80z"
}), /* @__PURE__ */ compat_module_default.createElement("g", null, /* @__PURE__ */ compat_module_default.createElement("path", {
  fill: "#818798",
  d: "M111 12a5 5 0 015 5v31a5 5 0 01-5 5H70a5 5 0 01-5-5V17a5 5 0 015-5h41zm0 2H70a3 3 0 00-3 3v31a3 3 0 003 3h41a3 3 0 003-3V17a3 3 0 00-3-3z"
}), /* @__PURE__ */ compat_module_default.createElement("path", {
  fill: "#D5D7DD",
  d: "M75 25h31v6H75z"
})), /* @__PURE__ */ compat_module_default.createElement("use", {
  stroke: "#B9BCC6",
  strokeDasharray: "5 2",
  strokeWidth: "2",
  mask: "url(#b)",
  xlinkHref: "#a"
})));
var PanelPlaceholderProvider = (translate3) => {
  if (!translate3)
    translate3 = (text) => text;
  return {
    getEmpty: () => {
      return {
        text: translate3("Select an element to edit its properties."),
        icon: EmptyIcon
      };
    },
    getMultiple: () => {
      return {
        text: translate3("Multiple elements are selected. Select a single element to edit its properties."),
        icon: MultipleIcon
      };
    }
  };
};
function BpmnPropertiesPanel(props) {
  const {
    element,
    injector,
    getProviders,
    layoutConfig,
    descriptionConfig
  } = props;
  const canvas = injector.get("canvas");
  const elementRegistry = injector.get("elementRegistry");
  const eventBus = injector.get("eventBus");
  const translate3 = injector.get("translate");
  const [state, setState] = l4({
    selectedElement: element
  });
  const selectedElement = state.selectedElement;
  const _update = (element2) => {
    if (!element2) {
      return;
    }
    let newSelectedElement = element2;
    if (newSelectedElement && newSelectedElement.type === "label") {
      newSelectedElement = newSelectedElement.labelTarget;
    }
    setState({
      ...state,
      selectedElement: newSelectedElement
    });
    eventBus.fire("propertiesPanel.updated", {
      element: newSelectedElement
    });
  };
  y3(() => {
    const onSelectionChanged = (e7) => {
      const {
        newSelection = []
      } = e7;
      if (newSelection.length > 1) {
        return _update(newSelection);
      }
      const newElement = newSelection[0];
      const rootElement = canvas.getRootElement();
      if (isImplicitRoot$1(rootElement)) {
        return;
      }
      _update(newElement || rootElement);
    };
    eventBus.on("selection.changed", onSelectionChanged);
    return () => {
      eventBus.off("selection.changed", onSelectionChanged);
    };
  }, []);
  y3(() => {
    const onElementsChanged = (e7) => {
      const elements = e7.elements;
      const updatedElement = findElement(elements, selectedElement);
      if (updatedElement && elementExists(updatedElement, elementRegistry)) {
        _update(updatedElement);
      }
    };
    eventBus.on("elements.changed", onElementsChanged);
    return () => {
      eventBus.off("elements.changed", onElementsChanged);
    };
  }, [selectedElement]);
  y3(() => {
    const onRootAdded = (e7) => {
      const element2 = e7.element;
      _update(element2);
    };
    eventBus.on("root.added", onRootAdded);
    return () => {
      eventBus.off("root.added", onRootAdded);
    };
  }, [selectedElement]);
  y3(() => {
    const onProvidersChanged = () => {
      _update(selectedElement);
    };
    eventBus.on("propertiesPanel.providersChanged", onProvidersChanged);
    return () => {
      eventBus.off("propertiesPanel.providersChanged", onProvidersChanged);
    };
  }, [selectedElement]);
  y3(() => {
    const onTemplatesChanged = () => {
      _update(selectedElement);
    };
    eventBus.on("elementTemplates.changed", onTemplatesChanged);
    return () => {
      eventBus.off("elementTemplates.changed", onTemplatesChanged);
    };
  }, [selectedElement]);
  const bpmnPropertiesPanelContext = {
    selectedElement,
    injector,
    getService(type, strict) {
      return injector.get(type, strict);
    }
  };
  const providers = getProviders(selectedElement);
  const groups = d4(() => {
    return (0, import_min_dash147.reduce)(providers, function(groups2, provider) {
      if ((0, import_min_dash147.isArray)(selectedElement)) {
        return [];
      }
      const updater = provider.getGroups(selectedElement);
      return updater(groups2);
    }, []);
  }, [providers, selectedElement]);
  const onLayoutChanged = (layout) => {
    eventBus.fire("propertiesPanel.layoutChanged", {
      layout
    });
  };
  const onDescriptionLoaded = (description) => {
    eventBus.fire("propertiesPanel.descriptionLoaded", {
      description
    });
  };
  return o5(BpmnPropertiesPanelContext.Provider, {
    value: bpmnPropertiesPanelContext,
    children: o5(PropertiesPanel, {
      element: selectedElement,
      headerProvider: PanelHeaderProvider,
      placeholderProvider: PanelPlaceholderProvider(translate3),
      groups,
      layoutConfig,
      layoutChanged: onLayoutChanged,
      descriptionConfig,
      descriptionLoaded: onDescriptionLoaded,
      eventBus
    })
  });
}
function isImplicitRoot$1(element) {
  return element && (element.isImplicit || element.id === "__implicitroot");
}
function findElement(elements, element) {
  return (0, import_min_dash147.find)(elements, (e7) => e7 === element);
}
function elementExists(element, elementRegistry) {
  return element && elementRegistry.get(element.id);
}
var DEFAULT_PRIORITY7 = 1e3;
var BpmnPropertiesPanelRenderer = class {
  constructor(config, injector, eventBus) {
    const {
      parent,
      layout: layoutConfig,
      description: descriptionConfig
    } = config || {};
    this._eventBus = eventBus;
    this._injector = injector;
    this._layoutConfig = layoutConfig;
    this._descriptionConfig = descriptionConfig;
    this._container = domify$1('<div style="height: 100%" class="bio-properties-panel-container"></div>');
    var commandStack = injector.get("commandStack", false);
    commandStack && setupKeyboard(this._container, eventBus, commandStack);
    eventBus.on("diagram.init", () => {
      if (parent) {
        this.attachTo(parent);
      }
    });
    eventBus.on("diagram.destroy", () => {
      this.detach();
    });
    eventBus.on("root.added", (event2) => {
      const {
        element
      } = event2;
      this._render(element);
    });
  }
  attachTo(container) {
    if (!container) {
      throw new Error("container required");
    }
    if (container.get && container.constructor.prototype.jquery) {
      container = container.get(0);
    }
    if (typeof container === "string") {
      container = query(container);
    }
    this.detach();
    container.appendChild(this._container);
    this._eventBus.fire("propertiesPanel.attach");
  }
  detach() {
    const parentNode = this._container.parentNode;
    if (parentNode) {
      parentNode.removeChild(this._container);
      this._eventBus.fire("propertiesPanel.detach");
    }
  }
  registerProvider(priority, provider) {
    if (!provider) {
      provider = priority;
      priority = DEFAULT_PRIORITY7;
    }
    if (typeof provider.getGroups !== "function") {
      console.error("Properties provider does not implement #getGroups(element) API");
      return;
    }
    this._eventBus.on("propertiesPanel.getProviders", priority, function(event2) {
      event2.providers.push(provider);
    });
    this._eventBus.fire("propertiesPanel.providersChanged");
  }
  _getProviders() {
    const event2 = this._eventBus.createEvent({
      type: "propertiesPanel.getProviders",
      providers: []
    });
    this._eventBus.fire(event2);
    return event2.providers;
  }
  _render(element) {
    const canvas = this._injector.get("canvas");
    if (!element) {
      element = canvas.getRootElement();
    }
    if (isImplicitRoot(element)) {
      return;
    }
    N2(o5(BpmnPropertiesPanel, {
      element,
      injector: this._injector,
      getProviders: this._getProviders.bind(this),
      layoutConfig: this._layoutConfig,
      descriptionConfig: this._descriptionConfig
    }), this._container);
    this._eventBus.fire("propertiesPanel.rendered");
  }
  _destroy() {
    if (this._container) {
      N2(null, this._container);
      this._eventBus.fire("propertiesPanel.destroyed");
    }
  }
};
BpmnPropertiesPanelRenderer.$inject = ["config.propertiesPanel", "injector", "eventBus"];
function isImplicitRoot(element) {
  return element && (element.isImplicit || element.id === "__implicitroot");
}
function setupKeyboard(container, eventBus, commandStack) {
  function cancel(event2) {
    event2.preventDefault();
    event2.stopPropagation();
  }
  function handleKeys(event2) {
    if (isUndo(event2)) {
      commandStack.undo();
      return cancel(event2);
    }
    if (isRedo(event2)) {
      commandStack.redo();
      return cancel(event2);
    }
  }
  eventBus.on("keyboard.bind", function() {
    event.bind(container, "keydown", handleKeys);
  });
  eventBus.on("keyboard.unbind", function() {
    event.unbind(container, "keydown", handleKeys);
  });
}
var MultiCommandHandler = class {
  constructor(commandStack) {
    this._commandStack = commandStack;
  }
  preExecute(context) {
    const commandStack = this._commandStack;
    (0, import_min_dash147.forEach)(context, function(command) {
      commandStack.execute(command.cmd, command.context);
    });
  }
};
MultiCommandHandler.$inject = ["commandStack"];
var HANDLERS = {
  "properties-panel.multi-command-executor": MultiCommandHandler
};
function CommandInitializer(eventBus, commandStack) {
  eventBus.on("diagram.init", function() {
    (0, import_min_dash147.forEach)(HANDLERS, function(handler, id) {
      commandStack.registerHandler(id, handler);
    });
  });
}
CommandInitializer.$inject = ["eventBus", "commandStack"];
var Commands = {
  __init__: [CommandInitializer]
};
var index$3 = {
  __depends__: [Commands, index],
  __init__: ["propertiesPanel"],
  propertiesPanel: ["type", BpmnPropertiesPanelRenderer]
};
function ReferenceSelectEntry(props) {
  const {
    autoFocusEntry,
    element,
    getOptions
  } = props;
  const options2 = getOptions(element);
  const prevOptions = usePrevious(options2);
  y3(() => {
    if (autoFocusEntry && prevOptions && options2.length > prevOptions.length) {
      const entry = query(`[data-entry-id="${autoFocusEntry}"]`);
      const focusableInput = query(".bio-properties-panel-input", entry);
      if (focusableInput) {
        focusableInput.select();
      }
    }
  }, [options2]);
  return o5(SelectEntry, {
    ...props
  });
}
function isErrorSupported(element) {
  return isAny(element, ["bpmn:StartEvent", "bpmn:BoundaryEvent", "bpmn:EndEvent"]) && !!getErrorEventDefinition(element);
}
function getErrorEventDefinition(element) {
  return getEventDefinition$1(element, "bpmn:ErrorEventDefinition");
}
function getTimerEventDefinition$1(element) {
  return getEventDefinition$1(element, "bpmn:TimerEventDefinition");
}
function getError(element) {
  const errorEventDefinition = getErrorEventDefinition(element);
  return errorEventDefinition && errorEventDefinition.get("errorRef");
}
function getEventDefinition$1(element, eventType) {
  const businessObject = getBusinessObject(element);
  const eventDefinitions = businessObject.get("eventDefinitions") || [];
  return (0, import_min_dash147.find)(eventDefinitions, function(definition) {
    return is(definition, eventType);
  });
}
function isMessageSupported(element) {
  return is(element, "bpmn:ReceiveTask") || isAny(element, ["bpmn:StartEvent", "bpmn:EndEvent", "bpmn:IntermediateThrowEvent", "bpmn:BoundaryEvent", "bpmn:IntermediateCatchEvent"]) && !!getMessageEventDefinition(element);
}
function getMessageEventDefinition(element) {
  if (is(element, "bpmn:ReceiveTask")) {
    return getBusinessObject(element);
  }
  return getEventDefinition$1(element, "bpmn:MessageEventDefinition");
}
function getMessage(element) {
  const messageEventDefinition = getMessageEventDefinition(element);
  return messageEventDefinition && messageEventDefinition.get("messageRef");
}
function getLinkEventDefinition(element) {
  return getEventDefinition$1(element, "bpmn:LinkEventDefinition");
}
function getSignalEventDefinition(element) {
  return getEventDefinition$1(element, "bpmn:SignalEventDefinition");
}
function isLinkSupported(element) {
  return isAny(element, ["bpmn:IntermediateThrowEvent", "bpmn:IntermediateCatchEvent"]) && !!getLinkEventDefinition(element);
}
function isSignalSupported(element) {
  return is(element, "bpmn:Event") && !!getSignalEventDefinition(element);
}
function getSignal(element) {
  const signalEventDefinition = getSignalEventDefinition(element);
  return signalEventDefinition && signalEventDefinition.get("signalRef");
}
function getEscalationEventDefinition(element) {
  return getEventDefinition$1(element, "bpmn:EscalationEventDefinition");
}
function isEscalationSupported(element) {
  return is(element, "bpmn:Event") && !!getEscalationEventDefinition(element);
}
function getEscalation(element) {
  const escalationEventDefinition = getEscalationEventDefinition(element);
  return escalationEventDefinition && escalationEventDefinition.get("escalationRef");
}
function isCompensationSupported(element) {
  return isAny(element, ["bpmn:EndEvent", "bpmn:IntermediateThrowEvent"]) && !!getCompensateEventDefinition(element);
}
function getCompensateEventDefinition(element) {
  return getEventDefinition$1(element, "bpmn:CompensateEventDefinition");
}
function getCompensateActivity(element) {
  const compensateEventDefinition = getCompensateEventDefinition(element);
  return compensateEventDefinition && compensateEventDefinition.get("activityRef");
}
function CompensationProps(props) {
  const {
    element
  } = props;
  if (!isCompensationSupported(element)) {
    return [];
  }
  return [{
    id: "waitForCompletion",
    component: WaitForCompletion,
    isEdited: isEdited$7
  }, {
    id: "activityRef",
    component: ActivityRef,
    isEdited: isEdited$4
  }];
}
function WaitForCompletion(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const compensateEventDefinition = getCompensateEventDefinition(element);
  const getValue2 = () => {
    return compensateEventDefinition.get("waitForCompletion");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: compensateEventDefinition,
      properties: {
        waitForCompletion: value
      }
    });
  };
  return CheckboxEntry({
    element,
    id: "waitForCompletion",
    label: translate3("Wait for completion"),
    getValue: getValue2,
    setValue
  });
}
function ActivityRef(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const elementRegistry = useService("elementRegistry");
  const translate3 = useService("translate");
  const compensateEventDefinition = getCompensateEventDefinition(element);
  const getValue2 = () => {
    const activityRef = getCompensateActivity(element);
    return activityRef && activityRef.get("id");
  };
  const setValue = (value) => {
    const activityRef = value ? getBusinessObject(elementRegistry.get(value)) : void 0;
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: compensateEventDefinition,
      properties: {
        activityRef
      }
    });
  };
  const getOptions = () => {
    let options2 = [{
      value: "",
      label: translate3("<none>")
    }];
    const activities = findActivityRefs(element);
    sortByName$6(activities).forEach(function(activity) {
      options2.push({
        value: activity.id,
        label: createOptionLabel(activity)
      });
    });
    return options2;
  };
  return ReferenceSelectEntry({
    element,
    id: "activityRef",
    label: translate3("Activity reference"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function getFlowElements(element, type) {
  const {
    flowElements
  } = element;
  return flowElements.filter(function(flowElement) {
    return is(flowElement, type);
  });
}
function getContainedActivities(element) {
  return getFlowElements(element, "bpmn:Activity");
}
function getContainedBoundaryEvents(element) {
  return getFlowElements(element, "bpmn:BoundaryEvent");
}
function hasCompensationEventAttached(activity, boundaryEvents) {
  const {
    id: activityId
  } = activity;
  return !!(0, import_min_dash147.find)(boundaryEvents, function(boundaryEvent) {
    const {
      attachedToRef
    } = boundaryEvent;
    const compensateEventDefinition = getCompensateEventDefinition(boundaryEvent);
    return attachedToRef && compensateEventDefinition && attachedToRef.id === activityId;
  });
}
function canBeCompensated(activity, boundaryEvents) {
  return is(activity, "bpmn:CallActivity") || is(activity, "bpmn:SubProcess") && !activity.triggeredByEvent && !activity.isForCompensation || hasCompensationEventAttached(activity, boundaryEvents);
}
function getActivitiesForCompensation(element) {
  const activities = getContainedActivities(element);
  const boundaryEvents = getContainedBoundaryEvents(element);
  return activities.filter(function(activity) {
    return canBeCompensated(activity, boundaryEvents);
  });
}
function findActivityRefs(element) {
  const businessObject = getBusinessObject(element);
  let parent = businessObject.$parent;
  let activities = getActivitiesForCompensation(parent);
  if (is(parent, "bpmn:SubProcess") && parent.triggeredByEvent) {
    parent = parent.$parent;
    if (parent) {
      activities = [...activities, ...getActivitiesForCompensation(parent)];
    }
  }
  return activities;
}
function createOptionLabel(activity) {
  const {
    id,
    name: name3
  } = activity;
  return `${name3 ? name3 + " " : ""}(id=${id})`;
}
function sortByName$6(elements) {
  return (0, import_min_dash147.sortBy)(elements, (e7) => (e7.name || "").toLowerCase());
}
var DOCUMENTATION_TEXT_FORMAT = "text/plain";
function DocumentationProps(props) {
  const {
    element
  } = props;
  const entries = [{
    id: "documentation",
    component: ElementDocumentationProperty,
    isEdited: isEdited$2
  }];
  if (hasProcessRef$2(element)) {
    entries.push({
      id: "processDocumentation",
      component: ProcessDocumentationProperty,
      isEdited: isEdited$2
    });
  }
  return entries;
}
function ElementDocumentationProperty(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = getDocumentation(getBusinessObject(element));
  const setValue = setDocumentation(element, getBusinessObject(element), bpmnFactory, commandStack);
  return TextAreaEntry({
    element,
    id: "documentation",
    label: translate3("Element documentation"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function ProcessDocumentationProperty(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const processRef = getBusinessObject(element).processRef;
  const getValue2 = getDocumentation(processRef);
  const setValue = setDocumentation(element, processRef, bpmnFactory, commandStack);
  return TextAreaEntry({
    element,
    id: "processDocumentation",
    label: translate3("Process documentation"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function hasProcessRef$2(element) {
  return is(element, "bpmn:Participant") && element.businessObject.get("processRef");
}
function findDocumentation(docs) {
  return docs.find(function(d5) {
    return (d5.textFormat || DOCUMENTATION_TEXT_FORMAT) === DOCUMENTATION_TEXT_FORMAT;
  });
}
function getDocumentation(businessObject) {
  return function() {
    const documentation = findDocumentation(businessObject && businessObject.get("documentation"));
    return documentation && documentation.text;
  };
}
function setDocumentation(element, businessObject, bpmnFactory, commandStack) {
  return function(value) {
    let documentation = findDocumentation(businessObject && businessObject.get("documentation"));
    if (documentation) {
      if (value) {
        return commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: documentation,
          properties: {
            text: value
          }
        });
      } else {
        return commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: businessObject,
          properties: {
            documentation: (0, import_min_dash147.without)(businessObject.get("documentation"), documentation)
          }
        });
      }
    }
    if (value) {
      documentation = bpmnFactory.create("bpmn:Documentation", {
        text: value
      });
      return commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: businessObject,
        properties: {
          documentation: [...businessObject.get("documentation"), documentation]
        }
      });
    }
  };
}
function createElement(elementType, properties, parent, factory) {
  const element = factory.create(elementType, properties);
  if (parent) {
    element.$parent = parent;
  }
  return element;
}
function nextId(prefix3) {
  const ids3 = new index_esm_default([32, 32, 1]);
  return ids3.nextPrefixed(prefix3);
}
function getRoot(businessObject) {
  let parent = businessObject;
  while (parent.$parent) {
    parent = parent.$parent;
  }
  return parent;
}
function filterElementsByType(objectList, type) {
  const list = objectList || [];
  return list.filter((element) => is(element, type));
}
function findRootElementsByType(businessObject, referencedType) {
  const root = getRoot(businessObject);
  return filterElementsByType(root.get("rootElements"), referencedType);
}
function findRootElementById(businessObject, type, id) {
  const elements = findRootElementsByType(businessObject, type);
  return elements.find((element) => element.id === id);
}
var EMPTY_OPTION$4 = "";
var CREATE_NEW_OPTION$4 = "create-new";
function ErrorProps$2(props) {
  const {
    element
  } = props;
  if (!isErrorSupported(element)) {
    return [];
  }
  const error4 = getError(element);
  let entries = [{
    id: "errorRef",
    component: ErrorRef$1,
    isEdited: isEdited$4
  }];
  if (error4) {
    entries = [...entries, {
      id: "errorName",
      component: ErrorName$1,
      isEdited: isEdited$1
    }, {
      id: "errorCode",
      component: ErrorCode$2,
      isEdited: isEdited$1
    }];
  }
  return entries;
}
function ErrorRef$1(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const errorEventDefinition = getErrorEventDefinition(element);
  const getValue2 = () => {
    const error4 = getError(element);
    if (error4) {
      return error4.get("id");
    }
    return EMPTY_OPTION$4;
  };
  const setValue = (value) => {
    const root = getRoot(errorEventDefinition);
    const commands = [];
    let error4;
    if (value === CREATE_NEW_OPTION$4) {
      error4 = createElement("bpmn:Error", {
        name: nextId("Error_")
      }, root, bpmnFactory);
      value = error4.get("id");
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: root,
          properties: {
            rootElements: [...root.get("rootElements"), error4]
          }
        }
      });
    }
    error4 = error4 || findRootElementById(errorEventDefinition, "bpmn:Error", value);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: errorEventDefinition,
        properties: {
          errorRef: error4
        }
      }
    });
    return commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  const getOptions = () => {
    let options2 = [{
      value: EMPTY_OPTION$4,
      label: translate3("<none>")
    }, {
      value: CREATE_NEW_OPTION$4,
      label: translate3("Create new ...")
    }];
    const errors = findRootElementsByType(getBusinessObject(element), "bpmn:Error");
    sortByName$5(errors).forEach((error4) => {
      options2.push({
        value: error4.get("id"),
        label: error4.get("name")
      });
    });
    return options2;
  };
  return ReferenceSelectEntry({
    element,
    id: "errorRef",
    label: translate3("Global error reference"),
    autoFocusEntry: "errorName",
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function ErrorName$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const error4 = getError(element);
  const getValue2 = () => {
    return error4.get("name");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: error4,
      properties: {
        name: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "errorName",
    label: translate3("Name"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function ErrorCode$2(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const error4 = getError(element);
  const getValue2 = () => {
    return error4.get("errorCode");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: error4,
      properties: {
        errorCode: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "errorCode",
    label: translate3("Code"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function sortByName$5(elements) {
  return (0, import_min_dash147.sortBy)(elements, (e7) => (e7.name || "").toLowerCase());
}
var CREATE_NEW_OPTION$3 = "create-new";
function EscalationProps$1(props) {
  const {
    element
  } = props;
  if (!isEscalationSupported(element)) {
    return [];
  }
  const escalation = getEscalation(element);
  let entries = [{
    id: "escalationRef",
    component: EscalationRef,
    isEdited: isEdited$4
  }];
  if (escalation) {
    entries = [...entries, {
      id: "escalationName",
      component: EscalationName,
      isEdited: isEdited$1
    }, {
      id: "escalationCode",
      component: EscalationCode,
      isEdited: isEdited$1
    }];
  }
  return entries;
}
function EscalationRef(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const escalationEventDefinition = getEscalationEventDefinition(element);
  const getValue2 = () => {
    const escalation = getEscalation(element);
    return escalation && escalation.get("id");
  };
  const setValue = (value) => {
    const root = getRoot(escalationEventDefinition);
    const commands = [];
    let escalation;
    if (value === CREATE_NEW_OPTION$3) {
      const id = nextId("Escalation_");
      escalation = createElement("bpmn:Escalation", {
        id,
        name: id
      }, root, bpmnFactory);
      value = escalation.get("id");
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: root,
          properties: {
            rootElements: [...root.get("rootElements"), escalation]
          }
        }
      });
    }
    escalation = escalation || findRootElementById(escalationEventDefinition, "bpmn:Escalation", value);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: escalationEventDefinition,
        properties: {
          escalationRef: escalation
        }
      }
    });
    return commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  const getOptions = () => {
    let options2 = [{
      value: "",
      label: translate3("<none>")
    }, {
      value: CREATE_NEW_OPTION$3,
      label: translate3("Create new ...")
    }];
    const escalations = findRootElementsByType(getBusinessObject(element), "bpmn:Escalation");
    sortByName$4(escalations).forEach((escalation) => {
      options2.push({
        value: escalation.get("id"),
        label: escalation.get("name")
      });
    });
    return options2;
  };
  return ReferenceSelectEntry({
    element,
    id: "escalationRef",
    label: translate3("Global escalation reference"),
    autoFocusEntry: "escalationName",
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function EscalationName(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const escalation = getEscalation(element);
  const getValue2 = () => {
    return escalation.get("name");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: escalation,
      properties: {
        name: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "escalationName",
    label: translate3("Name"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function EscalationCode(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const escalation = getEscalation(element);
  const getValue2 = () => {
    return escalation.get("escalationCode");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: escalation,
      properties: {
        escalationCode: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "escalationCode",
    label: translate3("Code"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function sortByName$4(elements) {
  return (0, import_min_dash147.sortBy)(elements, (e7) => (e7.name || "").toLowerCase());
}
function ExecutableProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:Process") && !hasProcessRef$1(element)) {
    return [];
  }
  return [{
    id: "isExecutable",
    component: Executable,
    isEdited: isEdited$7
  }];
}
function Executable(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  let getValue2, setValue;
  setValue = (value) => {
    modeling.updateProperties(element, {
      isExecutable: value
    });
  };
  getValue2 = (element2) => {
    return element2.businessObject.isExecutable;
  };
  if (is(element, "bpmn:Participant")) {
    const process2 = element.businessObject.get("processRef");
    setValue = (value) => {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: process2,
        properties: {
          isExecutable: value
        }
      });
    };
    getValue2 = () => {
      return process2.get("isExecutable");
    };
  }
  return CheckboxEntry({
    element,
    id: "isExecutable",
    label: translate3("Executable"),
    getValue: getValue2,
    setValue
  });
}
function hasProcessRef$1(element) {
  return is(element, "bpmn:Participant") && element.businessObject.get("processRef");
}
var SPACE_REGEX = /\s/;
var QNAME_REGEX = /^([a-z][\w-.]*:)?[a-z_][\w-.]*$/i;
var ID_REGEX = /^[a-z_][\w-.]*$/i;
function isIdValid(element, idValue, translate3) {
  const assigned = element.$model.ids.assigned(idValue);
  const idAlreadyExists = assigned && assigned !== element;
  if (!idValue) {
    return translate3("ID must not be empty.");
  }
  if (idAlreadyExists) {
    return translate3("ID must be unique.");
  }
  return validateId(idValue, translate3);
}
function validateId(idValue, translate3) {
  if (containsSpace(idValue)) {
    return translate3("ID must not contain spaces.");
  }
  if (!ID_REGEX.test(idValue)) {
    if (QNAME_REGEX.test(idValue)) {
      return translate3("ID must not contain prefix.");
    }
    return translate3("ID must be a valid QName.");
  }
}
function containsSpace(value) {
  return SPACE_REGEX.test(value);
}
function IdProps() {
  return [{
    id: "id",
    component: Id$3,
    isEdited: isEdited$1
  }];
}
function Id$3(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const debounce4 = useService("debounceInput");
  const translate3 = useService("translate");
  const setValue = (value) => {
    modeling.updateProperties(element, {
      id: value
    });
  };
  const getValue2 = (element2) => {
    return element2.businessObject.id;
  };
  const validate3 = (value) => {
    const businessObject = getBusinessObject(element);
    return isIdValid(businessObject, value, translate3);
  };
  return TextfieldEntry({
    element,
    id: "id",
    label: translate3(is(element, "bpmn:Participant") ? "Participant ID" : "ID"),
    getValue: getValue2,
    setValue,
    debounce: debounce4,
    validate: validate3
  });
}
function LinkProps(props) {
  const {
    element
  } = props;
  if (!isLinkSupported(element)) {
    return [];
  }
  return [{
    id: "linkName",
    component: LinkName,
    isEdited: isEdited$1
  }];
}
function LinkName(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const linkEventDefinition = getLinkEventDefinition(element);
  const getValue2 = () => {
    return linkEventDefinition.get("name");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: linkEventDefinition,
      properties: {
        name: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "linkName",
    label: translate3("Name"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
var EMPTY_OPTION$3 = "";
var CREATE_NEW_OPTION$2 = "create-new";
function MessageProps$1(props) {
  const {
    element
  } = props;
  if (!isMessageSupported(element)) {
    return [];
  }
  const message = getMessage(element);
  let entries = [{
    id: "messageRef",
    component: MessageRef,
    isEdited: isEdited$4
  }];
  if (message) {
    entries = [...entries, {
      id: "messageName",
      component: MessageName$1,
      isEdited: isEdited$1
    }];
  }
  return entries;
}
function MessageRef(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const messageEventDefinition = getMessageEventDefinition(element);
  const getValue2 = () => {
    const message = getMessage(element);
    if (message) {
      return message.get("id");
    }
    return EMPTY_OPTION$3;
  };
  const setValue = (value) => {
    const root = getRoot(messageEventDefinition);
    const commands = [];
    let message;
    if (value === CREATE_NEW_OPTION$2) {
      const id = nextId("Message_");
      message = createElement("bpmn:Message", {
        id,
        name: id
      }, root, bpmnFactory);
      value = message.get("id");
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: root,
          properties: {
            rootElements: [...root.get("rootElements"), message]
          }
        }
      });
    }
    message = message || findRootElementById(messageEventDefinition, "bpmn:Message", value);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: messageEventDefinition,
        properties: {
          messageRef: message
        }
      }
    });
    return commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  const getOptions = () => {
    let options2 = [{
      value: EMPTY_OPTION$3,
      label: translate3("<none>")
    }, {
      value: CREATE_NEW_OPTION$2,
      label: translate3("Create new ...")
    }];
    const messages = findRootElementsByType(getBusinessObject(element), "bpmn:Message");
    sortByName$3(messages).forEach((message) => {
      options2.push({
        value: message.get("id"),
        label: message.get("name")
      });
    });
    return options2;
  };
  return ReferenceSelectEntry({
    element,
    id: "messageRef",
    label: translate3("Global message reference"),
    autoFocusEntry: "messageName",
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function MessageName$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const message = getMessage(element);
  const getValue2 = () => {
    return message.get("name");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: message,
      properties: {
        name: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "messageName",
    label: translate3("Name"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function sortByName$3(elements) {
  return (0, import_min_dash147.sortBy)(elements, (e7) => (e7.name || "").toLowerCase());
}
function MultiInstanceProps$2(props) {
  const {
    element
  } = props;
  if (!isMultiInstanceSupported$1(element)) {
    return [];
  }
  const entries = [{
    id: "loopCardinality",
    component: LoopCardinality,
    isEdited: isEdited$1
  }, {
    id: "completionCondition",
    component: CompletionCondition$1,
    isEdited: isEdited$1
  }];
  return entries;
}
function LoopCardinality(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const debounce4 = useService("debounceInput");
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const getValue2 = () => {
    return getLoopCardinalityValue(element);
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", updateFormalExpression(element, "loopCardinality", value, bpmnFactory));
  };
  return TextfieldEntry({
    element,
    id: "loopCardinality",
    label: translate3("Loop cardinality"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function CompletionCondition$1(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const debounce4 = useService("debounceInput");
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const getValue2 = () => {
    return getCompletionConditionValue(element);
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", updateFormalExpression(element, "completionCondition", value, bpmnFactory));
  };
  return TextfieldEntry({
    element,
    id: "completionCondition",
    label: translate3("Completion condition"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function isMultiInstanceSupported$1(element) {
  const loopCharacteristics = getLoopCharacteristics$2(element);
  return !!loopCharacteristics && is(loopCharacteristics, "bpmn:MultiInstanceLoopCharacteristics");
}
function getBody(expression) {
  return expression && expression.get("body");
}
function getProperty$2(element, propertyName) {
  const loopCharacteristics = getLoopCharacteristics$2(element);
  return loopCharacteristics && loopCharacteristics.get(propertyName);
}
function getLoopCharacteristics$2(element) {
  const bo = getBusinessObject(element);
  return bo.loopCharacteristics;
}
function createFormalExpression$1(parent, body, bpmnFactory) {
  return createElement("bpmn:FormalExpression", {
    body
  }, parent, bpmnFactory);
}
function updateFormalExpression(element, propertyName, newValue, bpmnFactory) {
  const loopCharacteristics = getLoopCharacteristics$2(element);
  const expressionProps = {};
  if (!newValue) {
    expressionProps[propertyName] = void 0;
    return {
      element,
      moddleElement: loopCharacteristics,
      properties: expressionProps
    };
  }
  const existingExpression = loopCharacteristics.get(propertyName);
  if (!existingExpression) {
    expressionProps[propertyName] = createFormalExpression$1(loopCharacteristics, newValue, bpmnFactory);
    return {
      element,
      moddleElement: loopCharacteristics,
      properties: expressionProps
    };
  }
  return {
    element,
    moddleElement: existingExpression,
    properties: {
      body: newValue
    }
  };
}
function getLoopCardinality(element) {
  return getProperty$2(element, "loopCardinality");
}
function getLoopCardinalityValue(element) {
  const loopCardinality = getLoopCardinality(element);
  return getBody(loopCardinality);
}
function getCompletionCondition$1(element) {
  return getProperty$2(element, "completionCondition");
}
function getCompletionConditionValue(element) {
  const completionCondition = getCompletionCondition$1(element);
  return getBody(completionCondition);
}
function NameProps(props) {
  const {
    element
  } = props;
  if (isAny(element, ["bpmn:Collaboration", "bpmn:DataAssociation", "bpmn:Association"])) {
    return [];
  }
  return [{
    id: "name",
    component: Name$3,
    isEdited: isEdited$1
  }];
}
function Name$3(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const debounce4 = useService("debounceInput");
  const canvas = useService("canvas");
  const bpmnFactory = useService("bpmnFactory");
  const translate3 = useService("translate");
  let options2 = {
    element,
    id: "name",
    label: translate3("Name"),
    debounce: debounce4,
    setValue: (value) => {
      modeling.updateProperties(element, {
        name: value
      });
    },
    getValue: (element2) => {
      return element2.businessObject.name;
    }
  };
  if (is(element, "bpmn:TextAnnotation")) {
    options2 = {
      ...options2,
      setValue: (value) => {
        modeling.updateProperties(element, {
          text: value
        });
      },
      getValue: (element2) => {
        return element2.businessObject.text;
      }
    };
  } else if (is(element, "bpmn:Group")) {
    options2 = {
      ...options2,
      setValue: (value) => {
        const businessObject = getBusinessObject(element), categoryValueRef = businessObject.categoryValueRef;
        if (!categoryValueRef) {
          initializeCategory(businessObject, canvas.getRootElement(), bpmnFactory);
        }
        modeling.updateLabel(element, value);
      },
      getValue: (element2) => {
        const businessObject = getBusinessObject(element2), categoryValueRef = businessObject.categoryValueRef;
        return categoryValueRef && categoryValueRef.value;
      }
    };
  } else if (is(element, "bpmn:Participant")) {
    options2.label = translate3("Participant Name");
  }
  return TextfieldEntry(options2);
}
function initializeCategory(businessObject, rootElement, bpmnFactory) {
  const definitions = getBusinessObject(rootElement).$parent;
  const categoryValue = createCategoryValue2(definitions, bpmnFactory);
  businessObject.categoryValueRef = categoryValue;
}
function createCategoryValue2(definitions, bpmnFactory) {
  const categoryValue = bpmnFactory.create("bpmn:CategoryValue");
  const category = bpmnFactory.create("bpmn:Category", {
    categoryValue: [categoryValue]
  });
  add2(definitions.get("rootElements"), category);
  getBusinessObject(category).$parent = definitions;
  getBusinessObject(categoryValue).$parent = category;
  return categoryValue;
}
function ProcessProps(props) {
  const {
    element
  } = props;
  if (!hasProcessRef(element)) {
    return [];
  }
  return [{
    id: "processId",
    component: ProcessId,
    isEdited: isEdited$1
  }, {
    id: "processName",
    component: ProcessName,
    isEdited: isEdited$1
  }];
}
function ProcessName(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const process2 = element.businessObject.get("processRef");
  const getValue2 = () => {
    return process2.get("name");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: process2,
      properties: {
        name: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "processName",
    label: translate3("Process name"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function ProcessId(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const process2 = element.businessObject.get("processRef");
  const getValue2 = () => {
    return process2.get("id");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: process2,
      properties: {
        id: value
      }
    });
  };
  const validate3 = (value) => {
    return isIdValid(process2, value, translate3);
  };
  return TextfieldEntry({
    element,
    id: "processId",
    label: translate3("Process ID"),
    getValue: getValue2,
    setValue,
    debounce: debounce4,
    validate: validate3
  });
}
function hasProcessRef(element) {
  return is(element, "bpmn:Participant") && element.businessObject.get("processRef");
}
var EMPTY_OPTION$2 = "";
var CREATE_NEW_OPTION$1 = "create-new";
function SignalProps(props) {
  const {
    element
  } = props;
  if (!isSignalSupported(element)) {
    return [];
  }
  const signal = getSignal(element);
  let entries = [{
    id: "signalRef",
    component: SignalRef,
    isEdited: isEdited$4
  }];
  if (signal) {
    entries = [...entries, {
      id: "signalName",
      component: SignalName,
      isEdited: isEdited$1
    }];
  }
  return entries;
}
function SignalRef(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const signalEventDefinition = getSignalEventDefinition(element);
  const getValue2 = () => {
    const signal = getSignal(element);
    if (signal) {
      return signal.get("id");
    }
    return EMPTY_OPTION$2;
  };
  const setValue = (value) => {
    const root = getRoot(signalEventDefinition);
    const commands = [];
    let signal;
    if (value === CREATE_NEW_OPTION$1) {
      const id = nextId("Signal_");
      signal = createElement("bpmn:Signal", {
        id,
        name: id
      }, root, bpmnFactory);
      value = signal.get("id");
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: root,
          properties: {
            rootElements: [...root.get("rootElements"), signal]
          }
        }
      });
    }
    signal = signal || findRootElementById(signalEventDefinition, "bpmn:Signal", value);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: signalEventDefinition,
        properties: {
          signalRef: signal
        }
      }
    });
    return commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  const getOptions = () => {
    let options2 = [{
      value: EMPTY_OPTION$2,
      label: translate3("<none>")
    }, {
      value: CREATE_NEW_OPTION$1,
      label: translate3("Create new ...")
    }];
    const signals = findRootElementsByType(getBusinessObject(element), "bpmn:Signal");
    sortByName$2(signals).forEach((signal) => {
      options2.push({
        value: signal.get("id"),
        label: signal.get("name")
      });
    });
    return options2;
  };
  return ReferenceSelectEntry({
    element,
    id: "signalRef",
    label: translate3("Global signal reference"),
    autoFocusEntry: "signalName",
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function SignalName(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const signal = getSignal(element);
  const getValue2 = () => {
    return signal.get("name");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: signal,
      properties: {
        name: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "signalName",
    label: translate3("Name"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function sortByName$2(elements) {
  return (0, import_min_dash147.sortBy)(elements, (e7) => (e7.name || "").toLowerCase());
}
function isTimerSupported(element) {
  return isAny(element, ["bpmn:StartEvent", "bpmn:IntermediateCatchEvent", "bpmn:BoundaryEvent"]) && !!getTimerEventDefinition(element);
}
function getTimerDefinitionType(timer) {
  if (!timer) {
    return;
  }
  const timeDate = timer.get("timeDate");
  if (typeof timeDate !== "undefined") {
    return "timeDate";
  }
  const timeCycle = timer.get("timeCycle");
  if (typeof timeCycle !== "undefined") {
    return "timeCycle";
  }
  const timeDuration = timer.get("timeDuration");
  if (typeof timeDuration !== "undefined") {
    return "timeDuration";
  }
}
function getTimerEventDefinition(element) {
  return getEventDefinition3(element, "bpmn:TimerEventDefinition");
}
function getEventDefinition3(element, eventType) {
  const businessObject = getBusinessObject(element);
  const eventDefinitions = businessObject.get("eventDefinitions") || [];
  return (0, import_min_dash147.find)(eventDefinitions, function(definition) {
    return is(definition, eventType);
  });
}
function TimerProps$2(props) {
  const {
    element,
    listener,
    idPrefix
  } = props;
  let {
    timerEventDefinition
  } = props;
  if (!timerEventDefinition) {
    const businessObject = getBusinessObject(element);
    timerEventDefinition = getTimerEventDefinition(businessObject);
  }
  const timerEventDefinitionType = getTimerDefinitionType(timerEventDefinition);
  if (!isTimerSupported(element) && !isTimerSupportedOnListener$1(listener)) {
    return [];
  }
  const entries = [];
  entries.push({
    id: getId$1(idPrefix, "timerEventDefinitionType"),
    component: TimerEventDefinitionType$2,
    isEdited: isEdited$4,
    timerEventDefinition,
    timerEventDefinitionType
  });
  if (timerEventDefinitionType) {
    entries.push({
      id: getId$1(idPrefix, "timerEventDefinitionValue"),
      component: TimerEventDefinitionValue$2,
      isEdited: isEdited$1,
      timerEventDefinition,
      timerEventDefinitionType
    });
  }
  return entries;
}
function TimerEventDefinitionType$2(props) {
  const {
    element,
    timerEventDefinition,
    timerEventDefinitionType
  } = props;
  const commandStack = useService("commandStack"), bpmnFactory = useService("bpmnFactory"), translate3 = useService("translate");
  const getValue2 = () => {
    return timerEventDefinitionType || "";
  };
  const setValue = (value) => {
    if (value === timerEventDefinitionType) {
      return;
    }
    const formalExpression = bpmnFactory.create("bpmn:FormalExpression", {
      body: void 0
    });
    formalExpression.$parent = timerEventDefinition;
    const newProps = {
      timeDuration: void 0,
      timeDate: void 0,
      timeCycle: void 0
    };
    if (value !== "") {
      newProps[value] = formalExpression;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: timerEventDefinition,
      properties: newProps
    });
  };
  const getOptions = (element2) => {
    return [{
      value: "",
      label: translate3("<none>")
    }, {
      value: "timeDate",
      label: translate3("Date")
    }, {
      value: "timeDuration",
      label: translate3("Duration")
    }, {
      value: "timeCycle",
      label: translate3("Cycle")
    }];
  };
  return SelectEntry({
    element,
    id: "timerEventDefinitionType",
    label: translate3("Type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function TimerEventDefinitionValue$2(props) {
  const {
    element,
    timerEventDefinition,
    timerEventDefinitionType
  } = props;
  const commandStack = useService("commandStack"), translate3 = useService("translate"), debounce4 = useService("debounceInput");
  const timerEventFormalExpression = timerEventDefinition.get(timerEventDefinitionType);
  const getValue2 = () => {
    return timerEventFormalExpression && timerEventFormalExpression.get("body");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: timerEventFormalExpression,
      properties: {
        body: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "timerEventDefinitionValue",
    label: translate3("Value"),
    getValue: getValue2,
    setValue,
    debounce: debounce4,
    description: getTimerEventDefinitionValueDescription$2(timerEventDefinitionType, translate3)
  });
}
function getTimerEventDefinitionValueDescription$2(timerDefinitionType, translate3) {
  switch (timerDefinitionType) {
    case "timeDate":
      return o5("div", {
        children: [o5("p", {
          children: translate3("A specific point in time defined as ISO 8601 combined date and time representation.")
        }), o5("ul", {
          children: [o5("li", {
            children: [o5("code", {
              children: "2019-10-01T12:00:00Z"
            }), " - ", translate3("UTC time")]
          }), o5("li", {
            children: [o5("code", {
              children: "2019-10-02T08:09:40+02:00"
            }), " - ", translate3("UTC plus 2 hours zone offset")]
          })]
        }), o5("a", {
          href: "https://docs.camunda.org/manual/latest/reference/bpmn20/events/timer-events/#time-date",
          target: "_blank",
          rel: "noopener",
          children: translate3("Documentation: Timer events")
        })]
      });
    case "timeCycle":
      return o5("div", {
        children: [o5("p", {
          children: translate3("A cycle defined as ISO 8601 repeating intervals format.")
        }), o5("ul", {
          children: [o5("li", {
            children: [o5("code", {
              children: "R5/PT10S"
            }), " - ", translate3("every 10 seconds, up to 5 times")]
          }), o5("li", {
            children: [o5("code", {
              children: "R/P1D"
            }), " - ", translate3("every day, infinitely")]
          })]
        }), o5("a", {
          href: "https://docs.camunda.org/manual/latest/reference/bpmn20/events/timer-events/#time-cycle",
          target: "_blank",
          rel: "noopener",
          children: translate3("Documentation: Timer events")
        })]
      });
    case "timeDuration":
      return o5("div", {
        children: [o5("p", {
          children: translate3("A time duration defined as ISO 8601 durations format.")
        }), o5("ul", {
          children: [o5("li", {
            children: [o5("code", {
              children: "PT15S"
            }), " - ", translate3("15 seconds")]
          }), o5("li", {
            children: [o5("code", {
              children: "PT1H30M"
            }), " - ", translate3("1 hour and 30 minutes")]
          }), o5("li", {
            children: [o5("code", {
              children: "P14D"
            }), " - ", translate3("14 days")]
          })]
        }), o5("a", {
          href: "https://docs.camunda.org/manual/latest/reference/bpmn20/events/timer-events/#time-duration",
          target: "_blank",
          rel: "noopener",
          children: translate3("Documentation: Timer events")
        })]
      });
  }
}
function isTimerSupportedOnListener$1(listener) {
  return listener && is(listener, "camunda:TaskListener") && getTimerEventDefinition(listener);
}
function getId$1(idPrefix, id) {
  return idPrefix ? idPrefix + id : id;
}
function GeneralGroup(element, injector) {
  const translate3 = injector.get("translate");
  const entries = [...NameProps({
    element
  }), ...IdProps(), ...ProcessProps({
    element
  }), ...ExecutableProps({
    element
  })];
  return {
    id: "general",
    label: translate3("General"),
    entries,
    component: Group
  };
}
function CompensationGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Compensation"),
    id: "compensation",
    component: Group,
    entries: [...CompensationProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function DocumentationGroup(element, injector) {
  const translate3 = injector.get("translate");
  const entries = [...DocumentationProps({
    element
  })];
  return {
    id: "documentation",
    label: translate3("Documentation"),
    entries,
    component: Group
  };
}
function ErrorGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    id: "error",
    label: translate3("Error"),
    component: Group,
    entries: [...ErrorProps$2({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function MessageGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    id: "message",
    label: translate3("Message"),
    component: Group,
    entries: [...MessageProps$1({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function SignalGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    id: "signal",
    label: translate3("Signal"),
    component: Group,
    entries: [...SignalProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function LinkGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Link"),
    id: "link",
    component: Group,
    entries: [...LinkProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function EscalationGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    id: "escalation",
    label: translate3("Escalation"),
    component: Group,
    entries: [...EscalationProps$1({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function TimerGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Timer"),
    id: "timer",
    component: Group,
    entries: [...TimerProps$2({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function MultiInstanceGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Multi-instance"),
    id: "multiInstance",
    component: Group,
    entries: [...MultiInstanceProps$2({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function getGroups(element, injector) {
  const groups = [GeneralGroup(element, injector), DocumentationGroup(element, injector), CompensationGroup(element, injector), ErrorGroup(element, injector), LinkGroup(element, injector), MessageGroup(element, injector), MultiInstanceGroup(element, injector), SignalGroup(element, injector), EscalationGroup(element, injector), TimerGroup(element, injector)];
  return groups.filter((group) => group !== null);
}
var BpmnPropertiesProvider = class {
  constructor(propertiesPanel, injector) {
    propertiesPanel.registerProvider(this);
    this._injector = injector;
  }
  getGroups(element) {
    return (groups) => {
      groups = groups.concat(getGroups(element, this._injector));
      return groups;
    };
  }
};
BpmnPropertiesProvider.$inject = ["propertiesPanel", "injector"];
var index$2 = {
  __init__: ["bpmnPropertiesProvider"],
  bpmnPropertiesProvider: ["type", BpmnPropertiesProvider]
};
function getExtensionElementsList(businessObject, type = void 0) {
  const extensionElements = businessObject.get("extensionElements");
  if (!extensionElements) {
    return [];
  }
  const values5 = extensionElements.get("values");
  if (!values5 || !values5.length) {
    return [];
  }
  if (type) {
    return values5.filter((value) => is(value, type));
  }
  return values5;
}
function addExtensionElements(element, businessObject, extensionElementToAdd, bpmnFactory, commandStack) {
  const commands = [];
  let extensionElements = businessObject.get("extensionElements");
  if (!extensionElements) {
    extensionElements = createElement("bpmn:ExtensionElements", {
      values: []
    }, businessObject, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: businessObject,
        properties: {
          extensionElements
        }
      }
    });
  }
  extensionElementToAdd.$parent = extensionElements;
  commands.push({
    cmd: "element.updateModdleProperties",
    context: {
      element,
      moddleElement: extensionElements,
      properties: {
        values: [...extensionElements.get("values"), extensionElementToAdd]
      }
    }
  });
  commandStack.execute("properties-panel.multi-command-executor", commands);
}
function removeExtensionElements(element, businessObject, extensionElementsToRemove, commandStack) {
  if (!(0, import_min_dash147.isArray)(extensionElementsToRemove)) {
    extensionElementsToRemove = [extensionElementsToRemove];
  }
  const extensionElements = businessObject.get("extensionElements"), values5 = extensionElements.get("values").filter((value) => !extensionElementsToRemove.includes(value));
  commandStack.execute("element.updateModdleProperties", {
    element,
    moddleElement: extensionElements,
    properties: {
      values: values5
    }
  });
}
function withVariableContext(Component) {
  return (props) => {
    const {
      bpmnElement,
      element
    } = props;
    const bo = (bpmnElement || element).businessObject;
    const [variables2, setVariables] = l4([]);
    const eventBus = useService("eventBus");
    y3(() => {
      const callback = () => {
        const variables3 = (0, import_zeebe.getVariablesForElement)(bo);
        setVariables(variables3.map((variable) => {
          return {
            name: variable.name,
            info: "Written in " + variable.origin.map((origin) => origin.name || origin.id).join(", ")
          };
        }));
      };
      eventBus.on("commandStack.changed", callback);
      callback();
      return () => {
        eventBus.off("commandStack.changed", callback);
      };
    }, [bo]);
    return o5(Component, {
      ...props,
      variables: variables2
    });
  };
}
function withTooltipContainer(Component) {
  return (props) => {
    const tooltipContainer = d4(() => {
      const config = useService("config");
      return config && config.propertiesPanel && config.propertiesPanel.feelTooltipContainer;
    }, []);
    return o5(Component, {
      ...props,
      tooltipContainer
    });
  };
}
var FeelEntryWithContext = withVariableContext(withTooltipContainer(FeelEntry));
var FeelTextAreaEntryWithContext = withVariableContext(withTooltipContainer(FeelTextArea));
function AssignmentDefinitionProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:UserTask")) {
    return [];
  }
  return [{
    id: "assignmentDefinitionAssignee",
    component: Assignee$1,
    isEdited: isEdited$6
  }, {
    id: "assignmentDefinitionCandidateGroups",
    component: CandidateGroups$1,
    isEdited: isEdited$6
  }, {
    id: "assignmentDefinitionCandidateUsers",
    component: CandidateUsers$1,
    isEdited: isEdited$6
  }];
}
function Assignee$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return (getAssignmentDefinition(element) || {}).assignee;
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let assignmentDefinition = getAssignmentDefinition(element);
    if (!assignmentDefinition) {
      assignmentDefinition = createElement("zeebe:AssignmentDefinition", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), assignmentDefinition]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: assignmentDefinition,
        properties: {
          assignee: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithContext({
    element,
    id: "assignmentDefinitionAssignee",
    label: translate3("Assignee"),
    feel: "optional",
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function CandidateGroups$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return (getAssignmentDefinition(element) || {}).candidateGroups;
  };
  const setValue = (value) => {
    let commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let assignmentDefinition = getAssignmentDefinition(element);
    if (!assignmentDefinition) {
      assignmentDefinition = createElement("zeebe:AssignmentDefinition", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), assignmentDefinition]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: assignmentDefinition,
        properties: {
          candidateGroups: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithContext({
    element,
    id: "assignmentDefinitionCandidateGroups",
    label: translate3("Candidate groups"),
    feel: "optional",
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function CandidateUsers$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return (getAssignmentDefinition(element) || {}).candidateUsers;
  };
  const setValue = (value) => {
    let commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let assignmentDefinition = getAssignmentDefinition(element);
    if (!assignmentDefinition) {
      assignmentDefinition = createElement("zeebe:AssignmentDefinition", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), assignmentDefinition]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: assignmentDefinition,
        properties: {
          candidateUsers: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithContext({
    element,
    id: "assignmentDefinitionCandidateUsers",
    label: translate3("Candidate users"),
    feel: "optional",
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function getAssignmentDefinition(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:AssignmentDefinition")[0];
}
var DMN_IMPLEMENTATION_OPTION = "dmn";
var JOB_WORKER_IMPLEMENTATION_OPTION$1 = "jobWorker";
var DEFAULT_IMPLEMENTATION_OPTION$1 = "";
function BusinessRuleImplementationProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:BusinessRuleTask")) {
    return [];
  }
  return [{
    id: "businessRuleImplementation",
    component: BusinessRuleImplementation,
    isEdited: () => isBusinessRuleImplementationEdited(element)
  }];
}
function BusinessRuleImplementation(props) {
  const {
    element,
    id
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate3 = useService("translate");
  const getValue2 = () => {
    if (getCalledDecision$1(element)) {
      return DMN_IMPLEMENTATION_OPTION;
    }
    if (getTaskDefinition$3(element)) {
      return JOB_WORKER_IMPLEMENTATION_OPTION$1;
    }
    return DEFAULT_IMPLEMENTATION_OPTION$1;
  };
  const setValue = (value) => {
    let extensionElement, extensionElementType;
    if (value === DMN_IMPLEMENTATION_OPTION) {
      extensionElement = getCalledDecision$1(element);
      extensionElementType = "zeebe:CalledDecision";
    } else if (value === JOB_WORKER_IMPLEMENTATION_OPTION$1) {
      extensionElement = getTaskDefinition$3(element);
      extensionElementType = "zeebe:TaskDefinition";
    } else {
      resetElement$1(element, commandStack);
    }
    if (!extensionElement && extensionElementType) {
      extensionElement = createElement(extensionElementType, {}, null, bpmnFactory);
      updateExtensionElements$1(element, extensionElement, bpmnFactory, commandStack);
    }
  };
  const getOptions = () => {
    const options2 = [{
      value: DEFAULT_IMPLEMENTATION_OPTION$1,
      label: translate3("<none>")
    }, {
      value: DMN_IMPLEMENTATION_OPTION,
      label: translate3("DMN decision")
    }, {
      value: JOB_WORKER_IMPLEMENTATION_OPTION$1,
      label: translate3("Job worker")
    }];
    return options2;
  };
  return SelectEntry({
    element,
    id,
    label: translate3("Implementation"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function getTaskDefinition$3(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:TaskDefinition")[0];
}
function getCalledDecision$1(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:CalledDecision")[0];
}
function isBusinessRuleImplementationEdited(element) {
  return getTaskDefinition$3(element);
}
function resetElement$1(element, commandStack) {
  const businessObject = getBusinessObject(element);
  const taskDefintion = getTaskDefinition$3(element);
  const calledDecision = getCalledDecision$1(element);
  if (taskDefintion) {
    removeExtensionElements(element, businessObject, taskDefintion, commandStack);
  }
  if (calledDecision) {
    removeExtensionElements(element, businessObject, calledDecision, commandStack);
  }
}
function updateExtensionElements$1(element, extensionElementToAdd, bpmnFactory, commandStack) {
  const businessObject = getBusinessObject(element);
  const commands = [];
  let extensionElements = businessObject.get("extensionElements");
  let extensionElementValues;
  if (!extensionElements) {
    extensionElements = createElement("bpmn:ExtensionElements", {
      values: []
    }, businessObject, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: businessObject,
        properties: {
          extensionElements
        }
      }
    });
  }
  extensionElementToAdd.$parent = extensionElements;
  if (is(extensionElementToAdd, "zeebe:TaskDefinition")) {
    extensionElementValues = (0, import_min_dash147.without)(extensionElements.get("values"), getCalledDecision$1(element));
  } else if (is(extensionElementToAdd, "zeebe:CalledDecision")) {
    extensionElementValues = (0, import_min_dash147.without)(extensionElements.get("values"), getTaskDefinition$3(element));
  }
  commands.push({
    cmd: "element.updateModdleProperties",
    context: {
      element,
      moddleElement: extensionElements,
      properties: {
        values: [...extensionElementValues, extensionElementToAdd]
      }
    }
  });
  commandStack.execute("properties-panel.multi-command-executor", commands);
}
function CalledDecisionProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:BusinessRuleTask") || !getCalledDecision(element)) {
    return [];
  }
  return [{
    id: "decisionId",
    component: DecisionID,
    isEdited: isEdited$6
  }, {
    id: "resultVariable",
    component: ResultVariable$4,
    isEdited: isEdited$1
  }];
}
function DecisionID(props) {
  const {
    element,
    id
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return (getCalledDecision(element) || {}).decisionId;
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let calledDecision = getCalledDecision(element);
    if (!calledDecision) {
      calledDecision = createElement("zeebe:CalledDecision", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), calledDecision]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: calledDecision,
        properties: {
          decisionId: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithContext({
    element,
    id,
    label: translate3("Decision ID"),
    feel: "optional",
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function ResultVariable$4(props) {
  const {
    element,
    id
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return (getCalledDecision(element) || {}).resultVariable;
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let calledDecision = getCalledDecision(element);
    if (!calledDecision) {
      calledDecision = createElement("zeebe:CalledDecision", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), calledDecision]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: calledDecision,
        properties: {
          resultVariable: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return TextfieldEntry({
    element,
    id,
    label: translate3("Result variable"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function getCalledDecision(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:CalledDecision")[0];
}
function ConditionProps$1(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:SequenceFlow")) {
    return [];
  }
  const conditionProps = [];
  if (isConditionalSource$1(element.source)) {
    conditionProps.push({
      id: "conditionExpression",
      component: ConditionExpression$1,
      isEdited: isEdited$6
    });
  }
  return conditionProps;
}
function ConditionExpression$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), bpmnFactory = useService("bpmnFactory"), translate3 = useService("translate"), debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return getConditionExpression$1(element);
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    const source = element.source;
    if (source.businessObject.default === businessObject) {
      commands.push({
        cmd: "element.updateProperties",
        context: {
          element: source,
          properties: {
            "default": void 0
          }
        }
      });
    }
    const formalExpressionElement = value && value != "" ? createElement("bpmn:FormalExpression", {
      body: value
    }, businessObject, bpmnFactory) : void 0;
    commands.push({
      cmd: "element.updateProperties",
      context: {
        element,
        properties: {
          conditionExpression: formalExpressionElement
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithContext({
    element,
    id: "conditionExpression",
    label: translate3("Condition expression"),
    feel: "required",
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
var CONDITIONAL_SOURCES$1 = ["bpmn:Activity", "bpmn:ExclusiveGateway", "bpmn:InclusiveGateway"];
function isConditionalSource$1(element) {
  return isAny(element, CONDITIONAL_SOURCES$1);
}
function getConditionExpression$1(element) {
  const businessObject = getBusinessObject(element);
  const conditionExpression = businessObject.conditionExpression;
  if (conditionExpression) {
    return conditionExpression.get("body");
  }
}
function ErrorProps$1(props) {
  const {
    element
  } = props;
  const error4 = getError(element);
  const entries = [];
  if (error4) {
    entries.push({
      id: "errorCode",
      component: ErrorCode$1,
      isEdited: isEdited$6
    });
  }
  return entries;
}
function ErrorCode$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const error4 = getError(element);
  const getValue2 = () => {
    return error4.get("errorCode");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: error4,
      properties: {
        errorCode: value
      }
    });
  };
  return FeelEntryWithContext({
    element,
    id: "errorCode",
    label: translate3("Code"),
    feel: "optional",
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function FormProps$1(props) {
  const {
    element,
    injector
  } = props;
  const formHelper = injector.invoke(FormHelper);
  if (!is(element, "bpmn:UserTask")) {
    return [];
  }
  const entries = [{
    id: "formType",
    component: FormType$1,
    isEdited: isEdited$4
  }];
  if (isCamundaForm(element, formHelper)) {
    entries.push({
      id: "formConfiguration",
      component: FormConfiguration,
      isEdited: isEdited$2
    });
  } else if (isCustomKey(element, formHelper)) {
    entries.push({
      id: "customFormKey",
      component: CustomFormKey,
      isEdited: isEdited$1
    });
  }
  return entries;
}
function FormType$1(props) {
  const {
    element
  } = props;
  const translate3 = useService("translate");
  const injector = useService("injector");
  const formHelper = injector.invoke(FormHelper);
  const getValue2 = () => {
    const formDefinition = formHelper.getFormDefinition(element);
    const userTaskForm = formHelper.getUserTaskForm(element);
    if (formDefinition) {
      if (userTaskForm) {
        return "camundaForm";
      }
      return "formKey";
    }
    return "";
  };
  const setValue = (value) => {
    formHelper.resetForm(element);
    if (value === "camundaForm") {
      formHelper.setUserTaskForm(element, "");
    } else if (value === "formKey") {
      formHelper.setFormDefinition(element, "");
    }
  };
  const getOptions = () => {
    return [{
      value: "",
      label: translate3("<none>")
    }, {
      value: "camundaForm",
      label: translate3("Camunda forms")
    }, {
      value: "formKey",
      label: translate3("Custom form key")
    }];
  };
  return SelectEntry({
    element,
    id: "formType",
    label: translate3("Type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function FormConfiguration(props) {
  const {
    element
  } = props;
  const injector = useService("injector");
  const debounce4 = useService("debounceInput");
  const translate3 = useService("translate");
  const formHelper = injector.invoke(FormHelper);
  const getValue2 = () => {
    const userTaskForm = formHelper.getUserTaskForm(element);
    return userTaskForm.get("body");
  };
  const setValue = (value) => {
    formHelper.setUserTaskForm(element, value);
  };
  return TextAreaEntry({
    element,
    id: "formConfiguration",
    label: translate3("Form JSON configuration"),
    rows: 4,
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function CustomFormKey(props) {
  const {
    element
  } = props;
  const injector = useService("injector");
  const debounce4 = useService("debounceInput");
  const translate3 = useService("translate");
  const formHelper = injector.invoke(FormHelper);
  const getValue2 = () => {
    const formDefinition = formHelper.getFormDefinition(element);
    return formDefinition.get("formKey");
  };
  const setValue = (value) => {
    formHelper.setFormDefinition(element, value);
  };
  return TextfieldEntry({
    element,
    id: "customFormKey",
    label: translate3("Form key"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
var USER_TASK_FORM_PREFIX = "userTaskForm_";
function FormHelper(bpmnFactory, commandStack) {
  function getFormDefinition(element) {
    const businessObject = getBusinessObject(element);
    const formDefinitions = getExtensionElementsList(businessObject, "zeebe:FormDefinition");
    return formDefinitions[0];
  }
  function getUserTaskForm(element, parent) {
    const rootElement = parent || getRootElement3(element);
    const formDefinition = getFormDefinition(element);
    if ((0, import_min_dash147.isUndefined)(formDefinition)) {
      return;
    }
    const formKey = formDefinition.get("formKey");
    const userTaskForm = findUserTaskForm(formKey, rootElement);
    return userTaskForm;
  }
  function ensureTaskForm(element, values5) {
    let commands = [];
    const rootElement = getRootElement3(element);
    let rootExtensionElements = rootElement.get("extensionElements");
    if (!rootExtensionElements) {
      rootExtensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, rootElement, bpmnFactory);
      commands.push(UpdateModdlePropertiesCmd(element, rootElement, {
        extensionElements: rootExtensionElements
      }));
    }
    let userTaskForm = getUserTaskForm(element);
    if (!userTaskForm) {
      userTaskForm = createUserTaskForm(values5, rootExtensionElements, bpmnFactory);
      commands.push(UpdateModdlePropertiesCmd(element, rootExtensionElements, {
        values: [...rootExtensionElements.get("values"), userTaskForm]
      }));
    }
    commands.push(UpdateModdlePropertiesCmd(element, userTaskForm, values5));
    return commands;
  }
  function ensureFormDefinition(element, customFormKey) {
    const businessObject = getBusinessObject(element);
    let commands = [];
    let extensionElements = businessObject.get("extensionElements");
    if ((0, import_min_dash147.isUndefined)(extensionElements)) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push(UpdateModdlePropertiesCmd(element, businessObject, {
        extensionElements
      }));
    }
    let formDefinition = getFormDefinition(element);
    if (!formDefinition) {
      let formKey = customFormKey;
      if ((0, import_min_dash147.isUndefined)(formKey)) {
        const formId = createFormId();
        formKey = createFormKey(formId);
      }
      formDefinition = createFormDefinition({
        formKey
      }, extensionElements, bpmnFactory);
      commands.push(UpdateModdlePropertiesCmd(element, extensionElements, {
        values: [...extensionElements.get("values"), formDefinition]
      }));
    } else if (customFormKey) {
      commands.push(UpdateModdlePropertiesCmd(element, formDefinition, {
        formKey: customFormKey
      }));
    }
    return {
      formId: resolveFormId(formDefinition.get("formKey")),
      commands
    };
  }
  function setFormDefinition(element, customFormKey) {
    const {
      commands
    } = ensureFormDefinition(element, customFormKey);
    commandStack.execute("properties-panel.multi-command-executor", commands);
  }
  function setUserTaskForm(element, value) {
    const {
      formId,
      commands: formDefCommands
    } = ensureFormDefinition(element);
    const userTaskCommands = ensureTaskForm(element, {
      id: formId,
      body: value
    });
    const commands = formDefCommands.concat(userTaskCommands);
    commandStack.execute("properties-panel.multi-command-executor", commands);
  }
  function unsetFormDefinition(element) {
    const businessObject = getBusinessObject(element), extensionElements = businessObject.get("extensionElements");
    let commands = [];
    const formDefinition = getFormDefinition(element);
    if (!formDefinition) {
      return commands;
    }
    let values5 = (0, import_min_dash147.without)(extensionElements.get("values"), formDefinition);
    commands.push(UpdateModdlePropertiesCmd(element, extensionElements, {
      values: values5
    }));
    return commands;
  }
  function resetForm(element) {
    const rootElement = getRootElement3(element), rootExtensionElements = rootElement.get("extensionElements");
    const commands = unsetFormDefinition(element);
    const userTaskForm = getUserTaskForm(element);
    if (!userTaskForm) {
      commandStack.execute("properties-panel.multi-command-executor", commands);
      return;
    }
    const values5 = (0, import_min_dash147.without)(rootExtensionElements.get("values"), userTaskForm);
    commands.push(UpdateModdlePropertiesCmd(element, rootExtensionElements, {
      values: values5
    }));
    commandStack.execute("properties-panel.multi-command-executor", commands);
  }
  function createFormKey(formId) {
    return "camunda-forms:bpmn:" + formId;
  }
  function createFormId() {
    return nextId(USER_TASK_FORM_PREFIX);
  }
  function resolveFormId(formKey) {
    return formKey.split(":")[2];
  }
  function createFormDefinition(properties, extensionElements, bpmnFactory2) {
    return createElement("zeebe:FormDefinition", properties, extensionElements, bpmnFactory2);
  }
  function createUserTaskForm(properties, extensionElements, bpmnFactory2) {
    return createElement("zeebe:UserTaskForm", properties, extensionElements, bpmnFactory2);
  }
  function findUserTaskForm(formKey, rootElement) {
    const forms = getExtensionElementsList(rootElement, "zeebe:UserTaskForm");
    return (0, import_min_dash147.find)(forms, function(userTaskForm) {
      return createFormKey(userTaskForm.id) === formKey;
    });
  }
  function getRootElement3(element) {
    const businessObject = getBusinessObject(element);
    let parent = businessObject;
    while (parent.$parent && !is(parent, "bpmn:Process")) {
      parent = parent.$parent;
    }
    return parent;
  }
  return {
    getFormDefinition,
    getUserTaskForm,
    setFormDefinition,
    setUserTaskForm,
    resetForm
  };
}
FormHelper.$inject = ["bpmnFactory", "commandStack"];
function UpdateModdlePropertiesCmd(element, businessObject, newProperties) {
  return {
    cmd: "element.updateModdleProperties",
    context: {
      element,
      moddleElement: businessObject,
      properties: newProperties
    }
  };
}
function isCamundaForm(element, formHelper) {
  const formDefinition = formHelper.getFormDefinition(element);
  const userTaskForm = formHelper.getUserTaskForm(element);
  return formDefinition && userTaskForm;
}
function isCustomKey(element, formHelper) {
  const formDefinition = formHelper.getFormDefinition(element);
  const userTaskForm = formHelper.getUserTaskForm(element);
  return formDefinition && !userTaskForm;
}
function Header2(props) {
  const {
    idPrefix,
    header
  } = props;
  const entries = [{
    id: idPrefix + "-key",
    component: KeyProperty,
    header,
    idPrefix
  }, {
    id: idPrefix + "-value",
    component: ValueProperty$2,
    header,
    idPrefix
  }];
  return entries;
}
function KeyProperty(props) {
  const {
    idPrefix,
    element,
    header
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: header,
      properties: {
        key: value
      }
    });
  };
  const getValue2 = (header2) => {
    return header2.key;
  };
  return TextfieldEntry({
    element: header,
    id: idPrefix + "-key",
    label: translate3("Key"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function ValueProperty$2(props) {
  const {
    idPrefix,
    element,
    header
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: header,
      properties: {
        value
      }
    });
  };
  const getValue2 = (header2) => {
    return header2.value;
  };
  return TextfieldEntry({
    element: header,
    id: idPrefix + "-value",
    label: translate3("Value"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function isZeebeServiceTask(element) {
  if (!is(element, "zeebe:ZeebeServiceTask"))
    return false;
  if (is(element, "bpmn:EndEvent") || is(element, "bpmn:IntermediateThrowEvent")) {
    return !!getMessageEventDefinition(element);
  }
  if (isAny(element, ["bpmn:BusinessRuleTask", "bpmn:ScriptTask"]) && !getTaskDefinition$2(element)) {
    return false;
  }
  return true;
}
function isMessageEndEvent(element) {
  return is(element, "bpmn:EndEvent") && !!getMessageEventDefinition(element);
}
function isMessageThrowEvent(element) {
  return is(element, "bpmn:IntermediateThrowEvent") && !!getMessageEventDefinition(element);
}
function getTaskDefinition$2(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:TaskDefinition")[0];
}
function areHeadersSupported(element) {
  return is(element, "bpmn:UserTask") || isZeebeServiceTask(element);
}
function getTaskHeaders$1(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:TaskHeaders")[0];
}
function getHeaders(element) {
  const taskHeaders = getTaskHeaders$1(element);
  return taskHeaders ? taskHeaders.get("values") : [];
}
function HeaderProps({
  element,
  injector
}) {
  if (!areHeadersSupported(element)) {
    return null;
  }
  const headers = getHeaders(element) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = headers.map((header, index2) => {
    const id = element.id + "-header-" + index2;
    return {
      id,
      label: header.get("key") || "",
      entries: Header2({
        idPrefix: id,
        element,
        header
      }),
      autoFocusEntry: id + "-key",
      remove: removeFactory$c({
        commandStack,
        element,
        header
      })
    };
  });
  return {
    items,
    add: addFactory$9({
      bpmnFactory,
      commandStack,
      element
    })
  };
}
function removeFactory$c({
  commandStack,
  element,
  header
}) {
  return function(event2) {
    event2.stopPropagation();
    let commands = [];
    const taskHeaders = getTaskHeaders$1(element);
    if (!taskHeaders) {
      return;
    }
    const newTaskHeaders = (0, import_min_dash147.without)(taskHeaders.get("values"), header);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: taskHeaders,
        properties: {
          values: newTaskHeaders
        }
      }
    });
    if (!newTaskHeaders.length) {
      const businessObject = getBusinessObject(element), extensionElements = businessObject.get("extensionElements");
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: (0, import_min_dash147.without)(extensionElements.get("values"), taskHeaders)
          }
        }
      });
    }
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function addFactory$9({
  bpmnFactory,
  commandStack,
  element
}) {
  return function(event2) {
    event2.stopPropagation();
    let commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let taskHeaders = getTaskHeaders$1(element);
    if (!taskHeaders) {
      const parent = extensionElements;
      taskHeaders = createElement("zeebe:TaskHeaders", {
        values: []
      }, parent, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), taskHeaders]
          }
        }
      });
    }
    const header = createElement("zeebe:Header", {}, taskHeaders, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: taskHeaders,
        properties: {
          values: [...taskHeaders.get("values"), header]
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function InputOutputParameter$1(props) {
  const {
    idPrefix,
    parameter
  } = props;
  const entries = [{
    id: idPrefix + "-target",
    component: TargetProperty,
    idPrefix,
    parameter
  }, {
    id: idPrefix + "-source",
    component: SourceProperty,
    idPrefix,
    parameter
  }];
  return entries;
}
function TargetProperty(props) {
  const {
    idPrefix,
    element,
    parameter
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: parameter,
      properties: {
        target: value
      }
    });
  };
  const getValue2 = (parameter2) => {
    return parameter2.target;
  };
  return TextfieldEntry({
    element: parameter,
    id: idPrefix + "-target",
    label: translate3(is(parameter, "zeebe:Input") ? "Local variable name" : "Process variable name"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function SourceProperty(props) {
  const {
    idPrefix,
    element,
    parameter
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: parameter,
      properties: {
        source: value
      }
    });
  };
  const getValue2 = (parameter2) => {
    return parameter2.source;
  };
  return FeelEntryWithContext({
    bpmnElement: element,
    element: parameter,
    id: idPrefix + "-source",
    label: translate3("Variable assignment value"),
    feel: "required",
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function getElements$1(bo, type, prop) {
  const elems = getExtensionElementsList(bo, type);
  return !prop ? elems : (elems[0] || {})[prop] || [];
}
function getParameters$1(element, prop) {
  const ioMapping = getIoMapping(element);
  return ioMapping && ioMapping.get(prop) || [];
}
function getIoMapping(element) {
  const bo = getBusinessObject(element);
  return (getElements$1(bo, "zeebe:IoMapping") || [])[0];
}
function getInputParameters$1(element) {
  return getParameters$1.apply(this, [element, "inputParameters"]);
}
function getOutputParameters$1(element) {
  return getParameters$1.apply(this, [element, "outputParameters"]);
}
function areInputParametersSupported$1(element) {
  return isAny(element, ["bpmn:UserTask", "bpmn:SubProcess", "bpmn:CallActivity", "bpmn:BusinessRuleTask", "bpmn:ScriptTask"]) || isZeebeServiceTask(element);
}
function areOutputParametersSupported$1(element) {
  return isAny(element, ["zeebe:ZeebeServiceTask", "bpmn:UserTask", "bpmn:SubProcess", "bpmn:ReceiveTask", "bpmn:CallActivity", "bpmn:Event", "bpmn:BusinessRuleTask"]);
}
function createIOMapping(properties, parent, bpmnFactory) {
  return createElement("zeebe:IoMapping", properties, parent, bpmnFactory);
}
function InputProps$1({
  element,
  injector
}) {
  if (!areInputParametersSupported$1(element)) {
    return null;
  }
  const inputParameters = getInputParameters$1(element) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = inputParameters.map((parameter, index2) => {
    const id = element.id + "-input-" + index2;
    return {
      id,
      label: parameter.get("target") || "",
      entries: InputOutputParameter$1({
        idPrefix: id,
        element,
        parameter
      }),
      autoFocusEntry: id + "-target",
      remove: removeFactory$b({
        commandStack,
        element,
        parameter
      })
    };
  });
  return {
    items,
    add: addFactory$8({
      element,
      bpmnFactory,
      commandStack
    })
  };
}
function removeFactory$b({
  commandStack,
  element,
  parameter
}) {
  return function(event2) {
    event2.stopPropagation();
    const commands = [];
    const ioMapping = getIoMapping(element);
    if (!ioMapping) {
      return;
    }
    const inputParameters = (0, import_min_dash147.without)(ioMapping.get("inputParameters"), parameter);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: ioMapping,
        properties: {
          inputParameters
        }
      }
    });
    const businessObject = getBusinessObject(element), extensionElements = businessObject.get("extensionElements"), values5 = (0, import_min_dash147.without)(extensionElements.get("values"), ioMapping);
    if (!inputParameters.length && !ioMapping.get("outputParameters").length) {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: values5
          }
        }
      });
    }
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function addFactory$8({
  element,
  bpmnFactory,
  commandStack
}) {
  return function(event2) {
    event2.stopPropagation();
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let ioMapping = getIoMapping(element);
    if (!ioMapping) {
      ioMapping = createIOMapping({
        inputParameters: [],
        outputParameters: []
      }, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), ioMapping]
          }
        }
      });
    }
    const newParameter = createElement("zeebe:Input", {
      source: "",
      target: nextId("InputVariable_")
    }, ioMapping, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: ioMapping,
        properties: {
          inputParameters: [...ioMapping.get("inputParameters"), newParameter]
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function MessageProps(props) {
  const {
    element
  } = props;
  const message = getMessage(element);
  const entries = [];
  if (message) {
    entries.push({
      id: "messageName",
      component: MessageName,
      isEdited: isEdited$6
    });
  }
  if (message && canHaveSubscriptionCorrelationKey(element)) {
    entries.push({
      id: "messageSubscriptionCorrelationKey",
      component: SubscriptionCorrelationKey,
      isEdited: isEdited$6
    });
  }
  return entries;
}
function MessageName(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const message = getMessage(element);
  const getValue2 = () => {
    return message.get("name");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: message,
      properties: {
        name: value
      }
    });
  };
  return FeelEntryWithContext({
    element,
    id: "messageName",
    label: translate3("Name"),
    feel: "optional",
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function SubscriptionCorrelationKey(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return getCorrelationKey(element);
  };
  const setValue = (value) => {
    const commands = [];
    const message = getMessage(element);
    let extensionElements = message.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, message, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: message,
          properties: {
            extensionElements
          }
        }
      });
    }
    let subscription = getSubscription(element);
    if (!subscription) {
      subscription = createElement("zeebe:Subscription", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), subscription]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: subscription,
        properties: {
          correlationKey: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithContext({
    element,
    id: "messageSubscriptionCorrelationKey",
    label: translate3("Subscription correlation key"),
    feel: "required",
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function canHaveSubscriptionCorrelationKey(element) {
  if (is(element, "bpmn:ReceiveTask")) {
    return true;
  }
  if (!is(element, "bpmn:StartEvent")) {
    return true;
  }
  if (is(element, "bpmn:StartEvent") && isEventSubProcess(element.parent)) {
    return true;
  }
  return false;
}
function getCorrelationKey(element) {
  const subscription = getSubscription(element);
  return subscription ? subscription.get("correlationKey") : "";
}
function getSubscription(element) {
  const message = getMessage(element);
  const subscriptions = getSubscriptions(message);
  return subscriptions[0];
}
function getSubscriptions(message) {
  const extensionElements = getExtensionElementsList(message, "zeebe:Subscription");
  return extensionElements;
}
function MultiInstanceProps$1(props) {
  const {
    element
  } = props;
  if (!supportsMultiInstances(element)) {
    return [];
  }
  return [{
    id: "multiInstance-inputCollection",
    component: InputCollection,
    isEdited: isEdited$6
  }, {
    id: "multiInstance-inputElement",
    component: InputElement,
    isEdited: isEdited$1
  }, {
    id: "multiInstance-outputCollection",
    component: OutputCollection,
    isEdited: isEdited$1
  }, {
    id: "multiInstance-outputElement",
    component: OutputElement,
    isEdited: isEdited$6
  }, {
    id: "multiInstance-completionCondition",
    component: CompletionCondition,
    isEdited: isEdited$6
  }];
}
function InputCollection(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return getProperty$1(element, "inputCollection");
  };
  const setValue = (value) => {
    return setProperty(element, "inputCollection", value, commandStack, bpmnFactory);
  };
  return FeelEntryWithContext({
    element,
    id: "multiInstance-inputCollection",
    label: translate3("Input collection"),
    feel: "required",
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function InputElement(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return getProperty$1(element, "inputElement");
  };
  const setValue = (value) => {
    return setProperty(element, "inputElement", value, commandStack, bpmnFactory);
  };
  return TextfieldEntry({
    element,
    id: "multiInstance-inputElement",
    label: translate3("Input element"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function OutputCollection(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return getProperty$1(element, "outputCollection");
  };
  const setValue = (value) => {
    return setProperty(element, "outputCollection", value, commandStack, bpmnFactory);
  };
  return TextfieldEntry({
    element,
    id: "multiInstance-outputCollection",
    label: translate3("Output collection"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function OutputElement(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return getProperty$1(element, "outputElement");
  };
  const setValue = (value) => {
    return setProperty(element, "outputElement", value, commandStack, bpmnFactory);
  };
  return FeelEntryWithContext({
    element,
    id: "multiInstance-outputElement",
    label: translate3("Output element"),
    feel: "required",
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function CompletionCondition(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    const completionCondition = getCompletionCondition(element);
    return completionCondition && completionCondition.get("body");
  };
  const setValue = (value) => {
    if (value && value !== "") {
      const loopCharacteristics = getLoopCharacteristics$1(element);
      const completionCondition = createElement("bpmn:FormalExpression", {
        body: value
      }, loopCharacteristics, bpmnFactory);
      setCompletionCondition(element, commandStack, completionCondition);
    } else {
      setCompletionCondition(element, commandStack, void 0);
    }
  };
  return FeelEntryWithContext({
    element,
    id: "multiInstance-completionCondition",
    label: translate3("Completion condition"),
    feel: "required",
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function getLoopCharacteristics$1(element) {
  const businessObject = getBusinessObject(element);
  return businessObject.get("loopCharacteristics");
}
function getZeebeLoopCharacteristics(loopCharacteristics) {
  const extensionElements = getExtensionElementsList(loopCharacteristics, "zeebe:LoopCharacteristics");
  return extensionElements && extensionElements[0];
}
function supportsMultiInstances(element) {
  return !!getLoopCharacteristics$1(element);
}
function getCompletionCondition(element) {
  return getLoopCharacteristics$1(element).get("completionCondition");
}
function setCompletionCondition(element, commandStack, completionCondition = void 0) {
  commandStack.execute("element.updateModdleProperties", {
    element,
    moddleElement: getLoopCharacteristics$1(element),
    properties: {
      completionCondition
    }
  });
}
function getProperty$1(element, propertyName) {
  const loopCharacteristics = getLoopCharacteristics$1(element), zeebeLoopCharacteristics = getZeebeLoopCharacteristics(loopCharacteristics);
  return zeebeLoopCharacteristics && zeebeLoopCharacteristics.get(propertyName);
}
function setProperty(element, propertyName, value, commandStack, bpmnFactory) {
  const loopCharacteristics = getLoopCharacteristics$1(element);
  const commands = [];
  let extensionElements = loopCharacteristics.get("extensionElements");
  if (!extensionElements) {
    extensionElements = createElement("bpmn:ExtensionElements", {
      values: []
    }, loopCharacteristics, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: loopCharacteristics,
        properties: {
          extensionElements
        }
      }
    });
  }
  let zeebeLoopCharacteristics = getZeebeLoopCharacteristics(loopCharacteristics);
  if (!zeebeLoopCharacteristics) {
    zeebeLoopCharacteristics = createElement("zeebe:LoopCharacteristics", {}, extensionElements, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: extensionElements,
        properties: {
          values: [...extensionElements.get("values"), zeebeLoopCharacteristics]
        }
      }
    });
  }
  commands.push({
    cmd: "element.updateModdleProperties",
    context: {
      element,
      moddleElement: zeebeLoopCharacteristics,
      properties: {
        [propertyName]: value
      }
    }
  });
  commandStack.execute("properties-panel.multi-command-executor", commands);
}
function getProcessId(element) {
  const calledElement = getCalledElement(element);
  return calledElement ? calledElement.get("processId") : "";
}
function getCalledElement(element) {
  const calledElements = getCalledElements(element);
  return calledElements[0];
}
function getCalledElements(element) {
  const bo = getBusinessObject(element);
  const extElements = getExtensionElementsList(bo, "zeebe:CalledElement");
  return extElements;
}
function OutputPropagationProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:CallActivity")) {
    return [];
  }
  return [{
    id: "propagateAllChildVariables",
    component: PropagateAllChildVariables,
    isEdited
  }];
}
function PropagateAllChildVariables(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), bpmnFactory = useService("bpmnFactory"), translate3 = useService("translate");
  const propagateAllChildVariables = isPropagateAllChildVariables(element);
  const getValue2 = () => {
    return propagateAllChildVariables;
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let calledElement = getCalledElement(businessObject);
    if (!calledElement) {
      calledElement = createElement("zeebe:CalledElement", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), calledElement]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: calledElement,
        properties: {
          propagateAllChildVariables: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return ToggleSwitchEntry({
    id: "propagateAllChildVariables",
    label: translate3("Propagate all child process variables"),
    switcherLabel: propagateAllChildVariables ? translate3("On") : translate3("Off"),
    description: propagateAllChildVariables ? translate3("All variables from the child process instance will be propagated to the parent process instance") : translate3("Only variables defined via output mappings will be propagated from the child to the parent process instance"),
    getValue: getValue2,
    setValue
  });
}
function determinePropAllChildVariablesDefault(element) {
  const outputParameters = getOutputParameters$1(element);
  if (outputParameters) {
    return outputParameters.length > 0 ? false : true;
  }
}
function isPropagateAllChildVariables(element) {
  if (!is(element, "bpmn:CallActivity")) {
    return void 0;
  }
  const bo = getBusinessObject(element), calledElement = getCalledElement(bo);
  return calledElement && (0, import_min_dash147.has)(calledElement, "propagateAllChildVariables") ? calledElement.get("propagateAllChildVariables") : determinePropAllChildVariablesDefault(element);
}
function OutputProps$1({
  element,
  injector
}) {
  if (!areOutputParametersSupported$1(element)) {
    return null;
  }
  const outputParameters = getOutputParameters$1(element) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = outputParameters.map((parameter, index2) => {
    const id = element.id + "-output-" + index2;
    return {
      id,
      label: parameter.get("target") || "",
      entries: InputOutputParameter$1({
        idPrefix: id,
        element,
        parameter
      }),
      autoFocusEntry: id + "-target",
      remove: removeFactory$a({
        commandStack,
        element,
        parameter
      })
    };
  });
  return {
    items,
    add: addFactory$7({
      element,
      bpmnFactory,
      commandStack
    })
  };
}
function removeFactory$a({
  commandStack,
  element,
  parameter
}) {
  return function(event2) {
    event2.stopPropagation();
    let commands = [];
    const ioMapping = getIoMapping(element);
    if (!ioMapping) {
      return;
    }
    const outputParameters = (0, import_min_dash147.without)(ioMapping.get("outputParameters"), parameter);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: ioMapping,
        properties: {
          outputParameters
        }
      }
    });
    if (!ioMapping.get("inputParameters").length && !outputParameters.length) {
      const businessObject = getBusinessObject(element), extensionElements = businessObject.get("extensionElements"), values5 = (0, import_min_dash147.without)(extensionElements.get("values"), ioMapping);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: values5
          }
        }
      });
    }
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function addFactory$7({
  element,
  bpmnFactory,
  commandStack
}) {
  return function(event2) {
    event2.stopPropagation();
    let commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let ioMapping = getIoMapping(element);
    if (!ioMapping) {
      const parent = extensionElements;
      ioMapping = createIOMapping({
        inputParameters: [],
        outputParameters: []
      }, parent, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), ioMapping]
          }
        }
      });
    }
    const newParameter = createElement("zeebe:Output", {
      source: "",
      target: nextId("OutputVariable_")
    }, ioMapping, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: ioMapping,
        properties: {
          outputParameters: [...ioMapping.get("outputParameters"), newParameter]
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
var SCRIPT_IMPLEMENTATION_OPTION = "script";
var JOB_WORKER_IMPLEMENTATION_OPTION = "jobWorker";
var DEFAULT_IMPLEMENTATION_OPTION = "";
function ScriptImplementationProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:ScriptTask")) {
    return [];
  }
  return [{
    id: "scriptImplementation",
    component: ScriptImplementation,
    isEdited: () => isScriptImplementationEdited(element)
  }];
}
function ScriptImplementation(props) {
  const {
    element,
    id
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate3 = useService("translate");
  const getValue2 = () => {
    if (getScript$1(element)) {
      return SCRIPT_IMPLEMENTATION_OPTION;
    }
    if (getTaskDefinition$1(element)) {
      return JOB_WORKER_IMPLEMENTATION_OPTION;
    }
    return DEFAULT_IMPLEMENTATION_OPTION;
  };
  const setValue = (value) => {
    let extensionElement, extensionElementType;
    if (value === SCRIPT_IMPLEMENTATION_OPTION) {
      extensionElement = getScript$1(element);
      extensionElementType = "zeebe:Script";
    } else if (value === JOB_WORKER_IMPLEMENTATION_OPTION) {
      extensionElement = getTaskDefinition$1(element);
      extensionElementType = "zeebe:TaskDefinition";
    } else {
      resetElement(element, commandStack);
    }
    if (!extensionElement && extensionElementType) {
      extensionElement = createElement(extensionElementType, {}, null, bpmnFactory);
      updateExtensionElements(element, extensionElement, bpmnFactory, commandStack);
    }
  };
  const getOptions = () => {
    const options2 = [{
      value: DEFAULT_IMPLEMENTATION_OPTION,
      label: translate3("<none>")
    }, {
      value: SCRIPT_IMPLEMENTATION_OPTION,
      label: translate3("FEEL expression")
    }, {
      value: JOB_WORKER_IMPLEMENTATION_OPTION,
      label: translate3("Job worker")
    }];
    return options2;
  };
  return SelectEntry({
    element,
    id,
    label: translate3("Implementation"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function getTaskDefinition$1(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:TaskDefinition")[0];
}
function getScript$1(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:Script")[0];
}
function getTaskHeaders(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:TaskHeaders");
}
function isScriptImplementationEdited(element) {
  return getTaskDefinition$1(element) || getScript$1(element);
}
function resetElement(element, commandStack) {
  const businessObject = getBusinessObject(element);
  const taskDefinition = getTaskDefinition$1(element);
  const taskHeaders = getTaskHeaders(element);
  const script = getScript$1(element);
  if (taskDefinition) {
    const removed = [taskDefinition, taskHeaders].filter(Boolean);
    removeExtensionElements(element, businessObject, removed, commandStack);
    return;
  }
  if (script) {
    removeExtensionElements(element, businessObject, script, commandStack);
  }
}
function updateExtensionElements(element, extensionElementToAdd, bpmnFactory, commandStack) {
  const businessObject = getBusinessObject(element);
  const commands = [];
  let extensionElements = businessObject.get("extensionElements");
  let extensionElementValues;
  if (!extensionElements) {
    extensionElements = createElement("bpmn:ExtensionElements", {
      values: []
    }, businessObject, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: businessObject,
        properties: {
          extensionElements
        }
      }
    });
  }
  extensionElementToAdd.$parent = extensionElements;
  if (is(extensionElementToAdd, "zeebe:TaskDefinition")) {
    extensionElementValues = (0, import_min_dash147.without)(extensionElements.get("values"), getScript$1(element));
  } else if (is(extensionElementToAdd, "zeebe:Script")) {
    const matcher = (extension) => isAny(extension, ["zeebe:TaskDefinition", "zeebe:TaskHeaders"]);
    extensionElementValues = (0, import_min_dash147.without)(extensionElements.get("values"), matcher);
  }
  commands.push({
    cmd: "element.updateModdleProperties",
    context: {
      element,
      moddleElement: extensionElements,
      properties: {
        values: [...extensionElementValues, extensionElementToAdd]
      }
    }
  });
  commandStack.execute("properties-panel.multi-command-executor", commands);
}
function ScriptProps$1(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:ScriptTask") || !getScript(element)) {
    return [];
  }
  return [{
    id: "scriptExpression",
    component: Expression$3,
    isEdited: isEdited$6
  }, {
    id: "resultVariable",
    component: ResultVariable$3,
    isEdited: isEdited$1
  }];
}
function Expression$3(props) {
  const {
    element,
    id
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return (getScript(element) || {}).get("expression");
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let script = getScript(element);
    if (!script) {
      script = createElement("zeebe:Script", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), script]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: script,
        properties: {
          expression: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithContext({
    element,
    id,
    label: translate3("FEEL expression"),
    feel: "required",
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function ResultVariable$3(props) {
  const {
    element,
    id
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return (getScript(element) || {}).resultVariable;
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let script = getScript(element);
    if (!script) {
      script = createElement("zeebe:Script", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), script]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: script,
        properties: {
          resultVariable: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return TextfieldEntry({
    element,
    id,
    label: translate3("Result variable"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function getScript(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:Script")[0];
}
function TargetProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:CallActivity")) {
    return [];
  }
  return [{
    id: "targetProcessId",
    component: TargetProcessId,
    isEdited: isEdited$6
  }];
}
function TargetProcessId(props) {
  const {
    element,
    id
  } = props;
  const commandStack = useService("commandStack"), bpmnFactory = useService("bpmnFactory"), translate3 = useService("translate"), debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return getProcessId(element);
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let calledElement = getCalledElement(businessObject);
    if (!calledElement) {
      calledElement = createElement("zeebe:CalledElement", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), calledElement]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: calledElement,
        properties: {
          processId: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithContext({
    element,
    id,
    label: translate3("Process ID"),
    feel: "optional",
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function TaskDefinitionProps(props) {
  const {
    element
  } = props;
  if (!isZeebeServiceTask(element)) {
    return [];
  }
  return [{
    id: "taskDefinitionType",
    component: TaskDefinitionType,
    isEdited: isEdited$6
  }, {
    id: "taskDefinitionRetries",
    component: TaskDefinitionRetries,
    isEdited: isEdited$6
  }];
}
function TaskDefinitionType(props) {
  const {
    element,
    id
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return (getTaskDefinition(element) || {}).type;
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let taskDefinition = getTaskDefinition(element);
    if (!taskDefinition) {
      taskDefinition = createElement("zeebe:TaskDefinition", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), taskDefinition]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: taskDefinition,
        properties: {
          type: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithContext({
    element,
    id,
    label: translate3("Type"),
    feel: "optional",
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function TaskDefinitionRetries(props) {
  const {
    element,
    id
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return (getTaskDefinition(element) || {}).retries;
  };
  const setValue = (value) => {
    let commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let taskDefinition = getTaskDefinition(element);
    if (!taskDefinition) {
      taskDefinition = createElement("zeebe:TaskDefinition", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), taskDefinition]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: taskDefinition,
        properties: {
          retries: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithContext({
    element,
    id,
    label: translate3("Retries"),
    feel: "optional",
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function getTaskDefinition(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:TaskDefinition")[0];
}
function TimerProps$1(props) {
  const {
    element,
    injector
  } = props;
  const translate3 = injector.get("translate");
  const businessObject = getBusinessObject(element), timerEventDefinition = getTimerEventDefinition(businessObject), timerEventDefinitionType = getTimerDefinitionType(timerEventDefinition);
  if (!isTimerSupported(element)) {
    return [];
  }
  const timerOptions = getTimerOptions(element, translate3);
  const singleOption = timerOptions.length === 1;
  const entries = [];
  if (!singleOption) {
    entries.push({
      id: "timerEventDefinitionType",
      component: TimerEventDefinitionType$1,
      isEdited: isEdited$4,
      options: timerOptions
    });
  }
  if (timerEventDefinitionType || singleOption) {
    entries.push({
      id: "timerEventDefinitionValue",
      component: TimerEventDefinitionValue$1,
      isEdited: isEdited$6,
      label: singleOption ? timerOptions[0].label : void 0,
      timerEventDefinitionType: timerEventDefinitionType || timerOptions[0].value
    });
  }
  return entries;
}
function getTimerOptions(element, translate3) {
  const options2 = [];
  if (isTimerDefinitionTypeSupported("timeDate", element)) {
    options2.push({
      value: "timeDate",
      label: translate3("Date")
    });
  }
  if (isTimerDefinitionTypeSupported("timeDuration", element)) {
    options2.push({
      value: "timeDuration",
      label: translate3("Duration")
    });
  }
  if (isTimerDefinitionTypeSupported("timeCycle", element)) {
    options2.push({
      value: "timeCycle",
      label: translate3("Cycle")
    });
  }
  return options2;
}
function TimerEventDefinitionType$1(props) {
  const {
    element,
    options: options2
  } = props;
  const commandStack = useService("commandStack"), bpmnFactory = useService("bpmnFactory"), translate3 = useService("translate");
  const businessObject = getBusinessObject(element), timerEventDefinition = getTimerEventDefinition(businessObject), timerEventDefinitionType = getTimerDefinitionType(timerEventDefinition);
  const getValue2 = () => {
    return timerEventDefinitionType || "";
  };
  const setValue = (value) => {
    if (value === timerEventDefinitionType) {
      return;
    }
    const formalExpression = createTimerFormalExpression(bpmnFactory, timerEventDefinition);
    const newProps = {
      timeDuration: void 0,
      timeDate: void 0,
      timeCycle: void 0
    };
    if (value !== "") {
      newProps[value] = formalExpression;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: timerEventDefinition,
      properties: newProps
    });
  };
  const getOptions = (element2) => {
    return [{
      value: "",
      label: translate3("<none>")
    }, ...options2];
  };
  return SelectEntry({
    element,
    id: "timerEventDefinitionType",
    label: translate3("Type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function TimerEventDefinitionValue$1(props) {
  const {
    element,
    label,
    timerEventDefinitionType
  } = props;
  const commandStack = useService("commandStack"), translate3 = useService("translate"), debounce4 = useService("debounceInput"), bpmnFactory = useService("bpmnFactory");
  const businessObject = getBusinessObject(element), timerEventDefinition = getTimerEventDefinition(businessObject), timerEventFormalExpression = timerEventDefinition.get(timerEventDefinitionType);
  const legacyId = getLegacyId(element);
  const getValue2 = () => {
    return timerEventFormalExpression && timerEventFormalExpression.get("body");
  };
  const setValue = (value) => {
    if (!timerEventFormalExpression) {
      const expression = createTimerFormalExpression(bpmnFactory, timerEventDefinition);
      expression.set("body", value);
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: timerEventDefinition,
        properties: {
          [timerEventDefinitionType]: expression
        }
      });
      return;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: timerEventFormalExpression,
      properties: {
        body: value
      }
    });
  };
  return FeelEntryWithContext({
    element,
    id: legacyId || "timerEventDefinitionValue",
    label: label || translate3("Value"),
    feel: "optional",
    getValue: getValue2,
    setValue,
    debounce: debounce4,
    description: getTimerEventDefinitionValueDescription$1(timerEventDefinitionType, translate3)
  });
}
function isTimerDefinitionTypeSupported(timerDefinitionType, element) {
  const businessObject = getBusinessObject(element);
  switch (timerDefinitionType) {
    case "timeDate":
      if (is(element, "bpmn:StartEvent")) {
        return true;
      }
      return false;
    case "timeCycle":
      if (is(element, "bpmn:StartEvent") && !isInterruptingStartEvent(businessObject)) {
        return true;
      }
      if (is(element, "bpmn:BoundaryEvent") && !businessObject.cancelActivity) {
        return true;
      }
      return false;
    case "timeDuration":
      if (is(element, "bpmn:IntermediateCatchEvent")) {
        return true;
      }
      if (is(element, "bpmn:BoundaryEvent")) {
        return true;
      }
      return false;
    default:
      return void 0;
  }
}
function createTimerFormalExpression(bpmnFactory, eventDefinition) {
  const formalExpression = bpmnFactory.create("bpmn:FormalExpression", {
    body: void 0
  });
  formalExpression.$parent = eventDefinition;
  return formalExpression;
}
function getTimerEventDefinitionValueDescription$1(timerDefinitionType, translate3) {
  switch (timerDefinitionType) {
    case "timeDate":
      return o5("div", {
        children: [o5("p", {
          children: translate3("A specific point in time defined as ISO 8601 combined date and time representation.")
        }), o5("ul", {
          children: [o5("li", {
            children: [o5("code", {
              children: "2019-10-01T12:00:00Z"
            }), " - ", translate3("UTC time")]
          }), o5("li", {
            children: [o5("code", {
              children: "2019-10-02T08:09:40+02:00"
            }), " - ", translate3("UTC plus 2 hours zone offset")]
          })]
        }), o5("a", {
          href: "https://docs.camunda.io/docs/reference/bpmn-processes/timer-events/timer-events#time-date",
          target: "_blank",
          rel: "noopener",
          title: translate3("Timer documentation"),
          children: translate3("How to configure a timer")
        })]
      });
    case "timeCycle":
      return o5("div", {
        children: [o5("p", {
          children: translate3("A cycle defined as ISO 8601 repeating intervals format, or a cron expression.")
        }), o5("ul", {
          children: [o5("li", {
            children: [o5("code", {
              children: "R5/PT10S"
            }), " - ", translate3("every 10 seconds, up to 5 times")]
          }), o5("li", {
            children: [o5("code", {
              children: "R/P1D"
            }), " - ", translate3("every day, infinitely")]
          }), o5("li", {
            children: [o5("code", {
              children: "0 0 9-17 * * MON-FRI"
            }), " - ", translate3("every hour on the hour from 9-5 p.m. UTC Monday-Friday")]
          })]
        }), o5("a", {
          href: "https://docs.camunda.io/docs/reference/bpmn-processes/timer-events/timer-events#time-cycle",
          target: "_blank",
          rel: "noopener",
          title: translate3("Timer documentation"),
          children: translate3("How to configure a timer")
        })]
      });
    case "timeDuration":
      return o5("div", {
        children: [o5("p", {
          children: translate3("A time duration defined as ISO 8601 durations format.")
        }), o5("ul", {
          children: [o5("li", {
            children: [o5("code", {
              children: "PT15S"
            }), " - ", translate3("15 seconds")]
          }), o5("li", {
            children: [o5("code", {
              children: "PT1H30M"
            }), " - ", translate3("1 hour and 30 minutes")]
          }), o5("li", {
            children: [o5("code", {
              children: "P14D"
            }), " - ", translate3("14 days")]
          })]
        }), o5("a", {
          href: "https://docs.camunda.io/docs/reference/bpmn-processes/timer-events/timer-events#time-duration",
          target: "_blank",
          rel: "noopener",
          title: translate3("Timer documentation"),
          children: translate3("How to configure a timer")
        })]
      });
  }
}
function isInterruptingStartEvent(bo) {
  return isInEventSubProcess$1(bo) && bo.get("isInterrupting") !== false;
}
function isInEventSubProcess$1(bo) {
  const parent = bo.$parent;
  return is(parent, "bpmn:SubProcess") && parent.triggeredByEvent;
}
function getLegacyId(event2) {
  if (is(event2, "bpmn:IntermediateCatchEvent") || isInterruptingBoundaryEvent(event2)) {
    return "timerEventDefinitionDurationValue";
  }
}
function isInterruptingBoundaryEvent(event2) {
  const bo = getBusinessObject(event2);
  return is(bo, "bpmn:BoundaryEvent") && bo.get("cancelActivity") !== false;
}
function ExtensionProperty(props) {
  const {
    idPrefix,
    property
  } = props;
  const entries = [{
    id: idPrefix + "-name",
    component: NameProperty$1,
    idPrefix,
    property
  }, {
    id: idPrefix + "-value",
    component: ValueProperty$1,
    idPrefix,
    property
  }];
  return entries;
}
function NameProperty$1(props) {
  const {
    idPrefix,
    element,
    property
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: property,
      properties: {
        name: value
      }
    });
  };
  const getValue2 = () => {
    return property.name;
  };
  return TextfieldEntry({
    element: property,
    id: idPrefix + "-name",
    label: translate3("Name"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function ValueProperty$1(props) {
  const {
    idPrefix,
    element,
    property
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: property,
      properties: {
        value
      }
    });
  };
  const getValue2 = () => {
    return property.value;
  };
  return TextfieldEntry({
    element: property,
    id: idPrefix + "-value",
    label: translate3("Value"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function ExtensionPropertiesProps({
  element,
  injector,
  namespace = "camunda"
}) {
  if (namespace === "zeebe" && !is(element, "zeebe:PropertiesHolder")) {
    return [];
  }
  let businessObject = getRelevantBusinessObject(element);
  if (!businessObject) {
    return;
  }
  const properties = getPropertiesList(businessObject, namespace) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = properties.map((property, index2) => {
    const id = element.id + "-extensionProperty-" + index2;
    return {
      id,
      label: property.get("name") || "",
      entries: ExtensionProperty({
        idPrefix: id,
        element,
        property
      }),
      autoFocusEntry: id + "-name",
      remove: removeFactory$9({
        commandStack,
        element,
        property,
        namespace
      })
    };
  });
  return {
    items,
    add: addFactory$6({
      bpmnFactory,
      commandStack,
      element,
      namespace
    })
  };
}
function removeFactory$9({
  commandStack,
  element,
  property,
  namespace
}) {
  return function(event2) {
    event2.stopPropagation();
    const commands = [];
    const businessObject = getRelevantBusinessObject(element);
    const properties = getProperties2(businessObject, namespace);
    if (!properties) {
      return;
    }
    const propertyName = getPropertyName(namespace);
    const values5 = (0, import_min_dash147.without)(properties.get(propertyName), property);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: properties,
        properties: {
          [propertyName]: values5
        }
      }
    });
    if (!values5.length) {
      const businessObject2 = getBusinessObject(element), extensionElements = businessObject2.get("extensionElements");
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: (0, import_min_dash147.without)(extensionElements.get("values"), properties)
          }
        }
      });
    }
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function addFactory$6({
  bpmnFactory,
  commandStack,
  element,
  namespace
}) {
  return function(event2) {
    event2.stopPropagation();
    let commands = [];
    const businessObject = getRelevantBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    const propertyName = getPropertyName(namespace);
    let properties = getProperties2(businessObject, namespace);
    if (!properties) {
      const parent = extensionElements;
      properties = createElement(`${namespace}:Properties`, {
        [propertyName]: []
      }, parent, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), properties]
          }
        }
      });
    }
    const property = createElement(`${namespace}:Property`, {}, properties, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: properties,
        properties: {
          [propertyName]: [...properties.get(propertyName), property]
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function getRelevantBusinessObject(element) {
  let businessObject = getBusinessObject(element);
  if (is(element, "bpmn:Participant")) {
    return businessObject.get("processRef");
  }
  return businessObject;
}
function getPropertyName(namespace = "camunda") {
  if (namespace === "zeebe") {
    return "properties";
  }
  return "values";
}
function getProperties2(element, namespace = "camunda") {
  return getExtensionElementsList(getBusinessObject(element), `${namespace}:Properties`)[0];
}
function getPropertiesList(element, namespace = "camunda") {
  const properties = getProperties2(getBusinessObject(element), namespace);
  return properties && properties.get(getPropertyName(namespace));
}
var LOW_PRIORITY$1 = 500;
var ZEEBE_GROUPS = [BusinessRuleImplementationGroup, CalledDecisionGroup, ScriptImplementationGroup, ScriptGroup$1, TaskDefinitionGroup, AssignmentDefinitionGroup, FormGroup$1, ConditionGroup$1, TargetGroup, InputGroup$1, OutputPropagationGroup, OutputGroup$1, HeaderGroup, ExtensionPropertiesGroup$1];
var ZeebePropertiesProvider$1 = class {
  constructor(propertiesPanel, injector) {
    propertiesPanel.registerProvider(LOW_PRIORITY$1, this);
    this._injector = injector;
  }
  getGroups(element) {
    return (groups) => {
      groups = groups.concat(this._getGroups(element));
      updateErrorGroup$1(groups, element);
      updateMessageGroup(groups, element);
      updateTimerGroup$1(groups, element, this._injector);
      updateMultiInstanceGroup$1(groups, element);
      groups = removeMessageGroup(groups, element);
      return groups;
    };
  }
  _getGroups(element) {
    const groups = ZEEBE_GROUPS.map((createGroup2) => createGroup2(element, this._injector));
    return groups.filter((group) => group !== null);
  }
};
ZeebePropertiesProvider$1.$inject = ["propertiesPanel", "injector"];
function CalledDecisionGroup(element) {
  const group = {
    id: "calledDecision",
    label: "Called decision",
    entries: [...CalledDecisionProps({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function ScriptGroup$1(element) {
  const group = {
    id: "script",
    label: "Script",
    entries: [...ScriptProps$1({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function TaskDefinitionGroup(element) {
  const group = {
    id: "taskDefinition",
    label: "Task definition",
    entries: [...TaskDefinitionProps({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function InputGroup$1(element, injector) {
  const group = {
    id: "inputs",
    label: "Inputs",
    component: ListGroup,
    ...InputProps$1({
      element,
      injector
    })
  };
  return group.items ? group : null;
}
function OutputGroup$1(element, injector) {
  const group = {
    id: "outputs",
    label: "Outputs",
    component: ListGroup,
    ...OutputProps$1({
      element,
      injector
    })
  };
  return group.items ? group : null;
}
function ConditionGroup$1(element) {
  const group = {
    id: "condition",
    label: "Condition",
    entries: [...ConditionProps$1({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function FormGroup$1(element, injector) {
  const group = {
    id: "form",
    label: "Form",
    entries: [...FormProps$1({
      element,
      injector
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function TargetGroup(element) {
  const group = {
    id: "calledElement",
    label: "Called element",
    entries: [...TargetProps({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function HeaderGroup(element, injector) {
  const group = {
    id: "headers",
    label: "Headers",
    component: ListGroup,
    ...HeaderProps({
      element,
      injector
    })
  };
  return group.items ? group : null;
}
function OutputPropagationGroup(element) {
  const group = {
    id: "outputPropagation",
    label: "Output propagation",
    entries: [...OutputPropagationProps({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function BusinessRuleImplementationGroup(element) {
  const group = {
    id: "businessRuleImplementation",
    label: "Implementation",
    entries: [...BusinessRuleImplementationProps({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function ScriptImplementationGroup(element) {
  const group = {
    id: "scriptImplementation",
    label: "Implementation",
    entries: [...ScriptImplementationProps({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function AssignmentDefinitionGroup(element) {
  const group = {
    id: "assignmentDefinition",
    label: "Assignment",
    entries: [...AssignmentDefinitionProps({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function ExtensionPropertiesGroup$1(element, injector) {
  const group = {
    label: "Extension properties",
    id: "Zeebe__ExtensionProperties",
    component: ListGroup,
    ...ExtensionPropertiesProps({
      element,
      injector,
      namespace: "zeebe"
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function updateErrorGroup$1(groups, element) {
  const errorGroup = findGroup$1(groups, "error");
  if (!errorGroup) {
    return;
  }
  errorGroup.entries = overrideGenericEntries(errorGroup.entries, ErrorProps$1({
    element
  }));
}
function updateMessageGroup(groups, element) {
  const messageGroup = findGroup$1(groups, "message");
  if (!messageGroup) {
    return;
  }
  messageGroup.entries = overrideGenericEntries(messageGroup.entries, MessageProps({
    element
  }));
}
function updateTimerGroup$1(groups, element, injector) {
  const timerEventGroup = findGroup$1(groups, "timer");
  if (!timerEventGroup) {
    return;
  }
  timerEventGroup.entries = [...TimerProps$1({
    element,
    injector
  })];
}
function updateMultiInstanceGroup$1(groups, element) {
  const multiInstanceGroup = findGroup$1(groups, "multiInstance");
  if (!multiInstanceGroup) {
    return;
  }
  multiInstanceGroup.entries = [...MultiInstanceProps$1({
    element
  })];
}
function removeMessageGroup(groups, element) {
  const messageGroup = findGroup$1(groups, "message");
  if (isMessageEndEvent(element) || isMessageThrowEvent(element)) {
    groups = groups.filter((g6) => g6 != messageGroup);
  }
  return groups;
}
function findGroup$1(groups, id) {
  return groups.find((g6) => g6.id === id);
}
function overrideGenericEntries(oldEntries, newEntries) {
  const filteredEntries = oldEntries.filter((oldEntry) => !newEntries.find((newEntry) => newEntry.id === oldEntry.id));
  return [...filteredEntries, ...newEntries];
}
function AsynchronousContinuationsProps(props) {
  const {
    element
  } = props;
  const checkboxIsEditedInverted2 = (node2) => {
    return node2 && !node2.checked;
  };
  const businessObject = getBusinessObject(element);
  const entries = [];
  if (is(element, "camunda:AsyncCapable")) {
    entries.push({
      id: "asynchronousContinuationBefore",
      component: AsynchronousContinuationBefore,
      isEdited: isEdited$7
    }, {
      id: "asynchronousContinuationAfter",
      component: AsynchronousContinuationAfter,
      isEdited: isEdited$7
    });
    if (isAsyncBefore$2(businessObject) || isAsyncAfter$2(businessObject)) {
      entries.push({
        id: "exclusive",
        component: Exclusive,
        isEdited: checkboxIsEditedInverted2
      });
    }
  }
  return entries;
}
function AsynchronousContinuationBefore(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), translate3 = useService("translate");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return isAsyncBefore$2(businessObject);
  };
  const setValue = (value) => {
    const props2 = {
      "camunda:asyncBefore": value,
      "camunda:async": void 0
    };
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: props2
    });
  };
  return CheckboxEntry({
    element,
    id: "asynchronousContinuationBefore",
    label: translate3("Before"),
    getValue: getValue2,
    setValue
  });
}
function AsynchronousContinuationAfter(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), translate3 = useService("translate");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return isAsyncAfter$2(businessObject);
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:asyncAfter": value
      }
    });
  };
  return CheckboxEntry({
    element,
    id: "asynchronousContinuationAfter",
    label: translate3("After"),
    getValue: getValue2,
    setValue
  });
}
function Exclusive(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), translate3 = useService("translate");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return isExclusive$1(businessObject);
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:exclusive": value
      }
    });
  };
  return CheckboxEntry({
    element,
    id: "exclusive",
    label: translate3("Exclusive"),
    getValue: getValue2,
    setValue
  });
}
function isAsyncBefore$2(bo) {
  return !!(bo.get("camunda:asyncBefore") || bo.get("camunda:async"));
}
function isAsyncAfter$2(bo) {
  return !!bo.get("camunda:asyncAfter");
}
function isExclusive$1(bo) {
  return !!bo.get("camunda:exclusive");
}
var EMPTY_OPTION$1 = "";
function BusinessKeyProps$1(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:StartEvent") || !hasFormFields(element)) {
    return [];
  }
  return [{
    id: "businessKey",
    component: BusinessKey$1,
    isEdited: isEdited$4
  }];
}
function BusinessKey$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const formData = getFormData$2(element);
  const getValue2 = () => {
    return formData.get("camunda:businessKey") || "";
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: formData,
      properties: {
        "camunda:businessKey": value
      }
    });
  };
  const getOptions = () => {
    const options2 = [{
      value: EMPTY_OPTION$1,
      label: translate3("<none>")
    }];
    const fields = formData.get("fields");
    fields.forEach((field) => {
      const id = field.get("camunda:id");
      if (id) {
        options2.push({
          value: id,
          label: id
        });
      }
    });
    return options2;
  };
  return SelectEntry({
    element,
    id: "businessKey",
    label: translate3("Key"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function getFormData$2(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "camunda:FormData")[0];
}
function hasFormFields(element) {
  const businessObject = getBusinessObject(element);
  const formData = getFormData$2(businessObject);
  return formData && formData.get("camunda:fields").length;
}
function CalledBpmnProps(props) {
  const {
    element
  } = props;
  const entries = [{
    id: "calledElement",
    component: CalledElement,
    isEdited: isEdited$1
  }, {
    id: "calledElementBinding",
    component: CalledElementBinding,
    isEdited: isEdited$4
  }, {
    id: "calledElementTenantId",
    component: CalledElementTenantId,
    isEdited: isEdited$1
  }];
  const binding = getBusinessObject(element).get("camunda:calledElementBinding");
  if (binding === "version") {
    entries.splice(-1, 0, {
      id: "calledElementVersion",
      component: CalledElementVersion,
      isEdited: isEdited$1
    });
  } else if (binding === "versionTag") {
    entries.splice(-1, 0, {
      id: "calledElementVersionTag",
      component: CalledElementVersionTag,
      isEdited: isEdited$1
    });
  }
  return entries;
}
function CalledElement(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return getBusinessObject(element).get("calledElement");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      calledElement: value || ""
    });
  };
  return o5(TextfieldEntry, {
    element,
    id: "calledElement",
    label: translate3("Called element"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function CalledElementBinding(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate3 = useService("translate");
  const getValue2 = () => {
    return getBusinessObject(element).get("camunda:calledElementBinding") || "latest";
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      calledElementBinding: value === "latest" ? void 0 : value,
      calledElementVersion: void 0,
      calledElementVersionTag: void 0
    });
  };
  const getOptions = () => [{
    value: "latest",
    label: translate3("latest")
  }, {
    value: "deployment",
    label: translate3("deployment")
  }, {
    value: "version",
    label: translate3("version")
  }, {
    value: "versionTag",
    label: translate3("version tag")
  }];
  return o5(SelectEntry, {
    element,
    id: "calledElementBinding",
    label: translate3("Binding"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function CalledElementVersion(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return getBusinessObject(element).get("camunda:calledElementVersion");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      calledElementVersion: value
    });
  };
  return o5(TextfieldEntry, {
    element,
    id: "calledElementVersion",
    label: translate3("Version"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function CalledElementVersionTag(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return getBusinessObject(element).get("camunda:calledElementVersionTag");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      calledElementVersionTag: value
    });
  };
  return o5(TextfieldEntry, {
    element,
    id: "calledElementVersionTag",
    label: translate3("Version tag"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function CalledElementTenantId(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return getBusinessObject(element).get("camunda:calledElementTenantId");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      calledElementTenantId: value
    });
  };
  return o5(TextfieldEntry, {
    element,
    id: "calledElementTenantId",
    label: translate3("Tenant ID"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function CalledCmmnProps(props) {
  const {
    element
  } = props;
  const entries = [{
    id: "calledElementCaseRef",
    component: CaseRef,
    isEdited: isEdited$1
  }, {
    id: "calledElementCaseBinding",
    component: CaseBinding,
    isEdited: isEdited$4
  }, {
    id: "calledElementCaseTenantId",
    component: CaseTenantId,
    isEdited: isEdited$1
  }];
  if (getBusinessObject(element).get("camunda:caseBinding") === "version") {
    entries.splice(-1, 0, {
      id: "calledElementCaseVersion",
      component: CaseVersion,
      isEdited: isEdited$1
    });
  }
  return entries;
}
function CaseRef(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return getBusinessObject(element).get("camunda:caseRef");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      caseRef: value || ""
    });
  };
  return o5(TextfieldEntry, {
    element,
    id: "calledElementCaseRef",
    label: translate3("Case ref"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function CaseBinding(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate3 = useService("translate");
  const getValue2 = () => {
    return getBusinessObject(element).get("camunda:caseBinding") || "latest";
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      caseBinding: value === "latest" ? void 0 : value,
      caseVersion: void 0
    });
  };
  const getOptions = () => [{
    value: "latest",
    label: translate3("latest")
  }, {
    value: "deployment",
    label: translate3("deployment")
  }, {
    value: "version",
    label: translate3("version")
  }];
  return o5(SelectEntry, {
    element,
    id: "calledElementCaseBinding",
    label: translate3("Binding"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function CaseVersion(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return getBusinessObject(element).get("camunda:caseVersion");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      caseVersion: value
    });
  };
  return o5(TextfieldEntry, {
    element,
    id: "calledElementCaseVersion",
    label: translate3("Version"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function CaseTenantId(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return getBusinessObject(element).get("camunda:caseTenantId");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      caseTenantId: value
    });
  };
  return o5(TextfieldEntry, {
    element,
    id: "calledElementCaseTenantId",
    label: translate3("Tenant ID"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function DelegateVariableMappingProps(props) {
  const {
    element
  } = props;
  const entries = [{
    id: "calledElementDelegateVariableMappingType",
    component: DelegateVariableMappingType,
    isEdited: isEdited$4
  }];
  const type = getDelegateVariableMappingType(element);
  if (type === "class") {
    entries.push({
      id: "calledElementVariableMappingClass",
      component: VariableMappingClass,
      isEdited: isEdited$1
    });
  } else if (type === "delegateExpression") {
    entries.push({
      id: "calledElementVariableMappingDelegateExpression",
      component: VariableMappingDelegateExpression,
      isEdited: isEdited$1
    });
  }
  return entries;
}
var DEFAULT_PROPS$5 = {
  "camunda:variableMappingClass": void 0,
  "camunda:variableMappingDelegateExpression": void 0
};
function DelegateVariableMappingType(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const getValue2 = () => {
    return getDelegateVariableMappingType(element);
  };
  const setValue = (value) => {
    const properties = {
      ...DEFAULT_PROPS$5
    };
    if (value === "class") {
      properties["camunda:variableMappingClass"] = "";
    } else if (value === "delegateExpression") {
      properties["camunda:variableMappingDelegateExpression"] = "";
    }
    commandStack.execute("element.updateProperties", {
      element,
      properties
    });
  };
  const getOptions = () => [{
    value: "none",
    label: translate3("<none>")
  }, {
    value: "class",
    label: translate3("Class")
  }, {
    value: "delegateExpression",
    label: translate3("Delegate expression")
  }];
  return o5(SelectEntry, {
    element,
    id: "calledElementDelegateVariableMappingType",
    label: translate3("Delegate Variable Mapping"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function VariableMappingDelegateExpression(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return getBusinessObject(element).get("camunda:variableMappingDelegateExpression");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      variableMappingDelegateExpression: value || "",
      variableMappingClass: void 0
    });
  };
  return o5(TextfieldEntry, {
    element,
    id: "calledElementVariableMappingDelegateExpression",
    label: translate3("Delegate Expression"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function VariableMappingClass(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return getBusinessObject(element).get("camunda:variableMappingClass");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      variableMappingDelegateExpression: void 0,
      variableMappingClass: value || ""
    });
  };
  return o5(TextfieldEntry, {
    element,
    id: "calledElementVariableMappingClass",
    label: translate3("Delegate Class"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function getDelegateVariableMappingType(element) {
  const businessObject = getBusinessObject(element);
  if (businessObject.get("camunda:variableMappingClass") !== void 0) {
    return "class";
  } else if (businessObject.get("camunda:variableMappingDelegateExpression") !== void 0) {
    return "delegateExpression";
  }
  return "none";
}
function CallActivityProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:CallActivity")) {
    return [];
  }
  const entries = [];
  entries.push({
    id: "calledElementType",
    component: CalledElementType,
    isEdited: isEdited$4
  });
  const calledElementType = getCalledElementType(element);
  if (calledElementType === "bpmn") {
    entries.push(...CalledBpmnProps({
      element
    }), ...BusinessKeyProps({
      element
    }), ...DelegateVariableMappingProps({
      element
    }));
  } else if (calledElementType === "cmmn") {
    entries.push(...CalledCmmnProps({
      element
    }), ...BusinessKeyProps({
      element
    }));
  } else {
    entries.push(...BusinessKeyProps({
      element
    }));
  }
  return entries;
}
var DEFAULT_PROPS$4 = {
  calledElement: void 0,
  "camunda:calledElementBinding": void 0,
  "camunda:calledElementVersion": void 0,
  "camunda:calledElementTenantId": void 0,
  "camunda:variableMappingClass": void 0,
  "camunda:variableMappingDelegateExpression": void 0,
  "camunda:caseRef": void 0,
  "camunda:caseBinding": void 0,
  "camunda:caseVersion": void 0,
  "camunda:caseTenantId": void 0
};
var DEFAULT_BUSINESS_KEY = "#{execution.processBusinessKey}";
function CalledElementType(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const getValue2 = () => {
    return getCalledElementType(element);
  };
  const setValue = (value) => {
    const properties = {
      ...DEFAULT_PROPS$4
    };
    if (value === "bpmn") {
      properties["calledElement"] = "";
    } else if (value === "cmmn") {
      properties["camunda:caseRef"] = "";
    }
    commandStack.execute("element.updateProperties", {
      element,
      properties
    });
  };
  const getOptions = () => [{
    value: "",
    label: translate3("<none>")
  }, {
    value: "bpmn",
    label: translate3("BPMN")
  }, {
    value: "cmmn",
    label: translate3("CMMN")
  }];
  return o5(SelectEntry, {
    element,
    id: "calledElementType",
    label: translate3("Type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function BusinessKeyProps(props) {
  const {
    element
  } = props;
  const entries = [{
    id: "calledElementBusinessKey",
    component: BusinessKey,
    isEdited: isEdited$7
  }];
  if (hasBusinessKey(element)) {
    entries.push({
      id: "calledElementBusinessKeyExpression",
      component: BusinessKeyExpression,
      isEdited: isEdited$1
    });
  }
  return entries;
}
function BusinessKey(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const modeling = useService("modeling");
  const bpmnFactory = useService("bpmnFactory");
  const translate3 = useService("translate");
  const getValue2 = () => {
    return hasBusinessKey(element);
  };
  const setValue = (value) => {
    if (value) {
      addBusinessKey();
    } else {
      removeBusinessKey();
    }
  };
  function addBusinessKey() {
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {}, businessObject, bpmnFactory);
      const businessKeyItem = createBusinessKey(extensionElements);
      extensionElements.set("values", [businessKeyItem]);
      modeling.updateProperties(element, {
        extensionElements
      });
    } else {
      const businessKeyItem = createBusinessKey(extensionElements);
      addExtensionElements(element, businessObject, businessKeyItem, bpmnFactory, commandStack);
    }
  }
  function createBusinessKey(parent) {
    return createElement("camunda:In", {
      businessKey: DEFAULT_BUSINESS_KEY
    }, parent, bpmnFactory);
  }
  function removeBusinessKey() {
    const businessObject = getBusinessObject(element);
    const camundaInList = getExtensionElementsList(businessObject, "camunda:In");
    const businessKeyItems = camundaInList.filter((camundaIn) => camundaIn.get("businessKey") !== void 0);
    removeExtensionElements(element, businessObject, businessKeyItems, commandStack);
  }
  return o5(CheckboxEntry, {
    element,
    id: "calledElementBusinessKey",
    label: translate3("Business key"),
    getValue: getValue2,
    setValue
  });
}
function BusinessKeyExpression(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => getBusinessKey(element);
  const setValue = (value) => {
    const camundaIn = findCamundaInWithBusinessKey(element);
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: camundaIn,
      properties: {
        businessKey: value || ""
      }
    });
  };
  return o5(TextfieldEntry, {
    element,
    id: "calledElementBusinessKeyExpression",
    label: translate3("Business key expression"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function getCalledElementType(element) {
  const businessObject = getBusinessObject(element);
  if (businessObject.get("calledElement") !== void 0) {
    return "bpmn";
  } else if (businessObject.get("camunda:caseRef") !== void 0) {
    return "cmmn";
  }
  return "";
}
function hasBusinessKey(element) {
  return getBusinessKey(element) !== void 0;
}
function getBusinessKey(element) {
  const camundaIn = findCamundaInWithBusinessKey(element);
  if (camundaIn) {
    return camundaIn.get("businessKey");
  }
}
function findCamundaInWithBusinessKey(element) {
  const businessObject = getBusinessObject(element);
  const camundaInList = getExtensionElementsList(businessObject, "camunda:In");
  for (const camundaIn of camundaInList) {
    const businessKey = camundaIn.get("businessKey");
    if (businessKey !== void 0) {
      return camundaIn;
    }
  }
}
function CandidateStarterProps(props) {
  const {
    element
  } = props;
  const businessObject = getBusinessObject(element);
  if (!is(element, "bpmn:Process") && !(is(element, "bpmn:Participant") && businessObject.get("processRef"))) {
    return [];
  }
  return [{
    id: "candidateStarterGroups",
    component: CandidateStarterGroups,
    isEdited: isEdited$1
  }, {
    id: "candidateStarterUsers",
    component: CandidateStarterUsers,
    isEdited: isEdited$1
  }];
}
function CandidateStarterGroups(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), translate3 = useService("translate"), debounce4 = useService("debounceInput");
  const process2 = getProcess$3(element);
  const getValue2 = () => {
    return process2.get("camunda:candidateStarterGroups") || "";
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: process2,
      properties: {
        "camunda:candidateStarterGroups": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "candidateStarterGroups",
    label: translate3("Candidate starter groups"),
    description: translate3("Specify more than one group as a comma separated list."),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function CandidateStarterUsers(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), translate3 = useService("translate"), debounce4 = useService("debounceInput");
  const process2 = getProcess$3(element);
  const getValue2 = () => {
    return process2.get("camunda:candidateStarterUsers") || "";
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: process2,
      properties: {
        "camunda:candidateStarterUsers": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "candidateStarterUsers",
    label: translate3("Candidate starter users"),
    description: translate3("Specify more than one user as a comma separated list."),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function getProcess$3(element) {
  return is(element, "bpmn:Process") ? getBusinessObject(element) : getBusinessObject(element).get("processRef");
}
function ConditionProps(props) {
  const {
    element
  } = props;
  if (!(is(element, "bpmn:SequenceFlow") && isConditionalSource(element.source)) && !getConditionalEventDefinition(element)) {
    return [];
  }
  const entries = [];
  if (getConditionalEventDefinition(element)) {
    entries.push(...VariableEventProps({
      element
    }));
  }
  entries.push({
    id: "conditionType",
    component: ConditionType,
    isEdited: isEdited$4
  });
  const conditionType = getConditionType(element);
  if (conditionType === "script") {
    entries.push(...ConditionScriptProps({
      element
    }));
  } else if (conditionType === "expression") {
    entries.push({
      id: "conditionExpression",
      component: ConditionExpression,
      isEdited: isEdited$1
    });
  }
  return entries;
}
function ConditionType(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate3 = useService("translate");
  const getValue2 = () => {
    return getConditionType(element);
  };
  const setValue = (value) => {
    if (value === "") {
      updateCondition(element, commandStack, void 0);
    } else {
      const attributes = {
        body: "",
        language: value === "script" ? "" : void 0
      };
      const formalExpressionElement = createFormalExpression(element, attributes, bpmnFactory);
      updateCondition(element, commandStack, formalExpressionElement);
    }
  };
  const getOptions = () => [{
    value: "",
    label: translate3("<none>")
  }, {
    value: "script",
    label: translate3("Script")
  }, {
    value: "expression",
    label: translate3("Expression")
  }];
  return o5(SelectEntry, {
    element,
    id: "conditionType",
    label: translate3("Type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function ConditionExpression(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), bpmnFactory = useService("bpmnFactory"), translate3 = useService("translate"), debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return getConditionExpression(element).get("body");
  };
  const setValue = (value) => {
    const conditionExpression = createFormalExpression(element, {
      body: value
    }, bpmnFactory);
    updateCondition(element, commandStack, conditionExpression);
  };
  return o5(TextfieldEntry, {
    element,
    id: "conditionExpression",
    label: translate3("Condition Expression"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function ConditionScriptProps(props) {
  const {
    element
  } = props;
  const entries = [];
  const scriptType = getScriptType$1(element);
  entries.push({
    id: "conditionScriptLanguage",
    component: Language,
    isEdited: isEdited$1
  });
  entries.push({
    id: "conditionScriptType",
    component: ScriptType,
    isEdited: isEdited$4
  });
  if (scriptType === "script") {
    entries.push({
      id: "conditionScriptValue",
      component: Script$1,
      isEdited: isEdited$2
    });
  } else if (scriptType === "resource") {
    entries.push({
      id: "conditionScriptResource",
      component: Resource$1,
      isEdited: isEdited$1
    });
  }
  return entries;
}
function Language(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return getConditionExpression(element).get("language");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: getConditionExpression(element),
      properties: {
        language: value || ""
      }
    });
  };
  return o5(TextfieldEntry, {
    element,
    id: "conditionScriptLanguage",
    label: translate3("Format"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function ScriptType(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const getValue2 = () => {
    return getScriptType$1(element);
  };
  const setValue = (value) => {
    const updatedProperties = {
      "body": value === "script" ? "" : void 0,
      "camunda:resource": value === "resource" ? "" : void 0
    };
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: getConditionExpression(element),
      properties: updatedProperties
    });
  };
  const getOptions = () => {
    const options2 = [{
      value: "resource",
      label: translate3("External resource")
    }, {
      value: "script",
      label: translate3("Inline script")
    }];
    return options2;
  };
  return SelectEntry({
    element,
    id: "conditionScriptType",
    label: translate3("Script type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function Script$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return getConditionExpression(element).get("body");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: getConditionExpression(element),
      properties: {
        "body": value || ""
      }
    });
  };
  return o5(TextAreaEntry, {
    element,
    id: "conditionScriptValue",
    label: translate3("Script"),
    getValue: getValue2,
    setValue,
    debounce: debounce4,
    monospace: true
  });
}
function Resource$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return getConditionExpression(element).get("camunda:resource");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: getConditionExpression(element),
      properties: {
        "camunda:resource": value || ""
      }
    });
  };
  return o5(TextfieldEntry, {
    element: true,
    id: "conditionScriptResource",
    label: translate3("Resource"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function VariableEventProps(props) {
  const {
    element
  } = props;
  const entries = [];
  entries.push({
    id: "conditionVariableName",
    component: VariableName2,
    isEdited: isEdited$1
  });
  if (!is(element, "bpmn:StartEvent")) {
    entries.push({
      id: "conditionVariableEvents",
      component: VariableEvents,
      isEdited: isEdited$1
    });
  }
  return entries;
}
function VariableName2(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return getConditionalEventDefinition(element).get("variableName");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: getConditionalEventDefinition(element),
      properties: {
        variableName: value || ""
      }
    });
  };
  return o5(TextfieldEntry, {
    element,
    id: "conditionVariableName",
    label: translate3("Variable name"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function VariableEvents(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return getConditionalEventDefinition(element).get("variableEvents");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: getConditionalEventDefinition(element),
      properties: {
        variableEvents: value || ""
      }
    });
  };
  return o5(TextfieldEntry, {
    element,
    id: "conditionVariableEvents",
    label: translate3("Variable events"),
    description: translate3("Specify more than one variable change event as a comma separated list."),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
var CONDITIONAL_SOURCES = ["bpmn:Activity", "bpmn:ExclusiveGateway", "bpmn:InclusiveGateway", "bpmn:ComplexGateway"];
function isConditionalSource(element) {
  return isAny(element, CONDITIONAL_SOURCES);
}
function getConditionalEventDefinition(element) {
  if (!is(element, "bpmn:Event")) {
    return false;
  }
  return getEventDefinition$1(element, "bpmn:ConditionalEventDefinition");
}
function getConditionType(element) {
  const conditionExpression = getConditionExpression(element);
  if (!conditionExpression) {
    return "";
  } else {
    return conditionExpression.get("language") === void 0 ? "expression" : "script";
  }
}
function getConditionExpression(element) {
  const businessObject = getBusinessObject(element);
  if (is(businessObject, "bpmn:SequenceFlow")) {
    return businessObject.get("conditionExpression");
  } else if (getConditionalEventDefinition(businessObject)) {
    return getConditionalEventDefinition(businessObject).get("condition");
  }
}
function getScriptType$1(element) {
  const conditionExpression = getConditionExpression(element);
  const resource = conditionExpression.get("camunda:resource");
  if (typeof resource !== "undefined") {
    return "resource";
  } else {
    return "script";
  }
}
function updateCondition(element, commandStack, condition = void 0) {
  if (is(element, "bpmn:SequenceFlow")) {
    commandStack.execute("element.updateProperties", {
      element,
      properties: {
        conditionExpression: condition
      }
    });
  } else {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: getConditionalEventDefinition(element),
      properties: {
        condition
      }
    });
  }
}
function createFormalExpression(parent, attributes, bpmnFactory) {
  return createElement("bpmn:FormalExpression", attributes, is(parent, "bpmn:SequenceFlow") ? getBusinessObject(parent) : getConditionalEventDefinition(parent), bpmnFactory);
}
function ScriptProps(props) {
  const {
    element,
    script,
    prefix: prefix3
  } = props;
  const entries = [];
  const scriptType = getScriptType(script || element);
  const idPrefix = prefix3 || "";
  entries.push({
    id: idPrefix + "scriptFormat",
    component: Format,
    isEdited: isEdited$1,
    idPrefix,
    script
  });
  entries.push({
    id: idPrefix + "scriptType",
    component: Type$3,
    isEdited: isEdited$4,
    idPrefix,
    script
  });
  if (scriptType === "script") {
    entries.push({
      id: idPrefix + "scriptValue",
      component: Script,
      isEdited: isEdited$2,
      idPrefix,
      script
    });
  }
  if (scriptType === "resource") {
    entries.push({
      id: idPrefix + "scriptResource",
      component: Resource,
      isEdited: isEdited$1,
      idPrefix,
      script
    });
  }
  return entries;
}
function Format(props) {
  const {
    element,
    idPrefix,
    script
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const businessObject = script || getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("scriptFormat");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        scriptFormat: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: idPrefix + "scriptFormat",
    label: translate3("Format"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function Type$3(props) {
  const {
    element,
    idPrefix,
    script
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const businessObject = script || getBusinessObject(element);
  const scriptProperty = getScriptProperty(businessObject);
  const getValue2 = () => {
    return getScriptType(businessObject);
  };
  const setValue = (value) => {
    const properties = {
      [scriptProperty]: value === "script" ? "" : void 0,
      "camunda:resource": value === "resource" ? "" : void 0
    };
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties
    });
  };
  const getOptions = () => {
    const options2 = [{
      value: "",
      label: translate3("<none>")
    }, {
      value: "resource",
      label: translate3("External resource")
    }, {
      value: "script",
      label: translate3("Inline script")
    }];
    return options2;
  };
  return SelectEntry({
    element,
    id: idPrefix + "scriptType",
    label: translate3("Type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function Script(props) {
  const {
    element,
    idPrefix,
    script
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const businessObject = script || getBusinessObject(element);
  const scriptProperty = getScriptProperty(businessObject);
  const getValue2 = () => {
    return getScriptValue(businessObject);
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        [scriptProperty]: value || ""
      }
    });
  };
  return TextAreaEntry({
    element,
    id: idPrefix + "scriptValue",
    label: translate3("Script"),
    getValue: getValue2,
    setValue,
    debounce: debounce4,
    monospace: true
  });
}
function Resource(props) {
  const {
    element,
    idPrefix,
    script
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const businessObject = script || getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:resource");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:resource": value || ""
      }
    });
  };
  return TextfieldEntry({
    element,
    id: idPrefix + "scriptResource",
    label: translate3("Resource"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function getScriptType(element) {
  const businessObject = getBusinessObject(element);
  const scriptValue = getScriptValue(businessObject);
  if (typeof scriptValue !== "undefined") {
    return "script";
  }
  const resource = businessObject.get("camunda:resource");
  if (typeof resource !== "undefined") {
    return "resource";
  }
}
function getScriptValue(businessObject) {
  return businessObject.get(getScriptProperty(businessObject));
}
function isScript$2(element) {
  return is(element, "camunda:Script");
}
function getScriptProperty(businessObject) {
  return isScript$2(businessObject) ? "value" : "script";
}
function getElements(businessObject, type, property) {
  const elements = getExtensionElementsList(businessObject, type);
  return !property ? elements : (elements[0] || {})[property] || [];
}
function getParameters(element, prop) {
  const inputOutput = getInputOutput(element);
  return inputOutput && inputOutput.get(prop) || [];
}
function getInputOutput(element) {
  if (is(element, "camunda:Connector")) {
    return element.get("inputOutput");
  }
  const businessObject = getBusinessObject(element);
  return (getElements(businessObject, "camunda:InputOutput") || [])[0];
}
function getInputParameters(element) {
  return getParameters(element, "inputParameters");
}
function getOutputParameters(element) {
  return getParameters(element, "outputParameters");
}
function isInputOutputSupported(element) {
  const businessObject = getBusinessObject(element);
  return is(businessObject, "bpmn:FlowNode") && !(isAny(businessObject, ["bpmn:StartEvent", "bpmn:BoundaryEvent", "bpmn:Gateway"]) || is(businessObject, "bpmn:SubProcess") && businessObject.get("triggeredByEvent"));
}
function areInputParametersSupported(element) {
  return isInputOutputSupported(element);
}
function areOutputParametersSupported(element) {
  const businessObject = getBusinessObject(element);
  return isInputOutputSupported(element) && !is(businessObject, "bpmn:EndEvent") && !businessObject.loopCharacteristics;
}
function getInputOutputType(parameter) {
  const definitionTypes = {
    "camunda:Map": "map",
    "camunda:List": "list",
    "camunda:Script": "script"
  };
  let type = "stringOrExpression";
  const definition = parameter.get("definition");
  if (typeof definition !== "undefined") {
    type = definitionTypes[definition.$type];
  }
  return type;
}
function CreateParameterCmd(element, type, parent, bpmnFactory) {
  const isInput3 = type === "camunda:InputParameter";
  const newParameter = createElement(type, {
    name: nextId(isInput3 ? "Input_" : "Output_")
  }, parent, bpmnFactory);
  const propertyName = isInput3 ? "inputParameters" : "outputParameters";
  return {
    cmd: "element.updateModdleProperties",
    context: {
      element,
      moddleElement: parent,
      properties: {
        [propertyName]: [...parent.get(propertyName), newParameter]
      }
    }
  };
}
function AddParameterCmd(element, type, bpmnFactory) {
  const commands = [];
  const businessObject = getBusinessObject(element);
  let extensionElements = businessObject.get("extensionElements");
  if (!extensionElements) {
    extensionElements = createElement("bpmn:ExtensionElements", {
      values: []
    }, businessObject, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: businessObject,
        properties: {
          extensionElements
        }
      }
    });
  }
  let inputOutput = getInputOutput(element);
  if (!inputOutput) {
    const parent = extensionElements;
    inputOutput = createElement("camunda:InputOutput", {
      inputParameters: [],
      outputParameters: []
    }, parent, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: extensionElements,
        properties: {
          values: [...extensionElements.get("values"), inputOutput]
        }
      }
    });
  }
  commands.push(CreateParameterCmd(element, type, inputOutput, bpmnFactory));
  return commands;
}
function ListProp(props) {
  const {
    element,
    id: idPrefix,
    index: index2,
    item
  } = props;
  const id = `${idPrefix}-listItem-${index2}`;
  return o5(ListItem2, {
    idPrefix: id,
    element,
    item
  });
}
function ListProps(props) {
  const {
    idPrefix,
    element,
    parameter
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const list = parameter.get("definition");
  const items = list.get("items");
  function addItem() {
    const value = createElement("camunda:Value", {}, parameter, bpmnFactory);
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: list,
      properties: {
        items: [...list.get("items"), value]
      }
    });
  }
  function removeItem(item) {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: list,
      properties: {
        items: (0, import_min_dash147.without)(list.get("items"), item)
      }
    });
  }
  function compareFn(item, anotherItem) {
    const [value = "", anotherValue = ""] = [item.value, anotherItem.value];
    return value === anotherValue ? 0 : value > anotherValue ? 1 : -1;
  }
  return List({
    element,
    autoFocusEntry: true,
    compareFn,
    id: idPrefix + "-list",
    items,
    label: translate3("List values"),
    onAdd: addItem,
    onRemove: removeItem,
    component: ListProp
  });
}
function ListItem2(props) {
  const {
    idPrefix,
    element,
    item
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const definitionLabels = {
    "camunda:Map": translate3("Map"),
    "camunda:List": translate3("List"),
    "camunda:Script": translate3("Script")
  };
  const getValue2 = () => {
    if (isDefinitionType$1(item)) {
      return definitionLabels[item.$type];
    }
    return item.get("value");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: item,
      properties: {
        value
      }
    });
  };
  return ListValue({
    id: idPrefix + "-value",
    disabled: isDefinitionType$1(item),
    getValue: getValue2,
    setValue
  });
}
function ListValue(props) {
  const {
    id,
    disabled,
    getValue: getValue2,
    setValue
  } = props;
  const debounce4 = useService("debounceInput", true);
  return o5(Simple, {
    id,
    getValue: getValue2,
    setValue,
    disabled,
    debounce: debounce4
  });
}
function isScript$1(element) {
  return is(element, "camunda:Script");
}
function isList$1(element) {
  return is(element, "camunda:List");
}
function isMap$1(element) {
  return is(element, "camunda:Map");
}
function isDefinitionType$1(element) {
  return isScript$1(element) || isList$1(element) || isMap$1(element);
}
function MapProp(props) {
  const {
    element,
    id: idPrefix,
    index: index2,
    item: entry,
    open: open3
  } = props;
  const id = `${idPrefix}-mapEntry-${index2}`;
  const translate3 = useService("translate");
  return o5(CollapsibleEntry, {
    id,
    element,
    entries: MapEntry({
      element,
      entry,
      idPrefix: id
    }),
    label: entry.get("key") || translate3("<empty>"),
    open: open3
  });
}
function MapProps(props) {
  const {
    idPrefix,
    element,
    parameter
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const map14 = parameter.get("definition");
  const entries = map14.get("entries");
  function addEntry() {
    const entry = createElement("camunda:Entry", {}, parameter, bpmnFactory);
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: map14,
      properties: {
        entries: [...map14.get("entries"), entry]
      }
    });
  }
  function removeEntry2(entry) {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: map14,
      properties: {
        entries: (0, import_min_dash147.without)(map14.get("entries"), entry)
      }
    });
  }
  function compareFn(entry, anotherEntry) {
    const [key = "", anotherKey = ""] = [entry.key, anotherEntry.key];
    return key === anotherKey ? 0 : key > anotherKey ? 1 : -1;
  }
  return List({
    element,
    autoFocusEntry: true,
    compareFn,
    id: idPrefix + "-map",
    items: entries,
    label: translate3("Map entries"),
    onAdd: addEntry,
    onRemove: removeEntry2,
    component: MapProp
  });
}
function MapEntry(props) {
  const {
    element,
    entry,
    idPrefix
  } = props;
  const entries = [{
    id: idPrefix + "-key",
    component: MapKey,
    entry,
    idPrefix,
    element
  }, {
    id: idPrefix + "-value",
    component: MapValue,
    entry,
    idPrefix,
    element
  }];
  return entries;
}
function MapKey(props) {
  const {
    element,
    entry,
    idPrefix
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: entry,
      properties: {
        key: value
      }
    });
  };
  const getValue2 = () => {
    return entry.get("key");
  };
  return TextfieldEntry({
    element: entry,
    id: idPrefix + "-key",
    label: translate3("Key"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function MapValue(props) {
  const {
    element,
    entry,
    idPrefix
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const definition = entry.get("definition");
  const definitionLabels = {
    "camunda:Map": translate3("Map"),
    "camunda:List": translate3("List"),
    "camunda:Script": translate3("Script")
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: entry,
      properties: {
        value
      }
    });
  };
  const getValue2 = () => {
    if (isDefinitionType(definition)) {
      return definitionLabels[definition.$type];
    }
    return entry.get("value");
  };
  return TextfieldEntry({
    element: entry,
    id: idPrefix + "-value",
    label: translate3("Value"),
    getValue: getValue2,
    setValue,
    disabled: isDefinitionType(definition),
    debounce: debounce4
  });
}
function isScript(element) {
  return is(element, "camunda:Script");
}
function isList(element) {
  return is(element, "camunda:List");
}
function isMap(element) {
  return is(element, "camunda:Map");
}
function isDefinitionType(element) {
  return isScript(element) || isList(element) || isMap(element);
}
var DEFAULT_PROPS$3 = {
  value: void 0,
  definition: void 0
};
function InputOutputParameter(props) {
  const {
    idPrefix,
    element,
    parameter
  } = props;
  const inputOutputType = getInputOutputType(parameter);
  let entries = [{
    id: idPrefix + "-name",
    component: Name$2,
    isEdited: isEdited$1,
    idPrefix,
    parameter
  }, {
    id: idPrefix + "-type",
    component: Type$2,
    isEdited: isEdited$4,
    idPrefix,
    parameter
  }];
  if (inputOutputType === "stringOrExpression") {
    entries.push({
      id: idPrefix + "-stringOrExpression",
      component: StringOrExpression,
      isEdited: isEdited$2,
      idPrefix,
      parameter
    });
  } else if (inputOutputType === "script") {
    const script = parameter.get("definition");
    entries = [...entries, ...ScriptProps({
      element,
      prefix: idPrefix + "-",
      script
    })];
  } else if (inputOutputType === "list") {
    entries.push({
      id: `${idPrefix}-list`,
      component: ListProps,
      idPrefix,
      parameter
    });
  } else if (inputOutputType === "map") {
    entries.push({
      id: `${idPrefix}-map`,
      component: MapProps,
      idPrefix,
      parameter
    });
  }
  return entries;
}
function Name$2(props) {
  const {
    idPrefix,
    element,
    parameter
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: parameter,
      properties: {
        name: value
      }
    });
  };
  const getValue2 = (parameter2) => {
    return parameter2.get("name");
  };
  return TextfieldEntry({
    element: parameter,
    id: idPrefix + "-name",
    label: translate3(isInput2(parameter) ? "Local variable name" : "Process variable name"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function Type$2(props) {
  const {
    idPrefix,
    element,
    parameter
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const createDefinitionElement = (type) => {
    return createElement(type, {}, parameter, bpmnFactory);
  };
  const getValue2 = (mapping) => {
    return getInputOutputType(mapping);
  };
  const setValue = (value) => {
    let properties = {
      ...DEFAULT_PROPS$3
    };
    if (value === "script") {
      properties.definition = createDefinitionElement("camunda:Script");
    } else if (value === "list") {
      properties.definition = createDefinitionElement("camunda:List");
    } else if (value === "map") {
      properties.definition = createDefinitionElement("camunda:Map");
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: parameter,
      properties
    });
  };
  const getOptions = () => {
    const options2 = [{
      label: translate3("List"),
      value: "list"
    }, {
      label: translate3("Map"),
      value: "map"
    }, {
      label: translate3("Script"),
      value: "script"
    }, {
      label: translate3("String or expression"),
      value: "stringOrExpression"
    }];
    return options2;
  };
  return SelectEntry({
    element: parameter,
    id: idPrefix + "-type",
    label: translate3("Assignment type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function StringOrExpression(props) {
  const {
    idPrefix,
    element,
    parameter
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: parameter,
      properties: {
        value
      }
    });
  };
  const getValue2 = (parameter2) => {
    return parameter2.get("value");
  };
  return TextAreaEntry({
    element: parameter,
    id: idPrefix + "-stringOrExpression",
    label: translate3("Value"),
    description: translate3('Start typing "${}" to create an expression.'),
    getValue: getValue2,
    setValue,
    rows: 1,
    debounce: debounce4
  });
}
function isInput2(parameter) {
  return is(parameter, "camunda:InputParameter");
}
function isServiceTaskLike(element) {
  return is(element, "camunda:ServiceTaskLike");
}
function isDmnCapable(element) {
  return is(element, "camunda:DmnCapable");
}
function isExternalCapable(element) {
  return is(element, "camunda:ExternalCapable");
}
function getServiceTaskLikeBusinessObject(element) {
  if (is(element, "bpmn:IntermediateThrowEvent") || is(element, "bpmn:EndEvent")) {
    const messageEventDefinition = getMessageEventDefinition(element);
    if (messageEventDefinition) {
      element = messageEventDefinition;
    }
  }
  return isServiceTaskLike(element) && getBusinessObject(element);
}
function getImplementationType(element) {
  const businessObject = getListenerBusinessObject(element) || getServiceTaskLikeBusinessObject(element);
  if (!businessObject) {
    return;
  }
  if (isDmnCapable(businessObject)) {
    const decisionRef = businessObject.get("camunda:decisionRef");
    if (typeof decisionRef !== "undefined") {
      return "dmn";
    }
  }
  if (isServiceTaskLike(businessObject)) {
    const connectors = getExtensionElementsList(businessObject, "camunda:Connector");
    if (connectors.length) {
      return "connector";
    }
  }
  if (isExternalCapable(businessObject)) {
    const type = businessObject.get("camunda:type");
    if (type === "external") {
      return "external";
    }
  }
  const cls = businessObject.get("camunda:class");
  if (typeof cls !== "undefined") {
    return "class";
  }
  const expression = businessObject.get("camunda:expression");
  if (typeof expression !== "undefined") {
    return "expression";
  }
  const delegateExpression = businessObject.get("camunda:delegateExpression");
  if (typeof delegateExpression !== "undefined") {
    return "delegateExpression";
  }
  const script = businessObject.get("script");
  if (typeof script !== "undefined") {
    return "script";
  }
}
function getListenerBusinessObject(businessObject) {
  if (isAny(businessObject, ["camunda:ExecutionListener", "camunda:TaskListener"])) {
    return businessObject;
  }
}
function areConnectorsSupported(element) {
  const businessObject = getServiceTaskLikeBusinessObject(element);
  return businessObject && getImplementationType(businessObject) === "connector";
}
function getConnectors$2(businessObject) {
  return getExtensionElementsList(businessObject, "camunda:Connector");
}
function getConnector$1(element) {
  const businessObject = getServiceTaskLikeBusinessObject(element);
  const connectors = getConnectors$2(businessObject);
  return connectors[0];
}
function ConnectorInputProps(props) {
  const {
    element,
    injector
  } = props;
  if (!areConnectorsSupported(element)) {
    return null;
  }
  const connector = getConnector$1(element);
  const commandStack = injector.get("commandStack"), bpmnFactory = injector.get("bpmnFactory");
  const inputParameters = getInputParameters(connector) || [];
  const items = inputParameters.map((parameter, index2) => {
    const id = element.id + "-connector-inputParameter-" + index2;
    return {
      id,
      label: parameter.get("name") || "",
      entries: InputOutputParameter({
        element,
        idPrefix: id,
        parameter
      }),
      autoFocusEntry: id + "-name",
      remove: removeFactory$8({
        connector,
        element,
        parameter,
        commandStack
      })
    };
  });
  function add3(event2) {
    event2.stopPropagation();
    const commands = [];
    let inputOutput = getInputOutput(connector);
    if (!inputOutput) {
      inputOutput = createElement("camunda:InputOutput", {
        inputParameters: [],
        outputParameters: []
      }, connector, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: connector,
          properties: {
            inputOutput
          }
        }
      });
    }
    commands.push(CreateParameterCmd(element, "camunda:InputParameter", inputOutput, bpmnFactory));
    commandStack.execute("properties-panel.multi-command-executor", commands);
  }
  return {
    items,
    add: add3
  };
}
function removeFactory$8(props) {
  const {
    commandStack,
    connector,
    element,
    parameter
  } = props;
  return function(event2) {
    event2.stopPropagation();
    const inputOutput = getInputOutput(connector);
    if (!inputOutput) {
      return;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: inputOutput,
      properties: {
        inputParameters: (0, import_min_dash147.without)(inputOutput.get("inputParameters"), parameter)
      }
    });
  };
}
function ConnectorOutputProps(props) {
  const {
    element,
    injector
  } = props;
  if (!areConnectorsSupported(element)) {
    return null;
  }
  const connector = getConnector$1(element);
  const commandStack = injector.get("commandStack"), bpmnFactory = injector.get("bpmnFactory");
  const outputParameters = getOutputParameters(connector) || [];
  const items = outputParameters.map((parameter, index2) => {
    const id = element.id + "-connector-outputParameter-" + index2;
    return {
      id,
      label: parameter.get("name") || "",
      entries: InputOutputParameter({
        idPrefix: id,
        element,
        parameter
      }),
      autoFocusEntry: id + "-name",
      remove: removeFactory$7({
        connector,
        element,
        commandStack,
        parameter
      })
    };
  });
  function add3(event2) {
    event2.stopPropagation();
    const commands = [];
    let inputOutput = getInputOutput(connector);
    if (!inputOutput) {
      inputOutput = createElement("camunda:InputOutput", {
        inputParameters: [],
        outputParameters: []
      }, connector, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: connector,
          properties: {
            inputOutput
          }
        }
      });
    }
    commands.push(CreateParameterCmd(element, "camunda:OutputParameter", inputOutput, bpmnFactory));
    commandStack.execute("properties-panel.multi-command-executor", commands);
  }
  return {
    items,
    add: add3
  };
}
function removeFactory$7(props) {
  const {
    commandStack,
    connector,
    element,
    parameter
  } = props;
  return function(event2) {
    event2.stopPropagation();
    const inputOutput = getInputOutput(connector);
    if (!inputOutput) {
      return;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: inputOutput,
      properties: {
        outputParameters: (0, import_min_dash147.without)(inputOutput.get("outputParameters"), parameter)
      }
    });
  };
}
function ErrorProps(props) {
  const {
    element,
    entries
  } = props;
  if (!isErrorSupported(element)) {
    return entries;
  }
  const error4 = getError(element);
  if (error4) {
    const idx = findPlaceToInsert(entries, "errorCode");
    entries.splice(idx, 0, {
      id: "errorMessage",
      component: ErrorMessage$1,
      isEdited: isEdited$1
    });
  }
  if (!canHaveErrorVariables(element)) {
    return entries;
  }
  entries.push({
    id: "errorCodeVariable",
    component: ErrorCodeVariable,
    isEdited: isEdited$1
  }, {
    id: "errorMessageVariable",
    component: ErrorMessageVariable,
    isEdited: isEdited$1
  });
  return entries;
}
function ErrorMessage$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const error4 = getError(element);
  const getValue2 = () => {
    return error4.get("camunda:errorMessage");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: error4,
      properties: {
        "camunda:errorMessage": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "errorMessage",
    label: translate3("Message"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function ErrorCodeVariable(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const errorEventDefinition = getErrorEventDefinition(element);
  const getValue2 = () => {
    return errorEventDefinition.get("camunda:errorCodeVariable");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: errorEventDefinition,
      properties: {
        "camunda:errorCodeVariable": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "errorCodeVariable",
    label: translate3("Code variable"),
    description: translate3("Define the name of the variable that will contain the error code."),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function ErrorMessageVariable(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const errorEventDefinition = getErrorEventDefinition(element);
  const getValue2 = () => {
    return errorEventDefinition.get("camunda:errorMessageVariable");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: errorEventDefinition,
      properties: {
        "camunda:errorMessageVariable": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "errorMessageVariable",
    label: translate3("Message variable"),
    description: translate3("Define the name of the variable that will contain the error message."),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function canHaveErrorVariables(element) {
  return is(element, "bpmn:StartEvent") || is(element, "bpmn:BoundaryEvent");
}
function findPlaceToInsert(entries, idx) {
  const entryIndex = (0, import_min_dash147.findIndex)(entries, (entry) => entry.id === idx);
  return entryIndex >= 0 ? entryIndex + 1 : entries.length;
}
var EMPTY_OPTION = "";
var CREATE_NEW_OPTION = "create-new";
function Error$1(props) {
  const {
    idPrefix,
    errorEventDefinition
  } = props;
  let entries = [{
    id: idPrefix + "-errorRef",
    component: ErrorRef,
    isEdited: isEdited$4,
    errorEventDefinition,
    idPrefix
  }];
  const error4 = errorEventDefinition.get("errorRef");
  if (error4) {
    entries = [...entries, {
      id: idPrefix + "-errorName",
      component: ErrorName,
      isEdited: isEdited$1,
      error: error4,
      errorEventDefinition,
      idPrefix
    }, {
      id: idPrefix + "-errorCode",
      component: ErrorCode,
      isEdited: isEdited$1,
      error: error4,
      errorEventDefinition,
      idPrefix
    }, {
      id: idPrefix + "-errorMessage",
      component: ErrorMessage,
      isEdited: isEdited$1,
      error: error4,
      errorEventDefinition,
      idPrefix
    }];
  }
  entries.push({
    id: idPrefix + "-expression",
    component: Expression$2,
    errorEventDefinition,
    idPrefix
  });
  return entries;
}
function ErrorRef(props) {
  const {
    element,
    errorEventDefinition,
    idPrefix
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    const error4 = errorEventDefinition.get("errorRef");
    if (error4) {
      return error4.get("id");
    }
    return EMPTY_OPTION;
  };
  const setValue = (value) => {
    const root = getRoot(businessObject);
    const commands = [];
    let error4;
    if (value === CREATE_NEW_OPTION) {
      error4 = createElement("bpmn:Error", {
        name: nextId("Error_")
      }, root, bpmnFactory);
      value = error4.get("id");
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: root,
          properties: {
            rootElements: [...root.get("rootElements"), error4]
          }
        }
      });
    }
    error4 = error4 || findRootElementById(businessObject, "bpmn:Error", value);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: errorEventDefinition,
        properties: {
          errorRef: error4
        }
      }
    });
    return commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  const getOptions = () => {
    let options2 = [{
      value: EMPTY_OPTION,
      label: translate3("<none>")
    }, {
      value: CREATE_NEW_OPTION,
      label: translate3("Create new ...")
    }];
    const errors = findRootElementsByType(getBusinessObject(element), "bpmn:Error");
    sortByName$1(errors).forEach((error4) => {
      options2.push({
        value: error4.get("id"),
        label: error4.get("name") || error4.get("id")
      });
    });
    return options2;
  };
  return ReferenceSelectEntry({
    element,
    id: idPrefix + "-errorRef",
    label: translate3("Global error reference"),
    autoFocusEntry: idPrefix + "-errorName",
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function ErrorName(props) {
  const {
    element,
    error: error4,
    idPrefix
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return error4.get("name");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: error4,
      properties: {
        name: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: idPrefix + "-errorName",
    label: translate3("Name"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function ErrorCode(props) {
  const {
    element,
    error: error4,
    idPrefix
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return error4.get("errorCode");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: error4,
      properties: {
        errorCode: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: idPrefix + "-errorCode",
    label: translate3("Code"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function ErrorMessage(props) {
  const {
    element,
    error: error4,
    idPrefix
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return error4.get("errorMessage");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: error4,
      properties: {
        errorMessage: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: idPrefix + "-errorMessage",
    label: translate3("Message"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function Expression$2(props) {
  const {
    element,
    errorEventDefinition,
    idPrefix
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: errorEventDefinition,
      properties: {
        "camunda:expression": value
      }
    });
  };
  const getValue2 = () => {
    return errorEventDefinition.get("camunda:expression");
  };
  return TextfieldEntry({
    element: errorEventDefinition,
    id: idPrefix + "-expression",
    label: translate3("Throw expression"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function sortByName$1(elements) {
  return (0, import_min_dash147.sortBy)(elements, (e7) => (e7.name || "").toLowerCase());
}
function ErrorsProps({
  element,
  injector
}) {
  const businessObject = getBusinessObject(element);
  if (!is(element, "bpmn:ServiceTask") || getImplementationType(element) !== "external") {
    return null;
  }
  const errorEventDefinitions = getExtensionElementsList(businessObject, "camunda:ErrorEventDefinition");
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = errorEventDefinitions.map((errorEventDefinition, index2) => {
    const id = element.id + "-error-" + index2;
    return {
      id,
      label: getErrorLabel(errorEventDefinition),
      entries: Error$1({
        idPrefix: id,
        element,
        errorEventDefinition
      }),
      autoFocusEntry: id + "-errorRef",
      remove: removeFactory$6({
        commandStack,
        element,
        errorEventDefinition
      })
    };
  });
  return {
    items,
    add: addFactory$5({
      bpmnFactory,
      commandStack,
      element
    }),
    shouldSort: false
  };
}
function removeFactory$6({
  commandStack,
  element,
  errorEventDefinition
}) {
  return function(event2) {
    event2.stopPropagation();
    const businessObject = getBusinessObject(element);
    removeExtensionElements(element, businessObject, errorEventDefinition, commandStack);
  };
}
function addFactory$5({
  bpmnFactory,
  commandStack,
  element
}) {
  return function(event2) {
    event2.stopPropagation();
    const businessObject = getBusinessObject(element);
    const error4 = createElement("camunda:ErrorEventDefinition", {}, void 0, bpmnFactory);
    addExtensionElements(element, businessObject, error4, bpmnFactory, commandStack);
  };
}
function getErrorLabel(errorEventDefinition) {
  const error4 = errorEventDefinition.get("errorRef");
  if (!error4) {
    return "<no reference>";
  }
  const errorCode = error4.get("errorCode"), name3 = error4.get("name") || "<unnamed>";
  if (errorCode) {
    return `${name3} (code = ${errorCode})`;
  }
  return name3;
}
function EscalationProps(props) {
  const {
    element,
    entries
  } = props;
  if (!(isEscalationSupported(element) && canHaveEscalationVariables(element))) {
    return entries;
  }
  entries.push({
    id: "escalationCodeVariable",
    component: EscalationCodeVariable,
    isEdited: isEdited$1
  });
  return entries;
}
function EscalationCodeVariable(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const escalationEventDefinition = getEscalationEventDefinition(element);
  const getValue2 = () => {
    return escalationEventDefinition.get("camunda:escalationCodeVariable");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: escalationEventDefinition,
      properties: {
        "camunda:escalationCodeVariable": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "escalationCodeVariable",
    label: translate3("Code variable"),
    description: translate3("Define the name of the variable that will contain the escalation code."),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function canHaveEscalationVariables(element) {
  return is(element, "bpmn:StartEvent") || is(element, "bpmn:BoundaryEvent");
}
function ExternalTaskPriorityProps(props) {
  const {
    element
  } = props;
  const businessObject = getBusinessObject(element);
  if (!is(element, "bpmn:Process") && !(is(element, "bpmn:Participant") && businessObject.get("processRef")) && !isExternalTaskLike(element)) {
    return [];
  }
  return [{
    id: "externalTaskPriority",
    component: ExternalTaskPriority,
    isEdited: isEdited$1
  }];
}
function ExternalTaskPriority(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), translate3 = useService("translate"), debounce4 = useService("debounceInput");
  let businessObject;
  if (is(element, "bpmn:Participant")) {
    businessObject = getBusinessObject(element).get("processRef");
  } else if (isExternalTaskLike(element)) {
    businessObject = getServiceTaskLikeBusinessObject(element);
  } else {
    businessObject = getBusinessObject(element);
  }
  const getValue2 = () => {
    return businessObject.get("camunda:taskPriority");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:taskPriority": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "externalTaskPriority",
    label: translate3("Priority"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function isExternalTaskLike(element) {
  const bo = getServiceTaskLikeBusinessObject(element), type = bo && bo.get("camunda:type");
  return is(bo, "camunda:ServiceTaskLike") && type && type === "external";
}
var DEFAULT_PROPS$2 = {
  "stringValue": void 0,
  "string": void 0,
  "expression": void 0
};
function FieldInjection(props) {
  const {
    element,
    idPrefix,
    field
  } = props;
  const entries = [{
    id: idPrefix + "-name",
    component: NameProperty,
    field,
    idPrefix,
    element
  }, {
    id: idPrefix + "-type",
    component: TypeProperty,
    field,
    idPrefix,
    element
  }, {
    id: idPrefix + "-value",
    component: ValueProperty,
    field,
    idPrefix,
    element
  }];
  return entries;
}
function NameProperty(props) {
  const {
    idPrefix,
    element,
    field
  } = props;
  const commandStack = useService("commandStack"), translate3 = useService("translate"), debounce4 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: field,
      properties: {
        name: value
      }
    });
  };
  const getValue2 = (field2) => {
    return field2.name;
  };
  return TextfieldEntry({
    element: field,
    id: idPrefix + "-name",
    label: translate3("Name"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function TypeProperty(props) {
  const {
    idPrefix,
    element,
    field
  } = props;
  const commandStack = useService("commandStack"), translate3 = useService("translate");
  const getValue2 = (field2) => {
    return determineType(field2);
  };
  const setValue = (value) => {
    const properties = Object.assign({}, DEFAULT_PROPS$2);
    properties[value] = "";
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: field,
      properties
    });
  };
  const getOptions = (element2) => {
    const options2 = [{
      value: "string",
      label: translate3("String")
    }, {
      value: "expression",
      label: translate3("Expression")
    }];
    return options2;
  };
  return SelectEntry({
    element: field,
    id: idPrefix + "-type",
    label: translate3("Type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function ValueProperty(props) {
  const {
    idPrefix,
    element,
    field
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const setValue = (value) => {
    const type = determineType(field);
    const properties = Object.assign({}, DEFAULT_PROPS$2);
    properties[type] = value || "";
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: field,
      properties
    });
  };
  const getValue2 = (field2) => {
    return field2.string || field2.stringValue || field2.expression;
  };
  return TextfieldEntry({
    element: field,
    id: idPrefix + "-value",
    label: translate3("Value"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function determineType(field) {
  return "string" in field && "string" || "expression" in field && "expression" || "stringValue" in field && "string" || "string";
}
function FieldInjectionProps({
  element,
  injector
}) {
  const businessObject = getServiceTaskLikeBusinessObject(element);
  if (!businessObject) {
    return null;
  }
  const fieldInjections = getExtensionElementsList(businessObject, "camunda:Field");
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = fieldInjections.map((field, index2) => {
    const id = element.id + "-fieldInjection-" + index2;
    return {
      id,
      label: getFieldLabel(field),
      entries: FieldInjection({
        idPrefix: id,
        element,
        field
      }),
      autoFocusEntry: id + "-name",
      remove: removeFactory$5({
        commandStack,
        element,
        field
      })
    };
  });
  return {
    items,
    add: addFactory$4({
      bpmnFactory,
      commandStack,
      element
    })
  };
}
function removeFactory$5({
  commandStack,
  element,
  field
}) {
  return function(event2) {
    event2.stopPropagation();
    const businessObject = getServiceTaskLikeBusinessObject(element);
    removeExtensionElements(element, businessObject, field, commandStack);
  };
}
function addFactory$4({
  bpmnFactory,
  commandStack,
  element
}) {
  return function(event2) {
    event2.stopPropagation();
    const businessObject = getServiceTaskLikeBusinessObject(element);
    const fieldInjection = createElement("camunda:Field", {
      name: void 0,
      string: "",
      stringValue: void 0
    }, null, bpmnFactory);
    addExtensionElements(element, businessObject, fieldInjection, bpmnFactory, commandStack);
  };
}
function getFieldLabel(field) {
  return field.name || "<empty>";
}
function FormFieldConstraint(props) {
  const {
    constraint,
    element,
    idPrefix
  } = props;
  const entries = [{
    id: idPrefix + "-name",
    component: Name$1,
    constraint,
    idPrefix,
    element
  }, {
    id: idPrefix + "-config",
    component: Config,
    constraint,
    idPrefix,
    element
  }];
  return entries;
}
function Name$1(props) {
  const {
    idPrefix,
    element,
    constraint
  } = props;
  const commandStack = useService("commandStack"), translate3 = useService("translate"), debounce4 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: constraint,
      properties: {
        name: value
      }
    });
  };
  const getValue2 = () => {
    return constraint.name;
  };
  return TextfieldEntry({
    element: constraint,
    id: idPrefix + "-name",
    label: translate3("Name"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function Config(props) {
  const {
    idPrefix,
    element,
    constraint
  } = props;
  const commandStack = useService("commandStack"), translate3 = useService("translate"), debounce4 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: constraint,
      properties: {
        config: value
      }
    });
  };
  const getValue2 = () => {
    return constraint.config;
  };
  return TextfieldEntry({
    element: constraint,
    id: idPrefix + "-config",
    label: translate3("Config"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function FormFieldProperty(props) {
  const {
    element,
    idPrefix,
    property
  } = props;
  const entries = [{
    id: idPrefix + "-id",
    component: Id$2,
    idPrefix,
    property,
    element
  }, {
    id: idPrefix + "-value",
    component: Value$1,
    idPrefix,
    property,
    element
  }];
  return entries;
}
function Id$2(props) {
  const {
    idPrefix,
    element,
    property
  } = props;
  const commandStack = useService("commandStack"), translate3 = useService("translate"), debounce4 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: property,
      properties: {
        id: value
      }
    });
  };
  const getValue2 = () => {
    return property.id;
  };
  return TextfieldEntry({
    element: property,
    id: idPrefix + "-id",
    label: translate3("ID"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function Value$1(props) {
  const {
    idPrefix,
    element,
    property
  } = props;
  const commandStack = useService("commandStack"), translate3 = useService("translate"), debounce4 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: property,
      properties: {
        value
      }
    });
  };
  const getValue2 = () => {
    return property.value;
  };
  return TextfieldEntry({
    element: property,
    id: idPrefix + "-value",
    label: translate3("Value"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function FormFieldValue(props) {
  const {
    element,
    idPrefix,
    value
  } = props;
  const entries = [{
    id: idPrefix + "-id",
    component: Id$1,
    idPrefix,
    value,
    element
  }, {
    id: idPrefix + "-name",
    component: Name2,
    idPrefix,
    value,
    element
  }];
  return entries;
}
function Id$1(props) {
  const {
    idPrefix,
    element,
    value
  } = props;
  const commandStack = useService("commandStack"), translate3 = useService("translate"), debounce4 = useService("debounceInput");
  const setValue = (val) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: value,
      properties: {
        id: val
      }
    });
  };
  const getValue2 = () => {
    return value.id;
  };
  return TextfieldEntry({
    element: value,
    id: idPrefix + "-id",
    label: translate3("ID"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function Name2(props) {
  const {
    idPrefix,
    element,
    value
  } = props;
  const commandStack = useService("commandStack"), translate3 = useService("translate"), debounce4 = useService("debounceInput");
  const setValue = (val) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: value,
      properties: {
        name: val
      }
    });
  };
  const getValue2 = () => {
    return value.name;
  };
  return TextfieldEntry({
    element: value,
    id: idPrefix + "-name",
    label: translate3("Name"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
var CUSTOM_TYPE_VALUE = "";
var DEFINED_TYPE_VALUES = ["boolean", "date", "enum", "long", "string", void 0];
function FormField(props) {
  const {
    idPrefix,
    formField
  } = props;
  const entries = [{
    id: idPrefix + "-formFieldID",
    component: Id,
    idPrefix,
    formField
  }, {
    id: idPrefix + "-formFieldLabel",
    component: Label2,
    idPrefix,
    formField
  }, {
    id: idPrefix + "-formFieldType",
    component: Type$1,
    idPrefix,
    formField
  }];
  if (!DEFINED_TYPE_VALUES.includes(formField.get("type"))) {
    entries.push({
      id: idPrefix + "-formFieldCustomType",
      component: CustomType,
      idPrefix,
      formField
    });
  }
  entries.push({
    id: idPrefix + "-formFieldDefaultValue",
    component: DefaultValue,
    idPrefix,
    formField
  });
  if (formField.get("type") === "enum") {
    entries.push({
      id: idPrefix + "-formFieldValues",
      component: ValueList,
      formField,
      idPrefix
    });
  }
  entries.push({
    id: idPrefix + "-formFieldConstraints",
    component: ConstraintList,
    formField,
    idPrefix
  }, {
    id: idPrefix + "-formFieldProperties",
    component: PropertiesList,
    formField,
    idPrefix
  });
  return entries;
}
function Id(props) {
  const {
    idPrefix,
    element,
    formField
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: formField,
      properties: {
        id: value
      }
    });
  };
  const getValue2 = () => {
    return formField.get("id");
  };
  return TextfieldEntry({
    element: formField,
    id: idPrefix + "-formFieldID",
    label: translate3("ID"),
    description: translate3("Refers to the process variable name"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function Label2(props) {
  const {
    idPrefix,
    element,
    formField
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: formField,
      properties: {
        label: value
      }
    });
  };
  const getValue2 = () => {
    return formField.get("label");
  };
  return TextfieldEntry({
    element: formField,
    id: idPrefix + "-formFieldLabel",
    label: translate3("Label"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function Type$1(props) {
  const {
    idPrefix,
    element,
    formField
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: formField,
      properties: {
        type: value
      }
    });
  };
  const getValue2 = () => {
    const type = formField.get("type");
    return DEFINED_TYPE_VALUES.includes(type) ? type : CUSTOM_TYPE_VALUE;
  };
  const getOptions = () => {
    const options2 = [{
      label: translate3("boolean"),
      value: "boolean"
    }, {
      label: translate3("date"),
      value: "date"
    }, {
      label: translate3("enum"),
      value: "enum"
    }, {
      label: translate3("long"),
      value: "long"
    }, {
      label: translate3("string"),
      value: "string"
    }, {
      label: translate3("<custom type>"),
      value: CUSTOM_TYPE_VALUE
    }];
    if (formField.get("type") === void 0) {
      options2.unshift({
        label: translate3("<none>"),
        value: ""
      });
    }
    return options2;
  };
  return SelectEntry({
    element: formField,
    id: idPrefix + "-formFieldType",
    label: translate3("Type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function CustomType(props) {
  const {
    idPrefix,
    element,
    formField
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const setValue = (value) => {
    const type = value || "";
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: formField,
      properties: {
        type
      }
    });
  };
  const getValue2 = () => {
    return formField.get("type");
  };
  return TextfieldEntry({
    element: formField,
    id: idPrefix + "-formFieldCustomType",
    label: translate3("Custom type"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function DefaultValue(props) {
  const {
    idPrefix,
    element,
    formField
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: formField,
      properties: {
        defaultValue: value
      }
    });
  };
  const getValue2 = () => {
    return formField.get("defaultValue");
  };
  return TextfieldEntry({
    element: formField,
    id: idPrefix + "-formFieldDefaultValue",
    label: translate3("Default value"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function Value(props) {
  const {
    element,
    id: idPrefix,
    index: index2,
    item: value,
    open: open3
  } = props;
  const translate3 = useService("translate");
  const id = `${idPrefix}-value-${index2}`;
  return o5(CollapsibleEntry, {
    id,
    element,
    entries: FormFieldValue({
      idPrefix: id,
      element,
      value
    }),
    label: value.get("id") || translate3("<empty>"),
    open: open3
  });
}
function ValueList(props) {
  const {
    element,
    formField,
    idPrefix
  } = props;
  const id = `${idPrefix}-formFieldValues`;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const values5 = formField.get("values") || [];
  function addValue() {
    const value = createElement("camunda:Value", {
      id: void 0,
      name: void 0
    }, formField, bpmnFactory);
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: formField,
      properties: {
        values: [...formField.get("values"), value]
      }
    });
  }
  function removeValue(value) {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: formField,
      properties: {
        values: (0, import_min_dash147.without)(formField.get("values"), value)
      }
    });
  }
  return o5(List, {
    element,
    autoFocusEntry: `[data-entry-id="${id}-value-${values5.length - 1}"] input`,
    id,
    label: translate3("Values"),
    items: values5,
    component: Value,
    onAdd: addValue,
    onRemove: removeValue
  });
}
function Constraint(props) {
  const {
    element,
    id: idPrefix,
    index: index2,
    item: constraint,
    open: open3
  } = props;
  const translate3 = useService("translate");
  const id = `${idPrefix}-constraint-${index2}`;
  return o5(CollapsibleEntry, {
    id,
    element,
    entries: FormFieldConstraint({
      constraint,
      element,
      idPrefix: id
    }),
    label: constraint.get("name") || translate3("<empty>"),
    open: open3
  });
}
function ConstraintList(props) {
  const {
    element,
    formField,
    idPrefix
  } = props;
  const id = `${idPrefix}-formFieldConstraints`;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const businessObject = getBusinessObject(element);
  let validation = formField.get("validation");
  const constraints = validation && validation.get("constraints") || [];
  function addConstraint() {
    const commands = [];
    if (!validation) {
      validation = createElement("camunda:Validation", {}, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: formField,
          properties: {
            validation
          }
        }
      });
    }
    const constraint = createElement("camunda:Constraint", {
      name: void 0,
      config: void 0
    }, validation, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: validation,
        properties: {
          constraints: [...validation.get("constraints"), constraint]
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  }
  function removeConstraint(constraint) {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: validation,
      properties: {
        constraints: (0, import_min_dash147.without)(validation.get("constraints"), constraint)
      }
    });
  }
  return o5(List, {
    element,
    autoFocusEntry: `[data-entry-id="${id}-constraint-${constraints.length - 1}"] input`,
    id,
    label: translate3("Constraints"),
    items: constraints,
    component: Constraint,
    onAdd: addConstraint,
    onRemove: removeConstraint
  });
}
function Property(props) {
  const {
    element,
    id: idPrefix,
    index: index2,
    item: property,
    open: open3
  } = props;
  const translate3 = useService("translate");
  const id = `${idPrefix}-property-${index2}`;
  return o5(CollapsibleEntry, {
    id,
    element,
    entries: FormFieldProperty({
      element,
      idPrefix: id,
      property
    }),
    label: property.get("id") || translate3("<empty>"),
    open: open3
  });
}
function PropertiesList(props) {
  const {
    element,
    formField,
    idPrefix
  } = props;
  const id = `${idPrefix}-formFieldProperties`;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const businessObject = getBusinessObject(element);
  let properties = formField.get("properties");
  const propertyEntries = properties && properties.get("values") || [];
  function addProperty() {
    const commands = [];
    if (!properties) {
      properties = createElement("camunda:Properties", {}, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: formField,
          properties: {
            properties
          }
        }
      });
    }
    const property = createElement("camunda:Property", {
      id: void 0,
      value: void 0
    }, properties, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: properties,
        properties: {
          values: [...properties.get("values"), property]
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  }
  function removeProperty(property) {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: properties,
      properties: {
        values: (0, import_min_dash147.without)(properties.get("values"), property)
      }
    });
  }
  return o5(List, {
    element,
    autoFocusEntry: true,
    id,
    compareFn: createAlphanumericCompare("id"),
    label: translate3("Properties"),
    items: propertyEntries,
    component: Property,
    onAdd: addProperty,
    onRemove: removeProperty
  });
}
function createAlphanumericCompare(field) {
  return function(entry, anotherEntry) {
    const [key = "", anotherKey = ""] = [entry[field], anotherEntry[field]];
    return key === anotherKey ? 0 : key > anotherKey ? 1 : -1;
  };
}
function FormDataProps({
  element,
  injector
}) {
  if (!isFormDataSupported(element)) {
    return;
  }
  const formFields = getFormFieldsList(element) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = formFields.map((formField, index2) => {
    const id = element.id + "-formField-" + index2;
    return {
      id,
      label: formField.get("id") || "",
      entries: FormField({
        idPrefix: id,
        element,
        formField
      }),
      autoFocusEntry: id + "-formFieldID",
      remove: removeFactory$4({
        commandStack,
        element,
        formField
      })
    };
  });
  return {
    items,
    add: addFactory$3({
      bpmnFactory,
      commandStack,
      element
    }),
    shouldSort: false
  };
}
function addFactory$3({
  bpmnFactory,
  commandStack,
  element
}) {
  return function(event2) {
    event2.stopPropagation();
    const commands = [];
    const formData = getFormData$1(element);
    const formField = createElement("camunda:FormField", {}, formData, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: formData,
        properties: {
          fields: [...formData.get("fields"), formField]
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function removeFactory$4({
  commandStack,
  element,
  formField
}) {
  return function(event2) {
    event2.stopPropagation();
    const formData = getFormData$1(element), formFields = getFormFieldsList(element);
    if (!formFields || !formFields.length) {
      return;
    }
    const fields = (0, import_min_dash147.without)(formData.get("fields"), formField);
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: formData,
      properties: {
        fields
      }
    });
  };
}
function isFormDataSupported(element) {
  const formData = getFormData$1(element);
  return (is(element, "bpmn:StartEvent") && !is(element.parent, "bpmn:SubProcess") || is(element, "bpmn:UserTask")) && formData;
}
function getFormData$1(element) {
  const bo = getBusinessObject(element);
  return getExtensionElementsList(bo, "camunda:FormData")[0];
}
function getFormFieldsList(element) {
  const businessObject = getBusinessObject(element);
  const formData = getFormData$1(businessObject);
  return formData && formData.fields;
}
var FORM_KEY_PROPS = {
  "camunda:formRef": void 0,
  "camunda:formRefBinding": void 0,
  "camunda:formRefVersion": void 0
};
var FORM_REF_PROPS = {
  "camunda:formKey": void 0
};
function FormTypeProps(props) {
  return [{
    id: "formType",
    component: FormType,
    isEdited: isEdited$4
  }];
}
function FormType(props) {
  const {
    element
  } = props;
  const translate3 = useService("translate");
  const bpmnFactory = useService("bpmnFactory");
  const businessObject = getBusinessObject(element);
  const commandStack = useService("commandStack");
  let extensionElements = businessObject.get("extensionElements");
  const getValue2 = () => {
    if ((0, import_min_dash147.isDefined)(businessObject.get("camunda:formKey"))) {
      return "formKey";
    } else if ((0, import_min_dash147.isDefined)(businessObject.get("camunda:formRef"))) {
      return "formRef";
    } else if (getFormData(element)) {
      return "formData";
    }
    return "";
  };
  const setValue = (value) => {
    const commands = removePropertiesCommands(element);
    if (value === "formData") {
      if (!extensionElements) {
        extensionElements = createElement("bpmn:ExtensionElements", {
          values: []
        }, businessObject, bpmnFactory);
        commands.push({
          cmd: "element.updateModdleProperties",
          context: {
            element,
            moddleElement: businessObject,
            properties: {
              extensionElements
            }
          }
        });
      }
      const parent = extensionElements;
      const formData = createElement("camunda:FormData", {
        fields: []
      }, parent, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), formData]
          }
        }
      });
    } else if (value === "formKey") {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            "camunda:formKey": ""
          }
        }
      });
    } else if (value === "formRef") {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            "camunda:formRef": ""
          }
        }
      });
    }
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  const getOptions = () => {
    return [{
      value: "",
      label: translate3("<none>")
    }, {
      value: "formRef",
      label: translate3("Camunda Forms")
    }, {
      value: "formKey",
      label: translate3("Embedded or External Task Forms")
    }, {
      value: "formData",
      label: translate3("Generated Task Forms")
    }];
  };
  return SelectEntry({
    element,
    id: "formType",
    label: translate3("Type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function getFormData(element) {
  const bo = getBusinessObject(element);
  return getExtensionElementsList(bo, "camunda:FormData")[0];
}
function removePropertiesCommands(element, commandStack) {
  const businessObject = getBusinessObject(element);
  const extensionElements = businessObject.get("extensionElements");
  const commands = [];
  commands.push({
    cmd: "element.updateModdleProperties",
    context: {
      element,
      moddleElement: businessObject,
      properties: {
        ...FORM_KEY_PROPS,
        ...FORM_REF_PROPS
      }
    }
  });
  if (extensionElements && getFormData(element)) {
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: extensionElements,
        properties: {
          values: (0, import_min_dash147.without)(extensionElements.get("values"), getFormData(element))
        }
      }
    });
  }
  return commands;
}
function getFormRefBinding(element) {
  const businessObject = getBusinessObject(element);
  return businessObject.get("camunda:formRefBinding") || "latest";
}
function getFormType(element) {
  const businessObject = getBusinessObject(element);
  if ((0, import_min_dash147.isDefined)(businessObject.get("camunda:formKey"))) {
    return "formKey";
  } else if ((0, import_min_dash147.isDefined)(businessObject.get("camunda:formRef"))) {
    return "formRef";
  }
}
function isFormSupported(element) {
  return is(element, "bpmn:StartEvent") && !is(element.parent, "bpmn:SubProcess") || is(element, "bpmn:UserTask");
}
function FormProps(props) {
  const {
    element
  } = props;
  if (!isFormSupported(element)) {
    return [];
  }
  const formType = getFormType(element), bindingType = getFormRefBinding(element);
  const entries = [...FormTypeProps()];
  if (formType === "formKey") {
    entries.push({
      id: "formKey",
      component: FormKey,
      isEdited: isEdited$1
    });
  } else if (formType === "formRef") {
    entries.push({
      id: "formRef",
      component: FormRef,
      isEdited: isEdited$1
    }, {
      id: "formRefBinding",
      component: Binding$1,
      isEdited: isEdited$4
    });
    if (bindingType === "version") {
      entries.push({
        id: "formRefVersion",
        component: Version$1,
        isEdited: isEdited$1
      });
    }
  }
  return entries;
}
function FormKey(props) {
  const {
    element
  } = props;
  const debounce4 = useService("debounceInput");
  const modeling = useService("modeling");
  const translate3 = useService("translate");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:formKey");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      "camunda:formKey": value
    });
  };
  return TextfieldEntry({
    element,
    id: "formKey",
    label: translate3("Form key"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function FormRef(props) {
  const {
    element
  } = props;
  const debounce4 = useService("debounceInput");
  const modeling = useService("modeling");
  const translate3 = useService("translate");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:formRef");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      "camunda:formRef": value
    });
  };
  return TextfieldEntry({
    element,
    id: "formRef",
    label: translate3("Form reference"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function Binding$1(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate3 = useService("translate");
  const getValue2 = () => {
    return getFormRefBinding(element);
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      "camunda:formRefBinding": value
    });
  };
  const getOptions = () => {
    const options2 = [{
      value: "deployment",
      label: translate3("deployment")
    }, {
      value: "latest",
      label: translate3("latest")
    }, {
      value: "version",
      label: translate3("version")
    }];
    return options2;
  };
  return SelectEntry({
    element,
    id: "formRefBinding",
    label: translate3("Binding"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function Version$1(props) {
  const {
    element
  } = props;
  const debounce4 = useService("debounceInput");
  const modeling = useService("modeling");
  const translate3 = useService("translate");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:formRefVersion");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      "camunda:formRefVersion": value
    });
  };
  return TextfieldEntry({
    element,
    id: "formRefVersion",
    label: translate3("Version"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function HistoryCleanupProps(props) {
  const {
    element
  } = props;
  const businessObject = getBusinessObject(element);
  if (!is(element, "bpmn:Process") && !(is(element, "bpmn:Participant") && businessObject.get("processRef"))) {
    return [];
  }
  return [{
    id: "historyTimeToLive",
    component: HistoryTimeToLive,
    isEdited: isEdited$1
  }];
}
function HistoryTimeToLive(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const process2 = getProcess$2(element);
  const getValue2 = () => {
    return process2.get("camunda:historyTimeToLive") || "";
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: process2,
      properties: {
        "camunda:historyTimeToLive": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "historyTimeToLive",
    label: translate3("Time to live"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function getProcess$2(element) {
  return is(element, "bpmn:Process") ? getBusinessObject(element) : getBusinessObject(element).get("processRef");
}
function DmnImplementationProps(props) {
  const {
    element
  } = props;
  const entries = [];
  const implementationType = getImplementationType(element);
  const bindingType = getDecisionRefBinding(element);
  if (implementationType !== "dmn") {
    return entries;
  }
  entries.push({
    id: "decisionRef",
    component: DecisionRef,
    isEdited: isEdited$1
  });
  entries.push({
    id: "decisionRefBinding",
    component: Binding,
    isEdited: isEdited$4
  });
  if (bindingType === "version") {
    entries.push({
      id: "decisionRefVersion",
      component: Version,
      isEdited: isEdited$1
    });
  }
  if (bindingType === "versionTag") {
    entries.push({
      id: "decisionRefVersionTag",
      component: VersionTag$1,
      isEdited: isEdited$1
    });
  }
  entries.push({
    id: "decisionRefTenantId",
    component: TenantId,
    isEdited: isEdited$1
  });
  entries.push({
    id: "decisionRefResultVariable",
    component: ResultVariable$2,
    isEdited: isEdited$1
  });
  if (getResultVariable(element)) {
    entries.push({
      id: "mapDecisionResult",
      component: MapDecisionResult,
      isEdited: isEdited$4
    });
  }
  return entries;
}
function DecisionRef(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:decisionRef");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:decisionRef": value || ""
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "decisionRef",
    label: translate3("Decision reference"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function Binding(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const getValue2 = () => {
    return getDecisionRefBinding(element);
  };
  const setValue = (value) => {
    const businessObject = getBusinessObject(element);
    const updatedProperties = {
      "camunda:decisionRefVersion": void 0,
      "camunda:decisionRefVersionTag": void 0,
      "camunda:decisionRefBinding": value
    };
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: updatedProperties
    });
  };
  const getOptions = () => {
    const options2 = [{
      value: "deployment",
      label: translate3("deployment")
    }, {
      value: "latest",
      label: translate3("latest")
    }, {
      value: "version",
      label: translate3("version")
    }, {
      value: "versionTag",
      label: translate3("versionTag")
    }];
    return options2;
  };
  return SelectEntry({
    element,
    id: "decisionRefBinding",
    label: translate3("Binding"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function Version(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:decisionRefVersion");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:decisionRefVersion": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "decisionRefVersion",
    label: translate3("Version"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function VersionTag$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:decisionRefVersionTag");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:decisionRefVersionTag": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "decisionRefVersionTag",
    label: translate3("Version tag"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function TenantId(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:decisionRefTenantId");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:decisionRefTenantId": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "decisionRefTenantId",
    label: translate3("Tenant ID"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function ResultVariable$2(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return getResultVariable(businessObject);
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:resultVariable": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "decisionRefResultVariable",
    label: translate3("Result variable"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function MapDecisionResult(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:mapDecisionResult") || "resultList";
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:mapDecisionResult": value
      }
    });
  };
  const getOptions = () => {
    const options2 = [{
      value: "collectEntries",
      label: translate3("collectEntries (List<Object>)")
    }, {
      value: "resultList",
      label: translate3("resultList (List<Map<String, Object>>)")
    }, {
      value: "singleEntry",
      label: translate3("singleEntry (TypedValue)")
    }, {
      value: "singleResult",
      label: translate3("singleResult (Map<String, Object>)")
    }];
    return options2;
  };
  return SelectEntry({
    element,
    id: "mapDecisionResult",
    label: translate3("Map decision result"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function getDecisionRefBinding(element) {
  const businessObject = getBusinessObject(element);
  return businessObject.get("camunda:decisionRefBinding") || "latest";
}
function getResultVariable(element) {
  const businessObject = getBusinessObject(element);
  return businessObject.get("camunda:resultVariable");
}
var DELEGATE_PROPS = {
  "camunda:class": void 0,
  "camunda:expression": void 0,
  "camunda:delegateExpression": void 0,
  "camunda:resultVariable": void 0
};
var DMN_CAPABLE_PROPS = {
  "camunda:decisionRef": void 0,
  "camunda:decisionRefBinding": "latest",
  "camunda:decisionRefVersion": void 0,
  "camunda:mapDecisionResult": "resultList",
  "camunda:decisionRefTenantId": void 0
};
var EXTERNAL_CAPABLE_PROPS = {
  "camunda:type": void 0,
  "camunda:topic": void 0
};
var IMPLEMENTATION_TYPE_NONE_LABEL = "<none>";
var IMPLEMENTATION_TYPE_JAVA_LABEL = "Java class";
var IMPLEMENTATION_TYPE_EXPRESSION_LABEL = "Expression";
var IMPLEMENTATION_TYPE_DELEGATE_LABEL = "Delegate expression";
var IMPLEMENTATION_TYPE_DMN_LABEL = "DMN";
var IMPLEMENTATION_TYPE_EXTERNAL_LABEL = "External";
var IMPLEMENTATION_TYPE_CONNECTOR_LABEL = "Connector";
function ImplementationTypeProps(props) {
  return [{
    id: "implementationType",
    component: ImplementationType,
    isEdited: isEdited$4
  }];
}
function ImplementationType(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const getValue2 = () => {
    return getImplementationType(element) || "";
  };
  const setValue = (value) => {
    const oldType = getImplementationType(element);
    const businessObject = getServiceTaskLikeBusinessObject(element);
    const commands = [];
    let updatedProperties = DELEGATE_PROPS;
    let extensionElements = businessObject.get("extensionElements");
    if (isDelegateType(value)) {
      updatedProperties = {
        ...updatedProperties,
        [value]: isDelegateType(oldType) ? businessObject.get(`camunda:${oldType}`) : ""
      };
    }
    if (isDmnCapable(businessObject)) {
      updatedProperties = {
        ...updatedProperties,
        ...DMN_CAPABLE_PROPS
      };
      if (value === "dmn") {
        updatedProperties = {
          ...updatedProperties,
          "camunda:decisionRef": ""
        };
      }
    }
    if (isExternalCapable(businessObject)) {
      updatedProperties = {
        ...updatedProperties,
        ...EXTERNAL_CAPABLE_PROPS
      };
      if (value === "external") {
        updatedProperties = {
          ...updatedProperties,
          "camunda:type": "external",
          "camunda:topic": ""
        };
      }
    }
    if (isServiceTaskLike(businessObject)) {
      const connectors = getConnectors$1(businessObject);
      if (connectors.length) {
        commands.push({
          cmd: "element.updateModdleProperties",
          context: {
            element,
            moddleElement: extensionElements,
            properties: {
              values: (0, import_min_dash147.without)(extensionElements.get("values"), (value2) => connectors.includes(value2))
            }
          }
        });
      }
      if (value === "connector") {
        if (!extensionElements) {
          extensionElements = createElement("bpmn:ExtensionElements", {
            values: []
          }, businessObject, bpmnFactory);
          commands.push(UpdateModdlePropertiesCommand(element, businessObject, {
            extensionElements
          }));
        }
        const connector = createElement("camunda:Connector", {}, extensionElements, bpmnFactory);
        commands.push({
          cmd: "element.updateModdleProperties",
          context: {
            element,
            moddleElement: extensionElements,
            properties: {
              values: [...extensionElements.get("values"), connector]
            }
          }
        });
      }
    }
    commands.push(UpdateModdlePropertiesCommand(element, businessObject, updatedProperties));
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  const getOptions = () => {
    const businessObject = getServiceTaskLikeBusinessObject(element);
    const options2 = [{
      value: "",
      label: translate3(IMPLEMENTATION_TYPE_NONE_LABEL)
    }, {
      value: "class",
      label: translate3(IMPLEMENTATION_TYPE_JAVA_LABEL)
    }, {
      value: "expression",
      label: translate3(IMPLEMENTATION_TYPE_EXPRESSION_LABEL)
    }, {
      value: "delegateExpression",
      label: translate3(IMPLEMENTATION_TYPE_DELEGATE_LABEL)
    }];
    if (isDmnCapable(businessObject)) {
      options2.push({
        value: "dmn",
        label: translate3(IMPLEMENTATION_TYPE_DMN_LABEL)
      });
    }
    if (isExternalCapable(businessObject)) {
      options2.push({
        value: "external",
        label: translate3(IMPLEMENTATION_TYPE_EXTERNAL_LABEL)
      });
    }
    if (isServiceTaskLike(businessObject)) {
      options2.push({
        value: "connector",
        label: translate3(IMPLEMENTATION_TYPE_CONNECTOR_LABEL)
      });
    }
    return sortByPriority(options2);
  };
  return SelectEntry({
    element,
    id: "implementationType",
    label: translate3("Type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function isDelegateType(type) {
  return ["class", "expression", "delegateExpression"].includes(type);
}
function getConnectors$1(businessObject) {
  return getExtensionElementsList(businessObject, "camunda:Connector");
}
function UpdateModdlePropertiesCommand(element, businessObject, newProperties) {
  return {
    cmd: "element.updateModdleProperties",
    context: {
      element,
      moddleElement: businessObject,
      properties: newProperties
    }
  };
}
function sortByPriority(options2) {
  const priorities = {
    [IMPLEMENTATION_TYPE_NONE_LABEL]: 0,
    [IMPLEMENTATION_TYPE_JAVA_LABEL]: 3,
    [IMPLEMENTATION_TYPE_EXPRESSION_LABEL]: 4,
    [IMPLEMENTATION_TYPE_DELEGATE_LABEL]: 5,
    [IMPLEMENTATION_TYPE_DMN_LABEL]: 1,
    [IMPLEMENTATION_TYPE_EXTERNAL_LABEL]: 2,
    [IMPLEMENTATION_TYPE_CONNECTOR_LABEL]: 6
  };
  return (0, import_min_dash147.sortBy)(options2, (o7) => priorities[o7.label]);
}
function ImplementationProps(props) {
  const {
    element
  } = props;
  if (!getServiceTaskLikeBusinessObject(element)) {
    return [];
  }
  const implementationType = getImplementationType(element);
  const entries = [...ImplementationTypeProps()];
  if (implementationType === "class") {
    entries.push({
      id: "javaClass",
      component: JavaClass,
      isEdited: isEdited$1
    });
  } else if (implementationType === "expression") {
    entries.push({
      id: "expression",
      component: Expression$1,
      isEdited: isEdited$1
    }, {
      id: "expressionResultVariable",
      component: ResultVariable$1,
      isEdited: isEdited$1
    });
  } else if (implementationType === "delegateExpression") {
    entries.push({
      id: "delegateExpression",
      component: DelegateExpression,
      isEdited: isEdited$1
    });
  } else if (implementationType === "dmn") {
    entries.push(...DmnImplementationProps({
      element
    }));
  } else if (implementationType === "external") {
    entries.push({
      id: "externalTopic",
      component: Topic,
      isEdited: isEdited$1
    });
  } else if (implementationType === "connector") {
    entries.push({
      id: "connectorId",
      component: ConnectorId,
      isEdited: isEdited$1
    });
  }
  return entries;
}
function JavaClass(props) {
  const {
    element,
    businessObject = getServiceTaskLikeBusinessObject(element),
    id = "javaClass"
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return businessObject.get("camunda:class");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:class": value || ""
      }
    });
  };
  return TextfieldEntry({
    element,
    id,
    label: translate3("Java class"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function Expression$1(props) {
  const {
    element,
    businessObject = getServiceTaskLikeBusinessObject(element),
    id = "expression"
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return businessObject.get("camunda:expression");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:expression": value || ""
      }
    });
  };
  return TextfieldEntry({
    element,
    id,
    label: translate3("Expression"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function ResultVariable$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const businessObject = getServiceTaskLikeBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:resultVariable");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:resultVariable": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "expressionResultVariable",
    label: translate3("Result variable"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function DelegateExpression(props) {
  const {
    element,
    businessObject = getServiceTaskLikeBusinessObject(element),
    id = "delegateExpression"
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const getValue2 = () => {
    return businessObject.get("camunda:delegateExpression");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:delegateExpression": value || ""
      }
    });
  };
  return TextfieldEntry({
    element,
    id,
    label: translate3("Delegate expression"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function Topic(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const businessObject = getServiceTaskLikeBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:topic");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:topic": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "externalTopic",
    label: translate3("Topic"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function ConnectorId(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const connector = getConnector(element);
  const getValue2 = () => {
    return connector.get("camunda:connectorId");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: connector,
      properties: {
        "camunda:connectorId": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "connectorId",
    label: translate3("Connector ID"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function getConnectors(businessObject) {
  return getExtensionElementsList(businessObject, "camunda:Connector");
}
function getConnector(element) {
  const businessObject = getServiceTaskLikeBusinessObject(element);
  const connectors = getConnectors(businessObject);
  return connectors[0];
}
function InitiatorProps(props) {
  const {
    element
  } = props;
  if (!isInitiator(element)) {
    return [];
  }
  return [{
    id: "initiator",
    component: Initiator,
    isEdited: isEdited$1
  }];
}
function Initiator(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:initiator");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:initiator": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "initiator",
    label: translate3("Initiator"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function isInitiator(element) {
  return is(element, "camunda:Initiator") && !is(element.parent, "bpmn:SubProcess");
}
function InMappingPropagationProps(props) {
  const {
    element
  } = props;
  if (!areInMappingsSupported$1(element)) {
    return [];
  }
  const entries = [{
    id: "inMapping-propagation",
    component: PropagateAll$1,
    isEdited: isEdited$7
  }];
  if (isPropagateAll$1(element)) {
    entries.push({
      id: "inMapping-propagation-local",
      component: Local$2,
      isEdited: isEdited$7
    });
  }
  return entries;
}
function PropagateAll$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate3 = useService("translate");
  const getValue2 = () => {
    return isPropagateAll$1(element);
  };
  const setValue = (value) => {
    if (value) {
      addInMapping();
    } else {
      removeInMapping();
    }
  };
  function addInMapping() {
    const businessObject = getSignalEventDefinition(element) || getBusinessObject(element);
    const mapping = createElement("camunda:In", {
      variables: "all"
    }, null, bpmnFactory);
    addExtensionElements(element, businessObject, mapping, bpmnFactory, commandStack);
  }
  function removeInMapping() {
    const businessObject = getSignalEventDefinition(element) || getBusinessObject(element);
    const mappings = findRelevantInMappings(element);
    removeExtensionElements(element, businessObject, mappings, commandStack);
  }
  return CheckboxEntry({
    id: "inMapping-propagation",
    label: translate3("Propagate all variables"),
    getValue: getValue2,
    setValue
  });
}
function Local$2(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const mapping = findRelevantInMappings(element)[0];
  const getValue2 = () => {
    return mapping.get("camunda:local");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: mapping,
      properties: {
        local: value
      }
    });
  };
  return CheckboxEntry({
    element,
    id: "inMapping-propagation-local",
    label: translate3("Local"),
    getValue: getValue2,
    setValue
  });
}
function areInMappingsSupported$1(element) {
  const signalEventDefinition = getSignalEventDefinition(element);
  if (signalEventDefinition) {
    return isAny(element, ["bpmn:IntermediateThrowEvent", "bpmn:EndEvent"]);
  }
  return is(element, "bpmn:CallActivity");
}
function getInMappings$1(element) {
  const businessObject = getBusinessObject(element);
  const signalEventDefinition = getSignalEventDefinition(businessObject);
  return getExtensionElementsList(signalEventDefinition || businessObject, "camunda:In");
}
function findRelevantInMappings(element) {
  const inMappings = getInMappings$1(element);
  return (0, import_min_dash147.filter)(inMappings, function(mapping) {
    const variables2 = mapping.get("variables");
    return variables2 && variables2 === "all";
  });
}
function isPropagateAll$1(element) {
  const mappings = findRelevantInMappings(element);
  return !!mappings.length;
}
var DEFAULT_PROPS$1 = {
  "source": void 0,
  "sourceExpression": void 0
};
function InOutMapping(props) {
  const {
    idPrefix,
    mapping
  } = props;
  const type = getInOutType(mapping);
  const entries = [];
  entries.push({
    id: idPrefix + "-type",
    component: Type,
    idPrefix,
    mapping
  });
  if (type === "source") {
    entries.push({
      id: idPrefix + "-source",
      component: Source,
      idPrefix,
      mapping
    });
  }
  if (type === "sourceExpression") {
    entries.push({
      id: idPrefix + "-sourceExpression",
      component: SourceExpression,
      idPrefix,
      mapping
    });
  }
  entries.push({
    id: idPrefix + "-target",
    component: Target,
    idPrefix,
    mapping
  });
  entries.push({
    id: idPrefix + "-local",
    component: Local$1,
    idPrefix,
    mapping
  });
  return entries;
}
function Type(props) {
  const {
    idPrefix,
    element,
    mapping
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const getValue2 = (mapping2) => {
    return getInOutType(mapping2);
  };
  const setValue = (value) => {
    const properties = {
      ...DEFAULT_PROPS$1,
      [value]: ""
    };
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: mapping,
      properties
    });
  };
  const getOptions = () => {
    const options2 = [{
      label: translate3("Source"),
      value: "source"
    }, {
      label: translate3("Source expression"),
      value: "sourceExpression"
    }];
    return options2;
  };
  return SelectEntry({
    element: mapping,
    id: idPrefix + "-type",
    label: translate3("Type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function Source(props) {
  const {
    idPrefix,
    element,
    mapping
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: mapping,
      properties: {
        source: value
      }
    });
  };
  const getValue2 = (mapping2) => {
    return mapping2.get("camunda:source");
  };
  return TextfieldEntry({
    element: mapping,
    id: idPrefix + "-source",
    label: translate3("Source"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function SourceExpression(props) {
  const {
    idPrefix,
    element,
    mapping
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: mapping,
      properties: {
        sourceExpression: value
      }
    });
  };
  const getValue2 = (mapping2) => {
    return mapping2.get("camunda:sourceExpression");
  };
  return TextfieldEntry({
    element: mapping,
    id: idPrefix + "-sourceExpression",
    label: translate3("Source expression"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function Target(props) {
  const {
    idPrefix,
    element,
    mapping
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: mapping,
      properties: {
        target: value
      }
    });
  };
  const getValue2 = (mapping2) => {
    return mapping2.get("camunda:target");
  };
  return TextfieldEntry({
    element: mapping,
    id: idPrefix + "-target",
    label: translate3("Target"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function Local$1(props) {
  const {
    idPrefix,
    element,
    mapping
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const getValue2 = () => {
    return mapping.get("camunda:local");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: mapping,
      properties: {
        local: value
      }
    });
  };
  return CheckboxEntry({
    element,
    id: idPrefix + "-local",
    label: translate3("Local"),
    getValue: getValue2,
    setValue
  });
}
function getInOutType(mapping) {
  let inOutType = "";
  if (typeof mapping.source !== "undefined") {
    inOutType = "source";
  } else if (typeof mapping.sourceExpression !== "undefined") {
    inOutType = "sourceExpression";
  }
  return inOutType;
}
function InMappingProps({
  element,
  injector
}) {
  if (!areInMappingsSupported(element)) {
    return null;
  }
  const variableMappings = getInMappings(element) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = variableMappings.map((mapping, index2) => {
    const id = element.id + "-inMapping-" + index2;
    return {
      id,
      label: mapping.get("target") || "",
      entries: InOutMapping({
        idPrefix: id,
        element,
        mapping
      }),
      autoFocusEntry: id + "-target",
      remove: removeFactory$3({
        commandStack,
        element,
        mapping
      })
    };
  });
  return {
    items,
    add: addFactory$2({
      bpmnFactory,
      commandStack,
      element
    })
  };
}
function removeFactory$3({
  commandStack,
  element,
  mapping
}) {
  return function(event2) {
    event2.stopPropagation();
    const businessObject = getSignalEventDefinition(element) || getBusinessObject(element);
    removeExtensionElements(element, businessObject, mapping, commandStack);
  };
}
function addFactory$2({
  bpmnFactory,
  commandStack,
  element
}) {
  return function(event2) {
    event2.stopPropagation();
    const businessObject = getSignalEventDefinition(element) || getBusinessObject(element);
    const newMapping = createElement("camunda:In", {
      source: ""
    }, null, bpmnFactory);
    addExtensionElements(element, businessObject, newMapping, bpmnFactory, commandStack);
  };
}
function getInMappings(element) {
  const businessObject = getBusinessObject(element);
  const signalEventDefinition = getSignalEventDefinition(businessObject);
  const mappings = getExtensionElementsList(signalEventDefinition || businessObject, "camunda:In");
  return (0, import_min_dash147.filter)(mappings, function(mapping) {
    return !mapping.businessKey && !(mapping.variables && mapping.variables === "all");
  });
}
function areInMappingsSupported(element) {
  const signalEventDefinition = getSignalEventDefinition(element);
  if (signalEventDefinition) {
    return isAny(element, ["bpmn:IntermediateThrowEvent", "bpmn:EndEvent"]);
  }
  return is(element, "bpmn:CallActivity");
}
function InputProps(props) {
  const {
    element,
    injector
  } = props;
  if (!areInputParametersSupported(element)) {
    return null;
  }
  const inputParameters = getInputParameters(element) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = inputParameters.map((parameter, index2) => {
    const id = element.id + "-inputParameter-" + index2;
    return {
      id,
      label: parameter.get("name") || "",
      entries: InputOutputParameter({
        idPrefix: id,
        element,
        parameter
      }),
      autoFocusEntry: id + "-name",
      remove: removeFactory$2({
        element,
        commandStack,
        parameter
      })
    };
  });
  function add3(event2) {
    event2.stopPropagation();
    commandStack.execute("properties-panel.multi-command-executor", AddParameterCmd(element, "camunda:InputParameter", bpmnFactory));
  }
  return {
    items,
    add: add3
  };
}
function removeFactory$2(props) {
  const {
    commandStack,
    element,
    parameter
  } = props;
  return function(event2) {
    event2.stopPropagation();
    const inputOutput = getInputOutput(element);
    if (!inputOutput) {
      return;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: inputOutput,
      properties: {
        inputParameters: (0, import_min_dash147.without)(inputOutput.get("inputParameters"), parameter)
      }
    });
  };
}
function JobExecutionProps(props) {
  const {
    element
  } = props;
  const businessObject = getBusinessObject(element);
  const entries = [];
  if (is(element, "camunda:AsyncCapable") && isAsync$1(businessObject) || isTimerEvent(element)) {
    entries.push({
      id: "retryTimeCycle",
      component: RetryTimeCycle,
      isEdited: isEdited$1
    });
  }
  if (is(element, "camunda:JobPriorized") && isAsync$1(businessObject) || is(element, "bpmn:Process") || is(element, "bpmn:Participant") && businessObject.get("processRef") || isTimerEvent(element)) {
    entries.push({
      id: "jobPriority",
      component: JobPriority,
      isEdited: isEdited$1
    });
  }
  return entries;
}
function JobPriority(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), translate3 = useService("translate"), debounce4 = useService("debounceInput");
  const businessObject = is(element, "bpmn:Participant") ? getBusinessObject(element).get("processRef") : getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:jobPriority");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:jobPriority": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "jobPriority",
    label: translate3("Priority"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function RetryTimeCycle(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack"), translate3 = useService("translate"), debounce4 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    const failedJobRetryTimeCycle = getExtensionElementsList(businessObject, "camunda:FailedJobRetryTimeCycle")[0];
    return failedJobRetryTimeCycle && failedJobRetryTimeCycle.body;
  };
  const setValue = (value) => {
    const commands = [];
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let failedJobRetryTimeCycle = getExtensionElementsList(businessObject, "camunda:FailedJobRetryTimeCycle")[0];
    if (!failedJobRetryTimeCycle) {
      failedJobRetryTimeCycle = createElement("camunda:FailedJobRetryTimeCycle", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), failedJobRetryTimeCycle]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: failedJobRetryTimeCycle,
        properties: {
          body: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return TextfieldEntry({
    element,
    id: "retryTimeCycle",
    label: translate3("Retry time cycle"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function isAsyncBefore$1(bo) {
  return !!(bo.get("camunda:asyncBefore") || bo.get("camunda:async"));
}
function isAsyncAfter$1(bo) {
  return !!bo.get("camunda:asyncAfter");
}
function isAsync$1(bo) {
  return isAsyncAfter$1(bo) || isAsyncBefore$1(bo);
}
function isTimerEvent(element) {
  return is(element, "bpmn:Event") && getTimerEventDefinition$1(element);
}
function MultiInstanceProps(props) {
  const {
    element
  } = props;
  const loopCharacteristics = getLoopCharacteristics(element);
  let entries = props.entries || [];
  if (!isMultiInstanceSupported(element)) {
    return entries;
  }
  entries.push({
    id: "collection",
    component: Collection,
    isEdited: isEdited$1
  }, {
    id: "elementVariable",
    component: ElementVariable,
    isEdited: isEdited$1
  }, {
    id: "multiInstanceAsynchronousBefore",
    component: MultiInstanceAsynchronousBefore,
    isEdited: isEdited$7
  }, {
    id: "multiInstanceAsynchronousAfter",
    component: MultiInstanceAsynchronousAfter,
    isEdited: isEdited$7
  });
  if (isAsync(loopCharacteristics)) {
    entries.push({
      id: "multiInstanceExclusive",
      component: MultiInstanceExclusive,
      isEdited: checkboxIsEditedInverted
    }, {
      id: "multiInstanceRetryTimeCycle",
      component: MultiInstanceRetryTimeCycle,
      isEdited: isEdited$1
    });
  }
  return entries;
}
function Collection(props) {
  const {
    element
  } = props;
  const debounce4 = useService("debounceInput");
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const loopCharacteristics = getLoopCharacteristics(element);
  const getValue2 = () => {
    return getCollection(element);
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: loopCharacteristics,
      properties: {
        "camunda:collection": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "collection",
    label: translate3("Collection"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function ElementVariable(props) {
  const {
    element
  } = props;
  const debounce4 = useService("debounceInput");
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const loopCharacteristics = getLoopCharacteristics(element);
  const getValue2 = () => {
    return getElementVariable(element);
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: loopCharacteristics,
      properties: {
        "camunda:elementVariable": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "elementVariable",
    label: translate3("Element variable"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function MultiInstanceAsynchronousBefore(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const loopCharacteristics = getLoopCharacteristics(element);
  const getValue2 = () => {
    return isAsyncBefore(loopCharacteristics);
  };
  const setValue = (value) => {
    const properties = {
      "camunda:asyncBefore": value,
      "camunda:async": void 0
    };
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: loopCharacteristics,
      properties
    });
  };
  return CheckboxEntry({
    element,
    id: "multiInstanceAsynchronousBefore",
    label: translate3("Asynchronous before"),
    getValue: getValue2,
    setValue
  });
}
function MultiInstanceAsynchronousAfter(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const loopCharacteristics = getLoopCharacteristics(element);
  const getValue2 = () => {
    return isAsyncAfter(loopCharacteristics);
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: loopCharacteristics,
      properties: {
        "camunda:asyncAfter": value
      }
    });
  };
  return CheckboxEntry({
    element,
    id: "multiInstanceAsynchronousAfter",
    label: translate3("Asynchronous after"),
    getValue: getValue2,
    setValue
  });
}
function MultiInstanceExclusive(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), translate3 = useService("translate");
  const loopCharacteristics = getLoopCharacteristics(element);
  const getValue2 = () => {
    return isExclusive(loopCharacteristics);
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: loopCharacteristics,
      properties: {
        "camunda:exclusive": value
      }
    });
  };
  return CheckboxEntry({
    element,
    id: "multiInstanceExclusive",
    label: translate3("Exclusive"),
    getValue: getValue2,
    setValue
  });
}
function MultiInstanceRetryTimeCycle(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack"), translate3 = useService("translate"), debounce4 = useService("debounceInput");
  const loopCharacteristics = getLoopCharacteristics(element);
  const getValue2 = () => {
    const failedJobRetryTimeCycle = getExtensionElementsList(loopCharacteristics, "camunda:FailedJobRetryTimeCycle")[0];
    return failedJobRetryTimeCycle && failedJobRetryTimeCycle.body;
  };
  const setValue = (value) => {
    const commands = [];
    let extensionElements = loopCharacteristics.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, loopCharacteristics, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: loopCharacteristics,
          properties: {
            extensionElements
          }
        }
      });
    }
    let failedJobRetryTimeCycle = getExtensionElementsList(loopCharacteristics, "camunda:FailedJobRetryTimeCycle")[0];
    if (!failedJobRetryTimeCycle) {
      failedJobRetryTimeCycle = createElement("camunda:FailedJobRetryTimeCycle", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element: loopCharacteristics,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), failedJobRetryTimeCycle]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: failedJobRetryTimeCycle,
        properties: {
          body: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return TextfieldEntry({
    element,
    id: "multiInstanceRetryTimeCycle",
    label: translate3("Retry time cycle"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function isMultiInstanceSupported(element) {
  const loopCharacteristics = getLoopCharacteristics(element);
  return !!loopCharacteristics && is(loopCharacteristics, "camunda:Collectable");
}
function getProperty(element, propertyName) {
  var loopCharacteristics = getLoopCharacteristics(element);
  return loopCharacteristics && loopCharacteristics.get(propertyName);
}
function getLoopCharacteristics(element) {
  const bo = getBusinessObject(element);
  return bo.loopCharacteristics;
}
function getCollection(element) {
  return getProperty(element, "camunda:collection");
}
function getElementVariable(element) {
  return getProperty(element, "camunda:elementVariable");
}
function isAsyncBefore(bo) {
  return !!(bo.get("camunda:asyncBefore") || bo.get("camunda:async"));
}
function isAsyncAfter(bo) {
  return !!bo.get("camunda:asyncAfter");
}
function isExclusive(bo) {
  return !!bo.get("camunda:exclusive");
}
function isAsync(bo) {
  return isAsyncAfter(bo) || isAsyncBefore(bo);
}
function checkboxIsEditedInverted(node2) {
  return node2 && !node2.checked;
}
function OutMappingPropagationProps(props) {
  const {
    element
  } = props;
  if (!areOutMappingsSupported$1(element)) {
    return [];
  }
  const entries = [{
    id: "outMapping-propagation",
    component: PropagateAll,
    isEdited: isEdited$7
  }];
  if (isPropagateAll(element)) {
    entries.push({
      id: "outMapping-propagation-local",
      component: Local,
      isEdited: isEdited$7
    });
  }
  return entries;
}
function PropagateAll(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate3 = useService("translate");
  const getValue2 = () => {
    return isPropagateAll(element);
  };
  const setValue = (value) => {
    if (value) {
      addOutMapping();
    } else {
      removeOutMapping();
    }
  };
  function addOutMapping() {
    const businessObject = getBusinessObject(element);
    const mapping = createElement("camunda:Out", {
      variables: "all"
    }, null, bpmnFactory);
    addExtensionElements(element, businessObject, mapping, bpmnFactory, commandStack);
  }
  function removeOutMapping() {
    const businessObject = getBusinessObject(element);
    const mappings = findRelevantOutMappings(element);
    removeExtensionElements(element, businessObject, mappings, commandStack);
  }
  return CheckboxEntry({
    id: "outMapping-propagation",
    label: translate3("Propagate all variables"),
    getValue: getValue2,
    setValue
  });
}
function Local(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const mapping = findRelevantOutMappings(element)[0];
  const getValue2 = () => {
    return mapping.get("camunda:local");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: mapping,
      properties: {
        local: value
      }
    });
  };
  return CheckboxEntry({
    element,
    id: "outMapping-propagation-local",
    label: translate3("Local"),
    getValue: getValue2,
    setValue
  });
}
function areOutMappingsSupported$1(element) {
  return is(element, "bpmn:CallActivity");
}
function getOutMappings$1(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "camunda:Out");
}
function findRelevantOutMappings(element) {
  const inMappings = getOutMappings$1(element);
  return (0, import_min_dash147.filter)(inMappings, function(mapping) {
    const variables2 = mapping.get("variables");
    return variables2 && variables2 === "all";
  });
}
function isPropagateAll(element) {
  const mappings = findRelevantOutMappings(element);
  return !!mappings.length;
}
function OutMappingProps({
  element,
  injector
}) {
  if (!areOutMappingsSupported(element)) {
    return null;
  }
  const variableMappings = getOutMappings(element) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = variableMappings.map((mapping, index2) => {
    const id = element.id + "-outMapping-" + index2;
    return {
      id,
      label: mapping.get("target") || "",
      entries: InOutMapping({
        idPrefix: id,
        element,
        mapping
      }),
      autoFocusEntry: id + "-target",
      remove: removeFactory$1({
        commandStack,
        element,
        mapping
      })
    };
  });
  return {
    items,
    add: addFactory$1({
      bpmnFactory,
      commandStack,
      element
    })
  };
}
function removeFactory$1({
  commandStack,
  element,
  mapping
}) {
  return function(event2) {
    event2.stopPropagation();
    const businessObject = getBusinessObject(element);
    removeExtensionElements(element, businessObject, mapping, commandStack);
  };
}
function addFactory$1({
  bpmnFactory,
  commandStack,
  element
}) {
  return function(event2) {
    event2.stopPropagation();
    const businessObject = getBusinessObject(element);
    const newMapping = createElement("camunda:Out", {
      source: ""
    }, null, bpmnFactory);
    addExtensionElements(element, businessObject, newMapping, bpmnFactory, commandStack);
  };
}
function getOutMappings(element) {
  const businessObject = getBusinessObject(element);
  const mappings = getExtensionElementsList(businessObject, "camunda:Out");
  return (0, import_min_dash147.filter)(mappings, function(mapping) {
    return !mapping.businessKey && !(mapping.variables && mapping.variables === "all");
  });
}
function areOutMappingsSupported(element) {
  return is(element, "bpmn:CallActivity");
}
function OutputProps({
  element,
  injector
}) {
  if (!areOutputParametersSupported(element)) {
    return null;
  }
  const outputParameters = getOutputParameters(element) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = outputParameters.map((parameter, index2) => {
    const id = element.id + "-outputParameter-" + index2;
    return {
      id,
      label: parameter.get("name") || "",
      entries: InputOutputParameter({
        idPrefix: id,
        element,
        parameter
      }),
      autoFocusEntry: id + "-name",
      remove: removeFactory({
        commandStack,
        element,
        parameter
      })
    };
  });
  return {
    items,
    add: addFactory({
      bpmnFactory,
      commandStack,
      element
    })
  };
}
function removeFactory({
  commandStack,
  element,
  parameter
}) {
  return function(event2) {
    event2.stopPropagation();
    const inputOutput = getInputOutput(element);
    if (!inputOutput) {
      return;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: inputOutput,
      properties: {
        outputParameters: (0, import_min_dash147.without)(inputOutput.get("outputParameters"), parameter)
      }
    });
  };
}
function addFactory({
  bpmnFactory,
  commandStack,
  element
}) {
  return function(event2) {
    event2.stopPropagation();
    commandStack.execute("properties-panel.multi-command-executor", AddParameterCmd(element, "camunda:OutputParameter", bpmnFactory));
  };
}
var LISTENER_ALLOWED_TYPES = ["bpmn:Activity", "bpmn:Event", "bpmn:Gateway", "bpmn:SequenceFlow", "bpmn:Process", "bpmn:Participant"];
var SCRIPT_PROPS = {
  "script": void 0,
  "resource": void 0,
  "scriptFormat": void 0
};
var CLASS_PROPS = {
  "class": void 0
};
var EXPRESSION_PROPS = {
  "expression": void 0
};
var DELEGATE_EXPRESSION_PROPS = {
  "delegateExpression": void 0
};
var DEFAULT_PROPS = {
  ...SCRIPT_PROPS,
  ...CLASS_PROPS,
  ...EXPRESSION_PROPS,
  ...DELEGATE_EXPRESSION_PROPS
};
var DEFAULT_EVENT_PROPS = {
  "eventDefinitions": void 0,
  "event": void 0
};
var IMPLEMENTATION_TYPE_TO_LABEL = {
  class: "Java class",
  expression: "Expression",
  delegateExpression: "Delegate expression",
  script: "Script"
};
var EVENT_TO_LABEL = {
  start: "Start",
  end: "End",
  take: "Take",
  create: "Create",
  assignment: "Assignment",
  complete: "Complete",
  delete: "Delete",
  update: "Update",
  timeout: "Timeout"
};
function ExecutionListenerProps({
  element,
  injector
}) {
  if (!isAny(element, LISTENER_ALLOWED_TYPES)) {
    return;
  }
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  if (is(element, "bpmn:Participant") && !element.businessObject.processRef) {
    return;
  }
  const businessObject = getListenersContainer(element);
  const listeners = getExtensionElementsList(businessObject, "camunda:ExecutionListener");
  return {
    items: listeners.map((listener, index2) => {
      const id = `${element.id}-executionListener-${index2}`;
      return {
        id,
        label: getListenerLabel(listener),
        entries: ExecutionListener({
          idPrefix: id,
          element,
          listener
        }),
        remove: removeListenerFactory({
          element,
          listener,
          commandStack
        })
      };
    }),
    add: addExecutionListenerFactory({
      bpmnFactory,
      commandStack,
      element
    })
  };
}
function ExecutionListener(props) {
  const {
    idPrefix,
    element,
    listener
  } = props;
  return [{
    id: `${idPrefix}-eventType`,
    component: EventType,
    listener
  }, {
    id: `${idPrefix}-listenerType`,
    component: ListenerType,
    listener
  }, ...ImplementationDetails({
    idPrefix,
    element,
    listener
  }), {
    id: `${idPrefix}-fields`,
    component: Fields,
    listener
  }];
}
function TaskListenerProps({
  element,
  injector
}) {
  if (!is(element, "bpmn:UserTask")) {
    return;
  }
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const businessObject = getListenersContainer(element);
  const listeners = getExtensionElementsList(businessObject, "camunda:TaskListener");
  return {
    items: listeners.map((listener, index2) => {
      const id = `${element.id}-taskListener-${index2}`;
      return {
        id,
        label: getListenerLabel(listener),
        entries: TaskListener({
          idPrefix: id,
          element,
          listener
        }),
        remove: removeListenerFactory({
          element,
          listener,
          commandStack
        })
      };
    }),
    add: addTaskListenerFactory({
      bpmnFactory,
      commandStack,
      element
    })
  };
}
function TaskListener(props) {
  const {
    idPrefix,
    element,
    listener
  } = props;
  return [{
    id: `${idPrefix}-eventType`,
    component: EventType,
    listener
  }, {
    id: `${idPrefix}-listenerId`,
    component: ListenerId,
    listener
  }, {
    id: `${idPrefix}-listenerType`,
    component: ListenerType,
    listener
  }, ...ImplementationDetails({
    idPrefix,
    element,
    listener
  }), ...EventTypeDetails({
    idPrefix,
    element,
    listener
  }), {
    id: `${idPrefix}-fields`,
    component: Fields,
    listener
  }];
}
function removeListenerFactory({
  element,
  listener,
  commandStack
}) {
  return function removeListener(event2) {
    event2.stopPropagation();
    removeExtensionElements(element, getListenersContainer(element), listener, commandStack);
  };
}
function EventType({
  id,
  element,
  listener
}) {
  const translate3 = useService("translate");
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  function getValue2() {
    return listener.get("event");
  }
  function setValue(value) {
    const properties = getDefaultEventTypeProperties(value, bpmnFactory);
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: listener,
      properties
    });
  }
  function getOptions() {
    if (is(listener, "camunda:TaskListener")) {
      return [{
        value: "create",
        label: translate3("create")
      }, {
        value: "assignment",
        label: translate3("assignment")
      }, {
        value: "complete",
        label: translate3("complete")
      }, {
        value: "delete",
        label: translate3("delete")
      }, {
        value: "update",
        label: translate3("update")
      }, {
        value: "timeout",
        label: translate3("timeout")
      }];
    }
    if (is(element, "bpmn:SequenceFlow")) {
      return [{
        value: "take",
        label: translate3("take")
      }];
    }
    return [{
      value: "start",
      label: translate3("start")
    }, {
      value: "end",
      label: translate3("end")
    }];
  }
  return o5(SelectEntry, {
    id,
    label: translate3("Event type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function ListenerId({
  id,
  element,
  listener
}) {
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const commandStack = useService("commandStack");
  let options2 = {
    element,
    id,
    label: translate3("Listener ID"),
    debounce: debounce4,
    isEdited: isEdited$1,
    setValue: (value) => {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: listener,
        properties: {
          "camunda:id": value
        }
      });
    },
    getValue: () => {
      return listener.get("camunda:id");
    }
  };
  return TextfieldEntry(options2);
}
function ListenerType({
  id,
  element,
  listener
}) {
  const modeling = useService("modeling");
  const translate3 = useService("translate");
  const bpmnFactory = useService("bpmnFactory");
  function getValue2() {
    return getListenerType(listener);
  }
  function setValue(value) {
    const properties = getDefaultImplementationProperties(value, bpmnFactory);
    modeling.updateModdleProperties(element, listener, properties);
  }
  function getOptions() {
    return getListenerTypeOptions(translate3);
  }
  return o5(SelectEntry, {
    id,
    label: translate3("Listener type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function ImplementationDetails(props) {
  const {
    idPrefix,
    element,
    listener
  } = props;
  const type = getListenerType(listener);
  if (type === "class") {
    return [{
      id: getPrefixedId(idPrefix, "javaClass"),
      component: JavaClass,
      businessObject: listener
    }];
  } else if (type === "expression") {
    return [{
      id: getPrefixedId(idPrefix, "expression"),
      component: Expression$1,
      businessObject: listener
    }];
  } else if (type === "delegateExpression") {
    return [{
      id: getPrefixedId(idPrefix, "delegateExpression"),
      component: DelegateExpression,
      businessObject: listener
    }];
  } else if (type === "script") {
    return ScriptProps({
      element,
      script: listener.get("script"),
      prefix: idPrefix
    });
  }
  return [];
}
function EventTypeDetails(props) {
  const {
    idPrefix,
    element,
    listener
  } = props;
  const type = listener.get("event");
  if (type === "timeout") {
    return TimerProps$2({
      element,
      listener,
      timerEventDefinition: getTimerEventDefinition$1(listener),
      idPrefix
    });
  }
  return [];
}
function Field(props) {
  const {
    element,
    id: idPrefix,
    index: index2,
    item: field,
    open: open3
  } = props;
  const fieldId = `${idPrefix}-field-${index2}`;
  return o5(CollapsibleEntry, {
    id: fieldId,
    element,
    entries: FieldInjection({
      element,
      field,
      idPrefix: fieldId
    }),
    label: field.get("name") || "<empty>",
    open: open3
  });
}
function Fields(props) {
  const {
    id,
    element,
    listener
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const fields = listener.get("fields");
  function addField() {
    const field = createElement("camunda:Field", {}, listener, bpmnFactory);
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: listener,
      properties: {
        fields: [...listener.get("fields"), field]
      }
    });
  }
  function removeField(field) {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: listener,
      properties: {
        fields: (0, import_min_dash147.without)(listener.get("fields"), field)
      }
    });
  }
  return o5(List, {
    id,
    element,
    label: translate3("Field injection"),
    items: fields,
    component: Field,
    onAdd: addField,
    onRemove: removeField,
    compareFn: compareName,
    autoFocusEntry: true
  });
}
function addListenerFactory({
  bpmnFactory,
  commandStack,
  element,
  listenerGroup
}) {
  return function(event2) {
    event2.stopPropagation();
    const listener = bpmnFactory.create(listenerGroup, {
      event: getDefaultEvent(element, listenerGroup),
      class: ""
    });
    const businessObject = getListenersContainer(element);
    addExtensionElements(element, businessObject, listener, bpmnFactory, commandStack);
  };
}
function addTaskListenerFactory(props) {
  return addListenerFactory({
    ...props,
    listenerGroup: "camunda:TaskListener"
  });
}
function addExecutionListenerFactory(props) {
  return addListenerFactory({
    ...props,
    listenerGroup: "camunda:ExecutionListener"
  });
}
function getListenerLabel(listener, translate3 = (value) => value) {
  const event2 = listener.get("event");
  const implementationType = getListenerType(listener);
  return `${translate3(EVENT_TO_LABEL[event2])}: ${translate3(IMPLEMENTATION_TYPE_TO_LABEL[implementationType])}`;
}
function getListenerTypeOptions(translate3) {
  return Object.entries(IMPLEMENTATION_TYPE_TO_LABEL).map(([value, label]) => ({
    value,
    label: translate3(label)
  }));
}
function getListenerType(listener) {
  return getImplementationType(listener);
}
function getDefaultEvent(element, listenerGroup) {
  if (listenerGroup === "camunda:TaskListener")
    return "create";
  return is(element, "bpmn:SequenceFlow") ? "take" : "start";
}
function getDefaultImplementationProperties(type, bpmnFactory) {
  switch (type) {
    case "class":
      return {
        ...DEFAULT_PROPS,
        "class": ""
      };
    case "expression":
      return {
        ...DEFAULT_PROPS,
        "expression": ""
      };
    case "delegateExpression":
      return {
        ...DEFAULT_PROPS,
        "delegateExpression": ""
      };
    case "script":
      return {
        ...DEFAULT_PROPS,
        "script": bpmnFactory.create("camunda:Script")
      };
  }
}
function getDefaultEventTypeProperties(type, bpmnFactory) {
  switch (type) {
    case "timeout":
      return {
        ...DEFAULT_EVENT_PROPS,
        eventDefinitions: [bpmnFactory.create("bpmn:TimerEventDefinition")],
        event: type
      };
    default:
      return {
        ...DEFAULT_EVENT_PROPS,
        event: type
      };
  }
}
function getPrefixedId(prefix3, id) {
  return `${prefix3}-${id}`;
}
function compareName(field, anotherField) {
  const [name3 = "", anotherName = ""] = [field.name, anotherField.name];
  return name3 === anotherName ? 0 : name3 > anotherName ? 1 : -1;
}
function getListenersContainer(element) {
  const businessObject = getBusinessObject(element);
  return businessObject.get("processRef") || businessObject;
}
function ProcessVariablesProps(props) {
  const {
    element
  } = props;
  if (!canHaveProcessVariables(element)) {
    return null;
  }
  const businessObject = getBusinessObject(element);
  const rootElement = getRootElement2(businessObject);
  const scope = getScope(element);
  const variables2 = (0, import_extract_process_variables.getVariablesForScope)(scope, rootElement);
  if (!variables2.length) {
    return null;
  }
  const withNames = populateElementNames(sortByName(variables2));
  const byScope = groupByScope(withNames);
  const multiScope = isMultiScope(byScope);
  let variableItems = [];
  if (multiScope) {
    const reversed = (0, import_min_dash147.map)(reverse((0, import_min_dash147.keys)(byScope)), (scopeKey) => byScope[scopeKey]);
    variableItems = (0, import_min_dash147.flatten)(reversed);
  } else {
    variableItems = withNames;
  }
  const items = variableItems.map((variable, index2) => {
    const id = element.id + "-variable-" + index2;
    return {
      id,
      label: variable.name,
      entries: [...ProcessVariableItem({
        idPrefix: id,
        multiScope,
        variable
      })]
    };
  });
  return {
    items,
    shouldSort: false
  };
}
function ProcessVariableItem(props) {
  const {
    idPrefix,
    multiScope,
    variable
  } = props;
  let entries = [];
  if (multiScope) {
    entries.push({
      id: idPrefix + "-scope",
      component: Scope,
      idPrefix,
      variable
    });
  }
  entries.push({
    id: idPrefix + "-createdIn",
    component: CreatedIn,
    idPrefix,
    variable
  });
  return entries;
}
function Scope(props) {
  const {
    idPrefix,
    variable
  } = props;
  const translate3 = useService("translate");
  const id = idPrefix + "-scope";
  return o5("div", {
    "data-entry-id": id,
    class: "bio-properties-panel-entry",
    children: [o5("b", {
      style: "font-weight: bold",
      class: "bio-properties-panel-label",
      children: translate3("Scope")
    }), o5("label", {
      id: prefixId2(id),
      class: "bio-properties-panel-label",
      children: variable.scope
    })]
  });
}
function CreatedIn(props) {
  const {
    idPrefix,
    variable
  } = props;
  const translate3 = useService("translate");
  const id = idPrefix + "-createdIn";
  const origin = variable.origin.join(", ");
  return o5("div", {
    "data-entry-id": id,
    class: "bio-properties-panel-entry",
    children: [o5("b", {
      style: "font-weight: bold",
      class: "bio-properties-panel-label",
      children: translate3("Created in")
    }), o5("label", {
      id: prefixId2(id),
      class: "bio-properties-panel-label",
      children: origin
    })]
  });
}
function canHaveProcessVariables(element) {
  const businessObject = getBusinessObject(element);
  return isAny(element, ["bpmn:Process", "bpmn:SubProcess"]) || is(element, "bpmn:Participant") && businessObject.get("processRef");
}
function getRootElement2(element) {
  const businessObject = getBusinessObject(element);
  if (is(businessObject, "bpmn:Participant")) {
    return businessObject.processRef;
  }
  if (is(businessObject, "bpmn:Process")) {
    return businessObject;
  }
  let parent = businessObject;
  while (parent.$parent && !is(parent, "bpmn:Process")) {
    parent = parent.$parent;
  }
  return parent;
}
function getScope(element) {
  const bo = getBusinessObject(element);
  if (is(element, "bpmn:Participant")) {
    return bo.processRef.id;
  }
  return bo.id;
}
function sortByName(variables2) {
  return (0, import_min_dash147.sortBy)(variables2, function(variable) {
    return variable.name;
  });
}
function groupByScope(variables2) {
  return (0, import_min_dash147.groupBy)(variables2, "scope");
}
function populateElementNames(variables2) {
  (0, import_min_dash147.forEach)(variables2, function(variable) {
    const names = (0, import_min_dash147.map)(variable.origin, function(element) {
      return element.name || element.id;
    });
    variable.origin = names;
    variable.scope = variable.scope.name || variable.scope.id;
  });
  return variables2;
}
function isMultiScope(scopedVariables) {
  return (0, import_min_dash147.keys)(scopedVariables).length > 1;
}
function reverse(array) {
  return (0, import_min_dash147.map)(array, function(a6, i6) {
    return array[array.length - 1 - i6];
  });
}
function prefixId2(id) {
  return `bio-properties-panel-${id}`;
}
function ScriptTaskProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:ScriptTask")) {
    return [];
  }
  const entries = [...ScriptProps({
    element
  })];
  entries.push({
    id: "scriptResultVariable",
    component: ResultVariable,
    isEdited: isEdited$1
  });
  return entries;
}
function ResultVariable(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:resultVariable");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:resultVariable": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "scriptResultVariable",
    label: translate3("Result variable"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function TasklistProps(props) {
  const {
    element
  } = props;
  const businessObject = getBusinessObject(element);
  const isEdited2 = (node2) => {
    return node2 && !node2.checked;
  };
  if (!is(element, "bpmn:Process") && !(is(element, "bpmn:Participant") && businessObject.get("processRef"))) {
    return [];
  }
  return [{
    id: "isStartableInTasklist",
    component: Startable,
    isEdited: isEdited2
  }];
}
function Startable(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const process2 = getProcess$1(element);
  const getValue2 = () => {
    return process2.get("camunda:isStartableInTasklist");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: process2,
      properties: {
        "camunda:isStartableInTasklist": value
      }
    });
  };
  return CheckboxEntry({
    element,
    id: "isStartableInTasklist",
    label: translate3("Startable"),
    getValue: getValue2,
    setValue
  });
}
function getProcess$1(element) {
  return is(element, "bpmn:Process") ? getBusinessObject(element) : getBusinessObject(element).get("processRef");
}
function UserAssignmentProps(props) {
  const {
    element
  } = props;
  if (!is(element, "camunda:Assignable")) {
    return [];
  }
  return [{
    id: "assignee",
    component: Assignee,
    isEdited: isEdited$1
  }, {
    id: "candidateGroups",
    component: CandidateGroups,
    isEdited: isEdited$1
  }, {
    id: "candidateUsers",
    component: CandidateUsers,
    isEdited: isEdited$1
  }, {
    id: "dueDate",
    component: DueDate,
    isEdited: isEdited$1
  }, {
    id: "followUpDate",
    component: FollowUpDate,
    isEdited: isEdited$1
  }, {
    id: "priority",
    component: Priority,
    isEdited: isEdited$1
  }];
}
function Assignee(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:assignee");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:assignee": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "assignee",
    label: translate3("Assignee"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function CandidateUsers(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:candidateUsers");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:candidateUsers": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "candidateUsers",
    label: translate3("Candidate users"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function CandidateGroups(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:candidateGroups");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:candidateGroups": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "candidateGroups",
    label: translate3("Candidate groups"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function DueDate(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:dueDate");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:dueDate": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "dueDate",
    label: translate3("Due date"),
    description: translate3("The due date as an EL expression (e.g. ${someDate}) or an ISO date (e.g. 2015-06-26T09:54:00)."),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function FollowUpDate(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:followUpDate");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:followUpDate": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "followUpDate",
    label: translate3("Follow up date"),
    description: translate3("The follow up date as an EL expression (e.g. ${someDate}) or an ISO date (e.g. 2015-06-26T09:54:00)."),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function Priority(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:priority");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:priority": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "priority",
    label: translate3("Priority"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function VersionTagProps(props) {
  const {
    element
  } = props;
  const businessObject = getBusinessObject(element);
  if (!is(element, "bpmn:Process") && !(is(element, "bpmn:Participant") && businessObject.get("processRef"))) {
    return [];
  }
  return [{
    id: "versionTag",
    component: VersionTag,
    isEdited: isEdited$1
  }];
}
function VersionTag(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const process2 = getProcess(element);
  const getValue2 = () => {
    return process2.get("camunda:versionTag") || "";
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: process2,
      properties: {
        "camunda:versionTag": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "versionTag",
    label: translate3("Version tag"),
    getValue: getValue2,
    setValue,
    debounce: debounce4
  });
}
function getProcess(element) {
  return is(element, "bpmn:Process") ? getBusinessObject(element) : getBusinessObject(element).get("processRef");
}
function TimerProps(props) {
  const {
    element,
    listener,
    idPrefix
  } = props;
  let {
    timerEventDefinition
  } = props;
  if (!timerEventDefinition) {
    const businessObject = getBusinessObject(element);
    timerEventDefinition = getTimerEventDefinition(businessObject);
  }
  const timerEventDefinitionType = getTimerDefinitionType(timerEventDefinition);
  if (!isTimerSupported(element) && !isTimerSupportedOnListener(listener)) {
    return [];
  }
  const entries = [];
  entries.push({
    id: getId(idPrefix, "timerEventDefinitionType"),
    component: TimerEventDefinitionType,
    isEdited: isEdited$4,
    timerEventDefinition,
    timerEventDefinitionType
  });
  if (timerEventDefinitionType) {
    entries.push({
      id: getId(idPrefix, "timerEventDefinitionValue"),
      component: TimerEventDefinitionValue,
      isEdited: isEdited$1,
      timerEventDefinition,
      timerEventDefinitionType
    });
  }
  return entries;
}
function TimerEventDefinitionType(props) {
  const {
    element,
    timerEventDefinition,
    timerEventDefinitionType
  } = props;
  const commandStack = useService("commandStack"), bpmnFactory = useService("bpmnFactory"), translate3 = useService("translate");
  const getValue2 = () => {
    return timerEventDefinitionType || "";
  };
  const setValue = (value) => {
    if (value === timerEventDefinitionType) {
      return;
    }
    const formalExpression = bpmnFactory.create("bpmn:FormalExpression", {
      body: void 0
    });
    formalExpression.$parent = timerEventDefinition;
    const newProps = {
      timeDuration: void 0,
      timeDate: void 0,
      timeCycle: void 0
    };
    if (value !== "") {
      newProps[value] = formalExpression;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: timerEventDefinition,
      properties: newProps
    });
  };
  const getOptions = (element2) => {
    return [{
      value: "",
      label: translate3("<none>")
    }, {
      value: "timeDate",
      label: translate3("Date")
    }, {
      value: "timeDuration",
      label: translate3("Duration")
    }, {
      value: "timeCycle",
      label: translate3("Cycle")
    }];
  };
  return SelectEntry({
    element,
    id: "timerEventDefinitionType",
    label: translate3("Type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function TimerEventDefinitionValue(props) {
  const {
    element,
    timerEventDefinition,
    timerEventDefinitionType
  } = props;
  const commandStack = useService("commandStack"), translate3 = useService("translate"), debounce4 = useService("debounceInput");
  const timerEventFormalExpression = timerEventDefinition.get(timerEventDefinitionType);
  const getValue2 = () => {
    return timerEventFormalExpression && timerEventFormalExpression.get("body");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: timerEventFormalExpression,
      properties: {
        body: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "timerEventDefinitionValue",
    label: translate3("Value"),
    getValue: getValue2,
    setValue,
    debounce: debounce4,
    description: getTimerEventDefinitionValueDescription(timerEventDefinitionType, translate3)
  });
}
function getTimerEventDefinitionValueDescription(timerDefinitionType, translate3) {
  switch (timerDefinitionType) {
    case "timeDate":
      return o5("div", {
        children: [o5("p", {
          children: translate3("A specific point in time defined as ISO 8601 combined date and time representation.")
        }), o5("ul", {
          children: [o5("li", {
            children: [o5("code", {
              children: "2019-10-01T12:00:00Z"
            }), " - ", translate3("UTC time")]
          }), o5("li", {
            children: [o5("code", {
              children: "2019-10-02T08:09:40+02:00"
            }), " - ", translate3("UTC plus 2 hours zone offset")]
          })]
        }), o5("a", {
          href: "https://docs.camunda.org/manual/latest/reference/bpmn20/events/timer-events/#time-date",
          target: "_blank",
          rel: "noopener",
          children: translate3("Documentation: Timer events")
        })]
      });
    case "timeCycle":
      return o5("div", {
        children: [o5("p", {
          children: translate3("A cycle defined as ISO 8601 repeating intervals format, or a cron expression.")
        }), o5("ul", {
          children: [o5("li", {
            children: [o5("code", {
              children: "R5/PT10S"
            }), " - ", translate3("every 10 seconds, up to 5 times")]
          }), o5("li", {
            children: [o5("code", {
              children: "R/P1D"
            }), " - ", translate3("every day, infinitely")]
          }), o5("li", {
            children: [o5("code", {
              children: "0 0 9-17 * * MON-FRI"
            }), " - ", translate3("every hour on the hour from 9-5 p.m. UTC Monday-Friday")]
          })]
        }), o5("a", {
          href: "https://docs.camunda.org/manual/latest/reference/bpmn20/events/timer-events/#time-cycle",
          target: "_blank",
          rel: "noopener",
          children: translate3("Documentation: Timer events")
        })]
      });
    case "timeDuration":
      return o5("div", {
        children: [o5("p", {
          children: translate3("A time duration defined as ISO 8601 durations format.")
        }), o5("ul", {
          children: [o5("li", {
            children: [o5("code", {
              children: "PT15S"
            }), " - ", translate3("15 seconds")]
          }), o5("li", {
            children: [o5("code", {
              children: "PT1H30M"
            }), " - ", translate3("1 hour and 30 minutes")]
          }), o5("li", {
            children: [o5("code", {
              children: "P14D"
            }), " - ", translate3("14 days")]
          })]
        }), o5("a", {
          href: "https://docs.camunda.org/manual/latest/reference/bpmn20/events/timer-events/#time-duration",
          target: "_blank",
          rel: "noopener",
          children: translate3("Documentation: Timer events")
        })]
      });
  }
}
function isTimerSupportedOnListener(listener) {
  return listener && is(listener, "camunda:TaskListener") && getTimerEventDefinition(listener);
}
function getId(idPrefix, id) {
  return idPrefix ? idPrefix + id : id;
}
var LOW_PRIORITY28 = 500;
var CAMUNDA_PLATFORM_GROUPS = [HistoryCleanupGroup, TasklistGroup, CandidateStarterGroup, ImplementationGroup, ExternalTaskGroup, ProcessVariablesGroup, ErrorsGroup, UserAssignmentGroup, FormGroup, FormDataGroup, TaskListenerGroup, StartInitiatorGroup, ScriptGroup, ConditionGroup, CallActivityGroup, AsynchronousContinuationsGroup, JobExecutionGroup, InMappingPropagationGroup, InMappingGroup, InputGroup, ConnectorInputGroup, OutMappingPropagationGroup, OutMappingGroup, OutputGroup, ConnectorOutputGroup, ExecutionListenerGroup, ExtensionPropertiesGroup, FieldInjectionGroup, BusinessKeyGroup];
var CamundaPlatformPropertiesProvider = class {
  constructor(propertiesPanel, injector) {
    propertiesPanel.registerProvider(LOW_PRIORITY28, this);
    this._injector = injector;
  }
  getGroups(element) {
    return (groups) => {
      groups = groups.concat(this._getGroups(element));
      updateGeneralGroup(groups, element);
      updateErrorGroup(groups, element);
      updateEscalationGroup(groups, element);
      updateMultiInstanceGroup(groups, element);
      updateTimerGroup(groups, element);
      moveImplementationGroup(groups);
      return groups;
    };
  }
  _getGroups(element) {
    const groups = CAMUNDA_PLATFORM_GROUPS.map((createGroup2) => createGroup2(element, this._injector));
    return groups.filter((group) => group !== null);
  }
};
CamundaPlatformPropertiesProvider.$inject = ["propertiesPanel", "injector"];
function moveImplementationGroup(groups) {
  const documentationGroupIdx = findGroupIndex(groups, "documentation");
  if (documentationGroupIdx < 0) {
    return;
  }
  return moveGroup(groups, "CamundaPlatform__Implementation", documentationGroupIdx + 1);
}
function updateGeneralGroup(groups, element) {
  const generalGroup = findGroup(groups, "general");
  if (!generalGroup) {
    return;
  }
  const {
    entries
  } = generalGroup;
  const executableEntry = (0, import_min_dash147.findIndex)(entries, (entry) => entry.id === "isExecutable");
  const insertIndex = executableEntry >= 0 ? executableEntry : entries.length;
  entries.splice(insertIndex, 0, ...VersionTagProps({
    element
  }));
}
function updateErrorGroup(groups, element) {
  const errorGroup = findGroup(groups, "error");
  if (!errorGroup) {
    return;
  }
  const {
    entries
  } = errorGroup;
  ErrorProps({
    element,
    entries
  });
}
function updateMultiInstanceGroup(groups, element) {
  const multiInstanceGroup = findGroup(groups, "multiInstance");
  if (!multiInstanceGroup) {
    return;
  }
  const {
    entries
  } = multiInstanceGroup;
  MultiInstanceProps({
    element,
    entries
  });
}
function updateEscalationGroup(groups, element) {
  const escalationGroup = findGroup(groups, "escalation");
  if (!escalationGroup) {
    return;
  }
  const {
    entries
  } = escalationGroup;
  EscalationProps({
    element,
    entries
  });
}
function updateTimerGroup(groups, element) {
  const timerEventGroup = findGroup(groups, "timer");
  if (!timerEventGroup) {
    return;
  }
  timerEventGroup.entries = [...TimerProps({
    element
  })];
}
function ImplementationGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Implementation"),
    id: "CamundaPlatform__Implementation",
    component: Group,
    entries: [...ImplementationProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function ErrorsGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Errors"),
    id: "CamundaPlatform__Errors",
    component: ListGroup,
    ...ErrorsProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function UserAssignmentGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("User assignment"),
    id: "CamundaPlatform__UserAssignment",
    component: Group,
    entries: [...UserAssignmentProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function ScriptGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Script"),
    id: "CamundaPlatform__Script",
    component: Group,
    entries: [...ScriptTaskProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function CallActivityGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Called element"),
    id: "CamundaPlatform__CallActivity",
    component: Group,
    entries: [...CallActivityProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function ConditionGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Condition"),
    id: "CamundaPlatform__Condition",
    component: Group,
    entries: [...ConditionProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function StartInitiatorGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Start initiator"),
    id: "CamundaPlatform__StartInitiator",
    component: Group,
    entries: [...InitiatorProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function ExternalTaskGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("External task"),
    id: "CamundaPlatform__ExternalTask",
    component: Group,
    entries: [...ExternalTaskPriorityProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function AsynchronousContinuationsGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Asynchronous continuations"),
    id: "CamundaPlatform__AsynchronousContinuations",
    component: Group,
    entries: [...AsynchronousContinuationsProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function JobExecutionGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Job execution"),
    id: "CamundaPlatform__JobExecution",
    component: Group,
    entries: [...JobExecutionProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function CandidateStarterGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Candidate starter"),
    id: "CamundaPlatform__CandidateStarter",
    component: Group,
    entries: [...CandidateStarterProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function FieldInjectionGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Field injections"),
    id: "CamundaPlatform__FieldInjection",
    component: ListGroup,
    ...FieldInjectionProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function HistoryCleanupGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("History cleanup"),
    id: "CamundaPlatform__HistoryCleanup",
    component: Group,
    entries: [...HistoryCleanupProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function TasklistGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Tasklist"),
    id: "CamundaPlatform__Tasklist",
    component: Group,
    entries: [...TasklistProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function InMappingGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("In mappings"),
    id: "CamundaPlatform__InMapping",
    component: ListGroup,
    ...InMappingProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function InMappingPropagationGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("In mapping propagation"),
    id: "CamundaPlatform__InMappingPropagation",
    component: Group,
    entries: [...InMappingPropagationProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function OutMappingGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Out mappings"),
    id: "CamundaPlatform__OutMapping",
    component: ListGroup,
    ...OutMappingProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function OutMappingPropagationGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Out mapping propagation"),
    id: "CamundaPlatform__OutMappingPropagation",
    component: Group,
    entries: [...OutMappingPropagationProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function ProcessVariablesGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Process variables"),
    id: "CamundaPlatform__ProcessVariables",
    component: ListGroup,
    ...ProcessVariablesProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function FormDataGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Form fields"),
    id: "CamundaPlatform__FormData",
    component: ListGroup,
    ...FormDataProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function BusinessKeyGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Business key"),
    id: "CamundaPlatform__BusinessKey",
    component: Group,
    entries: [...BusinessKeyProps$1({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function FormGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Forms"),
    id: "CamundaPlatform__Form",
    component: Group,
    entries: [...FormProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function ExecutionListenerGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Execution listeners"),
    id: "CamundaPlatform__ExecutionListener",
    component: ListGroup,
    ...ExecutionListenerProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function TaskListenerGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Task listeners"),
    id: "CamundaPlatform__TaskListener",
    component: ListGroup,
    ...TaskListenerProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function InputGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Inputs"),
    id: "CamundaPlatform__Input",
    component: ListGroup,
    ...InputProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function OutputGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Outputs"),
    id: "CamundaPlatform__Output",
    component: ListGroup,
    ...OutputProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function ConnectorInputGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Connector inputs"),
    id: "CamundaPlatform__ConnectorInput",
    component: ListGroup,
    ...ConnectorInputProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function ConnectorOutputGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Connector outputs"),
    id: "CamundaPlatform__ConnectorOutput",
    component: ListGroup,
    ...ConnectorOutputProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function ExtensionPropertiesGroup(element, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Extension properties"),
    id: "CamundaPlatform__ExtensionProperties",
    component: ListGroup,
    ...ExtensionPropertiesProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function findGroup(groups, id) {
  return groups.find((g6) => g6.id === id);
}
function findGroupIndex(groups, id) {
  return (0, import_min_dash147.findIndex)(groups, (g6) => g6.id === id);
}
function moveGroup(groups, id, position) {
  const groupIndex = findGroupIndex(groups, id);
  if (position < 0 || groupIndex < 0) {
    return;
  }
  return (0, import_array_move.mutate)(groups, groupIndex, position);
}
var PROPERTY_TYPE$1 = "property";
var ZEBBE_PROPERTY_TYPE = "zeebe:property";
var ZEBBE_INPUT_TYPE = "zeebe:input";
var ZEEBE_OUTPUT_TYPE = "zeebe:output";
var ZEEBE_PROPERTY_TYPE = "zeebe:property";
var ZEEBE_TASK_DEFINITION_TYPE_TYPE = "zeebe:taskDefinition:type";
var ZEEBE_TASK_HEADER_TYPE = "zeebe:taskHeader";
var EXTENSION_BINDING_TYPES$1 = [ZEBBE_INPUT_TYPE, ZEEBE_OUTPUT_TYPE, ZEEBE_PROPERTY_TYPE, ZEEBE_TASK_DEFINITION_TYPE_TYPE, ZEEBE_TASK_HEADER_TYPE];
var TASK_DEFINITION_TYPES = [ZEEBE_TASK_DEFINITION_TYPE_TYPE];
var IO_BINDING_TYPES$1 = [ZEBBE_INPUT_TYPE, ZEEBE_OUTPUT_TYPE];
var TEMPLATE_ID_ATTR$1 = "zeebe:modelerTemplate";
var TEMPLATE_VERSION_ATTR$1 = "zeebe:modelerTemplateVersion";
function getTemplateId$1(element) {
  const businessObject = getBusinessObject(element);
  if (businessObject) {
    return businessObject.get(TEMPLATE_ID_ATTR$1);
  }
}
function getTemplateVersion$1(element) {
  const businessObject = getBusinessObject(element);
  if (businessObject) {
    return businessObject.get(TEMPLATE_VERSION_ATTR$1);
  }
}
function findExtension$1(element, type) {
  const businessObject = getBusinessObject(element);
  let extensionElements;
  if (is(businessObject, "bpmn:ExtensionElements")) {
    extensionElements = businessObject;
  } else {
    extensionElements = businessObject.get("extensionElements");
  }
  if (!extensionElements) {
    return null;
  }
  return extensionElements.get("values").find((value) => {
    return is(value, type);
  });
}
function findZeebeProperty(zeebeProperties, binding) {
  return zeebeProperties.get("properties").find((value) => {
    return value.name === binding.name;
  });
}
function findInputParameter$1(ioMapping, binding) {
  const parameters = ioMapping.get("inputParameters");
  return parameters.find((parameter) => {
    return parameter.target === binding.name;
  });
}
function findOutputParameter$1(ioMapping, binding) {
  const parameters = ioMapping.get("outputParameters");
  return parameters.find((parameter) => {
    return parameter.source === binding.source;
  });
}
function findTaskHeader(taskHeaders, binding) {
  const headers = taskHeaders.get("values");
  return headers.find((header) => {
    return header.key === binding.key;
  });
}
function createInputParameter$1(binding, value, bpmnFactory) {
  const {
    name: name3
  } = binding;
  return bpmnFactory.create("zeebe:Input", {
    source: value,
    target: name3
  });
}
function createOutputParameter$1(binding, value, bpmnFactory) {
  const {
    source
  } = binding;
  return bpmnFactory.create("zeebe:Output", {
    source,
    target: value
  });
}
function createTaskHeader(binding, value, bpmnFactory) {
  const {
    key
  } = binding;
  return bpmnFactory.create("zeebe:Header", {
    key,
    value
  });
}
function createTaskDefinitionWithType(value, bpmnFactory) {
  return bpmnFactory.create("zeebe:TaskDefinition", {
    type: value
  });
}
function createZeebeProperty(binding, value = "", bpmnFactory) {
  const {
    name: name3
  } = binding;
  return bpmnFactory.create("zeebe:Property", {
    name: name3,
    value
  });
}
function shouldUpdate(value, property) {
  const {
    optional
  } = property;
  return value || !optional;
}
function ensureExtension(element, type, bpmnFactory) {
  const businessObject = getBusinessObject(element);
  const extensionElements = businessObject.get("extensionElements");
  let extension = findExtension$1(extensionElements, type);
  if (!extension) {
    extension = bpmnFactory.create(type);
    extension.$parent = extensionElements;
    extensionElements.get("values").push(extension);
  }
  return extension;
}
var PRIMITIVE_MODDLE_TYPES$1 = ["Boolean", "Integer", "String"];
function getPropertyValue$1(element, property, scope) {
  let businessObject = getBusinessObject(element);
  const defaultValue = "";
  const {
    binding
  } = property;
  const {
    name: name3,
    type
  } = binding;
  if (type === "property") {
    const value = businessObject.get(name3);
    if (!(0, import_min_dash147.isUndefined)(value)) {
      return value;
    }
    return defaultValue;
  }
  if (TASK_DEFINITION_TYPES.includes(type)) {
    const taskDefinition = findExtension$1(businessObject, "zeebe:TaskDefinition");
    if (taskDefinition) {
      if (type === ZEEBE_TASK_DEFINITION_TYPE_TYPE) {
        return taskDefinition.get("type");
      }
    }
    return defaultValue;
  }
  if (IO_BINDING_TYPES$1.includes(type)) {
    const ioMapping = findExtension$1(businessObject, "zeebe:IoMapping");
    if (!ioMapping) {
      return defaultValue;
    }
    if (type === ZEBBE_INPUT_TYPE) {
      const inputParameter = findInputParameter$1(ioMapping, binding);
      if (inputParameter) {
        return inputParameter.get("source");
      }
      return defaultValue;
    }
    if (type === ZEEBE_OUTPUT_TYPE) {
      const outputParameter = findOutputParameter$1(ioMapping, binding);
      if (outputParameter) {
        return outputParameter.get("target");
      }
      return defaultValue;
    }
  }
  if (type === ZEEBE_TASK_HEADER_TYPE) {
    const taskHeaders = findExtension$1(businessObject, "zeebe:TaskHeaders");
    if (!taskHeaders) {
      return defaultValue;
    }
    const header = findTaskHeader(taskHeaders, binding);
    if (header) {
      return header.get("value");
    }
    return defaultValue;
  }
  if (type === ZEEBE_PROPERTY_TYPE) {
    const zeebeProperties = findExtension$1(businessObject, "zeebe:Properties");
    if (zeebeProperties) {
      const zeebeProperty = findZeebeProperty(zeebeProperties, binding);
      if (zeebeProperty) {
        return zeebeProperty.get("value");
      }
    }
    return defaultValue;
  }
  throw unknownBindingError$1(element, property);
}
var NO_OP = null;
function setPropertyValue(bpmnFactory, commandStack, element, property, value) {
  let businessObject = getBusinessObject(element);
  const {
    binding
  } = property;
  const {
    name: name3,
    type
  } = binding;
  let extensionElements;
  let propertyValue;
  const commands = [];
  const context = {
    element,
    property
  };
  if (EXTENSION_BINDING_TYPES$1.includes(type)) {
    extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", null, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    } else {
      commands.push(NO_OP);
    }
  }
  if (type === PROPERTY_TYPE$1) {
    const propertyDescriptor = businessObject.$descriptor.propertiesByName[name3];
    if (!propertyDescriptor) {
      propertyValue = value || "";
    } else {
      const {
        type: propertyType
      } = propertyDescriptor;
      if (!PRIMITIVE_MODDLE_TYPES$1.includes(propertyType)) {
        throw new Error(`cannot set property of type <${propertyType}>`);
      }
      if (propertyType === "Boolean") {
        propertyValue = !!value;
      } else if (propertyType === "Integer") {
        propertyValue = parseInt(value, 10);
        if (isNaN(propertyValue)) {
          propertyValue = void 0;
        }
      } else {
        propertyValue = value || "";
      }
    }
    if (!(0, import_min_dash147.isUndefined)(propertyValue)) {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: businessObject,
          properties: {
            [name3]: propertyValue
          }
        }
      });
    } else {
      commands.push(NO_OP);
    }
  }
  if (TASK_DEFINITION_TYPES.includes(type)) {
    const oldTaskDefinition = findExtension$1(extensionElements, "zeebe:TaskDefinition");
    let newTaskDefinition;
    if (type === ZEEBE_TASK_DEFINITION_TYPE_TYPE) {
      newTaskDefinition = createTaskDefinitionWithType(value, bpmnFactory);
    } else {
      throw unknownBindingError$1(element, property);
    }
    const values5 = extensionElements.get("values").filter((value2) => value2 !== oldTaskDefinition);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        ...context,
        moddleElement: extensionElements,
        properties: {
          values: [...values5, newTaskDefinition]
        }
      }
    });
  }
  if (IO_BINDING_TYPES$1.includes(type)) {
    let ioMapping = findExtension$1(extensionElements, "zeebe:IoMapping");
    if (!ioMapping) {
      ioMapping = createElement("zeebe:IoMapping", null, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), ioMapping]
          }
        }
      });
    }
    if (type === ZEBBE_INPUT_TYPE) {
      const oldZeebeInputParameter = findInputParameter$1(ioMapping, binding);
      const values5 = ioMapping.get("inputParameters").filter((value2) => value2 !== oldZeebeInputParameter);
      if (shouldUpdate(value, property)) {
        const newZeebeInputParameter = createInputParameter$1(binding, value, bpmnFactory);
        values5.push(newZeebeInputParameter);
      }
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: ioMapping,
          properties: {
            inputParameters: [...values5]
          }
        }
      });
    }
    if (type === ZEEBE_OUTPUT_TYPE) {
      const oldZeebeOutputParameter = findOutputParameter$1(ioMapping, binding);
      const values5 = ioMapping.get("outputParameters").filter((value2) => value2 !== oldZeebeOutputParameter);
      if (shouldUpdate(value, property)) {
        const newZeebeOutputParameter = createOutputParameter$1(binding, value, bpmnFactory);
        values5.push(newZeebeOutputParameter);
      }
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: ioMapping,
          properties: {
            "outputParameters": [...values5]
          }
        }
      });
    }
  }
  if (type === ZEEBE_TASK_HEADER_TYPE) {
    let taskHeaders = findExtension$1(extensionElements, "zeebe:TaskHeaders");
    if (!taskHeaders) {
      taskHeaders = createElement("zeebe:TaskHeaders", null, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), taskHeaders]
          }
        }
      });
    }
    const oldTaskHeader = findTaskHeader(taskHeaders, binding);
    const values5 = taskHeaders.get("values").filter((value2) => value2 !== oldTaskHeader);
    if (!value) {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: taskHeaders,
          properties: {
            values: values5
          }
        }
      });
    } else {
      const newTaskHeader = createTaskHeader(binding, value, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: taskHeaders,
          properties: {
            values: [...values5, newTaskHeader]
          }
        }
      });
    }
  }
  if (type === ZEEBE_PROPERTY_TYPE) {
    let zeebeProperties = findExtension$1(extensionElements, "zeebe:Properties");
    if (!zeebeProperties) {
      zeebeProperties = createElement("zeebe:Properties", null, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), zeebeProperties]
          }
        }
      });
    }
    const oldZeebeProperty = findZeebeProperty(zeebeProperties, binding);
    const properties = zeebeProperties.get("properties").filter((property2) => property2 !== oldZeebeProperty);
    if (shouldUpdate(value, property)) {
      const newZeebeProperty = createZeebeProperty(binding, value, bpmnFactory);
      properties.push(newZeebeProperty);
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: zeebeProperties,
        properties: {
          properties
        }
      }
    });
  }
  if (commands.length) {
    const commandsToExecute = commands.filter((command) => command !== NO_OP);
    commandsToExecute.length && commandStack.execute("properties-panel.multi-command-executor", commandsToExecute);
    return;
  }
  throw unknownBindingError$1(element, property);
}
function unsetProperty(commandStack, element, property) {
  let businessObject = getBusinessObject(element);
  const {
    binding
  } = property;
  const {
    type
  } = binding;
  let extensionElements;
  const commands = [];
  const context = {
    element,
    property
  };
  if (EXTENSION_BINDING_TYPES$1.includes(type)) {
    extensionElements = businessObject.get("extensionElements");
    if (!extensionElements)
      return;
  }
  if (TASK_DEFINITION_TYPES.includes(type)) {
    const oldTaskDefinition = findExtension$1(extensionElements, "zeebe:TaskDefinition");
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        ...context,
        moddleElement: extensionElements,
        properties: {
          values: (0, import_min_dash147.without)(extensionElements.get("values"), oldTaskDefinition)
        }
      }
    });
  }
  if (IO_BINDING_TYPES$1.includes(type)) {
    let ioMapping = findExtension$1(extensionElements, "zeebe:IoMapping");
    if (!ioMapping)
      return;
    if (type === ZEBBE_INPUT_TYPE) {
      const oldZeebeInputParameter = findInputParameter$1(ioMapping, binding);
      const values5 = ioMapping.get("inputParameters").filter((value) => value !== oldZeebeInputParameter);
      if (ioMapping.get("outputParameters").length == 0 && values5.length == 0) {
        commands.push({
          cmd: "element.updateModdleProperties",
          context: {
            ...context,
            moddleElement: extensionElements,
            properties: {
              values: (0, import_min_dash147.without)(extensionElements.get("values"), ioMapping)
            }
          }
        });
      } else {
        commands.push({
          cmd: "element.updateModdleProperties",
          context: {
            ...context,
            moddleElement: ioMapping,
            properties: {
              inputParameters: [...values5]
            }
          }
        });
      }
    }
    if (type === ZEEBE_OUTPUT_TYPE) {
      const oldZeebeOutputParameter = findOutputParameter$1(ioMapping, binding);
      const values5 = ioMapping.get("outputParameters").filter((value) => value !== oldZeebeOutputParameter);
      if (ioMapping.get("inputParameters").length == 0 && values5.length == 0) {
        commands.push({
          cmd: "element.updateModdleProperties",
          context: {
            ...context,
            moddleElement: extensionElements,
            properties: {
              values: (0, import_min_dash147.without)(extensionElements.get("values"), ioMapping)
            }
          }
        });
      }
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: ioMapping,
          properties: {
            "outputParameters": [...values5]
          }
        }
      });
    }
  }
  if (type === ZEEBE_TASK_HEADER_TYPE) {
    let taskHeaders = findExtension$1(extensionElements, "zeebe:TaskHeaders");
    if (!taskHeaders)
      return;
    const oldTaskHeader = findTaskHeader(taskHeaders, binding);
    const values5 = taskHeaders.get("values").filter((value) => value !== oldTaskHeader);
    if (values5.length === 0) {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: extensionElements,
          properties: {
            values: (0, import_min_dash147.without)(extensionElements.get("values"), taskHeaders)
          }
        }
      });
    } else {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: taskHeaders,
          properties: {
            values: [...values5]
          }
        }
      });
    }
  }
  if (type === ZEEBE_PROPERTY_TYPE) {
    let zeebeProperties = findExtension$1(extensionElements, "zeebe:Properties");
    if (!zeebeProperties)
      return;
    const oldZeebeProperty = findZeebeProperty(zeebeProperties, binding);
    const properties = zeebeProperties.get("properties").filter((property2) => property2 !== oldZeebeProperty);
    if (!properties.length) {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: extensionElements,
          properties: {
            values: (0, import_min_dash147.without)(extensionElements.get("values"), zeebeProperties)
          }
        }
      });
    } else {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: zeebeProperties,
          properties: {
            properties: [...properties]
          }
        }
      });
    }
  }
  if (commands.length) {
    commandStack.execute("properties-panel.multi-command-executor", commands);
    return;
  }
}
function unknownBindingError$1(element, property) {
  const businessObject = getBusinessObject(element);
  const id = businessObject.get("id");
  const {
    binding
  } = property;
  const {
    type
  } = binding;
  return new Error(`unknown binding <${type}> for element <${id}>, this should never happen`);
}
function applyConditions(element, elementTemplate) {
  const {
    properties
  } = elementTemplate;
  const filteredProperties = properties.filter((property) => {
    return isConditionMet(element, properties, property);
  });
  return {
    ...elementTemplate,
    properties: filteredProperties
  };
}
function isConditionMet(element, properties, property) {
  const {
    condition
  } = property;
  if (!condition) {
    return true;
  }
  return isSimpleConditionMet(element, properties, condition);
}
function isSimpleConditionMet(element, properties, condition) {
  const {
    property,
    equals: equals2,
    oneOf
  } = condition;
  const propertyValue = getValue(element, properties, property);
  if (equals2) {
    return propertyValue === equals2;
  }
  if (oneOf) {
    return oneOf.includes(propertyValue);
  }
  return false;
}
function getValue(element, properties, propertyId) {
  const property = properties.find((p6) => p6.id === propertyId);
  if (!property) {
    return;
  }
  return getPropertyValue$1(element, property);
}
var ElementTemplatesConditionChecker = class extends CommandInterceptor {
  constructor(eventBus, elementTemplates, commandStack, bpmnFactory) {
    super(eventBus);
    this._eventBus = eventBus;
    this._elementTemplates = elementTemplates;
    this._commandStack = commandStack;
    this._bpmnFactory = bpmnFactory;
    this.preExecute(["element.updateProperties", "element.updateModdleProperties"], this._saveConditionalState, true, this);
    this.postExecute(["element.updateProperties", "element.updateModdleProperties", "propertiesPanel.zeebe.changeTemplate"], this._applyConditions, true, this);
  }
  _saveConditionalState(context) {
    const {
      element
    } = context;
    const template = this._elementTemplates.get(element);
    if (!template) {
      return;
    }
    context.oldTemplate = applyConditions(element, template);
  }
  _applyConditions(context) {
    const {
      element,
      oldTemplate
    } = context;
    const template = this._elementTemplates.get(element);
    if (!template || !oldTemplate || template.id !== oldTemplate.id) {
      return;
    }
    const newTemplate = applyConditions(element, template);
    const propertiesToAdd = getMissingProperties(oldTemplate, newTemplate);
    const propertiesToRemove = getPropertiesToRemove(newTemplate, oldTemplate);
    propertiesToAdd.forEach((property) => setPropertyValue(this._bpmnFactory, this._commandStack, element, property, property.value));
    propertiesToRemove.forEach((property) => unsetProperty(this._commandStack, element, property));
  }
};
ElementTemplatesConditionChecker.$inject = ["eventBus", "elementTemplates", "commandStack", "bpmnFactory"];
function getMissingProperties(sourceTemplate, targetTemplate) {
  let properties = targetTemplate.properties;
  return properties.filter((targetProp) => !sourceTemplate.properties.find((sourceProp) => compareProps(sourceProp, targetProp)));
}
function compareProps(sourceProp, targetProp) {
  return equals(sourceProp.binding, targetProp.binding) && equals(sourceProp.condition, targetProp.condition);
}
function findPropertyWithBinding(template, prop1) {
  return template.properties.some((prop2) => equals(prop1.binding, prop2.binding));
}
function getPropertiesToRemove(newTemplate, oldTemplate) {
  const oldProperties = getMissingProperties(newTemplate, oldTemplate);
  return oldProperties.filter((property) => !findPropertyWithBinding(newTemplate, property));
}
function normalizeReplacer(key, value) {
  if ((0, import_min_dash147.isObject)(value)) {
    const keys4 = Object.keys(value).sort();
    return keys4.reduce((obj, key2) => {
      obj[key2] = value[key2];
      return obj;
    }, {});
  }
  return value;
}
function equals(a6, b5) {
  return JSON.stringify(a6, normalizeReplacer) === JSON.stringify(b5, normalizeReplacer);
}
var TEMPLATE_ID_ATTR = "camunda:modelerTemplate";
var TEMPLATE_VERSION_ATTR = "camunda:modelerTemplateVersion";
function getTemplateId(element) {
  const businessObject = getBusinessObject(element);
  if (businessObject) {
    return businessObject.get(TEMPLATE_ID_ATTR);
  }
}
function getTemplateVersion(element) {
  const businessObject = getBusinessObject(element);
  if (businessObject) {
    return businessObject.get(TEMPLATE_VERSION_ATTR);
  }
}
function findExtension(element, type) {
  const businessObject = getBusinessObject(element);
  let extensionElements;
  if (is(businessObject, "bpmn:ExtensionElements")) {
    extensionElements = businessObject;
  } else {
    extensionElements = businessObject.get("extensionElements");
  }
  if (!extensionElements) {
    return null;
  }
  return extensionElements.get("values").find((value) => {
    return is(value, type);
  });
}
function findExtensions(element, types3) {
  const extensionElements = getExtensionElements(element);
  if (!extensionElements) {
    return [];
  }
  return extensionElements.get("values").filter((value) => {
    return isAny(value, types3);
  });
}
function findCamundaInOut(element, binding) {
  const extensionElements = getExtensionElements(element);
  if (!extensionElements) {
    return;
  }
  const {
    type
  } = binding;
  let matcher;
  if (type === "camunda:in") {
    matcher = (element2) => {
      return is(element2, "camunda:In") && isInOut(element2, binding);
    };
  } else if (type === "camunda:out") {
    matcher = (element2) => {
      return is(element2, "camunda:Out") && isInOut(element2, binding);
    };
  } else if (type === "camunda:in:businessKey") {
    matcher = (element2) => {
      return is(element2, "camunda:In") && "businessKey" in element2;
    };
  }
  return extensionElements.get("values").find(matcher);
}
function findCamundaProperty(camundaProperties, binding) {
  return camundaProperties.get("values").find((value) => {
    return value.name === binding.name;
  });
}
function findInputParameter(inputOutput, binding) {
  const parameters = inputOutput.get("inputParameters");
  return parameters.find((parameter) => {
    return parameter.name === binding.name;
  });
}
function findOutputParameter(inputOutput, binding) {
  const parameters = inputOutput.get("outputParameters");
  return parameters.find(function(parameter) {
    const {
      value
    } = parameter;
    if (!binding.scriptFormat) {
      return value === binding.source;
    }
    const definition = parameter.get("camunda:definition");
    if (!definition || binding.scriptFormat !== definition.get("camunda:scriptFormat")) {
      return false;
    }
    return definition.get("camunda:value") === binding.source;
  });
}
function findCamundaErrorEventDefinition(element, errorRef) {
  const errorEventDefinitions = findExtensions(element, ["camunda:ErrorEventDefinition"]);
  let error4;
  return errorEventDefinitions.find((definition) => {
    error4 = definition.get("bpmn:errorRef");
    if (error4) {
      return error4.get("bpmn:id").startsWith(`Error_${errorRef}`);
    }
  });
}
function getExtensionElements(element) {
  const businessObject = getBusinessObject(element);
  if (is(businessObject, "bpmn:ExtensionElements")) {
    return businessObject;
  } else {
    return businessObject.get("extensionElements");
  }
}
function isInOut(element, binding) {
  if (binding.type === "camunda:in") {
    if (binding.target) {
      return element.target === binding.target;
    }
  }
  if (binding.type === "camunda:out") {
    if (binding.source) {
      return element.source === binding.source;
    }
    if (binding.sourceExpression) {
      return element.sourceExpression === binding.sourceExpression;
    }
  }
  if (binding.variables) {
    return element.variables === "all" && (binding.variables !== "local" || element.local);
  }
}
var ElementTemplates$1 = class {
  constructor(commandStack) {
    this._commandStack = commandStack;
    this._templates = {};
  }
  get(id, version2) {
    const templates = this._templates;
    let element;
    if ((0, import_min_dash147.isUndefined)(id)) {
      return null;
    } else if ((0, import_min_dash147.isString)(id)) {
      if ((0, import_min_dash147.isUndefined)(version2)) {
        version2 = "_";
      }
      if (templates[id] && templates[id][version2]) {
        return templates[id][version2];
      } else {
        return null;
      }
    } else {
      element = id;
      return this.get(this._getTemplateId(element), this._getTemplateVersion(element));
    }
  }
  getDefault(element) {
    return (0, import_min_dash147.find)(this.getAll(element), function(template) {
      return template.isDefault;
    }) || null;
  }
  getAll(id) {
    return this._getTemplateVerions(id, {
      includeDeprecated: true
    });
  }
  getLatest(id, options2 = {}) {
    return this._getTemplateVerions(id, {
      ...options2,
      latest: true
    });
  }
  set(templates) {
    this._templates = {};
    templates.forEach((template) => {
      const id = template.id, version2 = (0, import_min_dash147.isUndefined)(template.version) ? "_" : template.version;
      if (!this._templates[id]) {
        this._templates[id] = {
          latest: template
        };
      }
      this._templates[id][version2] = template;
      const latestVerions = this._templates[id].latest.version;
      if ((0, import_min_dash147.isUndefined)(latestVerions) || template.version > latestVerions) {
        this._templates[id].latest = template;
      }
    });
  }
  _getTemplateVerions(id, options2 = {}) {
    const {
      latest: latestOnly,
      deprecated: includeDeprecated
    } = options2;
    const templates = this._templates;
    const getVersions = (template) => {
      const {
        latest,
        ...versions
      } = template;
      return latestOnly ? !includeDeprecated && latest.deprecated ? [] : [latest] : (0, import_min_dash147.values)(versions);
    };
    if ((0, import_min_dash147.isNil)(id)) {
      return (0, import_min_dash147.flatten)((0, import_min_dash147.values)(templates).map(getVersions));
    }
    if ((0, import_min_dash147.isObject)(id)) {
      const element = id;
      return (0, import_min_dash147.filter)(this._getTemplateVerions(null, options2), function(template) {
        return isAny(element, template.appliesTo);
      }) || [];
    }
    if ((0, import_min_dash147.isString)(id)) {
      return templates[id] && getVersions(templates[id]);
    }
    throw new Error("argument must be of type {string|djs.model.Base|undefined}");
  }
  _getTemplateId(element) {
    return getTemplateId(element);
  }
  _getTemplateVersion(element) {
    return getTemplateVersion(element);
  }
  applyTemplate(element, newTemplate) {
    const oldTemplate = this.get(element);
    const context = {
      element,
      newTemplate,
      oldTemplate
    };
    this._commandStack.execute("propertiesPanel.camunda.changeTemplate", context);
    return context.element;
  }
};
ElementTemplates$1.$inject = ["commandStack"];
var ElementTemplates = class extends ElementTemplates$1 {
  constructor(templateElementFactory, commandStack) {
    super(commandStack);
    this._commandStack = commandStack;
    this._templateElementFactory = templateElementFactory;
  }
  _getTemplateId(element) {
    return getTemplateId$1(element);
  }
  _getTemplateVersion(element) {
    return getTemplateVersion$1(element);
  }
  createElement(template) {
    if (!template) {
      throw new Error("template is missing");
    }
    const element = this._templateElementFactory.create(template);
    return element;
  }
  applyTemplate(element, newTemplate) {
    const oldTemplate = this.get(element);
    const context = {
      element,
      newTemplate,
      oldTemplate
    };
    this._commandStack.execute("propertiesPanel.zeebe.changeTemplate", context);
    return context.element;
  }
};
ElementTemplates.$inject = ["templateElementFactory", "commandStack"];
var SUPPORTED_SCHEMA_VERSION$1 = getSchemaVersion();
var MORPHABLE_TYPES = ["bpmn:Activity", "bpmn:Event", "bpmn:Gateway"];
var Validator$1 = class {
  constructor(moddle) {
    this._templatesById = {};
    this._validTemplates = [];
    this._errors = [];
    this._moddle = moddle;
  }
  addAll(templates) {
    if (!(0, import_min_dash147.isArray)(templates)) {
      this._logError("templates must be []");
    } else {
      templates.forEach(this.add, this);
    }
    return this;
  }
  add(template) {
    const err = this._validateTemplate(template);
    let id, version2;
    if (!err) {
      id = template.id;
      version2 = template.version || "_";
      if (!this._templatesById[id]) {
        this._templatesById[id] = {};
      }
      this._templatesById[id][version2] = template;
      this._validTemplates.push(template);
    }
    return this;
  }
  _validateTemplate(template) {
    let err;
    const id = template.id, version2 = template.version || "_", schemaVersion = template.$schema && getSchemaVersion2(template.$schema);
    if (schemaVersion && (0, import_semver_compare.default)(SUPPORTED_SCHEMA_VERSION$1, schemaVersion) < 0) {
      return this._logError(`unsupported element template schema version <${schemaVersion}>. Your installation only supports up to version <${SUPPORTED_SCHEMA_VERSION$1}>. Please update your installation`, template);
    }
    if (this._templatesById[id] && this._templatesById[id][version2]) {
      if (version2 === "_") {
        return this._logError(`template id <${id}> already used`, template);
      } else {
        return this._logError(`template id <${id}> and version <${version2}> already used`, template);
      }
    }
    const elementTypeError = this._validateElementType(template);
    if (elementTypeError) {
      return elementTypeError;
    }
    const validationResult = validate(template);
    const {
      errors,
      valid
    } = validationResult;
    if (!valid) {
      err = new Error("invalid template");
      filteredSchemaErrors(errors).forEach((error4) => {
        this._logError(error4.message, template);
      });
    }
    return err;
  }
  _validateElementType(template) {
    if (template.elementType && template.appliesTo) {
      const elementType = template.elementType.value, appliesTo = template.appliesTo;
      if (!appliesTo.find((type) => this._isType(elementType, type))) {
        return this._logError(`template does not apply to requested element type <${elementType}>`, template);
      }
      for (const sourceType of appliesTo) {
        if (!this._canMorph(sourceType, elementType)) {
          return this._logError(`can not morph <${sourceType}> into <${elementType}>`, template);
        }
      }
    }
  }
  _isType(type, baseType) {
    const moddleType = this._moddle.getType(type);
    return moddleType && baseType in this._moddle.getElementDescriptor(moddleType).allTypesByName;
  }
  _canMorph(sourceType, targetType) {
    if (sourceType === targetType) {
      return true;
    }
    const baseType = MORPHABLE_TYPES.find((type) => this._isType(sourceType, type));
    if (!baseType) {
      return false;
    }
    return this._isType(targetType, baseType);
  }
  _logError(err, template) {
    if ((0, import_min_dash147.isString)(err)) {
      if (template) {
        const {
          id,
          name: name3
        } = template;
        err = `template(id: <${id}>, name: <${name3}>): ${err}`;
      }
      err = new Error(err);
    }
    this._errors.push(err);
    return err;
  }
  getErrors() {
    return this._errors;
  }
  getValidTemplates() {
    return this._validTemplates;
  }
};
function getSchemaVersion2(schemaUri) {
  const re = /\d+\.\d+\.\d+/g;
  const match = schemaUri.match(re);
  return match === null ? void 0 : match[0];
}
function filteredSchemaErrors(schemaErrors) {
  return (0, import_min_dash147.filter)(schemaErrors, (err) => {
    const {
      dataPath,
      keyword
    } = err;
    if (keyword === "errorMessage") {
      return true;
    }
    if (keyword === "type" && dataPath && !dataPath.startsWith("/scopes/")) {
      return true;
    }
    return false;
  });
}
var SUPPORTED_SCHEMA_VERSION = getZeebeSchemaVersion();
var SUPPORTED_SCHEMA_PACKAGE = getZeebeSchemaPackage();
var Validator = class extends Validator$1 {
  constructor(moddle) {
    super(moddle);
  }
  _validateTemplate(template) {
    let err;
    const id = template.id, version2 = template.version || "_", schema = template.$schema, schemaVersion = schema && getSchemaVersion2(schema);
    if (!schema) {
      return this._logError("missing $schema attribute.", template);
    }
    if (!this.isSchemaValid(schema)) {
      return this._logError(`unsupported $schema attribute <${schema}>.`, template);
    }
    if (schemaVersion && (0, import_semver_compare.default)(SUPPORTED_SCHEMA_VERSION, schemaVersion) < 0) {
      return this._logError(`unsupported element template schema version <${schemaVersion}>. Your installation only supports up to version <${SUPPORTED_SCHEMA_VERSION}>. Please update your installation`, template);
    }
    if (this._templatesById[id] && this._templatesById[id][version2]) {
      if (version2 === "_") {
        return this._logError(`template id <${id}> already used`, template);
      } else {
        return this._logError(`template id <${id}> and version <${version2}> already used`, template);
      }
    }
    const elementTypeError = this._validateElementType(template);
    if (elementTypeError) {
      return elementTypeError;
    }
    const validationResult = validateZeebe(template);
    const {
      errors,
      valid
    } = validationResult;
    if (!valid) {
      err = new Error("invalid template");
      filteredSchemaErrors(errors).forEach((error4) => {
        this._logError(error4.message, template);
      });
    }
    return err;
  }
  isSchemaValid(schema) {
    return schema && schema.includes(SUPPORTED_SCHEMA_PACKAGE);
  }
};
var ElementTemplatesLoader$1 = class {
  constructor(loadTemplates, eventBus, elementTemplates, moddle) {
    this._loadTemplates = loadTemplates;
    this._eventBus = eventBus;
    this._elementTemplates = elementTemplates;
    this._moddle = moddle;
    eventBus.on("diagram.init", () => {
      this.reload();
    });
  }
  reload() {
    const loadTemplates = this._loadTemplates;
    if ((0, import_min_dash147.isUndefined)(loadTemplates)) {
      return;
    }
    if ((0, import_min_dash147.isFunction)(loadTemplates)) {
      return loadTemplates((err, templates) => {
        if (err) {
          return this.templateErrors([err]);
        }
        this.setTemplates(templates);
      });
    }
    if (loadTemplates.length) {
      return this.setTemplates(loadTemplates);
    }
  }
  setTemplates(templates) {
    const elementTemplates = this._elementTemplates, moddle = this._moddle;
    const validator = new Validator$1(moddle).addAll(templates);
    const errors = validator.getErrors(), validTemplates = validator.getValidTemplates();
    elementTemplates.set(validTemplates);
    if (errors.length) {
      this.templateErrors(errors);
    }
    this.templatesChanged();
  }
  templatesChanged() {
    this._eventBus.fire("elementTemplates.changed");
  }
  templateErrors(errors) {
    this._eventBus.fire("elementTemplates.errors", {
      errors
    });
  }
};
ElementTemplatesLoader$1.$inject = ["config.elementTemplates", "eventBus", "elementTemplates", "moddle"];
var ElementTemplatesLoader = class extends ElementTemplatesLoader$1 {
  constructor(loadTemplates, eventBus, elementTemplates, moddle) {
    super(loadTemplates, eventBus, elementTemplates, moddle);
    this._elementTemplates = elementTemplates;
  }
  setTemplates(templates) {
    const elementTemplates = this._elementTemplates, moddle = this._moddle;
    const validator = new Validator(moddle).addAll(templates);
    const errors = validator.getErrors(), validTemplates = validator.getValidTemplates();
    elementTemplates.set(validTemplates);
    if (errors.length) {
      this.templateErrors(errors);
    }
    this.templatesChanged();
  }
};
ElementTemplatesLoader.$inject = ["config.elementTemplates", "eventBus", "elementTemplates", "moddle"];
function unlinkTemplate$1(element, injector) {
  const modeling = injector.get("modeling");
  modeling.updateProperties(element, {
    "camunda:modelerTemplate": null,
    "camunda:modelerTemplateVersion": null
  });
}
function removeTemplate(element, injector) {
  const replace = injector.get("replace"), selection = injector.get("selection");
  const businessObject = getBusinessObject(element);
  const type = businessObject.$type, eventDefinitionType = getEventDefinitionType(businessObject);
  const newBusinessObject = createBlankBusinessObject(element, injector);
  const newElement = replace.replaceElement(element, {
    type,
    businessObject: newBusinessObject,
    eventDefinitionType
  });
  selection.select(newElement);
}
function updateTemplate$1(element, newTemplate, injector) {
  const elementTemplates = injector.get("elementTemplates");
  return elementTemplates.applyTemplate(element, newTemplate);
}
function getVersionOrDateFromTemplate(template) {
  const metadata = template.metadata, version2 = template.version;
  if (metadata) {
    if (!(0, import_min_dash147.isUndefined)(metadata.created)) {
      return toDateString(metadata.created);
    } else if (!(0, import_min_dash147.isUndefined)(metadata.updated)) {
      return toDateString(metadata.updated);
    }
  }
  if ((0, import_min_dash147.isUndefined)(version2)) {
    return null;
  }
  return version2;
}
function getEventDefinitionType(businessObject) {
  if (!businessObject.eventDefinitions) {
    return null;
  }
  const eventDefinition = businessObject.eventDefinitions[0];
  if (!eventDefinition) {
    return null;
  }
  return eventDefinition.$type;
}
function toDateString(timestamp) {
  const date = new Date(timestamp);
  const year = date.getFullYear();
  const month = withLeadingZeros(String(date.getMonth() + 1));
  const day = withLeadingZeros(String(date.getDate()));
  const hours = withLeadingZeros(String(date.getHours()));
  const minutes = withLeadingZeros(String(date.getMinutes()));
  return day + "." + month + "." + year + " " + hours + ":" + minutes;
}
function withLeadingZeros(string) {
  return leftPad(string, 2, "0");
}
function leftPad(string, length2, character) {
  while (string.length < length2) {
    string = character + string;
  }
  return string;
}
function createBlankBusinessObject(element, injector) {
  const bpmnFactory = injector.get("bpmnFactory");
  const bo = getBusinessObject(element), newBo = bpmnFactory.create(bo.$type), label = getLabel(element);
  if (!label) {
    return newBo;
  }
  if (is(element, "bpmn:Group")) {
    newBo.categoryValueRef = bpmnFactory.create("bpmn:CategoryValue");
  }
  setLabel({
    businessObject: newBo
  }, label);
  return newBo;
}
function unlinkTemplate(element, injector) {
  const modeling = injector.get("modeling");
  modeling.updateProperties(element, {
    "zeebe:modelerTemplate": null,
    "zeebe:modelerTemplateVersion": null,
    "zeebe:modelerTemplateIcon": null
  });
}
function updateTemplate(element, newTemplate, injector) {
  const elementTemplates = injector.get("elementTemplates");
  return elementTemplates.applyTemplate(element, newTemplate);
}
var ReplaceBehavior$1 = class extends CommandInterceptor {
  constructor(elementTemplates, injector) {
    super(injector.get("eventBus"));
    this.postExecuted("shape.replace", function(e7) {
      var context = e7.context, oldShape = context.oldShape, oldBo = getBusinessObject(oldShape), newShape = context.newShape, newBo = getBusinessObject(newShape);
      if (!oldBo.modelerTemplate) {
        return;
      }
      const template = newBo.modelerTemplate;
      const version2 = newBo.modelerTemplateVersion;
      const elementTemplate = elementTemplates.get(template, version2);
      if (!elementTemplate) {
        unlinkTemplate(newShape, injector);
        return;
      }
      const {
        appliesTo,
        elementType
      } = elementTemplate;
      if (elementType) {
        if (!is(newShape, elementType.value)) {
          unlinkTemplate(newShape, injector);
        }
        return;
      }
      const allowed = appliesTo.reduce((allowed2, type) => {
        return allowed2 || is(newBo, type);
      }, false);
      if (!allowed) {
        unlinkTemplate(newShape, injector);
      }
    });
  }
};
ReplaceBehavior$1.$inject = ["elementTemplates", "injector"];
var ChangeElementTemplateHandler$1 = class {
  constructor(bpmnFactory, bpmnReplace, commandStack, modeling) {
    this._bpmnFactory = bpmnFactory;
    this._bpmnReplace = bpmnReplace;
    this._commandStack = commandStack;
    this._modeling = modeling;
  }
  preExecute(context) {
    let newTemplate = context.newTemplate, oldTemplate = context.oldTemplate;
    let element = context.element;
    this._updateZeebeModelerTemplate(element, newTemplate);
    this._updateZeebeModelerTemplateIcon(element, newTemplate);
    if (newTemplate) {
      newTemplate = applyConditions(element, newTemplate);
      element = context.element = this._updateTaskType(element, newTemplate);
      this._updateProperties(element, oldTemplate, newTemplate);
      this._updateZeebeTaskDefinition(element, oldTemplate, newTemplate);
      this._updateZeebeInputOutputParameterProperties(element, oldTemplate, newTemplate);
      this._updateZeebeTaskHeaderProperties(element, oldTemplate, newTemplate);
      this._updateZeebePropertyProperties(element, oldTemplate, newTemplate);
    }
  }
  _getOrCreateExtensionElements(element) {
    const bpmnFactory = this._bpmnFactory, modeling = this._modeling;
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = bpmnFactory.create("bpmn:ExtensionElements", {
        values: []
      });
      extensionElements.$parent = businessObject;
      modeling.updateProperties(element, {
        extensionElements
      });
    }
    return extensionElements;
  }
  _updateZeebeModelerTemplate(element, newTemplate) {
    const modeling = this._modeling;
    modeling.updateProperties(element, {
      "zeebe:modelerTemplate": newTemplate && newTemplate.id,
      "zeebe:modelerTemplateVersion": newTemplate && newTemplate.version
    });
  }
  _updateZeebeModelerTemplateIcon(element, newTemplate) {
    const modeling = this._modeling;
    const icon = newTemplate && newTemplate.icon;
    modeling.updateProperties(element, {
      "zeebe:modelerTemplateIcon": icon && icon.contents
    });
  }
  _updateProperties(element, oldTemplate, newTemplate) {
    const commandStack = this._commandStack;
    const newProperties = newTemplate.properties.filter((newProperty) => {
      const newBinding = newProperty.binding, newBindingType = newBinding.type;
      return newBindingType === "property";
    });
    if (!newProperties.length) {
      return;
    }
    const businessObject = getBusinessObject(element);
    newProperties.forEach((newProperty) => {
      const oldProperty = findOldProperty$1(oldTemplate, newProperty), newBinding = newProperty.binding, newBindingName = newBinding.name, newPropertyValue = newProperty.value, changedElement = businessObject;
      let properties = {};
      if (shouldKeepValue(changedElement, oldProperty, newProperty)) {
        return;
      }
      properties[newBindingName] = newPropertyValue;
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: businessObject,
        properties
      });
    });
  }
  _updateZeebeTaskDefinition(element, oldTemplate, newTemplate) {
    const bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
    const newProperties = newTemplate.properties.filter((newProperty) => {
      const newBinding = newProperty.binding, newBindingType = newBinding.type;
      return newBindingType === "zeebe:taskDefinition:type";
    });
    if (!newProperties.length) {
      return;
    }
    const businessObject = this._getOrCreateExtensionElements(element);
    newProperties.forEach((newProperty) => {
      const oldProperty = findOldProperty$1(oldTemplate, newProperty), oldBinding = oldProperty && oldProperty.binding, oldBindingType = oldBinding && oldBinding.type, oldTaskDefinition = findBusinessObject(businessObject, newProperty), newPropertyValue = newProperty.value, newBinding = newProperty.binding, newBindingType = newBinding.type;
      if (oldTaskDefinition) {
        if (!shouldKeepValue(oldTaskDefinition, oldProperty, newProperty)) {
          let properties = {};
          if (oldBindingType === "zeebe:taskDefinition:type" || !oldBindingType) {
            properties = {
              type: newPropertyValue
            };
          }
          commandStack.execute("element.updateModdleProperties", {
            element,
            moddleElement: oldTaskDefinition,
            properties
          });
        }
      } else {
        let newTaskDefinition;
        if (newBindingType === "zeebe:taskDefinition:type") {
          newTaskDefinition = createTaskDefinitionWithType(newPropertyValue, bpmnFactory);
        }
        commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: businessObject,
          properties: {
            values: [...businessObject.get("values"), newTaskDefinition]
          }
        });
      }
    });
  }
  _updateZeebeInputOutputParameterProperties(element, oldTemplate, newTemplate) {
    const bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
    const newProperties = newTemplate.properties.filter((newProperty) => {
      const newBinding = newProperty.binding, newBindingType = newBinding.type;
      return newBindingType === "zeebe:input" || newBindingType === "zeebe:output";
    });
    const businessObject = this._getOrCreateExtensionElements(element);
    let ioMapping = findExtension$1(businessObject, "zeebe:IoMapping");
    if (!newProperties.length) {
      if (!ioMapping) {
        return;
      }
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: businessObject,
        properties: {
          values: (0, import_min_dash147.without)(businessObject.get("values"), ioMapping)
        }
      });
    }
    if (!ioMapping) {
      ioMapping = bpmnFactory.create("zeebe:IoMapping");
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: businessObject,
        properties: {
          values: [...businessObject.get("values"), ioMapping]
        }
      });
    }
    const oldInputs = ioMapping.get("zeebe:inputParameters") ? ioMapping.get("zeebe:inputParameters").slice() : [];
    const oldOutputs = ioMapping.get("zeebe:outputParameters") ? ioMapping.get("zeebe:outputParameters").slice() : [];
    let propertyName;
    newProperties.forEach((newProperty) => {
      const oldProperty = findOldProperty$1(oldTemplate, newProperty), inputOrOutput = findBusinessObject(businessObject, newProperty), newPropertyValue = newProperty.value, newBinding = newProperty.binding, newBindingType = newBinding.type;
      let newInputOrOutput, properties;
      if (inputOrOutput) {
        if (shouldUpdate(newPropertyValue, newProperty) || shouldKeepValue(inputOrOutput, oldProperty, newProperty)) {
          if (is(inputOrOutput, "zeebe:Input")) {
            remove$1(oldInputs, inputOrOutput);
          } else {
            remove$1(oldOutputs, inputOrOutput);
          }
        }
        if (!shouldKeepValue(inputOrOutput, oldProperty, newProperty)) {
          if (is(inputOrOutput, "zeebe:Input")) {
            properties = {
              source: newPropertyValue
            };
          } else {
            properties = {
              target: newPropertyValue
            };
          }
          commandStack.execute("element.updateModdleProperties", {
            element,
            moddleElement: inputOrOutput,
            properties
          });
        }
      } else if (shouldUpdate(newPropertyValue, newProperty)) {
        if (newBindingType === "zeebe:input") {
          propertyName = "inputParameters";
          newInputOrOutput = createInputParameter$1(newBinding, newPropertyValue, bpmnFactory);
        } else {
          propertyName = "outputParameters";
          newInputOrOutput = createOutputParameter$1(newBinding, newPropertyValue, bpmnFactory);
        }
        commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: ioMapping,
          properties: {
            [propertyName]: [...ioMapping.get(propertyName), newInputOrOutput]
          }
        });
      }
    });
    if (oldInputs.length) {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: ioMapping,
        properties: {
          inputParameters: (0, import_min_dash147.without)(ioMapping.get("inputParameters"), (inputParameter) => oldInputs.includes(inputParameter))
        }
      });
    }
    if (oldOutputs.length) {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: ioMapping,
        properties: {
          outputParameters: (0, import_min_dash147.without)(ioMapping.get("outputParameters"), (outputParameter) => oldOutputs.includes(outputParameter))
        }
      });
    }
  }
  _updateZeebeTaskHeaderProperties(element, oldTemplate, newTemplate) {
    const bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
    const newProperties = newTemplate.properties.filter((newProperty) => {
      const newBinding = newProperty.binding, newBindingType = newBinding.type;
      return newBindingType === "zeebe:taskHeader";
    });
    const businessObject = this._getOrCreateExtensionElements(element);
    let taskHeaders = findExtension$1(businessObject, "zeebe:TaskHeaders");
    if (!newProperties.length) {
      if (!taskHeaders) {
        return;
      }
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: businessObject,
        properties: {
          values: (0, import_min_dash147.without)(businessObject.get("values"), taskHeaders)
        }
      });
    }
    if (!taskHeaders) {
      taskHeaders = bpmnFactory.create("zeebe:TaskHeaders");
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: businessObject,
        properties: {
          values: [...businessObject.get("values"), taskHeaders]
        }
      });
    }
    const oldHeaders = taskHeaders.get("zeebe:values") ? taskHeaders.get("zeebe:values").slice() : [];
    newProperties.forEach((newProperty) => {
      const oldProperty = findOldProperty$1(oldTemplate, newProperty), oldHeader = findBusinessObject(businessObject, newProperty), newPropertyValue = newProperty.value, newBinding = newProperty.binding;
      if (oldHeader) {
        if (!shouldKeepValue(oldHeader, oldProperty, newProperty)) {
          const properties = {
            value: newPropertyValue
          };
          commandStack.execute("element.updateModdleProperties", {
            element,
            moddleElement: oldHeader,
            properties
          });
        }
        remove$1(oldHeaders, oldHeader);
      } else if (newPropertyValue) {
        const newHeader = createTaskHeader(newBinding, newPropertyValue, bpmnFactory);
        commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: taskHeaders,
          properties: {
            values: [...taskHeaders.get("values"), newHeader]
          }
        });
      }
    });
    if (oldHeaders.length) {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: taskHeaders,
        properties: {
          values: (0, import_min_dash147.without)(taskHeaders.get("values"), (header) => oldHeaders.includes(header))
        }
      });
    }
  }
  _updateZeebePropertyProperties(element, oldTemplate, newTemplate) {
    const bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
    const newProperties = newTemplate.properties.filter((newProperty) => {
      const newBinding = newProperty.binding, newBindingType = newBinding.type;
      return newBindingType === "zeebe:property";
    });
    const businessObject = this._getOrCreateExtensionElements(element);
    let zeebeProperties = findExtension$1(businessObject, "zeebe:Properties");
    if (!newProperties.length) {
      if (!zeebeProperties) {
        return;
      }
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: businessObject,
        properties: {
          values: (0, import_min_dash147.without)(businessObject.get("values"), zeebeProperties)
        }
      });
    }
    if (!zeebeProperties) {
      zeebeProperties = bpmnFactory.create("zeebe:Properties");
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: businessObject,
        properties: {
          values: [...businessObject.get("values"), zeebeProperties]
        }
      });
    }
    const oldZeebeProperties = zeebeProperties.get("properties") ? zeebeProperties.get("properties").slice() : [];
    newProperties.forEach((newProperty) => {
      const oldProperty = findOldProperty$1(oldTemplate, newProperty), oldZeebeProperty = findBusinessObject(businessObject, newProperty), newPropertyValue = newProperty.value, newBinding = newProperty.binding;
      if (oldZeebeProperty) {
        if (shouldUpdate(newPropertyValue, newProperty) || shouldKeepValue(oldZeebeProperty, oldProperty, newProperty)) {
          remove$1(oldZeebeProperties, oldZeebeProperty);
        }
        if (!shouldKeepValue(oldZeebeProperty, oldProperty, newProperty)) {
          commandStack.execute("element.updateModdleProperties", {
            element,
            moddleElement: oldZeebeProperty,
            properties: {
              value: newPropertyValue
            }
          });
        }
      } else if (shouldUpdate(newPropertyValue, newProperty)) {
        const newProperty2 = createZeebeProperty(newBinding, newPropertyValue, bpmnFactory);
        commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: zeebeProperties,
          properties: {
            properties: [...zeebeProperties.get("properties"), newProperty2]
          }
        });
      }
    });
    if (oldZeebeProperties.length) {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: zeebeProperties,
        properties: {
          properties: (0, import_min_dash147.without)(zeebeProperties.get("properties"), (zeebeProperty) => oldZeebeProperties.includes(zeebeProperty))
        }
      });
    }
  }
  _updateTaskType(element, newTemplate) {
    const newType = newTemplate.elementType;
    if (!newType) {
      return element;
    }
    if (element.$type === newType.value) {
      return element;
    }
    return this._bpmnReplace.replaceElement(element, {
      type: newType.value
    });
  }
};
ChangeElementTemplateHandler$1.$inject = ["bpmnFactory", "bpmnReplace", "commandStack", "modeling"];
function findBusinessObject(element, property) {
  const businessObject = getBusinessObject(element);
  const binding = property.binding, bindingType = binding.type;
  if (bindingType === "zeebe:taskDefinition:type") {
    return findExtension$1(businessObject, "zeebe:TaskDefinition");
  }
  if (bindingType === "zeebe:input" || bindingType === "zeebe:output") {
    const extensionElements = findExtension$1(businessObject, "zeebe:IoMapping");
    if (!extensionElements) {
      return;
    }
    if (bindingType === "zeebe:input") {
      return (0, import_min_dash147.find)(extensionElements.get("zeebe:inputParameters"), function(input) {
        return input.get("zeebe:target") === binding.name;
      });
    } else {
      return (0, import_min_dash147.find)(extensionElements.get("zeebe:outputParameters"), function(output) {
        return output.get("zeebe:source") === binding.source;
      });
    }
  }
  if (bindingType === "zeebe:taskHeader") {
    const extensionElements = findExtension$1(businessObject, "zeebe:TaskHeaders");
    if (!extensionElements) {
      return;
    }
    return (0, import_min_dash147.find)(extensionElements.get("zeebe:values"), function(value) {
      return value.get("zeebe:key") === binding.key;
    });
  }
  if (bindingType === "zeebe:property") {
    const zeebeProperties = findExtension$1(businessObject, "zeebe:Properties");
    if (!zeebeProperties) {
      return;
    }
    return zeebeProperties.get("properties").find((value) => {
      return value.get("name") === binding.name;
    });
  }
}
function findOldProperty$1(oldTemplate, newProperty) {
  if (!oldTemplate) {
    return;
  }
  const oldProperties = oldTemplate.properties, newBinding = newProperty.binding, newBindingName = newBinding.name, newBindingType = newBinding.type;
  if (newBindingType === "property") {
    return (0, import_min_dash147.find)(oldProperties, function(oldProperty) {
      const oldBinding = oldProperty.binding, oldBindingName = oldBinding.name, oldBindingType = oldBinding.type;
      return oldBindingType === "property" && oldBindingName === newBindingName;
    });
  }
  if (newBindingType === "zeebe:taskDefinition:type") {
    return (0, import_min_dash147.find)(oldProperties, function(oldProperty) {
      const oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
      return oldBindingType === "zeebe:taskDefinition:type";
    });
  }
  if (newBindingType === "zeebe:input") {
    return (0, import_min_dash147.find)(oldProperties, function(oldProperty) {
      const oldBinding = oldProperty.binding, oldBindingName = oldBinding.name, oldBindingType = oldBinding.type;
      if (oldBindingType !== "zeebe:input") {
        return;
      }
      return oldBindingName === newBindingName;
    });
  }
  if (newBindingType === "zeebe:output") {
    return (0, import_min_dash147.find)(oldProperties, function(oldProperty) {
      const oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
      if (oldBindingType !== "zeebe:output") {
        return;
      }
      return oldBinding.source === newBinding.source;
    });
  }
  if (newBindingType === "zeebe:taskHeader") {
    return (0, import_min_dash147.find)(oldProperties, function(oldProperty) {
      const oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
      if (oldBindingType !== "zeebe:taskHeader") {
        return;
      }
      return oldBinding.key === newBinding.key;
    });
  }
  if (newBindingType === "zeebe:property") {
    return oldProperties.find((oldProperty) => {
      const oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
      if (oldBindingType !== "zeebe:property") {
        return;
      }
      return oldBinding.name === newBinding.name;
    });
  }
}
function shouldKeepValue(element, oldProperty, newProperty) {
  if (newProperty.type === "Hidden") {
    return false;
  }
  if (newProperty.type === "Dropdown") {
    const currentValue = getPropertyValue(element, newProperty);
    return newProperty.choices && newProperty.choices.some((choice) => choice.value === currentValue);
  }
  if (oldProperty) {
    return propertyChanged$1(element, oldProperty);
  }
  return !!getPropertyValue(element, newProperty);
}
function propertyChanged$1(element, oldProperty) {
  const oldPropertyValue = oldProperty.value;
  return getPropertyValue(element, oldProperty) !== oldPropertyValue;
}
function getPropertyValue(element, property) {
  const businessObject = getBusinessObject(element);
  const binding = property.binding, bindingName = binding.name, bindingType = binding.type;
  if (bindingType === "property") {
    return businessObject.get(bindingName);
  }
  if (bindingType === "zeebe:taskDefinition:type") {
    return businessObject.get("zeebe:type");
  }
  if (bindingType === "zeebe:input") {
    return businessObject.get("zeebe:source");
  }
  if (bindingType === "zeebe:output") {
    return businessObject.get("zeebe:target");
  }
  if (bindingType === "zeebe:taskHeader") {
    return businessObject.get("zeebe:value");
  }
  if (bindingType === "zeebe:property") {
    return businessObject.get("zeebe:value");
  }
}
function remove$1(array, item) {
  const index2 = array.indexOf(item);
  if ((0, import_min_dash147.isUndefined)(index2)) {
    return array;
  }
  array.splice(index2, 1);
  return array;
}
function registerHandlers$1(commandStack, elementTemplates, eventBus) {
  commandStack.registerHandler("propertiesPanel.zeebe.changeTemplate", ChangeElementTemplateHandler$1);
  eventBus.on(["commandStack.shape.create.postExecuted"], function(context) {
    applyDefaultTemplate$1(context.context.shape, elementTemplates, commandStack);
  });
  eventBus.on(["commandStack.connection.create.postExecuted"], function(context) {
    applyDefaultTemplate$1(context.context.connection, elementTemplates, commandStack);
  });
}
registerHandlers$1.$inject = ["commandStack", "elementTemplates", "eventBus"];
function applyDefaultTemplate$1(element, elementTemplates, commandStack) {
  if (!elementTemplates.get(element) && elementTemplates.getDefault(element)) {
    const command = "propertiesPanel.zeebe.changeTemplate";
    const commandContext = {
      element,
      newTemplate: elementTemplates.getDefault(element)
    };
    commandStack.execute(command, commandContext);
  }
}
function validate2(descriptors, moddle) {
  return new Validator(moddle).addAll(descriptors).getErrors();
}
var PropertyBindingProvider = class {
  static create(element, options2) {
    const {
      property
    } = options2;
    const {
      binding,
      value
    } = property;
    const {
      name: name3
    } = binding;
    const businessObject = getBusinessObject(element);
    businessObject[name3] = value;
  }
};
var TaskDefinitionTypeBindingProvider = class {
  static create(element, options2) {
    const {
      property,
      bpmnFactory
    } = options2;
    const {
      value
    } = property;
    const extensionElements = getBusinessObject(element).get("extensionElements");
    const taskDefinition = createTaskDefinitionWithType(value, bpmnFactory);
    taskDefinition.$parent = extensionElements;
    extensionElements.get("values").push(taskDefinition);
  }
};
var InputBindingProvider = class {
  static create(element, options2) {
    const {
      property,
      bpmnFactory
    } = options2;
    const {
      binding,
      value
    } = property;
    const ioMapping = ensureExtension(element, "zeebe:IoMapping", bpmnFactory);
    if (!shouldUpdate(value, property)) {
      return;
    }
    const input = createInputParameter$1(binding, value, bpmnFactory);
    input.$parent = ioMapping;
    ioMapping.get("inputParameters").push(input);
  }
};
var OutputBindingProvider = class {
  static create(element, options2) {
    const {
      property,
      bpmnFactory
    } = options2;
    const {
      binding,
      value
    } = property;
    const ioMapping = ensureExtension(element, "zeebe:IoMapping", bpmnFactory);
    if (!shouldUpdate(value, property)) {
      return;
    }
    const output = createOutputParameter$1(binding, value, bpmnFactory);
    output.$parent = ioMapping;
    ioMapping.get("outputParameters").push(output);
  }
};
var TaskHeaderBindingProvider = class {
  static create(element, options2) {
    const {
      property,
      bpmnFactory
    } = options2;
    const {
      binding,
      value
    } = property;
    const taskHeaders = ensureExtension(element, "zeebe:TaskHeaders", bpmnFactory);
    const header = createTaskHeader(binding, value, bpmnFactory);
    header.$parent = taskHeaders;
    taskHeaders.get("values").push(header);
  }
};
var ZeebePropertiesProvider = class {
  static create(element, options2) {
    const {
      property,
      bpmnFactory
    } = options2;
    const {
      binding,
      value
    } = property;
    const zeebeProperties = ensureExtension(element, "zeebe:Properties", bpmnFactory);
    if (!shouldUpdate(value, property)) {
      return;
    }
    const zeebeProperty = createZeebeProperty(binding, value, bpmnFactory);
    zeebeProperty.$parent = zeebeProperties;
    zeebeProperties.get("properties").push(zeebeProperty);
  }
};
var TemplateElementFactory = class {
  constructor(bpmnFactory, elementFactory, moddle) {
    this._bpmnFactory = bpmnFactory;
    this._elementFactory = elementFactory;
    this._moddle = moddle;
    this._providers = {
      [PROPERTY_TYPE$1]: PropertyBindingProvider,
      [ZEEBE_TASK_DEFINITION_TYPE_TYPE]: TaskDefinitionTypeBindingProvider,
      [ZEBBE_PROPERTY_TYPE]: ZeebePropertiesProvider,
      [ZEBBE_INPUT_TYPE]: InputBindingProvider,
      [ZEEBE_OUTPUT_TYPE]: OutputBindingProvider,
      [ZEEBE_TASK_HEADER_TYPE]: TaskHeaderBindingProvider
    };
  }
  create(template) {
    const {
      appliesTo,
      elementType
    } = template;
    const elementFactory = this._elementFactory;
    const bpmnFactory = this._bpmnFactory;
    const moddle = this._moddle;
    const providers = this._providers;
    const errors = validate2([template], moddle);
    if (errors && errors.length) {
      throw new Error("template is invalid");
    }
    const type = elementType && elementType.value || appliesTo[0];
    const element = elementFactory.createShape({
      type
    });
    if (hasExtensionBindings(template)) {
      this._ensureExtensionElements(element);
    }
    this._setModelerTemplate(element, template);
    if (hasIcon(template)) {
      this._setModelerTemplateIcon(element, template);
    }
    const {
      properties
    } = applyConditions(element, template);
    properties.forEach(function(property) {
      const {
        binding
      } = property;
      const {
        type: bindingType
      } = binding;
      const bindingProvider = providers[bindingType];
      bindingProvider.create(element, {
        property,
        bpmnFactory
      });
    });
    return element;
  }
  _ensureExtensionElements(element) {
    const bpmnFactory = this._bpmnFactory;
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = bpmnFactory.create("bpmn:ExtensionElements", {
        values: []
      });
      extensionElements.$parent = businessObject;
      businessObject.set("extensionElements", extensionElements);
    }
    return extensionElements;
  }
  _setModelerTemplate(element, template) {
    const {
      id,
      version: version2
    } = template;
    const businessObject = getBusinessObject(element);
    businessObject.set("zeebe:modelerTemplate", id);
    businessObject.set("zeebe:modelerTemplateVersion", version2);
  }
  _setModelerTemplateIcon(element, template) {
    const {
      icon
    } = template;
    const {
      contents
    } = icon;
    const businessObject = getBusinessObject(element);
    businessObject.set("zeebe:modelerTemplateIcon", contents);
  }
};
TemplateElementFactory.$inject = ["bpmnFactory", "elementFactory", "moddle"];
function hasExtensionBindings(template) {
  const {
    properties
  } = template;
  if (hasIcon(template)) {
    return true;
  }
  return (0, import_min_dash147.find)(properties, function(property) {
    const {
      binding
    } = property;
    return EXTENSION_BINDING_TYPES$1.includes(binding.type);
  });
}
function hasIcon(template) {
  const {
    icon
  } = template;
  return !!(icon && icon.contents);
}
function createElementTemplatesGroup(props = {}) {
  const {
    getTemplateId: getTemplateId$12 = getTemplateId,
    unlinkTemplate: unlinkTemplate2 = unlinkTemplate$1,
    updateTemplate: updateTemplate2 = updateTemplate$1
  } = props;
  return function ElementTemplatesGroup(props2) {
    const {
      id,
      label,
      element,
      entries = []
    } = props2;
    const [open3, setOpen] = useLayoutState(["groups", id, "open"], false);
    const empty = !entries.length;
    const toggleOpen = () => !empty && setOpen(!open3);
    return o5("div", {
      class: "bio-properties-panel-group bio-properties-panel-templates-group",
      "data-group-id": "group-" + id,
      children: [o5("div", {
        class: (0, import_classnames2.default)("bio-properties-panel-group-header", {
          empty,
          open: open3 && !empty
        }),
        onClick: toggleOpen,
        children: [o5("div", {
          title: label,
          class: "bio-properties-panel-group-header-title",
          children: label
        }), o5("div", {
          class: "bio-properties-panel-group-header-buttons",
          children: [o5(TemplateGroupButtons, {
            element,
            getTemplateId: getTemplateId$12,
            unlinkTemplate: unlinkTemplate2,
            updateTemplate: updateTemplate2
          }), !empty && o5(SectionToggle, {
            open: open3
          })]
        })]
      }), o5("div", {
        class: (0, import_classnames2.default)("bio-properties-panel-group-entries", {
          open: open3 && !empty
        }),
        children: entries.map((entry) => {
          const {
            component: Component,
            id: id2
          } = entry;
          return a3(Component, {
            ...entry,
            key: id2,
            element
          });
        })
      })]
    });
  };
}
function SectionToggle({
  open: open3
}) {
  return o5(HeaderButton, {
    title: "Toggle section",
    class: "bio-properties-panel-arrow",
    children: o5(ArrowIcon, {
      class: open3 ? "bio-properties-panel-arrow-down" : "bio-properties-panel-arrow-right"
    })
  });
}
function TemplateGroupButtons({
  element,
  getTemplateId: getTemplateId2,
  unlinkTemplate: unlinkTemplate2,
  updateTemplate: updateTemplate2
}) {
  const elementTemplates = useService("elementTemplates");
  const templateState = getTemplateState(elementTemplates, element, getTemplateId2);
  if (templateState.type === "NO_TEMPLATE") {
    return o5(SelectEntryTemplate, {
      element
    });
  } else if (templateState.type === "KNOWN_TEMPLATE") {
    return o5(AppliedTemplate, {
      element,
      unlinkTemplate: unlinkTemplate2
    });
  } else if (templateState.type === "UNKNOWN_TEMPLATE") {
    return o5(UnknownTemplate, {
      element,
      unlinkTemplate: unlinkTemplate2
    });
  } else if (templateState.type === "OUTDATED_TEMPLATE") {
    return o5(OutdatedTemplate, {
      element,
      templateState,
      unlinkTemplate: unlinkTemplate2,
      updateTemplate: updateTemplate2
    });
  }
}
function SelectEntryTemplate({
  element
}) {
  const translate3 = useService("translate");
  const eventBus = useService("eventBus");
  const selectTemplate = () => eventBus.fire("elementTemplates.select", {
    element
  });
  return o5(HeaderButton, {
    title: "Select a template",
    class: "bio-properties-panel-select-template-button",
    onClick: selectTemplate,
    children: [o5(CreateIcon, {}), o5("span", {
      children: translate3("Select")
    })]
  });
}
function AppliedTemplate({
  element,
  unlinkTemplate: unlinkTemplate2
}) {
  const translate3 = useService("translate"), injector = useService("injector");
  const menuItems = [{
    entry: translate3("Unlink"),
    action: () => unlinkTemplate2(element, injector)
  }, {
    entry: o5(RemoveTemplate, {}),
    action: () => removeTemplate(element, injector)
  }];
  return o5(DropdownButton, {
    menuItems,
    class: "bio-properties-panel-applied-template-button",
    children: o5(HeaderButton, {
      children: [o5("span", {
        children: translate3("Applied")
      }), o5(ArrowIcon, {
        class: "bio-properties-panel-arrow-down"
      })]
    })
  });
}
function RemoveTemplate() {
  const translate3 = useService("translate");
  return o5("span", {
    class: "bio-properties-panel-remove-template",
    children: translate3("Remove")
  });
}
function UnknownTemplate({
  element,
  unlinkTemplate: unlinkTemplate2
}) {
  const translate3 = useService("translate"), injector = useService("injector");
  const menuItems = [{
    entry: o5(NotFoundText, {})
  }, {
    separator: true
  }, {
    entry: translate3("Unlink"),
    action: () => unlinkTemplate2(element, injector)
  }, {
    entry: o5(RemoveTemplate, {}),
    action: () => removeTemplate(element, injector)
  }];
  return o5(DropdownButton, {
    menuItems,
    class: "bio-properties-panel-template-not-found",
    children: o5(HeaderButton, {
      children: [o5("span", {
        children: translate3("Not found")
      }), o5(ArrowIcon, {
        class: "bio-properties-panel-arrow-down"
      })]
    })
  });
}
function NotFoundText() {
  const translate3 = useService("translate");
  return o5("div", {
    class: "bio-properties-panel-template-not-found-text",
    children: translate3("The template applied was not found. Therefore, its properties cannot be shown. Unlink to access the data.")
  });
}
function OutdatedTemplate({
  element,
  templateState,
  unlinkTemplate: unlinkTemplate2,
  updateTemplate: updateTemplate2
}) {
  const {
    newerTemplate
  } = templateState;
  const translate3 = useService("translate"), injector = useService("injector");
  const menuItems = [{
    entry: o5(UpdateAvailableText, {
      newerTemplate
    })
  }, {
    separator: true
  }, {
    entry: translate3("Update"),
    action: () => updateTemplate2(element, newerTemplate, injector)
  }, {
    entry: translate3("Unlink"),
    action: () => unlinkTemplate2(element, injector)
  }, {
    entry: o5(RemoveTemplate, {}),
    action: () => removeTemplate(element, injector)
  }];
  return o5(DropdownButton, {
    menuItems,
    class: "bio-properties-panel-template-update-available",
    children: o5(HeaderButton, {
      children: [o5("span", {
        children: translate3("Update available")
      }), o5(ArrowIcon, {
        class: "bio-properties-panel-arrow-down"
      })]
    })
  });
}
function UpdateAvailableText({
  newerTemplate
}) {
  const translate3 = useService("translate");
  const text = translate3("A new version of the template is available: {templateVersion}", {
    templateVersion: getVersionOrDateFromTemplate(newerTemplate)
  });
  return o5("div", {
    class: "bio-properties-panel-template-update-available-text",
    children: text
  });
}
function getTemplateState(elementTemplates, element, getTemplateId2) {
  const templateId = getTemplateId2(element), template = elementTemplates.get(element);
  if (!templateId) {
    return {
      type: "NO_TEMPLATE"
    };
  }
  if (!template) {
    return {
      type: "UNKNOWN_TEMPLATE",
      templateId
    };
  }
  const newerTemplate = elementTemplates.getLatest(templateId, {
    deprecated: true
  })[0];
  if (newerTemplate !== template) {
    return {
      type: "OUTDATED_TEMPLATE",
      template,
      newerTemplate
    };
  }
  return {
    type: "KNOWN_TEMPLATE",
    template
  };
}
function TemplateProps({
  element,
  elementTemplates
}) {
  const template = elementTemplates.get(element);
  if (!template) {
    return [];
  }
  return [{
    id: "template-name",
    component: TemplateName,
    template
  }, {
    id: "template-version",
    component: TemplateVersion,
    template
  }, {
    id: "template-description",
    component: TemplateDescription,
    template
  }].filter((entry) => !!entry.component);
}
function TemplateName({
  id,
  template
}) {
  const translate3 = useService("translate");
  return o5(TextEntry, {
    id,
    label: translate3("Name"),
    content: template.name
  });
}
function TemplateVersion({
  id,
  template
}) {
  const translate3 = useService("translate");
  const version2 = getVersionOrDateFromTemplate(template);
  return version2 ? o5(TextEntry, {
    id,
    label: translate3("Version"),
    content: version2
  }) : null;
}
function TemplateDescription({
  id,
  template
}) {
  const translate3 = useService("translate");
  const {
    description
  } = template;
  return description ? o5(TextEntry, {
    id,
    label: translate3("Description"),
    content: template.description
  }) : null;
}
function TextEntry({
  id,
  label,
  content
}) {
  return o5("div", {
    "data-entry-id": id,
    class: "bio-properties-panel-entry bio-properties-panel-text-entry",
    children: [o5("span", {
      class: "bio-properties-panel-label",
      children: label
    }), o5("span", {
      class: "bio-properties-panel-text-entry__content",
      children: content
    })]
  });
}
var e6;
var o6 = {};
function n4(r6, t6, e7) {
  if (r6.nodeType === 3) {
    var o7 = "textContent" in r6 ? r6.textContent : r6.nodeValue || "";
    if (n4.options.trim !== false) {
      var a6 = t6 === 0 || t6 === e7.length - 1;
      if ((!(o7 = o7.match(/^[\s\n]+$/g) && n4.options.trim !== "all" ? " " : o7.replace(/(^[\s\n]+|[\s\n]+$)/g, n4.options.trim === "all" || a6 ? "" : " ")) || o7 === " ") && e7.length > 1 && a6)
        return null;
    }
    return o7;
  }
  if (r6.nodeType !== 1)
    return null;
  var p6 = String(r6.nodeName).toLowerCase();
  if (p6 === "script" && !n4.options.allowScripts)
    return null;
  var l6, s5, u5 = n4.h(p6, function(r7) {
    var t7 = r7 && r7.length;
    if (!t7)
      return null;
    for (var e8 = {}, o8 = 0; o8 < t7; o8++) {
      var a7 = r7[o8], i6 = a7.name, p7 = a7.value;
      i6.substring(0, 2) === "on" && n4.options.allowEvents && (p7 = new Function(p7)), e8[i6] = p7;
    }
    return e8;
  }(r6.attributes), (s5 = (l6 = r6.childNodes) && Array.prototype.map.call(l6, n4).filter(i5)) && s5.length ? s5 : null);
  return n4.visitor && n4.visitor(u5), u5;
}
var a5;
var i5 = function(r6) {
  return r6;
};
var p5 = {};
function l5(r6) {
  var t6 = (r6.type || "").toLowerCase(), e7 = l5.map;
  e7 && e7.hasOwnProperty(t6) ? (r6.type = e7[t6], r6.props = Object.keys(r6.props || {}).reduce(function(t7, e8) {
    var o7;
    return t7[o7 = e8, o7.replace(/-(.)/g, function(r7, t8) {
      return t8.toUpperCase();
    })] = r6.props[e8], t7;
  }, {})) : r6.type = t6.replace(/[^a-z0-9-]/i, "");
}
var Markup = function(t6) {
  function i6() {
    t6.apply(this, arguments);
  }
  return t6 && (i6.__proto__ = t6), (i6.prototype = Object.create(t6 && t6.prototype)).constructor = i6, i6.setReviver = function(r6) {
    a5 = r6;
  }, i6.prototype.shouldComponentUpdate = function(r6) {
    var t7 = this.props;
    return r6.wrap !== t7.wrap || r6.type !== t7.type || r6.markup !== t7.markup;
  }, i6.prototype.setComponents = function(r6) {
    if (this.map = {}, r6) {
      for (var t7 in r6)
        if (r6.hasOwnProperty(t7)) {
          var e7 = t7.replace(/([A-Z]+)([A-Z][a-z0-9])|([a-z0-9]+)([A-Z])/g, "$1$3-$2$4").toLowerCase();
          this.map[e7] = r6[t7];
        }
    }
  }, i6.prototype.render = function(t7) {
    var i7 = t7.wrap;
    i7 === void 0 && (i7 = true);
    var s5, u5 = t7.type, c5 = t7.markup, m6 = t7.components, v5 = t7.reviver, f5 = t7.onError, d5 = t7["allow-scripts"], h$1 = t7["allow-events"], y4 = t7.trim, w6 = function(r6, t8) {
      var e7 = {};
      for (var o7 in r6)
        Object.prototype.hasOwnProperty.call(r6, o7) && t8.indexOf(o7) === -1 && (e7[o7] = r6[o7]);
      return e7;
    }(t7, ["wrap", "type", "markup", "components", "reviver", "onError", "allow-scripts", "allow-events", "trim"]), C4 = v5 || this.reviver || this.constructor.prototype.reviver || a5 || a3;
    this.setComponents(m6);
    var g6 = {
      allowScripts: d5,
      allowEvents: h$1,
      trim: y4
    };
    try {
      s5 = function(r6, t8, a6, i8, s6) {
        var u6 = function(r7, t9) {
          var o7, n5, a7, i9, p6 = t9 === "html" ? "text/html" : "application/xml";
          t9 === "html" ? (i9 = "body", a7 = "<!DOCTYPE html>\n<html><body>" + r7 + "</body></html>") : (i9 = "xml", a7 = '<?xml version="1.0" encoding="UTF-8"?>\n<xml>' + r7 + "</xml>");
          try {
            o7 = new DOMParser().parseFromString(a7, p6);
          } catch (r8) {
            n5 = r8;
          }
          if (o7 || t9 !== "html" || ((o7 = e6 || (e6 = function() {
            if (document.implementation && document.implementation.createHTMLDocument)
              return document.implementation.createHTMLDocument("");
            var r8 = document.createElement("iframe");
            return r8.style.cssText = "position:absolute; left:0; top:-999em; width:1px; height:1px; overflow:hidden;", r8.setAttribute("sandbox", "allow-forms"), document.body.appendChild(r8), r8.contentWindow.document;
          }())).open(), o7.write(a7), o7.close()), o7) {
            var l6 = o7.getElementsByTagName(i9)[0], s7 = l6.firstChild;
            return r7 && !s7 && (l6.error = "Document parse failed."), s7 && String(s7.nodeName).toLowerCase() === "parsererror" && (s7.removeChild(s7.firstChild), s7.removeChild(s7.lastChild), l6.error = s7.textContent || s7.nodeValue || n5 || "Unknown error", l6.removeChild(s7)), l6;
          }
        }(r6, t8);
        if (u6 && u6.error)
          throw new Error(u6.error);
        var c6 = u6 && u6.body || u6;
        l5.map = i8 || p5;
        var m7 = c6 && function(r7, t9, e7, a7) {
          return n4.visitor = t9, n4.h = e7, n4.options = a7 || o6, n4(r7);
        }(c6, l5, a6, s6);
        return l5.map = null, m7 && m7.props && m7.props.children || null;
      }(c5, u5, C4, this.map, g6);
    } catch (r6) {
      f5 ? f5({
        error: r6
      }) : typeof console != "undefined" && console.error && console.error("preact-markup: " + r6);
    }
    if (i7 === false)
      return s5 || null;
    var x4 = w6.hasOwnProperty("className") ? "className" : "class", b5 = w6[x4];
    return b5 ? b5.splice ? b5.splice(0, 0, "markup") : typeof b5 == "string" ? w6[x4] += " markup" : typeof b5 == "object" && (b5.markup = true) : w6[x4] = "markup", C4("div", w6, s5 || null);
  }, i6;
}(p3);
var NODE_TYPE_TEXT = 3;
var NODE_TYPE_ELEMENT = 1;
var ALLOWED_NODES = ["h1", "h2", "h3", "h4", "h5", "span", "em", "a", "p", "div", "ul", "ol", "li", "hr", "blockquote", "img", "pre", "code", "br", "strong"];
var ALLOWED_ATTRIBUTES = ["align", "alt", "class", "href", "id", "name", "rel", "target", "src"];
var ALLOWED_URI_PATTERN = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i;
var ATTR_WHITESPACE_PATTERN = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
var FORM_ELEMENT = document.createElement("form");
function sanitizeHTML(html) {
  const doc = new DOMParser().parseFromString(`<!DOCTYPE html>
<html><body><div>${html}`, "text/html");
  doc.normalize();
  const element = doc.body.firstChild;
  if (element) {
    sanitizeNode(element);
    return new XMLSerializer().serializeToString(element);
  } else {
    return "";
  }
}
function sanitizeNode(node2) {
  if (node2.nodeType === NODE_TYPE_TEXT) {
    return;
  }
  if (node2.nodeType !== NODE_TYPE_ELEMENT) {
    return node2.remove();
  }
  const lcTag = node2.tagName.toLowerCase();
  if (!ALLOWED_NODES.includes(lcTag)) {
    return node2.remove();
  }
  const attributes = node2.attributes;
  for (let i6 = attributes.length; i6--; ) {
    const attribute = attributes[i6];
    const name3 = attribute.name;
    const lcName = name3.toLowerCase();
    const value = attribute.value.trim();
    node2.removeAttribute(name3);
    const valid = isValidAttribute(lcTag, lcName, value);
    if (valid) {
      node2.setAttribute(name3, value);
    }
  }
  if (lcTag === "a" && node2.getAttribute("target") === "_blank" && node2.getAttribute("rel") !== "noopener") {
    node2.setAttribute("rel", "noopener");
  }
  for (let i6 = node2.childNodes.length; i6--; ) {
    sanitizeNode(node2.childNodes[i6]);
  }
}
function isValidAttribute(lcTag, lcName, value) {
  if (!ALLOWED_ATTRIBUTES.includes(lcName)) {
    return false;
  }
  if ((lcName === "id" || lcName === "name") && (value in document || value in FORM_ELEMENT)) {
    return false;
  }
  if (lcName === "target" && value !== "_blank") {
    return false;
  }
  if (lcName === "href" && !ALLOWED_URI_PATTERN.test(value.replace(ATTR_WHITESPACE_PATTERN, ""))) {
    return false;
  }
  return true;
}
function PropertyDescription(props) {
  const {
    description
  } = props;
  return description && o5(Markup, {
    markup: sanitizeHTML(description),
    trim: false
  });
}
var DEFAULT_CUSTOM_GROUP$1 = {
  id: "ElementTemplates__CustomProperties",
  label: "Custom properties"
};
function CustomProperties$1(props) {
  const {
    element,
    elementTemplate
  } = props;
  const groups = [];
  const {
    id,
    properties,
    groups: propertyGroups
  } = elementTemplate;
  const groupedProperties = groupByGroupId$1(properties);
  const defaultProps = [];
  (0, import_min_dash147.forEach)(groupedProperties, (properties2, groupId) => {
    const group = findCustomGroup$1(propertyGroups, groupId);
    if (!group) {
      return defaultProps.push(...properties2);
    }
    addCustomGroup$1(groups, {
      element,
      id: `ElementTemplates__CustomProperties-${groupId}`,
      label: group.label,
      properties: properties2,
      templateId: `${id}-${groupId}`
    });
  });
  if (defaultProps.length) {
    addCustomGroup$1(groups, {
      ...DEFAULT_CUSTOM_GROUP$1,
      element,
      properties: defaultProps,
      templateId: id
    });
  }
  return groups;
}
function addCustomGroup$1(groups, props) {
  const {
    element,
    id,
    label,
    properties,
    templateId
  } = props;
  const customPropertiesGroup = {
    id,
    label,
    component: Group,
    entries: [],
    shouldOpen: true
  };
  properties.forEach((property, index2) => {
    const entry = createCustomEntry$1(`custom-entry-${templateId}-${index2}`, element, property);
    if (entry) {
      customPropertiesGroup.entries.push(entry);
    }
  });
  if (customPropertiesGroup.entries.length) {
    groups.push(customPropertiesGroup);
  }
}
function createCustomEntry$1(id, element, property) {
  let {
    type,
    feel
  } = property;
  if (!type) {
    type = getDefaultType$1(property);
  }
  if (type === "Boolean") {
    return {
      id,
      component: BooleanProperty$1,
      isEdited: isEdited$7,
      property
    };
  }
  if (type === "Dropdown") {
    return {
      id,
      component: DropdownProperty$1,
      isEdited: isEdited$4,
      property
    };
  }
  if (type === "String") {
    if (feel) {
      return {
        id,
        component: FeelProperty,
        isEdited: isEdited$6,
        property
      };
    }
    return {
      id,
      component: StringProperty$1,
      isEdited: isEdited$1,
      property
    };
  }
  if (type === "Text") {
    if (feel) {
      return {
        id,
        component: FeelTextAreaProperty,
        isEdited: isEdited$6,
        property
      };
    }
    return {
      id,
      component: TextAreaProperty$1,
      isEdited: isEdited$2,
      property
    };
  }
}
function getDefaultType$1(property) {
  const {
    binding
  } = property;
  const {
    type
  } = binding;
  if ([PROPERTY_TYPE$1, ZEEBE_TASK_DEFINITION_TYPE_TYPE, ZEBBE_INPUT_TYPE, ZEEBE_OUTPUT_TYPE, ZEEBE_PROPERTY_TYPE, ZEEBE_TASK_HEADER_TYPE].includes(type)) {
    return "String";
  }
}
function BooleanProperty$1(props) {
  const {
    element,
    id,
    property
  } = props;
  const {
    description,
    editable,
    label
  } = property;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack");
  return CheckboxEntry({
    element,
    getValue: propertyGetter$1(element, property),
    id,
    label,
    description: PropertyDescription({
      description
    }),
    setValue: propertySetter$1(bpmnFactory, commandStack, element, property),
    disabled: editable === false
  });
}
function DropdownProperty$1(props) {
  const {
    element,
    id,
    property
  } = props;
  const {
    description,
    editable,
    label
  } = property;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack");
  const getOptions = () => {
    const {
      choices
    } = property;
    return choices.map(({
      name: name3,
      value
    }) => {
      return {
        label: name3,
        value
      };
    });
  };
  return SelectEntry({
    element,
    id,
    label,
    getOptions,
    description: PropertyDescription({
      description
    }),
    getValue: propertyGetter$1(element, property),
    setValue: propertySetter$1(bpmnFactory, commandStack, element, property),
    disabled: editable === false
  });
}
function FeelTextAreaProperty(props) {
  const {
    element,
    id,
    property
  } = props;
  const {
    description,
    editable,
    label,
    feel
  } = property;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack"), debounce4 = useService("debounceInput"), translate3 = useService("translate");
  return FeelTextAreaEntryWithContext({
    debounce: debounce4,
    element,
    getValue: propertyGetter$1(element, property),
    id,
    label,
    feel,
    description: PropertyDescription({
      description
    }),
    setValue: propertySetter$1(bpmnFactory, commandStack, element, property),
    validate: propertyValidator$1(translate3, property),
    disabled: editable === false
  });
}
function FeelProperty(props) {
  const {
    element,
    id,
    property
  } = props;
  const {
    description,
    editable,
    label,
    feel
  } = property;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack"), debounce4 = useService("debounceInput"), translate3 = useService("translate");
  return FeelEntryWithContext({
    debounce: debounce4,
    element,
    getValue: propertyGetter$1(element, property),
    id,
    label,
    feel,
    description: PropertyDescription({
      description
    }),
    setValue: propertySetter$1(bpmnFactory, commandStack, element, property),
    validate: propertyValidator$1(translate3, property),
    disabled: editable === false
  });
}
function StringProperty$1(props) {
  const {
    element,
    id,
    property
  } = props;
  const {
    description,
    editable,
    label,
    feel
  } = property;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack"), debounce4 = useService("debounceInput"), translate3 = useService("translate");
  return TextfieldEntry({
    debounce: debounce4,
    element,
    getValue: propertyGetter$1(element, property),
    id,
    label,
    feel,
    description: PropertyDescription({
      description
    }),
    setValue: propertySetter$1(bpmnFactory, commandStack, element, property),
    validate: propertyValidator$1(translate3, property),
    disabled: editable === false
  });
}
function TextAreaProperty$1(props) {
  const {
    element,
    id,
    property
  } = props;
  const {
    description,
    editable,
    label,
    feel
  } = property;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack"), debounce4 = useService("debounceInput");
  return TextAreaEntry({
    debounce: debounce4,
    element,
    id,
    label,
    feel,
    description: PropertyDescription({
      description
    }),
    getValue: propertyGetter$1(element, property),
    setValue: propertySetter$1(bpmnFactory, commandStack, element, property),
    disabled: editable === false
  });
}
function propertyGetter$1(element, property) {
  return function getValue2() {
    return getPropertyValue$1(element, property);
  };
}
function propertySetter$1(bpmnFactory, commandStack, element, property) {
  return function getValue2(value) {
    return setPropertyValue(bpmnFactory, commandStack, element, property, value);
  };
}
function propertyValidator$1(translate3, property) {
  return function validate3(value) {
    const {
      constraints = {}
    } = property;
    const {
      maxLength,
      minLength,
      notEmpty
    } = constraints;
    if (notEmpty && isEmptyString$1(value)) {
      return translate3("Must not be empty.");
    }
    if (maxLength && value.length > maxLength) {
      return translate3("Must have max length {maxLength}.", {
        maxLength
      });
    }
    if (minLength && value.length < minLength) {
      return translate3("Must have min length {minLength}.", {
        minLength
      });
    }
    let {
      pattern
    } = constraints;
    if (pattern) {
      let message;
      if (!(0, import_min_dash147.isString)(pattern)) {
        message = pattern.message;
        pattern = pattern.value;
      }
      if (!matchesPattern$1(value, pattern)) {
        return message || translate3("Must match pattern {pattern}.", {
          pattern
        });
      }
    }
  };
}
function isEmptyString$1(string) {
  return !string || !string.trim().length;
}
function matchesPattern$1(string, pattern) {
  return new RegExp(pattern).test(string);
}
function groupByGroupId$1(properties) {
  return (0, import_min_dash147.groupBy)(properties, "group");
}
function findCustomGroup$1(groups, id) {
  return (0, import_min_dash147.find)(groups, (g6) => g6.id === id);
}
var LOWER_PRIORITY$1 = 300;
var ElementTemplatesPropertiesProvider$1 = class {
  constructor(elementTemplates, propertiesPanel, injector) {
    propertiesPanel.registerProvider(LOWER_PRIORITY$1, this);
    this._elementTemplates = elementTemplates;
    this._injector = injector;
  }
  getGroups(element) {
    return (groups) => {
      if (!this._shouldShowTemplateProperties(element)) {
        return groups;
      }
      groups = groups.slice();
      const templatesGroup = {
        element,
        id: "ElementTemplates__Template",
        label: "Template",
        component: createElementTemplatesGroup({
          getTemplateId: getTemplateId$1,
          unlinkTemplate,
          updateTemplate
        }),
        entries: TemplateProps({
          element,
          elementTemplates: this._elementTemplates
        })
      };
      addGroupsAfter$1("documentation", groups, [templatesGroup]);
      let elementTemplate = this._elementTemplates.get(element);
      if (elementTemplate) {
        elementTemplate = applyConditions(element, elementTemplate);
        const templateSpecificGroups = [].concat(CustomProperties$1({
          element,
          elementTemplate
        }));
        addGroupsAfter$1("ElementTemplates__Template", groups, templateSpecificGroups);
      }
      if (getTemplateId$1(element)) {
        groups = filterWithEntriesVisible$1(elementTemplate || {}, groups);
      }
      return groups;
    };
  }
  _shouldShowTemplateProperties(element) {
    return getTemplateId$1(element) || this._elementTemplates.getAll(element).length;
  }
};
ElementTemplatesPropertiesProvider$1.$inject = ["elementTemplates", "propertiesPanel", "injector"];
function addGroupsAfter$1(id, groups, groupsToAdd) {
  const index2 = groups.findIndex((group) => group.id === id);
  if (index2 !== -1) {
    groups.splice(index2 + 1, 0, ...groupsToAdd);
  } else {
    groups.unshift(...groupsToAdd);
  }
}
function filterWithEntriesVisible$1(template, groups) {
  if (!template.entriesVisible) {
    return groups.filter((group) => {
      return group.id === "general" || group.id.startsWith("ElementTemplates__");
    });
  }
  return groups;
}
var ReplaceBehavior = class extends CommandInterceptor {
  constructor(elementTemplates, injector) {
    super(injector.get("eventBus"));
    this.postExecuted("shape.replace", function(e7) {
      var context = e7.context, oldShape = context.oldShape, oldBo = getBusinessObject(oldShape), newShape = context.newShape, newBo = getBusinessObject(newShape);
      if (!oldBo.modelerTemplate) {
        return;
      }
      const template = newBo.modelerTemplate;
      const version2 = newBo.modelerTemplateVersion;
      const elementTemplate = elementTemplates.get(template, version2);
      if (!elementTemplate) {
        unlinkTemplate$1(newShape, injector);
        return;
      }
      const {
        appliesTo,
        elementType
      } = elementTemplate;
      if (elementType) {
        if (!is(newShape, elementType.value)) {
          unlinkTemplate$1(newShape, injector);
        }
        return;
      }
      const allowed = appliesTo.reduce((allowed2, type) => {
        return allowed2 || is(newBo, type);
      }, false);
      if (!allowed) {
        unlinkTemplate$1(newShape, injector);
      }
    });
  }
};
ReplaceBehavior.$inject = ["elementTemplates", "injector"];
function handleLegacyScopes(scopes = []) {
  const scopesAsArray = [];
  if (!(0, import_min_dash147.isObject)(scopes)) {
    return scopes;
  }
  (0, import_min_dash147.forEach)((0, import_min_dash147.keys)(scopes), function(scopeName) {
    scopesAsArray.push((0, import_min_dash147.assign)({
      type: scopeName
    }, scopes[scopeName]));
  });
  return scopesAsArray;
}
function createInputParameter(binding, value, bpmnFactory) {
  const {
    name: name3,
    scriptFormat
  } = binding;
  let parameterValue, parameterDefinition;
  if (scriptFormat) {
    parameterDefinition = bpmnFactory.create("camunda:Script", {
      scriptFormat,
      value
    });
  } else {
    parameterValue = value;
  }
  return bpmnFactory.create("camunda:InputParameter", {
    name: name3,
    value: parameterValue,
    definition: parameterDefinition
  });
}
function createOutputParameter(binding, value, bpmnFactory) {
  const {
    scriptFormat,
    source
  } = binding;
  let parameterValue, parameterDefinition;
  if (scriptFormat) {
    parameterDefinition = bpmnFactory.create("camunda:Script", {
      scriptFormat,
      value: source
    });
  } else {
    parameterValue = source;
  }
  return bpmnFactory.create("camunda:OutputParameter", {
    name: value,
    value: parameterValue,
    definition: parameterDefinition
  });
}
function createCamundaProperty(binding, value = "", bpmnFactory) {
  const {
    name: name3
  } = binding;
  return bpmnFactory.create("camunda:Property", {
    name: name3,
    value
  });
}
function createCamundaIn(binding, value, bpmnFactory) {
  const attrs = createCamundaInOutAttrs(binding, value);
  return bpmnFactory.create("camunda:In", attrs);
}
function createCamundaInWithBusinessKey(value, bpmnFactory) {
  return bpmnFactory.create("camunda:In", {
    businessKey: value
  });
}
function createCamundaOut(binding, value, bpmnFactory) {
  const attrs = createCamundaInOutAttrs(binding, value);
  return bpmnFactory.create("camunda:Out", attrs);
}
function createCamundaExecutionListenerScript(binding, value, bpmnFactory) {
  const {
    event: event2,
    scriptFormat
  } = binding;
  let parameterValue, parameterDefinition;
  if (scriptFormat) {
    parameterDefinition = bpmnFactory.create("camunda:Script", {
      scriptFormat,
      value
    });
  } else {
    parameterValue = value;
  }
  return bpmnFactory.create("camunda:ExecutionListener", {
    event: event2,
    value: parameterValue,
    script: parameterDefinition
  });
}
function createCamundaFieldInjection(binding, value, bpmnFactory) {
  const DEFAULT_PROPS2 = {
    "string": void 0,
    "expression": void 0,
    "name": void 0
  };
  const props = (0, import_min_dash147.assign)({}, DEFAULT_PROPS2);
  const {
    expression,
    name: name3
  } = binding;
  if (!expression) {
    props.string = value;
  } else {
    props.expression = value;
  }
  props.name = name3;
  return bpmnFactory.create("camunda:Field", props);
}
function createCamundaErrorEventDefinition(expression, errorRef, parent, bpmnFactory) {
  const errorEventDefinition = bpmnFactory.create("camunda:ErrorEventDefinition", {
    errorRef,
    expression
  });
  errorEventDefinition.$parent = parent;
  return errorEventDefinition;
}
function createError(bindingErrorRef, parent, bpmnFactory) {
  const error4 = bpmnFactory.create("bpmn:Error", {
    id: nextId("Error_" + bindingErrorRef + "_")
  });
  error4.$parent = parent;
  return error4;
}
function createCamundaInOutAttrs(binding, value) {
  const properties = {};
  const {
    expression,
    source,
    sourceExpression,
    target,
    type,
    variables: variables2
  } = binding;
  if (type === "camunda:in") {
    if (target && !expression && !variables2) {
      properties.target = target;
      properties.source = value;
    } else if (target && expression === true && !variables2) {
      properties.target = target;
      properties.sourceExpression = value;
    } else if (!target && !expression && variables2 === "local") {
      properties.local = true;
      properties.variables = "all";
    } else if (target && !expression && variables2 === "local") {
      properties.local = true;
      properties.source = value;
      properties.target = target;
    } else if (target && expression && variables2 === "local") {
      properties.local = true;
      properties.sourceExpression = value;
      properties.target = target;
    } else if (!target && !expression && variables2 === "all") {
      properties.variables = "all";
    } else {
      throw new Error("invalid configuration for camunda:in element template binding");
    }
  }
  if (type === "camunda:out") {
    if (source && !sourceExpression && !variables2) {
      properties.target = value;
      properties.source = source;
    } else if (!source && sourceExpression && !variables2) {
      properties.target = value;
      properties.sourceExpression = sourceExpression;
    } else if (!source && !sourceExpression && variables2 === "all") {
      properties.variables = "all";
    } else if (source && !sourceExpression && variables2 === "local") {
      properties.local = true;
      properties.source = source;
      properties.target = value;
    } else if (!source && sourceExpression && variables2 === "local") {
      properties.local = true;
      properties.sourceExpression = sourceExpression;
      properties.target = value;
    } else if (!source && !sourceExpression && variables2 === "local") {
      properties.local = true;
      properties.variables = "all";
    } else {
      throw new Error("invalid configuration for camunda:out element template binding");
    }
  }
  return properties;
}
var CAMUNDA_SERVICE_TASK_LIKE = ["camunda:class", "camunda:delegateExpression", "camunda:expression"];
var ChangeElementTemplateHandler = class {
  constructor(bpmnFactory, bpmnReplace, commandStack, modeling) {
    this._bpmnFactory = bpmnFactory;
    this._bpmnReplace = bpmnReplace;
    this._commandStack = commandStack;
    this._modeling = modeling;
  }
  preExecute(context) {
    const newTemplate = context.newTemplate, oldTemplate = context.oldTemplate;
    let element = context.element;
    this._updateCamundaModelerTemplate(element, newTemplate);
    if (newTemplate) {
      element = context.element = this._updateTaskType(element, newTemplate);
      this._updateProperties(element, oldTemplate, newTemplate);
      this._updateCamundaExecutionListenerProperties(element, newTemplate);
      this._updateCamundaFieldProperties(element, oldTemplate, newTemplate);
      this._updateCamundaInOutProperties(element, oldTemplate, newTemplate);
      this._updateCamundaInputOutputParameterProperties(element, oldTemplate, newTemplate);
      this._updateCamundaPropertyProperties(element, oldTemplate, newTemplate);
      this._updateCamundaErrorEventDefinitionProperties(element, oldTemplate, newTemplate);
      handleLegacyScopes(newTemplate.scopes).forEach((newScopeTemplate) => {
        this._updateScopeProperties(element, oldTemplate, newScopeTemplate, newTemplate);
      });
    }
  }
  _getOrCreateExtensionElements(element) {
    const bpmnFactory = this._bpmnFactory, modeling = this._modeling;
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = bpmnFactory.create("bpmn:ExtensionElements", {
        values: []
      });
      extensionElements.$parent = businessObject;
      modeling.updateProperties(element, {
        extensionElements
      });
    }
    return extensionElements;
  }
  _updateCamundaErrorEventDefinitionProperties(element, oldTemplate, newTemplate) {
    const bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
    const newProperties = newTemplate.properties.filter((newProperty) => {
      const newBinding = newProperty.binding, newBindingType = newBinding.type;
      return newBindingType === "camunda:errorEventDefinition";
    });
    if (!newProperties.length) {
      return;
    }
    const extensionElements = this._getOrCreateExtensionElements(element);
    const oldErrorEventDefinitions = findExtensions(element, ["camunda:ErrorEventDefinition"]);
    newProperties.forEach((newProperty) => {
      const oldProperty = findOldProperty(oldTemplate, newProperty), oldEventDefinition = oldProperty && findOldBusinessObject(extensionElements, oldProperty), newBinding = newProperty.binding;
      if (oldProperty && oldEventDefinition) {
        if (!propertyChanged(oldEventDefinition, oldProperty)) {
          commandStack.execute("element.updateModdleProperties", {
            element,
            moddleElement: oldEventDefinition,
            properties: {
              expression: newProperty.value
            }
          });
        }
        remove4(oldErrorEventDefinitions, oldEventDefinition);
      } else {
        const rootElement = getRoot(getBusinessObject(element)), newError = createError(newBinding.errorRef, rootElement, bpmnFactory), newEventDefinition = createCamundaErrorEventDefinition(newProperty.value, newError, extensionElements, bpmnFactory);
        commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: rootElement,
          properties: {
            rootElements: [...rootElement.get("rootElements"), newError]
          }
        });
        commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), newEventDefinition]
          }
        });
      }
    });
    if (oldErrorEventDefinitions.length) {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: extensionElements,
        properties: {
          values: (0, import_min_dash147.without)(extensionElements.get("values"), (value) => oldErrorEventDefinitions.includes(value))
        }
      });
    }
  }
  _updateCamundaExecutionListenerProperties(element, newTemplate) {
    const bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
    const newProperties = newTemplate.properties.filter((newProperty) => {
      const newBinding = newProperty.binding, newBindingType = newBinding.type;
      return newBindingType === "camunda:executionListener";
    });
    if (!newProperties.length) {
      return;
    }
    const extensionElements = this._getOrCreateExtensionElements(element);
    const oldExecutionListeners = findExtensions(element, ["camunda:ExecutionListener"]);
    const newExecutionListeners = newProperties.map((newProperty) => {
      const newBinding = newProperty.binding, propertyValue = newProperty.value;
      return createCamundaExecutionListenerScript(newBinding, propertyValue, bpmnFactory);
    });
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: extensionElements,
      properties: {
        values: [...(0, import_min_dash147.without)(extensionElements.get("values"), (value) => oldExecutionListeners.includes(value)), ...newExecutionListeners]
      }
    });
  }
  _updateCamundaFieldProperties(element, oldTemplate, newTemplate, businessObject) {
    const bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
    const newProperties = newTemplate.properties.filter((newProperty) => {
      const newBinding = newProperty.binding, newBindingType = newBinding.type;
      return newBindingType === "camunda:field";
    });
    if (!newProperties.length) {
      return;
    }
    if (!businessObject) {
      businessObject = this._getOrCreateExtensionElements(element);
    }
    const propertyName = isAny(businessObject, ["camunda:ExecutionListener", "camunda:TaskListener"]) ? "fields" : "values";
    const oldFields = findExtensions(element, ["camunda:Field"]);
    newProperties.forEach((newProperty) => {
      const oldProperty = findOldProperty(oldTemplate, newProperty), oldField = oldProperty && findOldBusinessObject(businessObject, oldProperty), newBinding = newProperty.binding;
      if (oldProperty && oldField) {
        if (!propertyChanged(oldField, oldProperty)) {
          commandStack.execute("element.updateModdleProperties", {
            element,
            moddleElement: oldField,
            properties: {
              string: newProperty.value
            }
          });
        }
        remove4(oldFields, oldField);
      } else {
        const newCamundaFieldInjection = createCamundaFieldInjection(newBinding, newProperty.value, bpmnFactory);
        commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: businessObject,
          properties: {
            [propertyName]: [...businessObject.get(propertyName), newCamundaFieldInjection]
          }
        });
      }
    });
    if (oldFields.length) {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: businessObject,
        properties: {
          [propertyName]: (0, import_min_dash147.without)(businessObject.get(propertyName), (value) => oldFields.includes(value))
        }
      });
    }
  }
  _updateCamundaInOutProperties(element, oldTemplate, newTemplate) {
    const bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
    const newProperties = newTemplate.properties.filter((newProperty) => {
      const newBinding = newProperty.binding, newBindingType = newBinding.type;
      return newBindingType === "camunda:in" || newBindingType === "camunda:in:businessKey" || newBindingType === "camunda:out";
    });
    if (!newProperties.length) {
      return;
    }
    const extensionElements = this._getOrCreateExtensionElements(getSignalEventDefinition(element) || element);
    const oldInsAndOuts = findExtensions(extensionElements, ["camunda:In", "camunda:Out"]);
    newProperties.forEach((newProperty) => {
      const oldProperty = findOldProperty(oldTemplate, newProperty), oldBinding = oldProperty && oldProperty.binding, oldInOurOut = oldProperty && findOldBusinessObject(extensionElements, oldProperty), newPropertyValue = newProperty.value, newBinding = newProperty.binding, newBindingType = newBinding.type, properties = {};
      let newInOrOut;
      if (oldProperty && oldInOurOut) {
        if (!propertyChanged(oldInOurOut, oldProperty)) {
          if (newBindingType === "camunda:in") {
            if (newBinding.expression) {
              properties["camunda:sourceExpression"] = newPropertyValue;
            } else {
              properties["camunda:source"] = newPropertyValue;
            }
          } else if (newBindingType === "camunda:in:businessKey") {
            properties["camunda:businessKey"] = newPropertyValue;
          } else if (newBindingType === "camunda:out") {
            properties["camunda:target"] = newPropertyValue;
          }
        }
        if (oldBinding.local && !newBinding.local || !oldBinding.local && newBinding.local) {
          properties.local = newBinding.local;
        }
        if ((0, import_min_dash147.keys)(properties)) {
          commandStack.execute("element.updateModdleProperties", {
            element,
            moddleElement: oldInOurOut,
            properties
          });
        }
        remove4(oldInsAndOuts, oldInOurOut);
      } else {
        if (newBindingType === "camunda:in") {
          newInOrOut = createCamundaIn(newBinding, newPropertyValue, bpmnFactory);
        } else if (newBindingType === "camunda:out") {
          newInOrOut = createCamundaOut(newBinding, newPropertyValue, bpmnFactory);
        } else if (newBindingType === "camunda:in:businessKey") {
          newInOrOut = createCamundaInWithBusinessKey(newPropertyValue, bpmnFactory);
        }
        commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), newInOrOut]
          }
        });
      }
    });
    if (oldInsAndOuts.length) {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: extensionElements,
        properties: {
          values: (0, import_min_dash147.without)(extensionElements.get("values"), (value) => oldInsAndOuts.includes(value))
        }
      });
    }
  }
  _updateCamundaInputOutputParameterProperties(element, oldTemplate, newTemplate, businessObject) {
    const bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
    const newProperties = newTemplate.properties.filter((newProperty) => {
      const newBinding = newProperty.binding, newBindingType = newBinding.type;
      return newBindingType === "camunda:inputParameter" || newBindingType === "camunda:outputParameter";
    });
    if (!newProperties.length) {
      return;
    }
    if (!businessObject) {
      businessObject = this._getOrCreateExtensionElements(element);
    }
    let inputOutput;
    if (is(businessObject, "camunda:Connector")) {
      inputOutput = businessObject.get("camunda:inputOutput");
      if (!inputOutput) {
        inputOutput = bpmnFactory.create("camunda:InputOutput");
        commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: businessObject,
          properties: {
            inputOutput
          }
        });
      }
    } else {
      inputOutput = findExtension(businessObject, "camunda:InputOutput");
      if (!inputOutput) {
        inputOutput = bpmnFactory.create("camunda:InputOutput");
        commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: businessObject,
          properties: {
            values: [...businessObject.get("values"), inputOutput]
          }
        });
      }
    }
    const oldInputs = inputOutput.get("camunda:inputParameters") ? inputOutput.get("camunda:inputParameters").slice() : [];
    const oldOutputs = inputOutput.get("camunda:outputParameters") ? inputOutput.get("camunda:outputParameters").slice() : [];
    let propertyName;
    newProperties.forEach((newProperty) => {
      const oldProperty = findOldProperty(oldTemplate, newProperty), oldInputOrOutput = oldProperty && findOldBusinessObject(businessObject, oldProperty), newPropertyValue = newProperty.value, newBinding = newProperty.binding, newBindingType = newBinding.type;
      let newInputOrOutput, properties;
      if (oldProperty && oldInputOrOutput) {
        if (!propertyChanged(oldInputOrOutput, oldProperty)) {
          if (is(oldInputOrOutput, "camunda:InputParameter")) {
            properties = {
              value: newPropertyValue
            };
          } else {
            properties = {
              name: newPropertyValue
            };
          }
          commandStack.execute("element.updateModdleProperties", {
            element,
            moddleElement: oldInputOrOutput,
            properties
          });
        }
        if (is(oldInputOrOutput, "camunda:InputParameter")) {
          remove4(oldInputs, oldInputOrOutput);
        } else {
          remove4(oldOutputs, oldInputOrOutput);
        }
      } else {
        if (newBindingType === "camunda:inputParameter") {
          propertyName = "inputParameters";
          newInputOrOutput = createInputParameter(newBinding, newPropertyValue, bpmnFactory);
        } else {
          propertyName = "outputParameters";
          newInputOrOutput = createOutputParameter(newBinding, newPropertyValue, bpmnFactory);
        }
        commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: inputOutput,
          properties: {
            [propertyName]: [...inputOutput.get(propertyName), newInputOrOutput]
          }
        });
      }
    });
    if (oldInputs.length) {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: inputOutput,
        properties: {
          inputParameters: (0, import_min_dash147.without)(inputOutput.get("inputParameters"), (inputParameter) => oldInputs.includes(inputParameter))
        }
      });
    }
    if (oldOutputs.length) {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: inputOutput,
        properties: {
          outputParameters: (0, import_min_dash147.without)(inputOutput.get("outputParameters"), (outputParameter) => oldOutputs.includes(outputParameter))
        }
      });
    }
  }
  _updateCamundaModelerTemplate(element, newTemplate) {
    const modeling = this._modeling;
    modeling.updateProperties(element, {
      "camunda:modelerTemplate": newTemplate && newTemplate.id,
      "camunda:modelerTemplateVersion": newTemplate && newTemplate.version
    });
  }
  _updateCamundaPropertyProperties(element, oldTemplate, newTemplate, businessObject) {
    const bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
    const newProperties = newTemplate.properties.filter((newProperty) => {
      const newBinding = newProperty.binding, newBindingType = newBinding.type;
      return newBindingType === "camunda:property";
    });
    if (!newProperties.length) {
      return;
    }
    if (businessObject) {
      businessObject = this._getOrCreateExtensionElements(businessObject);
    } else {
      businessObject = this._getOrCreateExtensionElements(element);
    }
    let camundaProperties = findExtension(businessObject, "camunda:Properties");
    if (!camundaProperties) {
      camundaProperties = bpmnFactory.create("camunda:Properties");
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: businessObject,
        properties: {
          values: [...businessObject.get("values"), camundaProperties]
        }
      });
    }
    const oldCamundaProperties = camundaProperties.get("camunda:values") ? camundaProperties.get("camunda:values").slice() : [];
    newProperties.forEach((newProperty) => {
      const oldProperty = findOldProperty(oldTemplate, newProperty), oldCamundaProperty = oldProperty && findOldBusinessObject(businessObject, oldProperty), newPropertyValue = newProperty.value, newBinding = newProperty.binding;
      if (oldProperty && oldCamundaProperty) {
        if (!propertyChanged(oldCamundaProperty, oldProperty)) {
          commandStack.execute("element.updateModdleProperties", {
            element,
            moddleElement: oldCamundaProperty,
            properties: {
              value: newPropertyValue
            }
          });
        }
        remove4(oldCamundaProperties, oldCamundaProperty);
      } else {
        const newCamundaProperty = createCamundaProperty(newBinding, newPropertyValue, bpmnFactory);
        commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: camundaProperties,
          properties: {
            values: [...camundaProperties.get("values"), newCamundaProperty]
          }
        });
      }
    });
    if (oldCamundaProperties.length) {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: camundaProperties,
        properties: {
          values: (0, import_min_dash147.without)(camundaProperties.get("values"), (value) => oldCamundaProperties.includes(value))
        }
      });
    }
  }
  _updateConditionExpression(element, oldProperty, newProperty) {
    const bpmnFactory = this._bpmnFactory, commandStack = this._commandStack, modeling = this._modeling;
    const newBinding = newProperty.binding, newPropertyValue = newProperty.value;
    if (!oldProperty) {
      modeling.updateProperties(element, {
        conditionExpression: bpmnFactory.create("bpmn:FormalExpression", {
          body: newPropertyValue,
          language: newBinding.scriptFormat
        })
      });
      return;
    }
    const oldBinding = oldProperty.binding, oldPropertyValue = oldProperty.value;
    const businessObject = getBusinessObject(element), conditionExpression = businessObject.get("bpmn:conditionExpression");
    const properties = {};
    if (conditionExpression.get("body") === oldPropertyValue) {
      properties.body = newPropertyValue;
    }
    if (conditionExpression.get("language") === oldBinding.scriptFormat) {
      properties.language = newBinding.scriptFormat;
    }
    if (!(0, import_min_dash147.keys)(properties).length) {
      return;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: conditionExpression,
      properties
    });
  }
  _updateProperties(element, oldTemplate, newTemplate, businessObject) {
    const commandStack = this._commandStack;
    const newProperties = newTemplate.properties.filter((newProperty) => {
      const newBinding = newProperty.binding, newBindingType = newBinding.type;
      return newBindingType === "property";
    });
    if (!newProperties.length) {
      return;
    }
    if (!businessObject) {
      businessObject = getBusinessObject(element);
    }
    newProperties.forEach((newProperty) => {
      const oldProperty = findOldProperty(oldTemplate, newProperty), newBinding = newProperty.binding, newBindingName = newBinding.name, newPropertyValue = newProperty.value;
      let changedElement, properties;
      if (newBindingName === "conditionExpression") {
        this._updateConditionExpression(element, oldProperty, newProperty);
      } else {
        if (is(businessObject, "bpmn:Error")) {
          changedElement = businessObject;
        } else {
          changedElement = element;
        }
        if (oldProperty && propertyChanged(changedElement, oldProperty)) {
          return;
        }
        properties = {};
        properties[newBindingName] = newPropertyValue;
        if (CAMUNDA_SERVICE_TASK_LIKE.indexOf(newBindingName) !== -1) {
          CAMUNDA_SERVICE_TASK_LIKE.forEach((camundaServiceTaskLikeProperty) => {
            if (camundaServiceTaskLikeProperty !== newBindingName) {
              properties[camundaServiceTaskLikeProperty] = void 0;
            }
          });
        }
        commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: businessObject,
          properties
        });
      }
    });
  }
  _updateScopeProperties(element, oldTemplate, newScopeTemplate, newTemplate) {
    const bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
    const scopeName = newScopeTemplate.type;
    let scopeElement;
    scopeElement = findOldScopeElement(element, newScopeTemplate, newTemplate);
    if (!scopeElement) {
      scopeElement = bpmnFactory.create(scopeName);
    }
    const oldScopeTemplate = findOldScopeTemplate(newScopeTemplate, oldTemplate);
    this._updateProperties(element, oldScopeTemplate, newScopeTemplate, scopeElement);
    this._updateCamundaExecutionListenerProperties(element, newScopeTemplate);
    this._updateCamundaInOutProperties(element, oldScopeTemplate, newScopeTemplate);
    this._updateCamundaInputOutputParameterProperties(element, oldScopeTemplate, newScopeTemplate, scopeElement);
    this._updateCamundaFieldProperties(element, oldScopeTemplate, newScopeTemplate, scopeElement);
    this._updateCamundaPropertyProperties(element, oldScopeTemplate, newScopeTemplate, scopeElement);
    if (isRootElementScope(scopeName)) {
      return;
    }
    const extensionElements = this._getOrCreateExtensionElements(element);
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: extensionElements,
      properties: {
        values: [...extensionElements.get("values"), scopeElement]
      }
    });
  }
  _updateTaskType(element, newTemplate) {
    const newType = newTemplate.elementType;
    if (!newType) {
      return element;
    }
    if (element.$type === newType.value) {
      return element;
    }
    return this._bpmnReplace.replaceElement(element, {
      type: newType.value
    });
  }
};
ChangeElementTemplateHandler.$inject = ["bpmnFactory", "bpmnReplace", "commandStack", "modeling"];
function findOldBusinessObject(element, oldProperty) {
  let businessObject = getBusinessObject(element), propertyName;
  const oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
  if (oldBindingType === "camunda:field") {
    if (isAny(businessObject, ["camunda:ExecutionListener", "camunda:TaskListener"])) {
      propertyName = "camunda:fields";
    } else {
      propertyName = "bpmn:values";
    }
    if (!businessObject || !businessObject.get(propertyName) || !businessObject.get(propertyName).length) {
      return;
    }
    return (0, import_min_dash147.find)(businessObject.get(propertyName), function(oldBusinessObject) {
      return oldBusinessObject.get("camunda:name") === oldBinding.name;
    });
  }
  if (oldBindingType === "camunda:in") {
    return (0, import_min_dash147.find)(businessObject.get("values"), function(oldBusinessObject) {
      return oldBusinessObject.get("target") === oldBinding.target;
    });
  }
  if (oldBindingType === "camunda:in:businessKey") {
    return (0, import_min_dash147.find)(businessObject.get("values"), function(oldBusinessObject) {
      return (0, import_min_dash147.isString)(oldBusinessObject.get("businessKey"));
    });
  }
  if (oldBindingType === "camunda:out") {
    return (0, import_min_dash147.find)(businessObject.get("values"), function(oldBusinessObject) {
      return oldBusinessObject.get("source") === oldBinding.source || oldBusinessObject.get("sourceExpression") || oldBinding.sourceExpression;
    });
  }
  if (oldBindingType === "camunda:inputParameter" || oldBindingType === "camunda:outputParameter") {
    if (is(businessObject, "camunda:Connector")) {
      businessObject = businessObject.get("camunda:inputOutput");
      if (!businessObject) {
        return;
      }
    } else {
      businessObject = findExtension(businessObject, "camunda:InputOutput");
      if (!businessObject) {
        return;
      }
    }
    if (oldBindingType === "camunda:inputParameter") {
      return (0, import_min_dash147.find)(businessObject.get("camunda:inputParameters"), function(oldBusinessObject) {
        return oldBusinessObject.get("camunda:name") === oldBinding.name;
      });
    } else {
      return (0, import_min_dash147.find)(businessObject.get("camunda:outputParameters"), function(oldBusinessObject) {
        if (oldBinding.scriptFormat) {
          const definition = oldBusinessObject.get("camunda:definition");
          return definition && definition.get("camunda:value") === oldBinding.source;
        } else {
          return oldBusinessObject.get("camunda:value") === oldBinding.source;
        }
      });
    }
  }
  if (oldBindingType === "camunda:property") {
    if (!businessObject || !businessObject.get("values") || !businessObject.get("values").length) {
      return;
    }
    businessObject = findExtension(businessObject, "camunda:Properties");
    if (!businessObject) {
      return;
    }
    return (0, import_min_dash147.find)(businessObject.get("values"), function(oldBusinessObject) {
      return oldBusinessObject.get("camunda:name") === oldBinding.name;
    });
  }
  if (oldBindingType === "camunda:errorEventDefinition") {
    return findCamundaErrorEventDefinition(element, oldBinding.errorRef);
  }
}
function findOldProperty(oldTemplate, newProperty) {
  if (!oldTemplate) {
    return;
  }
  const oldProperties = oldTemplate.properties, newBinding = newProperty.binding, newBindingName = newBinding.name, newBindingType = newBinding.type;
  if (newBindingType === "property") {
    return (0, import_min_dash147.find)(oldProperties, function(oldProperty) {
      const oldBinding = oldProperty.binding, oldBindingName = oldBinding.name, oldBindingType = oldBinding.type;
      return oldBindingType === "property" && oldBindingName === newBindingName;
    });
  }
  if (newBindingType === "camunda:field") {
    return (0, import_min_dash147.find)(oldProperties, function(oldProperty) {
      const oldBinding = oldProperty.binding, oldBindingName = oldBinding.name, oldBindingType = oldBinding.type;
      return oldBindingType === "camunda:field" && oldBindingName === newBindingName;
    });
  }
  if (newBindingType === "camunda:in") {
    return (0, import_min_dash147.find)(oldProperties, function(oldProperty) {
      const oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
      if (oldBindingType !== "camunda:in") {
        return;
      }
      if (oldBinding.expression && !newBinding.expression || !oldBinding.expression && newBinding.expression) {
        return;
      }
      return oldBinding.target === newBinding.target;
    });
  }
  if (newBindingType === "camunda:in:businessKey") {
    return (0, import_min_dash147.find)(oldProperties, function(oldProperty) {
      const oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
      return oldBindingType === "camunda:in:businessKey";
    });
  }
  if (newBindingType === "camunda:out") {
    return (0, import_min_dash147.find)(oldProperties, function(oldProperty) {
      const oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
      return oldBindingType === "camunda:out" && (oldBinding.source === newBinding.source || oldBinding.sourceExpression === newBinding.sourceExpression);
    });
  }
  if (newBindingType === "camunda:inputParameter") {
    return (0, import_min_dash147.find)(oldProperties, function(oldProperty) {
      const oldBinding = oldProperty.binding, oldBindingName = oldBinding.name, oldBindingType = oldBinding.type;
      if (oldBindingType !== "camunda:inputParameter") {
        return;
      }
      return oldBindingName === newBindingName && oldBinding.scriptFormat === newBinding.scriptFormat;
    });
  }
  if (newBindingType === "camunda:outputParameter") {
    return (0, import_min_dash147.find)(oldProperties, function(oldProperty) {
      const oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
      if (oldBindingType !== "camunda:outputParameter") {
        return;
      }
      return oldBinding.source === newBinding.source && oldBinding.scriptFormat === newBinding.scriptFormat;
    });
  }
  if (newBindingType === "camunda:property") {
    return (0, import_min_dash147.find)(oldProperties, function(oldProperty) {
      const oldBinding = oldProperty.binding, oldBindingName = oldBinding.name, oldBindingType = oldBinding.type;
      return oldBindingType === "camunda:property" && oldBindingName === newBindingName;
    });
  }
  if (newBindingType === "camunda:errorEventDefinition") {
    return (0, import_min_dash147.find)(oldProperties, function(oldProperty) {
      const newBindingRef = newBinding.errorRef, oldBinding = oldProperty.binding, oldBindingRef = oldBinding.errorRef, oldBindingType = oldBinding.type;
      return oldBindingType === "camunda:errorEventDefinition" && oldBindingRef === newBindingRef;
    });
  }
}
function findOldScopeElement(element, scopeTemplate, template) {
  const scopeName = scopeTemplate.type, id = scopeTemplate.id;
  if (scopeName === "camunda:Connector") {
    return findExtension(element, "camunda:Connector");
  }
  if (scopeName === "bpmn:Error") {
    const errorEventDefinitionBinding = findErrorEventDefinitionBinding(template, id);
    if (!errorEventDefinitionBinding) {
      return;
    }
    const errorEventDefinition = findOldBusinessObject(element, errorEventDefinitionBinding);
    if (!errorEventDefinition) {
      return;
    }
    return errorEventDefinition.errorRef;
  }
}
function isRootElementScope(scopeName) {
  return ["bpmn:Error"].includes(scopeName);
}
function findOldScopeTemplate(scopeTemplate, oldTemplate) {
  const scopeName = scopeTemplate.type, scopeId = scopeTemplate.id, scopes = oldTemplate && handleLegacyScopes(oldTemplate.scopes);
  return scopes && (0, import_min_dash147.find)(scopes, function(scope) {
    if (isRootElementScope(scopeName)) {
      return scope.id === scopeId;
    }
    return scope.type === scopeName;
  });
}
function findErrorEventDefinitionBinding(template, templateErrorId) {
  return (0, import_min_dash147.find)(template.properties, function(property) {
    return property.binding.errorRef === templateErrorId;
  });
}
function propertyChanged(element, oldProperty) {
  const businessObject = getBusinessObject(element);
  const oldBinding = oldProperty.binding, oldBindingName = oldBinding.name, oldBindingType = oldBinding.type, oldPropertyValue = oldProperty.value;
  let conditionExpression, definition;
  if (oldBindingType === "property") {
    if (oldBindingName === "conditionExpression") {
      conditionExpression = businessObject.get("bpmn:conditionExpression");
      return conditionExpression.get("bpmn:body") !== oldPropertyValue;
    }
    return businessObject.get(oldBindingName) !== oldPropertyValue;
  }
  if (oldBindingType === "camunda:field") {
    return businessObject.get("camunda:string") !== oldPropertyValue;
  }
  if (oldBindingType === "camunda:in") {
    if (oldBinding.expression) {
      return businessObject.get("sourceExpression") !== oldPropertyValue;
    } else {
      return businessObject.get("camunda:source") !== oldPropertyValue;
    }
  }
  if (oldBindingType === "camunda:in:businessKey") {
    return businessObject.get("camunda:businessKey") !== oldPropertyValue;
  }
  if (oldBindingType === "camunda:out") {
    return businessObject.get("camunda:target") !== oldPropertyValue;
  }
  if (oldBindingType === "camunda:inputParameter") {
    if (oldBinding.scriptFormat) {
      definition = businessObject.get("camunda:definition");
      return definition && definition.get("camunda:value") !== oldPropertyValue;
    } else {
      return businessObject.get("camunda:value") !== oldPropertyValue;
    }
  }
  if (oldBindingType === "camunda:outputParameter") {
    return businessObject.get("camunda:name") !== oldPropertyValue;
  }
  if (oldBindingType === "camunda:property") {
    return businessObject.get("camunda:value") !== oldPropertyValue;
  }
  if (oldBindingType === "camunda:errorEventDefinition") {
    return businessObject.get("expression") !== oldPropertyValue;
  }
}
function remove4(array, item) {
  const index2 = array.indexOf(item);
  if ((0, import_min_dash147.isUndefined)(index2)) {
    return array;
  }
  array.splice(index2, 1);
  return array;
}
function registerHandlers(commandStack, elementTemplates, eventBus) {
  commandStack.registerHandler("propertiesPanel.camunda.changeTemplate", ChangeElementTemplateHandler);
  eventBus.on(["commandStack.shape.create.postExecuted"], function(context) {
    applyDefaultTemplate(context.context.shape, elementTemplates, commandStack);
  });
  eventBus.on(["commandStack.connection.create.postExecuted"], function(context) {
    applyDefaultTemplate(context.context.connection, elementTemplates, commandStack);
  });
}
registerHandlers.$inject = ["commandStack", "elementTemplates", "eventBus"];
function applyDefaultTemplate(element, elementTemplates, commandStack) {
  if (!elementTemplates.get(element) && elementTemplates.getDefault(element)) {
    const command = "propertiesPanel.camunda.changeTemplate";
    const commandContext = {
      element,
      newTemplate: elementTemplates.getDefault(element)
    };
    commandStack.execute(command, commandContext);
  }
}
var CAMUNDA_ERROR_EVENT_DEFINITION_TYPE$1 = "camunda:errorEventDefinition";
var CAMUNDA_EXECUTION_LISTENER_TYPE = "camunda:executionListener";
var CAMUNDA_FIELD_TYPE = "camunda:field";
var CAMUNDA_IN_BUSINESS_KEY_TYPE = "camunda:in:businessKey";
var CAMUNDA_IN_TYPE = "camunda:in";
var CAMUNDA_INPUT_PARAMETER_TYPE$1 = "camunda:inputParameter";
var CAMUNDA_OUT_TYPE = "camunda:out";
var CAMUNDA_OUTPUT_PARAMETER_TYPE$1 = "camunda:outputParameter";
var CAMUNDA_PROPERTY_TYPE = "camunda:property";
var PROPERTY_TYPE = "property";
var EXTENSION_BINDING_TYPES = [CAMUNDA_ERROR_EVENT_DEFINITION_TYPE$1, CAMUNDA_FIELD_TYPE, CAMUNDA_IN_TYPE, CAMUNDA_IN_BUSINESS_KEY_TYPE, CAMUNDA_INPUT_PARAMETER_TYPE$1, CAMUNDA_OUT_TYPE, CAMUNDA_OUTPUT_PARAMETER_TYPE$1, CAMUNDA_PROPERTY_TYPE];
var IO_BINDING_TYPES = [CAMUNDA_INPUT_PARAMETER_TYPE$1, CAMUNDA_OUTPUT_PARAMETER_TYPE$1];
var IN_OUT_BINDING_TYPES = [CAMUNDA_IN_BUSINESS_KEY_TYPE, CAMUNDA_IN_TYPE, CAMUNDA_OUT_TYPE];
var PRIMITIVE_MODDLE_TYPES = ["Boolean", "Integer", "String"];
var DEFAULT_CUSTOM_GROUP = {
  id: "ElementTemplates__CustomProperties",
  label: "Custom properties"
};
function CustomProperties(props) {
  const {
    element,
    elementTemplate
  } = props;
  const groups = [];
  const {
    id,
    properties,
    groups: propertyGroups,
    scopes
  } = elementTemplate;
  const groupedProperties = groupByGroupId(properties);
  const defaultProps = [];
  (0, import_min_dash147.forEach)(groupedProperties, (properties2, groupId) => {
    const group = findCustomGroup(propertyGroups, groupId);
    if (!group) {
      return defaultProps.push(...properties2);
    }
    addCustomGroup(groups, {
      element,
      id: `ElementTemplates__CustomProperties-${groupId}`,
      label: group.label,
      properties: properties2,
      templateId: `${id}-${groupId}`
    });
  });
  if (defaultProps.length) {
    addCustomGroup(groups, {
      ...DEFAULT_CUSTOM_GROUP,
      element,
      properties: defaultProps,
      templateId: id
    });
  }
  if ((0, import_min_dash147.isArray)(scopes)) {
    scopes.forEach((scope) => {
      const {
        properties: properties2,
        type
      } = scope;
      const id2 = type.replace(/:/g, "-");
      addCustomGroup(groups, {
        element,
        id: `ElementTemplates__CustomGroup-${id2}`,
        label: `Custom properties for scope <${type}>`,
        properties: properties2,
        templateId: id2,
        scope
      });
    });
  }
  return groups;
}
function addCustomGroup(groups, props) {
  const {
    element,
    id,
    label,
    properties,
    scope,
    templateId
  } = props;
  const customPropertiesGroup = {
    id,
    label,
    component: Group,
    entries: [],
    shouldOpen: true
  };
  properties.forEach((property, index2) => {
    const entry = createCustomEntry(`custom-entry-${templateId}-${index2}`, element, property, scope);
    if (entry) {
      customPropertiesGroup.entries.push(entry);
    }
  });
  if (customPropertiesGroup.entries.length) {
    groups.push(customPropertiesGroup);
  }
}
function createCustomEntry(id, element, property, scope) {
  let {
    type
  } = property;
  if (!type) {
    type = getDefaultType(property);
  }
  if (type === "Boolean") {
    return {
      id,
      component: BooleanProperty,
      isEdited: isEdited$7,
      property,
      scope
    };
  }
  if (type === "Dropdown") {
    return {
      id,
      component: DropdownProperty,
      isEdited: isEdited$4,
      property,
      scope
    };
  }
  if (type === "String") {
    return {
      id,
      component: StringProperty,
      isEdited: isEdited$1,
      property,
      scope
    };
  }
  if (type === "Text") {
    return {
      id,
      component: TextAreaProperty,
      isEdited: isEdited$2,
      property,
      scope
    };
  }
}
function getDefaultType(property) {
  const {
    binding
  } = property;
  const {
    type
  } = binding;
  if ([PROPERTY_TYPE, CAMUNDA_PROPERTY_TYPE, CAMUNDA_IN_TYPE, CAMUNDA_IN_BUSINESS_KEY_TYPE, CAMUNDA_OUT_TYPE, CAMUNDA_FIELD_TYPE].includes(type)) {
    return "String";
  }
  if (type === CAMUNDA_EXECUTION_LISTENER_TYPE) {
    return "Hidden";
  }
}
function BooleanProperty(props) {
  const {
    element,
    id,
    property,
    scope
  } = props;
  const {
    description,
    editable,
    label
  } = property;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack");
  return CheckboxEntry({
    element,
    getValue: propertyGetter(element, property, scope),
    id,
    label,
    description: PropertyDescription({
      description
    }),
    setValue: propertySetter(bpmnFactory, commandStack, element, property, scope),
    disabled: editable === false
  });
}
function DropdownProperty(props) {
  const {
    element,
    id,
    property,
    scope
  } = props;
  const {
    description,
    editable,
    label
  } = property;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack");
  const getOptions = () => {
    const {
      choices
    } = property;
    return choices.map(({
      name: name3,
      value
    }) => {
      return {
        label: name3,
        value
      };
    });
  };
  return SelectEntry({
    element,
    id,
    label,
    getOptions,
    description: PropertyDescription({
      description
    }),
    getValue: propertyGetter(element, property, scope),
    setValue: propertySetter(bpmnFactory, commandStack, element, property, scope),
    disabled: editable === false
  });
}
function StringProperty(props) {
  const {
    element,
    id,
    property,
    scope
  } = props;
  const {
    description,
    editable,
    label
  } = property;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack"), debounce4 = useService("debounceInput"), translate3 = useService("translate");
  return TextfieldEntry({
    debounce: debounce4,
    element,
    getValue: propertyGetter(element, property, scope),
    id,
    label,
    description: PropertyDescription({
      description
    }),
    setValue: propertySetter(bpmnFactory, commandStack, element, property, scope),
    validate: propertyValidator(translate3, property),
    disabled: editable === false
  });
}
function TextAreaProperty(props) {
  const {
    element,
    id,
    property,
    scope
  } = props;
  const {
    description,
    editable,
    label
  } = property;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack"), debounce4 = useService("debounceInput");
  return TextAreaEntry({
    debounce: debounce4,
    element,
    id,
    label,
    description: PropertyDescription({
      description
    }),
    getValue: propertyGetter(element, property, scope),
    setValue: propertySetter(bpmnFactory, commandStack, element, property, scope),
    disabled: editable === false
  });
}
function propertyGetter(element, property, scope) {
  return function getValue2() {
    let businessObject = getBusinessObject(element);
    const {
      binding,
      value: defaultValue = ""
    } = property;
    const {
      name: name3,
      type
    } = binding;
    if (scope) {
      businessObject = getScopeBusinessObject(businessObject, scope);
      if (!businessObject) {
        return defaultValue;
      }
    }
    if (type === "property") {
      const value = businessObject.get(name3);
      if (name3 === "conditionExpression") {
        if (value) {
          return value.get("body");
        }
        return defaultValue;
      } else {
        if (!(0, import_min_dash147.isUndefined)(value)) {
          return value;
        }
        return defaultValue;
      }
    }
    if (type === CAMUNDA_ERROR_EVENT_DEFINITION_TYPE$1) {
      const {
        errorRef
      } = binding;
      const errorEventDefinition = findCamundaErrorEventDefinition(businessObject, errorRef);
      if (errorEventDefinition) {
        return errorEventDefinition.get("camunda:expression");
      } else {
        return "";
      }
    }
    if (type === CAMUNDA_FIELD_TYPE) {
      const camundaFields = findExtensions(businessObject, ["camunda:Field"]);
      const camundaField = camundaFields.find((camundaField2) => {
        return camundaField2.get("camunda:name") === name3;
      });
      if (camundaField) {
        return camundaField.get("camunda:string") || camundaField.get("camunda:expression");
      } else {
        return "";
      }
    }
    if (type === CAMUNDA_PROPERTY_TYPE) {
      let camundaProperties;
      if (scope) {
        camundaProperties = businessObject.get("properties");
      } else {
        camundaProperties = findExtension(businessObject, "camunda:Properties");
      }
      if (camundaProperties) {
        const camundaProperty = findCamundaProperty(camundaProperties, binding);
        if (camundaProperty) {
          return camundaProperty.get("camunda:value");
        }
      }
      return defaultValue;
    }
    if (IO_BINDING_TYPES.includes(type)) {
      let inputOutput;
      if (scope) {
        inputOutput = businessObject.get("inputOutput");
      } else {
        inputOutput = findExtension(businessObject, "camunda:InputOutput");
      }
      if (!inputOutput) {
        return defaultValue;
      }
      if (type === CAMUNDA_INPUT_PARAMETER_TYPE$1) {
        const inputParameter = findInputParameter(inputOutput, binding);
        if (inputParameter) {
          const {
            scriptFormat
          } = binding;
          if (scriptFormat) {
            const definition = inputParameter.get("camunda:definition");
            if (definition) {
              return definition.get("camunda:value");
            }
          } else {
            return inputParameter.get("value") || "";
          }
        }
        return defaultValue;
      }
      if (type === CAMUNDA_OUTPUT_PARAMETER_TYPE$1) {
        const outputParameter = findOutputParameter(inputOutput, binding);
        if (outputParameter) {
          return outputParameter.get("camunda:name");
        }
        return defaultValue;
      }
    }
    if (IN_OUT_BINDING_TYPES.includes(type)) {
      const camundaInOut = findCamundaInOut(businessObject, binding);
      if (camundaInOut) {
        if (type === CAMUNDA_IN_BUSINESS_KEY_TYPE) {
          return camundaInOut.get("camunda:businessKey");
        } else if (type === CAMUNDA_OUT_TYPE) {
          return camundaInOut.get("camunda:target");
        } else if (type === CAMUNDA_IN_TYPE) {
          const {
            expression
          } = binding;
          if (expression) {
            return camundaInOut.get("camunda:sourceExpression");
          } else {
            return camundaInOut.get("camunda:source");
          }
        }
      }
      return defaultValue;
    }
    throw unknownBindingError(element, property);
  };
}
function propertySetter(bpmnFactory, commandStack, element, property, scope) {
  return function setValue(value) {
    let businessObject = getBusinessObject(element);
    const {
      binding
    } = property;
    const {
      name: name3,
      type
    } = binding;
    const rootElement = getRoot(businessObject);
    let extensionElements;
    let propertyValue;
    const commands = [];
    if (EXTENSION_BINDING_TYPES.includes(type)) {
      extensionElements = businessObject.get("extensionElements");
      if (!extensionElements) {
        extensionElements = createElement("bpmn:ExtensionElements", null, businessObject, bpmnFactory);
        commands.push({
          cmd: "element.updateModdleProperties",
          context: {
            element,
            moddleElement: businessObject,
            properties: {
              extensionElements
            }
          }
        });
      }
    }
    if (scope) {
      businessObject = getScopeBusinessObject(businessObject, scope);
      if (!businessObject) {
        if (scope.type === "bpmn:Error") {
          businessObject = createError(scope.id, rootElement, bpmnFactory);
          commands.push({
            cmd: "element.updateModdleProperties",
            context: {
              element,
              moddleElement: rootElement,
              properties: {
                rootElements: [...rootElement.get("rootElements"), businessObject]
              }
            }
          });
        } else {
          businessObject = createElement(scope.type, null, element, bpmnFactory);
          commands.push({
            cmd: "element.updateModdleProperties",
            context: {
              element,
              moddleElement: extensionElements,
              properties: {
                values: [...extensionElements.get("values"), businessObject]
              }
            }
          });
        }
      }
    }
    if (type === "property") {
      if (name3 === "conditionExpression") {
        const {
          scriptFormat
        } = binding;
        propertyValue = createElement("bpmn:FormalExpression", {
          body: value,
          language: scriptFormat
        }, businessObject, bpmnFactory);
      } else {
        const propertyDescriptor = businessObject.$descriptor.propertiesByName[name3];
        const {
          type: propertyType
        } = propertyDescriptor;
        if (!PRIMITIVE_MODDLE_TYPES.includes(propertyType)) {
          throw new Error(`cannot set property of type <${propertyType}>`);
        }
        if (propertyType === "Boolean") {
          propertyValue = !!value;
        } else if (propertyType === "Integer") {
          propertyValue = parseInt(value, 10);
          if (isNaN(propertyValue)) {
            propertyValue = void 0;
          }
        } else {
          propertyValue = value || "";
        }
      }
      if (!(0, import_min_dash147.isUndefined)(propertyValue)) {
        commands.push({
          cmd: "element.updateModdleProperties",
          context: {
            element,
            moddleElement: businessObject,
            properties: {
              [name3]: propertyValue
            }
          }
        });
      }
    }
    if (type === CAMUNDA_ERROR_EVENT_DEFINITION_TYPE$1) {
      const {
        errorRef
      } = binding;
      const oldCamundaErrorEventDefinition = findCamundaErrorEventDefinition(businessObject, errorRef);
      if (oldCamundaErrorEventDefinition) {
        commands.push({
          cmd: "element.updateModdleProperties",
          context: {
            element,
            moddleElement: oldCamundaErrorEventDefinition,
            properties: {
              "camunda:expression": value
            }
          }
        });
      } else {
        const newError = createError(binding.errorRef, rootElement, bpmnFactory), newCamundaErrorEventDefinition = createCamundaErrorEventDefinition(value, newError, extensionElements, bpmnFactory);
        commands.push({
          cmd: "element.updateModdleProperties",
          context: {
            element,
            moddleElement: rootElement,
            properties: {
              rootElements: [...rootElement.get("rootElements"), newError]
            }
          }
        });
        commands.push({
          cmd: "element.updateModdleProperties",
          context: {
            element,
            moddleElement: extensionElements,
            properties: {
              values: [...extensionElements.get("values"), newCamundaErrorEventDefinition]
            }
          }
        });
      }
    }
    if (type === CAMUNDA_FIELD_TYPE) {
      const oldCamundaFields = findExtensions(businessObject, ["camunda:Field"]);
      const newCamundaFields = [];
      if (oldCamundaFields.length) {
        oldCamundaFields.forEach((camundaField) => {
          if (camundaField.name === name3) {
            newCamundaFields.push(createCamundaFieldInjection(binding, value, bpmnFactory));
          } else {
            newCamundaFields.push(camundaField);
          }
        });
      } else {
        newCamundaFields.push(createCamundaFieldInjection(binding, value, bpmnFactory));
      }
      const values5 = extensionElements.get("values").filter((value2) => !oldCamundaFields.includes(value2));
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...values5, ...newCamundaFields]
          }
        }
      });
    }
    if (type === CAMUNDA_PROPERTY_TYPE) {
      let camundaProperties;
      if (scope) {
        camundaProperties = businessObject.get("properties");
      } else {
        camundaProperties = findExtension(extensionElements, "camunda:Properties");
      }
      if (!camundaProperties) {
        camundaProperties = createElement("camunda:Properties", null, businessObject, bpmnFactory);
        if (scope) {
          commands.push({
            cmd: "element.updateModdleProperties",
            context: {
              element,
              moddleElement: businessObject,
              properties: {
                properties: camundaProperties
              }
            }
          });
        } else {
          commands.push({
            cmd: "element.updateModdleProperties",
            context: {
              element,
              moddleElement: extensionElements,
              properties: {
                values: [...extensionElements.get("values"), camundaProperties]
              }
            }
          });
        }
      }
      const oldCamundaProperty = findCamundaProperty(camundaProperties, binding);
      const newCamundaProperty = createCamundaProperty(binding, value, bpmnFactory);
      const values5 = camundaProperties.get("values").filter((value2) => value2 !== oldCamundaProperty);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: camundaProperties,
          properties: {
            values: [...values5, newCamundaProperty]
          }
        }
      });
    }
    if (IO_BINDING_TYPES.includes(type)) {
      let inputOutput;
      if (scope) {
        inputOutput = businessObject.get("inputOutput");
      } else {
        inputOutput = findExtension(extensionElements, "camunda:InputOutput");
      }
      if (!inputOutput) {
        inputOutput = createElement("camunda:InputOutput", null, businessObject, bpmnFactory);
        if (scope) {
          commands.push({
            cmd: "element.updateModdleProperties",
            context: {
              element,
              moddleElement: businessObject,
              properties: {
                inputOutput
              }
            }
          });
        } else {
          commands.push({
            cmd: "element.updateModdleProperties",
            context: {
              element,
              moddleElement: extensionElements,
              properties: {
                values: [...extensionElements.get("values"), inputOutput]
              }
            }
          });
        }
      }
      if (type === CAMUNDA_INPUT_PARAMETER_TYPE$1) {
        const oldCamundaInputParameter = findInputParameter(inputOutput, binding);
        const newCamundaInputParameter = createInputParameter(binding, value, bpmnFactory);
        const values5 = inputOutput.get("camunda:inputParameters").filter((value2) => value2 !== oldCamundaInputParameter);
        commands.push({
          cmd: "element.updateModdleProperties",
          context: {
            element,
            moddleElement: inputOutput,
            properties: {
              "camunda:inputParameters": [...values5, newCamundaInputParameter]
            }
          }
        });
      }
      if (type === CAMUNDA_OUTPUT_PARAMETER_TYPE$1) {
        const oldCamundaOutputParameter = findOutputParameter(inputOutput, binding);
        const newCamundaOutputParameter = createOutputParameter(binding, value, bpmnFactory);
        const values5 = inputOutput.get("camunda:outputParameters").filter((value2) => value2 !== oldCamundaOutputParameter);
        commands.push({
          cmd: "element.updateModdleProperties",
          context: {
            element,
            moddleElement: inputOutput,
            properties: {
              "camunda:outputParameters": [...values5, newCamundaOutputParameter]
            }
          }
        });
      }
    }
    if (IN_OUT_BINDING_TYPES.includes(type)) {
      const oldCamundaInOut = findCamundaInOut(businessObject, binding);
      let newCamundaInOut;
      if (type === CAMUNDA_IN_TYPE) {
        newCamundaInOut = createCamundaIn(binding, value, bpmnFactory);
      } else if (type === CAMUNDA_OUT_TYPE) {
        newCamundaInOut = createCamundaOut(binding, value, bpmnFactory);
      } else {
        newCamundaInOut = createCamundaInWithBusinessKey(value, bpmnFactory);
      }
      const values5 = extensionElements.get("values").filter((value2) => value2 !== oldCamundaInOut);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...values5, newCamundaInOut]
          }
        }
      });
    }
    if (commands.length) {
      commandStack.execute("properties-panel.multi-command-executor", commands);
      return;
    }
    throw unknownBindingError(element, property);
  };
}
function propertyValidator(translate3, property) {
  return function validate3(value) {
    const {
      constraints = {}
    } = property;
    const {
      maxLength,
      minLength,
      notEmpty
    } = constraints;
    if (notEmpty && isEmptyString(value)) {
      return translate3("Must not be empty.");
    }
    if (maxLength && value.length > maxLength) {
      return translate3("Must have max length {maxLength}.", {
        maxLength
      });
    }
    if (minLength && value.length < minLength) {
      return translate3("Must have min length {minLength}.", {
        minLength
      });
    }
    let {
      pattern
    } = constraints;
    if (pattern) {
      let message;
      if (!(0, import_min_dash147.isString)(pattern)) {
        message = pattern.message;
        pattern = pattern.value;
      }
      if (!matchesPattern(value, pattern)) {
        return message || translate3("Must match pattern {pattern}.", {
          pattern
        });
      }
    }
  };
}
function getScopeBusinessObject(businessObject, scope) {
  const {
    id,
    type
  } = scope;
  if (type === "bpmn:Error") {
    const errorEventDefinition = findCamundaErrorEventDefinition(businessObject, id);
    if (errorEventDefinition) {
      return errorEventDefinition.get("errorRef");
    }
  }
  return findExtension(businessObject, type);
}
function unknownBindingError(element, property) {
  const businessObject = getBusinessObject(element);
  const id = businessObject.get("id");
  const {
    binding
  } = property;
  const {
    type
  } = binding;
  return new Error(`unknown binding <${type}> for element <${id}>, this should never happen`);
}
function isEmptyString(string) {
  return !string || !string.trim().length;
}
function matchesPattern(string, pattern) {
  return new RegExp(pattern).test(string);
}
function groupByGroupId(properties) {
  return (0, import_min_dash147.groupBy)(properties, "group");
}
function findCustomGroup(groups, id) {
  return (0, import_min_dash147.find)(groups, (g6) => g6.id === id);
}
function ErrorProperties(props) {
  const {
    element,
    index: index2,
    property
  } = props;
  const {
    binding,
    label
  } = property;
  const {
    errorRef
  } = binding;
  const businessObject = getBusinessObject(element), errorEventDefinitions = findExtensions(businessObject, ["camunda:ErrorEventDefinition"]);
  if (!errorEventDefinitions.length) {
    return;
  }
  const errorEventDefinition = findCamundaErrorEventDefinition(element, errorRef);
  const id = `${element.id}-errorEventDefinition-${index2}`;
  let entries = [];
  entries = Error$1({
    idPrefix: id,
    element,
    errorEventDefinition
  });
  entries = removeEntry$1(entries, "-errorRef");
  entries = removeEntry$1(entries, "-expression");
  entries.push({
    id: `${id}-expression`,
    component: Expression,
    errorEventDefinition,
    property
  });
  const item = {
    id,
    label: label || getErrorLabel(errorEventDefinition),
    entries
  };
  return item;
}
function Expression(props) {
  const {
    errorEventDefinition,
    id
  } = props;
  const translate3 = useService("translate");
  const debounce4 = useService("debounceInput");
  const setValue = () => {
  };
  const getValue2 = () => {
    return errorEventDefinition.get("camunda:expression");
  };
  return TextfieldEntry({
    element: errorEventDefinition,
    id,
    label: translate3("Throw expression"),
    getValue: getValue2,
    setValue,
    debounce: debounce4,
    disabled: true
  });
}
function removeEntry$1(entries, suffix) {
  const entry = entries.find(({
    id
  }) => id.endsWith(suffix));
  return (0, import_min_dash147.without)(entries, entry);
}
function InputProperties(props) {
  const {
    element,
    index: index2,
    property
  } = props;
  const {
    binding,
    description,
    label
  } = property;
  const {
    name: name3
  } = binding;
  const businessObject = getBusinessObject(element), inputOutput = findExtension(businessObject, "camunda:InputOutput");
  const inputParameter = inputOutput && findInputParameter(inputOutput, binding);
  const id = `${element.id}-inputParameter-${index2}`;
  let entries = [];
  if (inputParameter) {
    entries = InputOutputParameter({
      idPrefix: id,
      element,
      parameter: inputParameter
    });
    entries = removeEntry(entries, "-name");
  }
  entries.unshift({
    id: `${id}-local-variable-assignment`,
    component: LocalVariableAssignment,
    inputParameter,
    property
  });
  if (description) {
    entries.unshift({
      id: `${id}-description`,
      component: Description$1,
      text: description
    });
  }
  const item = {
    id,
    label: label || name3,
    entries
  };
  return item;
}
function Description$1(props) {
  const {
    id,
    text
  } = props;
  return o5("div", {
    class: "bio-properties-panel-entry",
    "data-entry-id": id,
    children: o5("div", {
      class: "bio-properties-panel-description",
      children: o5(PropertyDescription, {
        description: text
      })
    })
  });
}
function LocalVariableAssignment(props) {
  const {
    element,
    id,
    property,
    inputParameter
  } = props;
  const {
    binding
  } = property;
  const bpmnFactory = useService("bpmnFactory"), modeling = useService("modeling"), translate3 = useService("translate");
  const getValue2 = () => {
    return inputParameter;
  };
  const setValue = (value) => {
    if (value) {
      addInputParameter(element, property, bpmnFactory, modeling);
    } else {
      removeInputParameter(element, binding, modeling);
    }
  };
  return ToggleSwitchEntry({
    id,
    label: translate3("Local variable assignment"),
    switcherLabel: inputParameter ? translate3("On") : translate3("Off"),
    description: inputParameter ? "" : translate3("Parameter won't be created as local variable."),
    getValue: getValue2,
    setValue
  });
}
function addInputParameter(element, property, bpmnFactory, modeling) {
  const {
    binding,
    value
  } = property;
  const businessObject = getBusinessObject(element);
  const extensionElements = businessObject.get("extensionElements");
  const inputOutput = findExtension(businessObject, "camunda:InputOutput");
  let updatedBusinessObject, update;
  if (!extensionElements) {
    updatedBusinessObject = businessObject;
    const extensionElements2 = createExtensionElements$1(businessObject, bpmnFactory), inputOutput2 = createInputOutput$1(binding, value, bpmnFactory, extensionElements2);
    extensionElements2.values.push(inputOutput2);
    update = {
      extensionElements: extensionElements2
    };
  } else if (!inputOutput) {
    updatedBusinessObject = extensionElements;
    const inputOutput2 = createInputOutput$1(binding, value, bpmnFactory, extensionElements);
    update = {
      values: extensionElements.get("values").concat(inputOutput2)
    };
  } else {
    updatedBusinessObject = inputOutput;
    const inputParameter = createInputParameter(binding, value, bpmnFactory);
    inputParameter.$parent = inputOutput;
    update = {
      inputParameters: inputOutput.get("camunda:inputParameters").concat(inputParameter)
    };
  }
  modeling.updateModdleProperties(element, updatedBusinessObject, update);
}
function removeInputParameter(element, binding, modeling) {
  const businessObject = getBusinessObject(element);
  const inputOutput = findExtension(businessObject, "camunda:InputOutput"), inputParameters = inputOutput.get("camunda:inputParameters");
  const inputParameter = findInputParameter(inputOutput, binding);
  modeling.updateModdleProperties(element, inputOutput, {
    inputParameters: (0, import_min_dash147.without)(inputParameters, inputParameter)
  });
}
function removeEntry(entries, suffix) {
  const entry = entries.find(({
    id
  }) => id.endsWith(suffix));
  return (0, import_min_dash147.without)(entries, entry);
}
function createExtensionElements$1(businessObject, bpmnFactory) {
  return createElement("bpmn:ExtensionElements", {
    values: []
  }, businessObject, bpmnFactory);
}
function createInputOutput$1(binding, value, bpmnFactory, extensionElements) {
  const inputParameter = createInputParameter(binding, value, bpmnFactory);
  const inputOutput = createElement("camunda:InputOutput", {
    inputParameters: [inputParameter],
    outputParameters: []
  }, extensionElements, bpmnFactory);
  inputParameter.$parent = inputOutput;
  return inputOutput;
}
function OutputProperties(props) {
  const {
    element,
    index: index2,
    injector,
    property
  } = props;
  const {
    binding,
    description,
    label
  } = property;
  const {
    name: name3
  } = binding;
  const businessObject = getBusinessObject(element), inputOutput = findExtension(businessObject, "camunda:InputOutput");
  const translate3 = injector.get("translate");
  const outputParameter = inputOutput && findOutputParameter(inputOutput, binding);
  const id = `${element.id}-outputParameter-${index2}`;
  let entries = [];
  if (description) {
    entries.push({
      id: `${id}-description`,
      component: Description2,
      text: description
    });
  }
  entries.push({
    id: `${id}-local-variable-assignment`,
    component: ProcessVariableAssignment,
    outputParameter,
    property
  });
  if (outputParameter) {
    entries.push({
      id: `${id}-assign-to-process-variable`,
      component: AssignToProcessVariable,
      property
    });
  }
  const item = {
    id,
    label: label || name3 || translate3("<unnamed>"),
    entries
  };
  return item;
}
function Description2(props) {
  const {
    id,
    text
  } = props;
  return o5("div", {
    class: "bio-properties-panel-entry",
    "data-entry-id": id,
    children: o5("div", {
      class: "bio-properties-panel-description",
      children: o5(PropertyDescription, {
        description: text
      })
    })
  });
}
function ProcessVariableAssignment(props) {
  const {
    element,
    id,
    property,
    outputParameter
  } = props;
  const {
    binding
  } = property;
  const bpmnFactory = useService("bpmnFactory"), modeling = useService("modeling"), translate3 = useService("translate");
  const getValue2 = () => {
    return outputParameter;
  };
  const setValue = (value) => {
    if (value) {
      addOutputParameter(element, property, bpmnFactory, modeling);
    } else {
      removeOutputParameter(element, binding, modeling);
    }
  };
  return ToggleSwitchEntry({
    id,
    label: translate3("Process variable assignment"),
    switcherLabel: outputParameter ? translate3("On") : translate3("Off"),
    description: outputParameter ? "" : translate3("Parameter won't be available in process scope."),
    getValue: getValue2,
    setValue
  });
}
function AssignToProcessVariable(props) {
  const {
    element,
    id,
    property
  } = props;
  const {
    binding
  } = property;
  const inputOutput = findExtension(element, "camunda:InputOutput"), outputParameter = findOutputParameter(inputOutput, binding);
  const commandStack = useService("commandStack"), debounce4 = useService("debounceInput"), translate3 = useService("translate");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: outputParameter,
      properties: {
        name: value
      }
    });
  };
  const getValue2 = () => {
    return outputParameter.get("camunda:name");
  };
  const validate3 = (value) => {
    if (!value) {
      return translate3("Process variable name must not be empty.");
    } else if (containsSpace(value)) {
      return translate3("Process variable name must not contain spaces.");
    }
  };
  return TextfieldEntry({
    debounce: debounce4,
    element: outputParameter,
    id,
    label: translate3("Assign to process variable"),
    getValue: getValue2,
    setValue,
    validate: validate3
  });
}
function addOutputParameter(element, property, bpmnFactory, modeling) {
  const {
    binding,
    value
  } = property;
  const businessObject = getBusinessObject(element);
  const extensionElements = businessObject.get("extensionElements");
  const inputOutput = findExtension(businessObject, "camunda:InputOutput");
  let updatedBusinessObject, update;
  if (!extensionElements) {
    updatedBusinessObject = businessObject;
    const extensionElements2 = createExtensionElements(businessObject, bpmnFactory), inputOutput2 = createInputOutput(binding, value, bpmnFactory, extensionElements2);
    extensionElements2.values.push(inputOutput2);
    update = {
      extensionElements: extensionElements2
    };
  } else if (!inputOutput) {
    updatedBusinessObject = extensionElements;
    const inputOutput2 = createInputOutput(binding, value, bpmnFactory, extensionElements);
    update = {
      values: extensionElements.get("values").concat(inputOutput2)
    };
  } else {
    updatedBusinessObject = inputOutput;
    const outputParameter = createOutputParameter(binding, value, bpmnFactory);
    outputParameter.$parent = inputOutput;
    update = {
      outputParameters: inputOutput.get("camunda:outputParameters").concat(outputParameter)
    };
  }
  modeling.updateModdleProperties(element, updatedBusinessObject, update);
}
function removeOutputParameter(element, binding, modeling) {
  const businessObject = getBusinessObject(element);
  const inputOutput = findExtension(businessObject, "camunda:InputOutput"), outputParameters = inputOutput.get("camunda:outputParameters");
  const outputParameter = findOutputParameter(inputOutput, binding);
  modeling.updateModdleProperties(element, inputOutput, {
    outputParameters: (0, import_min_dash147.without)(outputParameters, outputParameter)
  });
}
function createExtensionElements(businessObject, bpmnFactory) {
  return createElement("bpmn:ExtensionElements", {
    values: []
  }, businessObject, bpmnFactory);
}
function createInputOutput(binding, value, bpmnFactory, extensionElements) {
  const outputParameter = createOutputParameter(binding, value, bpmnFactory);
  const inputOutput = createElement("camunda:InputOutput", {
    inputParameters: [],
    outputParameters: [outputParameter]
  }, extensionElements, bpmnFactory);
  outputParameter.$parent = inputOutput;
  return inputOutput;
}
var CAMUNDA_ERROR_EVENT_DEFINITION_TYPE = "camunda:errorEventDefinition";
var CAMUNDA_INPUT_PARAMETER_TYPE = "camunda:inputParameter";
var CAMUNDA_OUTPUT_PARAMETER_TYPE = "camunda:outputParameter";
var LOWER_PRIORITY3 = 300;
var ElementTemplatesPropertiesProvider = class {
  constructor(elementTemplates, propertiesPanel, injector) {
    propertiesPanel.registerProvider(LOWER_PRIORITY3, this);
    this._elementTemplates = elementTemplates;
    this._injector = injector;
  }
  getGroups(element) {
    return (groups) => {
      const injector = this._injector;
      if (!this._shouldShowTemplateProperties(element)) {
        return groups;
      }
      groups = groups.slice();
      const templatesGroup = {
        element,
        id: "ElementTemplates__Template",
        label: "Template",
        component: createElementTemplatesGroup(),
        entries: TemplateProps({
          element,
          elementTemplates: this._elementTemplates
        })
      };
      addGroupsAfter("documentation", groups, [templatesGroup]);
      const elementTemplate = this._elementTemplates.get(element);
      if (elementTemplate) {
        const templateSpecificGroups = [].concat(createInputGroup(element, elementTemplate, injector) || [], createOutputGroup(element, elementTemplate, injector) || [], createErrorGroup(element, elementTemplate, injector) || [], CustomProperties({
          element,
          elementTemplate
        }));
        addGroupsAfter("ElementTemplates__Template", groups, templateSpecificGroups);
      }
      if (getTemplateId(element)) {
        groups = filterWithEntriesVisible(elementTemplate || {}, groups);
      }
      return groups;
    };
  }
  _shouldShowTemplateProperties(element) {
    return getTemplateId(element) || this._elementTemplates.getAll(element).length;
  }
};
ElementTemplatesPropertiesProvider.$inject = ["elementTemplates", "propertiesPanel", "injector"];
function createInputGroup(element, elementTemplate, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Inputs"),
    id: "ElementTemplates__Input",
    component: ListGroup,
    items: []
  };
  const properties = elementTemplate.properties.filter(({
    binding,
    type
  }) => {
    return !type && binding.type === CAMUNDA_INPUT_PARAMETER_TYPE;
  });
  properties.forEach((property, index2) => {
    const item = InputProperties({
      element,
      index: index2,
      property
    });
    if (item) {
      group.items.push(item);
    }
  });
  if (!group.items.length) {
    return null;
  }
  return group;
}
function createOutputGroup(element, elementTemplate, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Outputs"),
    id: "ElementTemplates__Output",
    component: ListGroup,
    items: []
  };
  const properties = elementTemplate.properties.filter(({
    binding,
    type
  }) => {
    return !type && binding.type === CAMUNDA_OUTPUT_PARAMETER_TYPE;
  });
  properties.forEach((property, index2) => {
    const item = OutputProperties({
      element,
      index: index2,
      property,
      injector
    });
    if (item) {
      group.items.push(item);
    }
  });
  if (!group.items.length) {
    return null;
  }
  return group;
}
function createErrorGroup(element, elementTemplate, injector) {
  const translate3 = injector.get("translate");
  const group = {
    label: translate3("Errors"),
    id: "ElementTemplates__Error",
    component: ListGroup,
    items: []
  };
  const properties = elementTemplate.properties.filter(({
    binding,
    type
  }) => {
    return !type && binding.type === CAMUNDA_ERROR_EVENT_DEFINITION_TYPE;
  });
  properties.forEach((property, index2) => {
    const item = ErrorProperties({
      element,
      index: index2,
      property
    });
    if (item) {
      group.items.push(item);
    }
  });
  if (!group.items.length) {
    return null;
  }
  return group;
}
function addGroupsAfter(id, groups, groupsToAdd) {
  const index2 = groups.findIndex((group) => group.id === id);
  if (index2 !== -1) {
    groups.splice(index2 + 1, 0, ...groupsToAdd);
  } else {
    groups.unshift(...groupsToAdd);
  }
}
function filterWithEntriesVisible(template, groups) {
  if (!template.entriesVisible) {
    return groups.filter((group) => {
      return group.id === "general" || group.id.startsWith("ElementTemplates__");
    });
  }
  return groups;
}

// bpmnModeler.ts
var import_obsidian2 = require("obsidian");
var VIEW_TYPE_BPMN = "bpmn-view";
var BpmnModelerView = class extends import_obsidian2.TextFileView {
  constructor(leaf, settings) {
    super(leaf);
    this.leaf = leaf;
    this.settings = settings;
  }
  getViewData() {
    return this.data;
  }
  setViewData(data, clear3) {
    this.bpmnXml = data;
    const thisRef = this;
    this.bpmnModeler.importXML(this.bpmnXml).catch(function(err) {
      thisRef.clear();
      thisRef.contentEl.createEl("div", { text: err.message });
    });
  }
  async onOpen() {
    let bpmnSave = this.contentEl.createEl("button", { text: "Save" });
    let bpmnUndo = this.contentEl.createEl("button", { text: "Undo" });
    let bpmnRedo = this.contentEl.createEl("button", { text: "Redo" });
    let bpmnProperties = this.contentEl.createEl("button", { text: "Properties" });
    this.bpmnDiv = this.contentEl.createEl("div", { cls: "bpmn-view bpmn-fullscreen" });
    let propertyPanel = this.contentEl.createEl("div", { cls: "bpmn-properties-panel hide" });
    this.bpmnModeler = new Modeler({
      container: this.bpmnDiv,
      keyboard: {
        bindTo: this.bpmnDiv.win
      },
      propertiesPanel: {
        parent: propertyPanel
      },
      additionalModules: [
        index$3,
        index$2
      ]
    });
    if (this.settings.force_white_background_by_default) {
      this.bpmnDiv.addClass("bpmn-view-white-background");
    }
    const bpmnModeler = this.bpmnModeler;
    const thisRef = this;
    this.bpmnModeler.on("commandStack.changed", function() {
      bpmnModeler.saveXML({ format: true }).then(function(data) {
        const { xml: xml2 } = data;
        thisRef.data = xml2;
      });
    });
    bpmnSave.addEventListener("click", function(e7) {
      thisRef.save();
    });
    bpmnUndo.addEventListener("click", function(e7) {
      bpmnModeler.get("commandStack").undo();
    });
    bpmnRedo.addEventListener("click", function(e7) {
      bpmnModeler.get("commandStack").redo();
    });
    bpmnProperties.addEventListener("click", function(e7) {
      propertyPanel.classList.toggle("hide");
    });
  }
  async onClose() {
    this.contentEl.empty();
  }
  clear() {
    this.contentEl.empty();
  }
  getViewType() {
    return VIEW_TYPE_BPMN;
  }
};

// main.ts
var emptyBpmn = '<?xml version="1.0" encoding="UTF-8"?>\n<bpmn2:definitions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:bpmn2="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:dc="http://www.omg.org/spec/DD/20100524/DC" xmlns:di="http://www.omg.org/spec/DD/20100524/DI" xsi:schemaLocation="http://www.omg.org/spec/BPMN/20100524/MODEL BPMN20.xsd" id="sample-diagram" targetNamespace="http://bpmn.io/schema/bpmn">\n  <bpmn2:process id="Process_1" isExecutable="false">\n    <bpmn2:startEvent id="StartEvent_1"/>\n  </bpmn2:process>\n  <bpmndi:BPMNDiagram id="BPMNDiagram_1">\n    <bpmndi:BPMNPlane id="BPMNPlane_1" bpmnElement="Process_1">\n      <bpmndi:BPMNShape id="_BPMNShape_StartEvent_2" bpmnElement="StartEvent_1">\n        <dc:Bounds height="36.0" width="36.0" x="412.0" y="240.0"/>\n      </bpmndi:BPMNShape>\n    </bpmndi:BPMNPlane>\n  </bpmndi:BPMNDiagram>\n</bpmn2:definitions>';
var ObsidianBPMNPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    console.log("BPMN loading...");
    this.settings = Object.assign(new ObsidianBpmnPluginSettings(), await this.loadData());
    this.addSettingTab(new ObsidianBpmnPluginSettingsTab(this.app, this));
    this.registerView(VIEW_TYPE_BPMN, (leaf) => new BpmnModelerView(leaf, this.settings));
    this.registerExtensions(["bpmn"], VIEW_TYPE_BPMN);
    this.registerMarkdownCodeBlockProcessor("bpmn", async (src, el, ctx) => {
      let parameters = null;
      try {
        parameters = this.readParameters(src);
      } catch (e7) {
        el.createEl("h3", { text: "BPMN parameters invalid: \n" + e7.message });
        return;
      }
      console.log("Try to render a BPMN");
      try {
        if (parameters.url.startsWith("./")) {
          const filePath = ctx.sourcePath;
          const folderPath = filePath.substring(0, filePath.lastIndexOf("/"));
          parameters.url = folderPath + "/" + parameters.url.substring(2, parameters.url.length);
        }
        const rootDiv = el.createEl("div");
        if (parameters.opendiagram) {
          const href = rootDiv.createEl("a", { text: "Open diagram" });
          href.href = parameters.url;
          href.className = "internal-link";
        }
        const bpmnDiv = rootDiv.createEl("div", { cls: "bpmn-view" });
        if (parameters.forcewhitebackground) {
          bpmnDiv.addClass("bpmn-view-white-background");
        } else {
          const theme2 = app.getTheme();
          if (theme2 === "obsidian") {
            bpmnDiv.addClass("bpmn-view-obsidian-theme");
          } else if (theme2 === "moonstone") {
            bpmnDiv.addClass("bpmn-view-moonstone-theme");
          }
        }
        const xml2 = await this.app.vault.adapter.read(parameters.url);
        bpmnDiv.setAttribute("style", "height: " + parameters.height + "px;");
        const bpmn = new NavigatedViewer({
          container: bpmnDiv,
          keyboard: {
            bindTo: bpmnDiv.win
          }
        });
        const p_zoom = parameters.zoom;
        const p_x = parameters.x;
        const p_y = parameters.y;
        bpmn.importXML(xml2).then(function(result) {
          const canvas = bpmn.get("canvas");
          if (p_zoom === void 0) {
            canvas.zoom("fit-viewport");
          } else {
            canvas.zoom(p_zoom, { x: p_x, y: p_y });
          }
        }).catch(function(err) {
          const { warnings, message } = err;
          console.error("something went wrong:", warnings, message);
          bpmn.destroy();
          rootDiv.createEl("h3", { text: warnings + " " + message });
        });
        if (parameters.showzoom) {
          const zoomDiv = rootDiv.createEl("div");
          const zoomInBtn = zoomDiv.createEl("button", { "text": "+" });
          zoomInBtn.addEventListener("click", (e7) => bpmn.get("zoomScroll").stepZoom(0.5));
          const zoomOutBtn = zoomDiv.createEl("button", { "text": "-" });
          zoomOutBtn.addEventListener("click", (e7) => bpmn.get("zoomScroll").stepZoom(-0.5));
        }
      } catch (error4) {
        el.createEl("h3", { text: error4 });
        console.error(error4);
      }
    });
    this.addRibbonIcon("file-input", "New BPMN", async () => {
      let path = "/";
      const currentFile = this.app.workspace.getActiveFile();
      if (currentFile != null) {
        path = currentFile.parent.path + "/";
      }
      path += "model";
      for (let i6 = 1; i6 < 99; i6++) {
        const newPath = path + "_" + i6 + ".bpmn";
        if (!await this.app.vault.adapter.exists(newPath)) {
          path = newPath;
          break;
        }
      }
      let newBpmnContent = emptyBpmn;
      const randomId = (Math.random() + 1).toString(36).substring(7);
      newBpmnContent = newBpmnContent.replace("Process_1", "Process_" + randomId).replace("BPMNDiagram_1", "BPMNDiagram_" + randomId).replace("BPMNPlane_1", "BPMNPlane_" + randomId);
      let newBpmnFile = await this.app.vault.create(path, newBpmnContent);
      let leaf = this.app.workspace.getMostRecentLeaf();
      if (leaf != null) {
        await leaf.openFile(newBpmnFile);
      }
    });
  }
  readParameters(jsonString) {
    if (jsonString.contains("[[") && !jsonString.contains('"[[')) {
      jsonString = jsonString.replace("[[", '"[[');
      jsonString = jsonString.replace("]]", ']]"');
    }
    const parameters = (0, import_obsidian3.parseYaml)(jsonString);
    if (parameters.url.startsWith("[[")) {
      parameters.url = parameters.url.substring(2, parameters.url.length - 2);
      parameters.url = this.app.metadataCache.getFirstLinkpathDest(parameters.url, "").path;
    }
    if (parameters.showzoom === void 0) {
      parameters.showzoom = this.settings.showzoom_by_default;
    }
    if (parameters.opendiagram === void 0) {
      parameters.opendiagram = this.settings.opendiagram_by_default;
    }
    if (parameters.height === void 0) {
      parameters.height = this.settings.height_by_default;
    }
    if (parameters.x === void 0) {
      parameters.x = 0;
    }
    parameters.x *= 10;
    if (parameters.y === void 0) {
      parameters.y = 0;
    }
    parameters.y *= 10;
    if (parameters.forcewhitebackground === void 0) {
      parameters.forcewhitebackground = this.settings.force_white_background_by_default;
    }
    return parameters;
  }
  onunload() {
    console.log("Unloading BPMN plugin...");
  }
};
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
/*! https://mths.be/cssescape v1.5.1 by @mathias | MIT license */
